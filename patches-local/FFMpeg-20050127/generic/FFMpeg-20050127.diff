diff -Nur FFMpeg-20050127/libavcodec/amr/a_refl.c FFMpeg-20050127-new/libavcodec/amr/a_refl.c
--- FFMpeg-20050127/libavcodec/amr/a_refl.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/a_refl.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,127 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : a_refl.c
+*      Purpose          : Convert from direct form coefficients to 
+*                         reflection coefficients
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "a_refl.h"
+const char a_refl_id[] = "@(#)$Id $" a_refl_h;
+ 
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : A_Refl
+*
+**************************************************************************
+*/ 
+void A_Refl(
+   Word16 a[],	      /* i   : Directform coefficients */
+   Word16 refl[]      /* o   : Reflection coefficients */
+)
+{				       
+   /* local variables */
+   Word16 i,j;
+   Word16 aState[M];
+   Word16 bState[M];
+   Word16 normShift;
+   Word16 normProd;
+   Word32 L_acc;
+   Word16 scale;
+   Word32 L_temp;
+   Word16 temp;
+   Word16 mult;
+
+   /* initialize states */
+   for (i = 0; i < M; i++)
+   {
+      aState[i] = a[i];                         move16 ();
+   }
+   
+   /* backward Levinson recursion */
+   for (i = M-1; i >= 0; i--)
+   {
+      if (sub(abs_s(aState[i]), 4096) >= 0)
+      {
+         goto ExitRefl;
+      }
+      
+      refl[i] = shl(aState[i], 3);
+
+      L_temp = L_mult(refl[i], refl[i]);
+      L_acc = L_sub(MAX_32, L_temp);
+      
+      normShift = norm_l(L_acc);
+      scale = sub(15, normShift);
+      
+      L_acc = L_shl(L_acc, normShift);
+      normProd = round(L_acc);
+
+      mult = div_s(16384, normProd);
+      
+      for (j = 0; j < i; j++)
+      {
+         L_acc = L_deposit_h(aState[j]);
+         L_acc = L_msu(L_acc, refl[i], aState[i-j-1]);
+         
+         temp = round(L_acc);
+         L_temp = L_mult(mult, temp);
+         L_temp = L_shr_r(L_temp, scale);
+         
+         if (L_sub(L_abs(L_temp), 32767) > 0)
+         {
+            goto ExitRefl;
+         }
+         
+         bState[j] = extract_l(L_temp);
+      }
+      
+      for (j = 0; j < i; j++)
+      {
+         aState[j] = bState[j];              move16 ();
+      }
+   }
+   return;
+
+ExitRefl:
+   for (i = 0; i < M; i++)
+   {
+      refl[i] = 0;                           move16 ();
+   }
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/a_refl.h FFMpeg-20050127-new/libavcodec/amr/a_refl.h
--- FFMpeg-20050127/libavcodec/amr/a_refl.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/a_refl.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,54 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : a_refl.h
+*      Purpose          : Convert from direct form coefficients to 
+*                         reflection coefficients
+*
+********************************************************************************
+*/
+#ifndef a_refl_h
+#define a_refl_h "$Id $"
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ *   FUNCTION:  A_Refl()
+ *
+ *   PURPOSE: Convert from direct form coefficients to reflection coefficients
+ *
+ *   DESCRIPTION:
+ *       Directform coeffs in Q12 are converted to 
+ *       reflection coefficients Q15 
+ *
+ *************************************************************************/
+void A_Refl(
+   Word16 a[],	      /* i   : Directform coefficients */
+   Word16 refl[]      /* o   : Reflection coefficients */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/agc.c FFMpeg-20050127-new/libavcodec/amr/agc.c
--- FFMpeg-20050127/libavcodec/amr/agc.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/agc.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,319 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : agc.c
+*
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "agc.h"
+const char agc_id[] = "@(#)$Id $" agc_h;
+
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+#include "inv_sqrt.h"
+ 
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         LOCAL PROGRAM CODE
+*****************************************************************************
+*/
+
+static Word32 energy_old( /* o : return energy of signal     */
+    Word16 in[],          /* i : input signal (length l_trm) */
+    Word16 l_trm          /* i : signal length               */
+)
+{
+    Word32 s;
+    Word16 i, temp;
+
+    temp = shr (in[0], 2);
+    s = L_mult (temp, temp);
+    
+    for (i = 1; i < l_trm; i++)
+    {
+        temp = shr (in[i], 2);
+        s = L_mac (s, temp, temp);
+    }
+
+    return s;
+}
+
+static Word32 energy_new( /* o : return energy of signal     */
+    Word16 in[],          /* i : input signal (length l_trm) */
+    Word16 l_trm          /* i : signal length               */
+)
+{
+    Word32 s;
+    Word16 i;
+    Flag ov_save;
+
+    ov_save = Overflow; move16 (); /* save overflow flag in case energy_old */
+                                   /* must be called                        */
+    s = L_mult(in[0], in[0]);
+    for (i = 1; i < l_trm; i++)
+    {
+        s = L_mac(s, in[i], in[i]);
+    }
+    
+    /* check for overflow */
+    test (); 
+    if (L_sub (s, MAX_32) == 0L)
+    {
+        Overflow = ov_save; move16 (); /* restore overflow flag */
+        s = energy_old (in, l_trm); move32 (); /* function result */
+    }
+    else
+    {
+       s = L_shr(s, 4);
+    }
+
+    return s;
+}
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : agc_init
+*  Purpose     : Allocates memory for agc state and initializes
+*                state memory
+*
+**************************************************************************
+*/
+int agc_init (agcState **state)
+{
+  agcState* s;
+ 
+  if (state == (agcState **) NULL){
+      fprintf(stderr, "agc_init: invalid parameter\n");
+      return -1;
+  }
+  *state = NULL;
+ 
+  /* allocate memory */
+  if ((s= (agcState *) malloc(sizeof(agcState))) == NULL){
+      fprintf(stderr, "agc_init: can not malloc state structure\n");
+      return -1;
+  }
+  
+  agc_reset(s);
+  *state = s;
+  
+  return 0;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : agc_reset
+*  Purpose     : Reset of agc (i.e. set state memory to 1.0)
+*
+**************************************************************************
+*/
+int agc_reset (agcState *state)
+{
+  if (state == (agcState *) NULL){
+      fprintf(stderr, "agc_reset: invalid parameter\n");
+      return -1;
+  }
+  
+  state->past_gain = 4096;   /* initial value of past_gain = 1.0  */
+  
+  return 0;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : agc_exit
+*  Purpose     : The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void agc_exit (agcState **state)
+{
+  if (state == NULL || *state == NULL)
+      return;
+ 
+  /* deallocate memory */
+  free(*state);
+  *state = NULL;
+  
+  return;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : agc
+*  Purpose     : Scales the postfilter output on a subframe basis
+*
+**************************************************************************
+*/
+int agc (
+    agcState *st,      /* i/o : agc state                        */
+    Word16 *sig_in,    /* i   : postfilter input signal  (l_trm) */
+    Word16 *sig_out,   /* i/o : postfilter output signal (l_trm) */
+    Word16 agc_fac,    /* i   : AGC factor                       */
+    Word16 l_trm       /* i   : subframe size                    */
+)
+{
+    Word16 i, exp;
+    Word16 gain_in, gain_out, g0, gain;
+    Word32 s;
+            
+    /* calculate gain_out with exponent */
+    s = energy_new(sig_out, l_trm); move32 (); /* function result */
+        
+    test (); 
+    if (s == 0)
+    {
+        st->past_gain = 0;          move16 (); 
+        return 0;
+    }
+    exp = sub (norm_l (s), 1);
+    gain_out = round (L_shl (s, exp));
+
+    /* calculate gain_in with exponent */
+    s = energy_new(sig_in, l_trm);   move32 (); /* function result */
+    
+    test (); 
+    if (s == 0)
+    {
+        g0 = 0;                 move16 (); 
+    }
+    else
+    {
+        i = norm_l (s);
+        gain_in = round (L_shl (s, i));
+        exp = sub (exp, i);
+
+        /*---------------------------------------------------*
+         *  g0 = (1-agc_fac) * sqrt(gain_in/gain_out);       *
+         *---------------------------------------------------*/
+
+        s = L_deposit_l (div_s (gain_out, gain_in));
+        s = L_shl (s, 7);       /* s = gain_out / gain_in */
+        s = L_shr (s, exp);     /* add exponent */
+
+        s = Inv_sqrt (s); move32 (); /* function result */
+        i = round (L_shl (s, 9));
+
+        /* g0 = i * (1-agc_fac) */
+        g0 = mult (i, sub (32767, agc_fac));
+    }
+
+    /* compute gain[n] = agc_fac * gain[n-1]
+                        + (1-agc_fac) * sqrt(gain_in/gain_out) */
+    /* sig_out[n] = gain[n] * sig_out[n]                        */
+
+    gain = st->past_gain;           move16 (); 
+
+    for (i = 0; i < l_trm; i++)
+    {
+        gain = mult (gain, agc_fac);
+        gain = add (gain, g0);
+        sig_out[i] = extract_h (L_shl (L_mult (sig_out[i], gain), 3));
+                                move16 (); 
+    }
+
+    st->past_gain = gain;           move16 (); 
+
+    return 0;
+}
+
+/*
+**************************************************************************
+*
+*  Function    : agc2
+*  Purpose     : Scales the excitation on a subframe basis
+*
+**************************************************************************
+*/
+void agc2 (
+ Word16 *sig_in,        /* i   : postfilter input signal  */
+ Word16 *sig_out,       /* i/o : postfilter output signal */
+ Word16 l_trm           /* i   : subframe size            */
+)
+{
+    Word16 i, exp;
+    Word16 gain_in, gain_out, g0;
+    Word32 s;
+    
+    /* calculate gain_out with exponent */
+    s = energy_new(sig_out, l_trm);   move32 (); /* function result */
+        
+    test (); 
+    if (s == 0)
+    {
+        return;
+    }
+    exp = sub (norm_l (s), 1);
+    gain_out = round (L_shl (s, exp));
+
+    /* calculate gain_in with exponent */
+    s = energy_new(sig_in, l_trm);   move32 (); /* function result */
+    
+    test (); 
+    if (s == 0)
+    {
+        g0 = 0;                 move16 (); 
+    }
+    else
+    {
+        i = norm_l (s);
+        gain_in = round (L_shl (s, i));
+        exp = sub (exp, i);
+
+        /*---------------------------------------------------*
+         *  g0 = sqrt(gain_in/gain_out);                     *
+         *---------------------------------------------------*/
+
+        s = L_deposit_l (div_s (gain_out, gain_in));
+        s = L_shl (s, 7);       /* s = gain_out / gain_in */
+        s = L_shr (s, exp);     /* add exponent */
+
+        s = Inv_sqrt (s); move32 (); /* function result */
+        g0 = round (L_shl (s, 9));
+    }
+
+    /* sig_out(n) = gain(n) sig_out(n) */
+
+    for (i = 0; i < l_trm; i++)
+    {
+        sig_out[i] = extract_h (L_shl (L_mult (sig_out[i], g0), 3));
+                                move16 (); 
+    }
+
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/agc.h FFMpeg-20050127-new/libavcodec/amr/agc.h
--- FFMpeg-20050127/libavcodec/amr/agc.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/agc.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,111 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : agc.h
+*      Purpose          : Scales the postfilter output on a subframe basis
+*                       : by automatic control of the subframe gain.
+*
+*****************************************************************************
+*/
+#ifndef agc_h
+#define agc_h "$Id $"
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+*****************************************************************************
+*                         DEFINITION OF DATA TYPES
+*****************************************************************************
+*/
+typedef struct {
+    Word16 past_gain;
+} agcState;
+
+/*
+*****************************************************************************
+*                         DECLARATION OF PROTOTYPES
+*****************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : agc_init
+*  Purpose     : Allocates memory for agc state and initializes
+*                state memory
+*  Description : Stores pointer to agc status struct in *st. This pointer
+*                has to be passed to agc in each call.
+*  Returns     : 0 on success
+*
+**************************************************************************
+*/
+int agc_init(agcState **st);
+
+/*
+**************************************************************************
+*
+*  Function    : agc_reset
+*  Purpose     : Reset of agc (i.e. set state memory to 1.0)
+*  Returns     : 0 on success
+*
+**************************************************************************
+*/
+int agc_reset (agcState *st);
+
+/*
+**************************************************************************
+*
+*  Function    : agc_exit
+*  Purpose     : The memory used for state memory is freed,
+*                de-initialize agc
+*
+**************************************************************************
+*/
+void agc_exit (agcState **st);
+
+/*
+**************************************************************************
+*
+*  Function    : agc
+*  Purpose     : Scales the postfilter output on a subframe basis
+*  Description : sig_out[n] = sig_out[n] * gain[n];
+*                where gain[n] is the gain at the nth sample given by
+*                gain[n] = agc_fac * gain[n-1] + (1 - agc_fac) g_in/g_out
+*                g_in/g_out is the square root of the ratio of energy at 
+*                the input and output of the postfilter.
+*
+**************************************************************************
+*/
+int agc (
+    agcState *st,      /* i/o : agc state                         */
+    Word16 *sig_in,    /* i   : postfilter input signal, (l_trm)  */
+    Word16 *sig_out,   /* i/o : postfilter output signal, (l_trm) */
+    Word16 agc_fac,    /* i   : AGC factor                        */
+    Word16 l_trm       /* i   : subframe size                     */
+);
+
+/*
+**************************************************************************
+*
+*  Function:  agc2
+*  Purpose:   Scales the excitation on a subframe basis
+*
+**************************************************************************
+*/
+void agc2 (
+    Word16 *sig_in,    /* i   : postfilter input signal   */
+    Word16 *sig_out,   /* i/o : postfilter output signal  */
+    Word16 l_trm       /* i   : subframe size             */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/allmodes.txt FFMpeg-20050127-new/libavcodec/amr/allmodes.txt
--- FFMpeg-20050127/libavcodec/amr/allmodes.txt	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/allmodes.txt	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,1400 @@
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
+MR122
+MR102
+MR795
+MR74
+MR67
+MR59
+MR515
+MR475
+MR515
+MR59
+MR67
+MR74
+MR795
+MR102
diff -Nur FFMpeg-20050127/libavcodec/amr/amr_chk.csh FFMpeg-20050127-new/libavcodec/amr/amr_chk.csh
--- FFMpeg-20050127/libavcodec/amr/amr_chk.csh	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/amr_chk.csh	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,64 @@
+#!/bin/csh -fb
+#
+# Unix shell script to check correct installation of AMR
+# speech encoder and decoder
+#
+# $Id $
+
+if ("$1" == "-vad2") then
+    set vad=2;
+    shift;
+else if ("$1" == "-vad1") then
+    set vad=1;
+    shift;
+else
+    set vad=1;
+endif
+
+if ("$1" == "unix") then
+    set BASEin=spch_unx;
+    if ($vad == 1) then
+        set BASEout = $BASEin;
+    else
+        set BASEout = spch_un2;
+    endif
+else if ("$1" == "dos") then
+    set BASEin = spch_dos;
+    if ($vad == 1) then
+        set BASEout = $BASEin;
+    else
+        set BASEout = spch_do2;
+    endif
+else
+    echo "Use:    $0 [-vad2] dos"
+    echo "  or    $0 [-vad2] unix"
+    exit -1;
+endif
+    
+./encoder -dtx -modefile=allmodes.txt $BASEin.inp tmp.cod
+echo ""
+cmp tmp.cod $BASEout.cod
+if ($status == 0) then
+    echo "##################################################"
+    echo "# AMR encoder executable installation successful #"
+    echo "##################################################"
+else
+    echo "#########################################################"
+    echo "# \!\!\! ERROR in AMR encoder installation verification \!\!\!#"
+    echo "#########################################################"
+    exit -1
+endif
+
+./decoder $BASEout.cod tmp.out
+echo ""
+cmp tmp.out $BASEout.out
+if ($status == 0) then
+    echo "##################################################"
+    echo "# AMR decoder executable installation successful #"
+    echo "##################################################"
+else
+    echo "#########################################################"
+    echo "# \!\!\! ERROR in AMR decoder installation verification \!\!\!#"
+    echo "#########################################################"
+    exit -1
+endif
diff -Nur FFMpeg-20050127/libavcodec/amr/autocorr.c FFMpeg-20050127-new/libavcodec/amr/autocorr.c
--- FFMpeg-20050127/libavcodec/amr/autocorr.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/autocorr.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,129 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : autocorr.c
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "autocorr.h"
+const char autocorr_id[] = "@(#)$Id $" autocorr_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : autocorr
+*  Purpose     : Compute autocorrelations of signal with windowing
+*
+**************************************************************************
+*/
+Word16 Autocorr (
+    Word16 x[],            /* (i)    : Input signal (L_WINDOW)            */
+    Word16 m,              /* (i)    : LPC order                          */
+    Word16 r_h[],          /* (o)    : Autocorrelations  (msb)            */
+    Word16 r_l[],          /* (o)    : Autocorrelations  (lsb)            */
+    const Word16 wind[]    /* (i)    : window for LPC analysis (L_WINDOW) */
+)
+{
+    Word16 i, j, norm;
+    Word16 y[L_WINDOW];
+    Word32 sum;
+    Word16 overfl, overfl_shft;
+
+    /* Windowing of signal */
+
+    for (i = 0; i < L_WINDOW; i++)
+    {
+        y[i] = mult_r (x[i], wind[i]); move16 (); 
+    }
+
+    /* Compute r[0] and test for overflow */
+
+    overfl_shft = 0;                   move16 (); 
+
+    do
+    {
+        overfl = 0;                    move16 (); 
+        sum = 0L;                      move32 ();
+
+        for (i = 0; i < L_WINDOW; i++)
+        {
+            sum = L_mac (sum, y[i], y[i]);
+        }
+
+        /* If overflow divide y[] by 4 */
+
+        test (); 
+        if (L_sub (sum, MAX_32) == 0L)
+        {
+            overfl_shft = add (overfl_shft, 4);
+            overfl = 1;                move16 (); /* Set the overflow flag */
+
+            for (i = 0; i < L_WINDOW; i++)
+            {
+                y[i] = shr (y[i], 2);  move16 (); 
+            }
+        }
+        test (); 
+    }
+    while (overfl != 0);
+
+    sum = L_add (sum, 1L);             /* Avoid the case of all zeros */
+
+    /* Normalization of r[0] */
+
+    norm = norm_l (sum);
+    sum = L_shl (sum, norm);
+    L_Extract (sum, &r_h[0], &r_l[0]); /* Put in DPF format (see oper_32b) */
+
+    /* r[1] to r[m] */
+
+    for (i = 1; i <= m; i++)
+    {
+        sum = 0;                       move32 (); 
+
+        for (j = 0; j < L_WINDOW - i; j++)
+        {
+            sum = L_mac (sum, y[j], y[j + i]);
+        }
+
+        sum = L_shl (sum, norm);
+        L_Extract (sum, &r_h[i], &r_l[i]);
+    }
+
+    norm = sub (norm, overfl_shft);
+
+    return norm;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/autocorr.h FFMpeg-20050127-new/libavcodec/amr/autocorr.h
--- FFMpeg-20050127/libavcodec/amr/autocorr.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/autocorr.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,58 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : autocorr.h
+*      Purpose          : Compute autocorrelations of signal with windowing
+*
+********************************************************************************
+*/
+#ifndef autocorr_h
+#define autocorr_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : autocorr
+*  Purpose     : Compute autocorrelations of signal with windowing
+*  Description : - Windowing of input speech:   s'[n] = s[n] * w[n]
+*                - Autocorrelations of input speech:
+*                  r[k] = sum_{i=k}^{239} s'[i]*s'[i-k]    k=0,...,10
+*                The autocorrelations are expressed in normalized 
+*                double precision format.
+*  Returns     : Autocorrelation
+*
+**************************************************************************
+*/
+Word16 Autocorr (
+    Word16 x[],        /* (i)    : Input signal (L_WINDOW)             */
+    Word16 m,          /* (i)    : LPC order                           */
+    Word16 r_h[],      /* (o)    : Autocorrelations  (msb)  (MP1)      */
+    Word16 r_l[],      /* (o)    : Autocorrelations  (lsb)  (MP1)      */
+    const Word16 wind[]/* (i)    : window for LPC analysis. (L_WINDOW) */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/az_lsp.c FFMpeg-20050127-new/libavcodec/amr/az_lsp.c
--- FFMpeg-20050127/libavcodec/amr/az_lsp.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/az_lsp.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,281 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : az_lsp.c
+*      Purpose          : Compute the LSPs from the LP coefficients
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "az_lsp.h"
+const char az_lsp_id[] = "@(#)$Id $" az_lsp_h;
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "cnst.h"
+ 
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#include "grid.tab"
+#define NC   M/2                  /* M = LPC order, NC = M/2 */
+
+/*
+********************************************************************************
+*                         LOCAL PROGRAM CODE
+********************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : Chebps
+*  Purpose     : Evaluates the Chebyshev polynomial series
+*  Description : - The polynomial order is   n = m/2 = 5
+*                - The polynomial F(z) (F1(z) or F2(z)) is given by
+*                   F(w) = 2 exp(-j5w) C(x)
+*                  where
+*                   C(x) = T_n(x) + f(1)T_n-1(x) + ... +f(n-1)T_1(x) + f(n)/2
+*                  and T_m(x) = cos(mw) is the mth order Chebyshev
+*                  polynomial ( x=cos(w) )
+*  Returns     : C(x) for the input x.
+*
+**************************************************************************
+*/
+static Word16 Chebps (Word16 x,
+                      Word16 f[], /* (n) */
+                      Word16 n)
+{
+    Word16 i, cheb;
+    Word16 b0_h, b0_l, b1_h, b1_l, b2_h, b2_l;
+    Word32 t0;
+
+    b2_h = 256;                    move16 (); /* b2 = 1.0 */
+    b2_l = 0;                      move16 (); 
+
+    t0 = L_mult (x, 512);          /* 2*x                 */
+    t0 = L_mac (t0, f[1], 8192);   /* + f[1]              */
+    L_Extract (t0, &b1_h, &b1_l);  /* b1 = 2*x + f[1]     */
+
+    for (i = 2; i < n; i++)
+    {
+        t0 = Mpy_32_16 (b1_h, b1_l, x);         /* t0 = 2.0*x*b1        */
+        t0 = L_shl (t0, 1);
+        t0 = L_mac (t0, b2_h, (Word16) 0x8000); /* t0 = 2.0*x*b1 - b2   */
+        t0 = L_msu (t0, b2_l, 1);
+        t0 = L_mac (t0, f[i], 8192);            /* t0 = 2.0*x*b1 - b2 + f[i] */
+
+        L_Extract (t0, &b0_h, &b0_l);           /* b0 = 2.0*x*b1 - b2 + f[i]*/
+
+        b2_l = b1_l;               move16 ();   /* b2 = b1; */
+        b2_h = b1_h;               move16 (); 
+        b1_l = b0_l;               move16 ();   /* b1 = b0; */
+        b1_h = b0_h;               move16 (); 
+    }
+
+    t0 = Mpy_32_16 (b1_h, b1_l, x);             /* t0 = x*b1; */
+    t0 = L_mac (t0, b2_h, (Word16) 0x8000);     /* t0 = x*b1 - b2   */
+    t0 = L_msu (t0, b2_l, 1);
+    t0 = L_mac (t0, f[i], 4096);                /* t0 = x*b1 - b2 + f[i]/2 */
+
+    t0 = L_shl (t0, 6);
+
+    cheb = extract_h (t0);
+
+    return (cheb);
+}
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : Az_lsp
+*  Purpose     : Compute the LSPs from  the LP coefficients
+*
+**************************************************************************
+*/
+void Az_lsp (
+    Word16 a[],         /* (i)  : predictor coefficients (MP1)               */
+    Word16 lsp[],       /* (o)  : line spectral pairs (M)                    */
+    Word16 old_lsp[]    /* (i)  : old lsp[] (in case not found 10 roots) (M) */
+)
+{
+    Word16 i, j, nf, ip;
+    Word16 xlow, ylow, xhigh, yhigh, xmid, ymid, xint;
+    Word16 x, y, sign, exp;
+    Word16 *coef;
+    Word16 f1[M / 2 + 1], f2[M / 2 + 1];
+    Word32 t0;
+
+    /*-------------------------------------------------------------*
+     *  find the sum and diff. pol. F1(z) and F2(z)                *
+     *    F1(z) <--- F1(z)/(1+z**-1) & F2(z) <--- F2(z)/(1-z**-1)  *
+     *                                                             *
+     * f1[0] = 1.0;                                                *
+     * f2[0] = 1.0;                                                *
+     *                                                             *
+     * for (i = 0; i< NC; i++)                                     *
+     * {                                                           *
+     *   f1[i+1] = a[i+1] + a[M-i] - f1[i] ;                       *
+     *   f2[i+1] = a[i+1] - a[M-i] + f2[i] ;                       *
+     * }                                                           *
+     *-------------------------------------------------------------*/
+
+    f1[0] = 1024;                  move16 (); /* f1[0] = 1.0 */
+    f2[0] = 1024;                  move16 (); /* f2[0] = 1.0 */
+
+    for (i = 0; i < NC; i++)
+    {
+        t0 = L_mult (a[i + 1], 8192);   /* x = (a[i+1] + a[M-i]) >> 2  */
+        t0 = L_mac (t0, a[M - i], 8192);
+        x = extract_h (t0);
+        /* f1[i+1] = a[i+1] + a[M-i] - f1[i] */
+        f1[i + 1] = sub (x, f1[i]);move16 (); 
+
+        t0 = L_mult (a[i + 1], 8192);   /* x = (a[i+1] - a[M-i]) >> 2 */
+        t0 = L_msu (t0, a[M - i], 8192);
+        x = extract_h (t0);
+        /* f2[i+1] = a[i+1] - a[M-i] + f2[i] */
+        f2[i + 1] = add (x, f2[i]);move16 (); 
+    }
+
+    /*-------------------------------------------------------------*
+     * find the LSPs using the Chebychev pol. evaluation           *
+     *-------------------------------------------------------------*/
+
+    nf = 0;                        move16 (); /* number of found frequencies */
+    ip = 0;                        move16 (); /* indicator for f1 or f2      */
+
+    coef = f1;                     move16 (); 
+
+    xlow = grid[0];                move16 (); 
+    ylow = Chebps (xlow, coef, NC);move16 (); 
+
+    j = 0;
+    test (); test (); 
+    /* while ( (nf < M) && (j < grid_points) ) */
+    while ((sub (nf, M) < 0) && (sub (j, grid_points) < 0))
+    {
+        j++;
+        xhigh = xlow;              move16 (); 
+        yhigh = ylow;              move16 (); 
+        xlow = grid[j];            move16 (); 
+        ylow = Chebps (xlow, coef, NC);
+                                   move16 (); 
+
+        test (); 
+        if (L_mult (ylow, yhigh) <= (Word32) 0L)
+        {
+
+            /* divide 4 times the interval */
+
+            for (i = 0; i < 4; i++)
+            {
+                /* xmid = (xlow + xhigh)/2 */
+                xmid = add (shr (xlow, 1), shr (xhigh, 1));
+                ymid = Chebps (xmid, coef, NC);
+                                   move16 (); 
+
+                test (); 
+                if (L_mult (ylow, ymid) <= (Word32) 0L)
+                {
+                    yhigh = ymid;  move16 (); 
+                    xhigh = xmid;  move16 (); 
+                }
+                else
+                {
+                    ylow = ymid;   move16 (); 
+                    xlow = xmid;   move16 (); 
+                }
+            }
+
+            /*-------------------------------------------------------------*
+             * Linear interpolation                                        *
+             *    xint = xlow - ylow*(xhigh-xlow)/(yhigh-ylow);            *
+             *-------------------------------------------------------------*/
+
+            x = sub (xhigh, xlow);
+            y = sub (yhigh, ylow);
+
+            test (); 
+            if (y == 0)
+            {
+                xint = xlow;       move16 (); 
+            }
+            else
+            {
+                sign = y;          move16 (); 
+                y = abs_s (y);
+                exp = norm_s (y);
+                y = shl (y, exp);
+                y = div_s ((Word16) 16383, y);
+                t0 = L_mult (x, y);
+                t0 = L_shr (t0, sub (20, exp));
+                y = extract_l (t0);     /* y= (xhigh-xlow)/(yhigh-ylow) */
+
+                test (); 
+                if (sign < 0)
+                    y = negate (y);
+
+                t0 = L_mult (ylow, y);
+                t0 = L_shr (t0, 11);
+                xint = sub (xlow, extract_l (t0)); /* xint = xlow - ylow*y */
+            }
+
+            lsp[nf] = xint;        move16 (); 
+            xlow = xint;           move16 (); 
+            nf++;
+
+            test (); 
+            if (ip == 0)
+            {
+                ip = 1;            move16 (); 
+                coef = f2;         move16 (); 
+            }
+            else
+            {
+                ip = 0;            move16 (); 
+                coef = f1;         move16 (); 
+            }
+            ylow = Chebps (xlow, coef, NC);
+                                   move16 (); 
+
+        }
+        test (); test (); 
+    }
+
+    /* Check if M roots found */
+
+    test (); 
+    if (sub (nf, M) < 0)
+    {
+        for (i = 0; i < M; i++)
+        {
+            lsp[i] = old_lsp[i];   move16 (); 
+        }
+
+    }
+    return;
+}
+
diff -Nur FFMpeg-20050127/libavcodec/amr/az_lsp.h FFMpeg-20050127-new/libavcodec/amr/az_lsp.h
--- FFMpeg-20050127/libavcodec/amr/az_lsp.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/az_lsp.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,65 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : az_lsp.h
+*
+********************************************************************************
+*/
+#ifndef az_lsp_h
+#define az_lsp_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : Az_lsp
+*  Purpose     : Compute the LSPs from the LP coefficients
+*  Description : - The sum and difference filters are computed
+*                  and divided by 1+z^{-1} and 1-z^{-1}, respectively.
+*
+*                  f1[i] = a[i] + a[11-i] - f1[i-1] ;   i=1,...,5
+*                  f2[i] = a[i] - a[11-i] + f2[i-1] ;   i=1,...,5
+*
+*                - The roots of F1(z) and F2(z) are found using
+*                  Chebyshev polynomial evaluation. The polynomials
+*                  are evaluated at 60 points regularly spaced in the
+*                  frequency domain. The sign change interval is
+*                  subdivided 4 times to better track the root. The
+*                  LSPs are found in the cosine domain [1,-1].
+*
+*                - If less than 10 roots are found, the LSPs from 
+*                  the past frame are used.
+*  Returns     : void
+*
+**************************************************************************
+*/
+void Az_lsp (
+    Word16 a[],        /* (i)  : predictor coefficients (MP1)              */
+    Word16 lsp[],      /* (o)  : line spectral pairs (M)                   */
+    Word16 old_lsp[]   /* (i)  : old lsp[] (in case not found 10 roots) (M)*/
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/b_cn_cod.c FFMpeg-20050127-new/libavcodec/amr/b_cn_cod.c
--- FFMpeg-20050127/libavcodec/amr/b_cn_cod.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/b_cn_cod.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,162 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : b_cn_cod.c
+*      Purpose          : Contains function for comfort noise generation.
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "b_cn_cod.h"
+const char b_cn_cod_id[] = "@(#)$Id $" b_cn_cod_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "cnst.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "window.tab"
+/*
+********************************************************************************
+*                         LOCAL CONSTANTS
+********************************************************************************
+*/
+#define  NB_PULSE 10 /* number of random pulses in DTX operation   */
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *   FUNCTION NAME: pseudonoise
+ *
+ *************************************************************************/
+Word16 pseudonoise (
+    Word32 *shift_reg, /* i/o : Old CN generator shift register state */
+    Word16 no_bits     /* i   : Number of bits                        */
+)
+{
+   Word16 noise_bits, Sn, i;
+   
+   noise_bits = 0;                              move16 ();
+   for (i = 0; i < no_bits; i++)
+   {
+      /* State n == 31 */
+      test (); logic32 ();
+      if ((*shift_reg & 0x00000001L) != 0)
+      {
+         Sn = 1;                                move16 ();                         
+      }
+      else
+      {
+         Sn = 0;                                move16 ();                        
+      }
+      
+      /* State n == 3 */
+      test (); logic32 ();
+      if ((*shift_reg & 0x10000000L) != 0)
+      {
+         Sn = Sn ^ 1;                           move16 (); logic16 ();
+      }
+      else
+      {
+         Sn = Sn ^ 0;                           move16 (); logic16 ();  
+      }
+      
+      noise_bits = shl (noise_bits, 1);
+      noise_bits = noise_bits | (extract_l (*shift_reg) & 1);
+      logic16 (); logic16 (); move16 ();
+      
+      *shift_reg = L_shr (*shift_reg, 1);         
+      test ();
+      if (Sn & 1)
+      {
+         *shift_reg = *shift_reg | 0x40000000L; move32 (); logic32 ();
+      }
+   }
+   return noise_bits;
+}
+
+/***************************************************************************
+*
+*  Function    : build_CN_code
+*
+***************************************************************************/ 
+void build_CN_code (
+    Word32 *seed,         /* i/o : Old CN generator shift register state */
+    Word16 cod[]          /* o   : Generated CN fixed codebook vector    */
+)
+{
+   Word16 i, j, k;
+   
+   for (i = 0; i < L_SUBFR; i++)
+   {
+      cod[i] = 0;                    move16 ();     
+   }
+   
+   for (k = 0; k < NB_PULSE; k++)
+   {
+      i = pseudonoise (seed, 2);      /* generate pulse position */
+      i = shr (extract_l (L_mult (i, 10)), 1);
+      i = add (i, k);
+      
+      j = pseudonoise (seed, 1);      /* generate sign           */
+
+      test ();   
+      if (j > 0)
+      {
+         cod[i] = 4096;              move16 ();                   
+      }
+      else
+      {
+         cod[i] = -4096;             move16 ();                         
+      }
+   }
+   
+   return;
+}
+
+/*************************************************************************
+ *
+ *   FUNCTION NAME: build_CN_param
+ *
+ *************************************************************************/
+void build_CN_param (
+    Word16 *seed,             /* i/o : Old CN generator shift register state */
+    const Word16 n_param,           /* i  : number of params */  
+    const Word16 param_size_table[],/* i : size of params */   
+    Word16 parm[]             /* o : CN Generated params */
+    )
+{
+   Word16 i;
+   const Word16 *p;
+
+   *seed = extract_l(L_add(L_shr(L_mult(*seed, 31821), 1), 13849L));
+
+   p = &window_200_40[*seed & 0x7F]; logic16();
+   for(i=0; i< n_param;i++){
+     move16 (); logic16(); logic16(); logic16();
+     parm[i] = *p++ & ~(0xFFFF<<param_size_table[i]);  
+   }
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/b_cn_cod.h FFMpeg-20050127-new/libavcodec/amr/b_cn_cod.h
--- FFMpeg-20050127/libavcodec/amr/b_cn_cod.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/b_cn_cod.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,104 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : b_cn_cod.h
+*      Purpose          : Contains function for comfort noise generation.
+*
+********************************************************************************
+*/
+#ifndef b_cn_cod_h
+#define b_cn_cod_h "$Id $"
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ *   FUNCTION NAME: pseudonoise
+ *
+ *   PURPOSE: Generate a random integer value to use in comfort noise
+ *            generation. The algorithm uses polynomial x^31 + x^3 + 1
+ *            (length of PN sequence is 2^31 - 1).
+ *
+ *   INPUTS:      *shift_reg    Old CN generator shift register state
+ *
+ *
+ *   OUTPUTS:     *shift_reg    Updated CN generator shift register state
+ *
+ *   RETURN VALUE: Generated random integer value
+ *
+ *************************************************************************/
+
+Word16 pseudonoise (
+    Word32 *shift_reg, /* i/o : Old CN generator shift register state */
+    Word16 no_bits     /* i   : Number of bits                        */
+);
+
+/*************************************************************************
+ *
+ *   FUNCTION NAME: build_CN_code
+ *
+ *   PURPOSE: Compute the comfort noise fixed codebook excitation. The
+ *            gains of the pulses are always +/-1.
+ *
+ *   INPUTS:      *seed         Old CN generator shift register state
+ *
+ *   OUTPUTS:     cod[0..39]    Generated comfort noise fixed codebook vector
+ *                *seed         Updated CN generator shift register state
+ *
+ *   RETURN VALUE: none
+ *
+ *************************************************************************/
+void build_CN_code (
+    Word32 *seed,         /* i/o : Old CN generator shift register state */
+    Word16 cod[]          /* o   : Generated CN fixed codebook vector    */
+);
+
+/*************************************************************************
+ *
+ *   FUNCTION NAME: build_CN_param
+ *
+ *   PURPOSE: Randomize the speech parameters. So that they 
+ *            do not produce tonal artifacts if used by ECU.
+ *
+ *   INPUTS:      *seed            Old CN generator shift register state
+ *                n_param,         Number of parameters to randomize
+ *                parm_size_table, 
+ *                  
+ *
+ *   OUTPUTS:      parm    CN Generated Parameters
+ *                *seed    Updated CN generator shift register state
+ *
+ *   RETURN VALUE: none
+ *
+ *************************************************************************/
+void build_CN_param (
+    Word16 *seed,              /* i/o : Old CN generator shift register state */
+    const Word16 n_param,            /* i : number of params     */  
+    const Word16 param_size_table[], /* i : size of params       */   
+    Word16 parm[]              /* o   : CN Generated Params*/
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/basic_op.h FFMpeg-20050127-new/libavcodec/amr/basic_op.h
--- FFMpeg-20050127/libavcodec/amr/basic_op.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/basic_op.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,64 @@
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Constants and Globals                                                   |
+ |                                                                           |
+ | $Id $
+ |___________________________________________________________________________|
+*/
+extern Flag Overflow;
+extern Flag Carry;
+
+#define MAX_32 (Word32)0x7fffffffL
+#define MIN_32 (Word32)0x80000000L
+
+#define MAX_16 (Word16)0x7fff
+#define MIN_16 (Word16)0x8000
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Prototypes for basic arithmetic operators                               |
+ |___________________________________________________________________________|
+*/
+
+Word16 add (Word16 var1, Word16 var2);    /* Short add,           1   */
+Word16 sub (Word16 var1, Word16 var2);    /* Short sub,           1   */
+Word16 abs_s (Word16 var1);               /* Short abs,           1   */
+Word16 shl (Word16 var1, Word16 var2);    /* Short shift left,    1   */
+Word16 shr (Word16 var1, Word16 var2);    /* Short shift right,   1   */
+Word16 mult (Word16 var1, Word16 var2);   /* Short mult,          1   */
+Word32 L_mult (Word16 var1, Word16 var2); /* Long mult,           1   */
+Word16 negate (Word16 var1);              /* Short negate,        1   */
+Word16 extract_h (Word32 L_var1);         /* Extract high,        1   */
+Word16 extract_l (Word32 L_var1);         /* Extract low,         1   */
+Word16 round (Word32 L_var1);             /* Round,               1   */
+Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2);   /* Mac,  1  */
+Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2);   /* Msu,  1  */
+Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2); /* Mac without
+                                                             sat, 1   */
+Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2); /* Msu without
+                                                             sat, 1   */
+Word32 L_add (Word32 L_var1, Word32 L_var2);    /* Long add,        2 */
+Word32 L_sub (Word32 L_var1, Word32 L_var2);    /* Long sub,        2 */
+Word32 L_add_c (Word32 L_var1, Word32 L_var2);  /* Long add with c, 2 */
+Word32 L_sub_c (Word32 L_var1, Word32 L_var2);  /* Long sub with c, 2 */
+Word32 L_negate (Word32 L_var1);                /* Long negate,     2 */
+Word16 mult_r (Word16 var1, Word16 var2);       /* Mult with round, 2 */
+Word32 L_shl (Word32 L_var1, Word16 var2);      /* Long shift left, 2 */
+Word32 L_shr (Word32 L_var1, Word16 var2);      /* Long shift right, 2*/
+Word16 shr_r (Word16 var1, Word16 var2);        /* Shift right with
+                                                   round, 2           */
+Word16 mac_r (Word32 L_var3, Word16 var1, Word16 var2); /* Mac with
+                                                           rounding,2 */
+Word16 msu_r (Word32 L_var3, Word16 var1, Word16 var2); /* Msu with
+                                                           rounding,2 */
+Word32 L_deposit_h (Word16 var1);        /* 16 bit var1 -> MSB,     2 */
+Word32 L_deposit_l (Word16 var1);        /* 16 bit var1 -> LSB,     2 */
+
+Word32 L_shr_r (Word32 L_var1, Word16 var2); /* Long shift right with
+                                                round,  3             */
+Word32 L_abs (Word32 L_var1);            /* Long abs,              3  */
+Word32 L_sat (Word32 L_var1);            /* Long saturation,       4  */
+Word16 norm_s (Word16 var1);             /* Short norm,           15  */
+Word16 div_s (Word16 var1, Word16 var2); /* Short division,       18  */
+Word16 norm_l (Word32 L_var1);           /* Long norm,            30  */   
+
diff -Nur FFMpeg-20050127/libavcodec/amr/basicop2.c FFMpeg-20050127-new/libavcodec/amr/basicop2.c
--- FFMpeg-20050127/libavcodec/amr/basicop2.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/basicop2.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,2136 @@
+/*___________________________________________________________________________
+ |                                                                           |
+ | Basic arithmetic operators.                                               |
+ |                                                                           |
+ | $Id $
+ |___________________________________________________________________________|
+*/
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Include-Files                                                           |
+ |___________________________________________________________________________|
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "typedef.h"
+#include "basic_op.h"
+
+#if (WMOPS)
+#include "count.h"
+extern BASIC_OP multiCounter[MAXCOUNTERS];
+extern int currCounter;
+
+#endif
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Local Functions                                                         |
+ |___________________________________________________________________________|
+*/
+Word16 saturate (Word32 L_var1);
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Constants and Globals                                                   |
+ |___________________________________________________________________________|
+*/
+Flag Overflow = 0;
+Flag Carry = 0;
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Functions                                                               |
+ |___________________________________________________________________________|
+*/
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : saturate                                                |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |    Limit the 32 bit input to the range of a 16 bit word.                  |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1                                                                 |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+
+Word16 
+saturate (Word32 L_var1)
+{
+    Word16 var_out;
+
+    if (L_var1 > 0X00007fffL)
+    {
+        Overflow = 1;
+        var_out = MAX_16;
+    }
+    else if (L_var1 < (Word32) 0xffff8000L)
+    {
+        Overflow = 1;
+        var_out = MIN_16;
+    }
+    else
+    {
+        var_out = extract_l (L_var1);
+#if (WMOPS)
+        multiCounter[currCounter].extract_l--;
+#endif
+    }
+
+    return (var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : add                                                     |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |    Performs the addition (var1+var2) with overflow control and saturation;|
+ |    the 16 bit result is set at +32767 when overflow occurs or at -32768   |
+ |    when underflow occurs.                                                 |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+
+Word16 add (Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+    Word32 L_sum;
+
+    L_sum = (Word32) var1 + var2;
+    var_out = saturate (L_sum);
+#if (WMOPS)
+    multiCounter[currCounter].add++;
+#endif
+    return (var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : sub                                                     |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |    Performs the subtraction (var1+var2) with overflow control and satu-   |
+ |    ration; the 16 bit result is set at +32767 when overflow occurs or at  |
+ |    -32768 when underflow occurs.                                          |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+
+Word16 sub (Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+    Word32 L_diff;
+
+    L_diff = (Word32) var1 - var2;
+    var_out = saturate (L_diff);
+#if (WMOPS)
+    multiCounter[currCounter].sub++;
+#endif
+    return (var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : abs_s                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |    Absolute value of var1; abs_s(-32768) = 32767.                         |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+
+Word16 abs_s (Word16 var1)
+{
+    Word16 var_out;
+
+    if (var1 == (Word16) 0X8000)
+    {
+        var_out = MAX_16;
+    }
+    else
+    {
+        if (var1 < 0)
+        {
+            var_out = -var1;
+        }
+        else
+        {
+            var_out = var1;
+        }
+    }
+#if (WMOPS)
+    multiCounter[currCounter].abs_s++;
+#endif
+    return (var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : shl                                                     |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Arithmetically shift the 16 bit input var1 left var2 positions.Zero fill|
+ |   the var2 LSB of the result. If var2 is negative, arithmetically shift   |
+ |   var1 right by -var2 with sign extension. Saturate the result in case of |
+ |   underflows or overflows.                                                |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+
+Word16 shl (Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+    Word32 result;
+
+    if (var2 < 0)
+    {
+        if (var2 < -16)
+            var2 = -16;
+        var_out = shr (var1, -var2);
+#if (WMOPS)
+        multiCounter[currCounter].shr--;
+#endif
+    }
+    else
+    {
+        result = (Word32) var1 *((Word32) 1 << var2);
+
+        if ((var2 > 15 && var1 != 0) || (result != (Word32) ((Word16) result)))
+        {
+            Overflow = 1;
+            var_out = (var1 > 0) ? MAX_16 : MIN_16;
+        }
+        else
+        {
+            var_out = extract_l (result);
+#if (WMOPS)
+            multiCounter[currCounter].extract_l--;
+#endif
+        }
+    }
+#if (WMOPS)
+    multiCounter[currCounter].shl++;
+#endif
+    return (var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : shr                                                     |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Arithmetically shift the 16 bit input var1 right var2 positions with    |
+ |   sign extension. If var2 is negative, arithmetically shift var1 left by  |
+ |   -var2 with sign extension. Saturate the result in case of underflows or |
+ |   overflows.                                                              |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+
+Word16 shr (Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+
+    if (var2 < 0)
+    {
+        if (var2 < -16)
+            var2 = -16;
+        var_out = shl (var1, -var2);
+#if (WMOPS)
+        multiCounter[currCounter].shl--;
+#endif
+    }
+    else
+    {
+        if (var2 >= 15)
+        {
+            var_out = (var1 < 0) ? -1 : 0;
+        }
+        else
+        {
+            if (var1 < 0)
+            {
+                var_out = ~((~var1) >> var2);
+            }
+            else
+            {
+                var_out = var1 >> var2;
+            }
+        }
+    }
+
+#if (WMOPS)
+    multiCounter[currCounter].shr++;
+#endif
+    return (var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : mult                                                    |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |    Performs the multiplication of var1 by var2 and gives a 16 bit result  |
+ |    which is scaled i.e.:                                                  |
+ |             mult(var1,var2) = extract_l(L_shr((var1 times var2),15)) and  |
+ |             mult(-32768,-32768) = 32767.                                  |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+
+Word16 mult (Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+    Word32 L_product;
+
+    L_product = (Word32) var1 *(Word32) var2;
+
+    L_product = (L_product & (Word32) 0xffff8000L) >> 15;
+
+    if (L_product & (Word32) 0x00010000L)
+        L_product = L_product | (Word32) 0xffff0000L;
+
+    var_out = saturate (L_product);
+#if (WMOPS)
+    multiCounter[currCounter].mult++;
+#endif
+    return (var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_mult                                                  |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   L_mult is the 32 bit result of the multiplication of var1 times var2    |
+ |   with one shift left i.e.:                                               |
+ |        L_mult(var1,var2) = L_shl((var1 times var2),1) and                   |
+ |        L_mult(-32768,-32768) = 2147483647.                                |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |___________________________________________________________________________|
+*/
+
+Word32 L_mult (Word16 var1, Word16 var2)
+{
+    Word32 L_var_out;
+
+    L_var_out = (Word32) var1 *(Word32) var2;
+
+    if (L_var_out != (Word32) 0x40000000L)
+    {
+        L_var_out *= 2;
+    }
+    else
+    {
+        Overflow = 1;
+        L_var_out = MAX_32;
+    }
+
+#if (WMOPS)
+    multiCounter[currCounter].L_mult++;
+#endif
+    return (L_var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : negate                                                  |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Negate var1 with saturation, saturate in the case where input is -32768:|
+ |                negate(var1) = sub(0,var1).                                |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+
+Word16 negate (Word16 var1)
+{
+    Word16 var_out;
+
+    var_out = (var1 == MIN_16) ? MAX_16 : -var1;
+#if (WMOPS)
+    multiCounter[currCounter].negate++;
+#endif
+    return (var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : extract_h                                               |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Return the 16 MSB of L_var1.                                            |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1                                                                 |
+ |             32 bit long signed integer (Word32 ) whose value falls in the |
+ |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+
+Word16 extract_h (Word32 L_var1)
+{
+    Word16 var_out;
+
+    var_out = (Word16) (L_var1 >> 16);
+#if (WMOPS)
+    multiCounter[currCounter].extract_h++;
+#endif
+    return (var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : extract_l                                               |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Return the 16 LSB of L_var1.                                            |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1                                                                 |
+ |             32 bit long signed integer (Word32 ) whose value falls in the |
+ |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+
+Word16 extract_l (Word32 L_var1)
+{
+    Word16 var_out;
+
+    var_out = (Word16) L_var1;
+#if (WMOPS)
+    multiCounter[currCounter].extract_l++;
+#endif
+    return (var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : round                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Round the lower 16 bits of the 32 bit input number into the MS 16 bits  |
+ |   with saturation. Shift the resulting bits right by 16 and return the 16 |
+ |   bit number:                                                             |
+ |               round(L_var1) = extract_h(L_add(L_var1,32768))              |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1                                                                 |
+ |             32 bit long signed integer (Word32 ) whose value falls in the |
+ |             range : 0x8000 0000 <= L_var1 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+
+Word16 round (Word32 L_var1)
+{
+    Word16 var_out;
+    Word32 L_rounded;
+
+    L_rounded = L_add (L_var1, (Word32) 0x00008000L);
+#if (WMOPS)
+    multiCounter[currCounter].L_add--;
+#endif
+    var_out = extract_h (L_rounded);
+#if (WMOPS)
+    multiCounter[currCounter].extract_h--;
+    multiCounter[currCounter].round++;
+#endif
+    return (var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_mac                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
+ |   result to L_var3 with saturation, return a 32 bit result:               |
+ |        L_mac(L_var3,var1,var2) = L_add(L_var3,L_mult(var1,var2)).         |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |___________________________________________________________________________|
+*/
+
+Word32 L_mac (Word32 L_var3, Word16 var1, Word16 var2)
+{
+    Word32 L_var_out;
+    Word32 L_product;
+
+    L_product = L_mult (var1, var2);
+#if (WMOPS)
+    multiCounter[currCounter].L_mult--;
+#endif
+    L_var_out = L_add (L_var3, L_product);
+#if (WMOPS)
+    multiCounter[currCounter].L_add--;
+    multiCounter[currCounter].L_mac++;
+#endif
+    return (L_var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_msu                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
+ |   bit result to L_var3 with saturation, return a 32 bit result:           |
+ |        L_msu(L_var3,var1,var2) = L_sub(L_var3,L_mult(var1,var2)).         |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |___________________________________________________________________________|
+*/
+
+Word32 L_msu (Word32 L_var3, Word16 var1, Word16 var2)
+{
+    Word32 L_var_out;
+    Word32 L_product;
+
+    L_product = L_mult (var1, var2);
+#if (WMOPS)
+    multiCounter[currCounter].L_mult--;
+#endif
+    L_var_out = L_sub (L_var3, L_product);
+#if (WMOPS)
+    multiCounter[currCounter].L_sub--;
+    multiCounter[currCounter].L_msu++;
+#endif
+    return (L_var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_macNs                                                 |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
+ |   result to L_var3 without saturation, return a 32 bit result. Generate   |
+ |   carry and overflow values :                                             |
+ |        L_macNs(L_var3,var1,var2) = L_add_c(L_var3,L_mult(var1,var2)).     |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |                                                                           |
+ |   Caution :                                                               |
+ |                                                                           |
+ |    In some cases the Carry flag has to be cleared or set before using     |
+ |    operators which take into account its value.                           |
+ |___________________________________________________________________________|
+*/
+
+Word32 L_macNs (Word32 L_var3, Word16 var1, Word16 var2)
+{
+    Word32 L_var_out;
+
+    L_var_out = L_mult (var1, var2);
+#if (WMOPS)
+    multiCounter[currCounter].L_mult--;
+#endif
+    L_var_out = L_add_c (L_var3, L_var_out);
+#if (WMOPS)
+    multiCounter[currCounter].L_add_c--;
+    multiCounter[currCounter].L_macNs++;
+#endif
+    return (L_var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_msuNs                                                 |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
+ |   bit result from L_var3 without saturation, return a 32 bit result. Ge-  |
+ |   nerate carry and overflow values :                                      |
+ |        L_msuNs(L_var3,var1,var2) = L_sub_c(L_var3,L_mult(var1,var2)).     |
+ |                                                                           |
+ |   Complexity weight : 1                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |                                                                           |
+ |   Caution :                                                               |
+ |                                                                           |
+ |    In some cases the Carry flag has to be cleared or set before using     |
+ |    operators which take into account its value.                           |
+ |___________________________________________________________________________|
+*/
+
+Word32 L_msuNs (Word32 L_var3, Word16 var1, Word16 var2)
+{
+    Word32 L_var_out;
+
+    L_var_out = L_mult (var1, var2);
+#if (WMOPS)
+    multiCounter[currCounter].L_mult--;
+#endif
+    L_var_out = L_sub_c (L_var3, L_var_out);
+#if (WMOPS)
+    multiCounter[currCounter].L_sub_c--;
+    multiCounter[currCounter].L_msuNs++;
+#endif
+    return (L_var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_add                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   32 bits addition of the two 32 bits variables (L_var1+L_var2) with      |
+ |   overflow control and saturation; the result is set at +2147483647 when  |
+ |   overflow occurs or at -2147483648 when underflow occurs.                |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |___________________________________________________________________________|
+*/
+
+Word32 L_add (Word32 L_var1, Word32 L_var2)
+{
+    Word32 L_var_out;
+
+    L_var_out = L_var1 + L_var2;
+
+    if (((L_var1 ^ L_var2) & MIN_32) == 0)
+    {
+        if ((L_var_out ^ L_var1) & MIN_32)
+        {
+            L_var_out = (L_var1 < 0) ? MIN_32 : MAX_32;
+            Overflow = 1;
+        }
+    }
+#if (WMOPS)
+    multiCounter[currCounter].L_add++;
+#endif
+    return (L_var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_sub                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   32 bits subtraction of the two 32 bits variables (L_var1-L_var2) with   |
+ |   overflow control and saturation; the result is set at +2147483647 when  |
+ |   overflow occurs or at -2147483648 when underflow occurs.                |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |___________________________________________________________________________|
+*/
+
+Word32 L_sub (Word32 L_var1, Word32 L_var2)
+{
+    Word32 L_var_out;
+
+    L_var_out = L_var1 - L_var2;
+
+    if (((L_var1 ^ L_var2) & MIN_32) != 0)
+    {
+        if ((L_var_out ^ L_var1) & MIN_32)
+        {
+            L_var_out = (L_var1 < 0L) ? MIN_32 : MAX_32;
+            Overflow = 1;
+        }
+    }
+#if (WMOPS)
+    multiCounter[currCounter].L_sub++;
+#endif
+    return (L_var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_add_c                                                 |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Performs 32 bits addition of the two 32 bits variables (L_var1+L_var2+C)|
+ |   with carry. No saturation. Generate carry and Overflow values. The car- |
+ |   ry and overflow values are binary variables which can be tested and as- |
+ |   signed values.                                                          |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |                                                                           |
+ |   Caution :                                                               |
+ |                                                                           |
+ |    In some cases the Carry flag has to be cleared or set before using     |
+ |    operators which take into account its value.                           |
+ |___________________________________________________________________________|
+*/
+Word32 L_add_c (Word32 L_var1, Word32 L_var2)
+{
+    Word32 L_var_out;
+    Word32 L_test;
+    Flag carry_int = 0;
+
+    L_var_out = L_var1 + L_var2 + Carry;
+
+    L_test = L_var1 + L_var2;
+
+    if ((L_var1 > 0) && (L_var2 > 0) && (L_test < 0))
+    {
+        Overflow = 1;
+        carry_int = 0;
+    }
+    else
+    {
+        if ((L_var1 < 0) && (L_var2 < 0))
+        {
+            if (L_test >= 0)
+	    {
+                Overflow = 1;
+                carry_int = 1;
+	    }
+            else
+	    {
+                Overflow = 0;
+                carry_int = 1;
+	    }
+        }
+        else
+        {
+            if (((L_var1 ^ L_var2) < 0) && (L_test >= 0))
+            {
+                Overflow = 0;
+                carry_int = 1;
+            }
+            else
+            {
+                Overflow = 0;
+                carry_int = 0;
+            }
+        }
+    }
+
+    if (Carry)
+    {
+        if (L_test == MAX_32)
+        {
+            Overflow = 1;
+            Carry = carry_int;
+        }
+        else
+        {
+            if (L_test == (Word32) 0xFFFFFFFFL)
+            {
+                Carry = 1;
+            }
+            else
+            {
+                Carry = carry_int;
+            }
+        }
+    }
+    else
+    {
+        Carry = carry_int;
+    }
+
+#if (WMOPS)
+    multiCounter[currCounter].L_add_c++;
+#endif
+    return (L_var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_sub_c                                                 |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Performs 32 bits subtraction of the two 32 bits variables with carry    |
+ |   (borrow) : L_var1-L_var2-C. No saturation. Generate carry and Overflow  |
+ |   values. The carry and overflow values are binary variables which can    |
+ |   be tested and assigned values.                                          |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    L_var2   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |                                                                           |
+ |   Caution :                                                               |
+ |                                                                           |
+ |    In some cases the Carry flag has to be cleared or set before using     |
+ |    operators which take into account its value.                           |
+ |___________________________________________________________________________|
+*/
+
+Word32 L_sub_c (Word32 L_var1, Word32 L_var2)
+{
+    Word32 L_var_out;
+    Word32 L_test;
+    Flag carry_int = 0;
+
+    if (Carry)
+    {
+        Carry = 0;
+        if (L_var2 != MIN_32)
+        {
+            L_var_out = L_add_c (L_var1, -L_var2);
+#if (WMOPS)
+            multiCounter[currCounter].L_add_c--;
+#endif
+        }
+        else
+        {
+            L_var_out = L_var1 - L_var2;
+            if (L_var1 > 0L)
+            {
+                Overflow = 1;
+                Carry = 0;
+            }
+        }
+    }
+    else
+    {
+        L_var_out = L_var1 - L_var2 - (Word32) 0X00000001L;
+        L_test = L_var1 - L_var2;
+
+        if ((L_test < 0) && (L_var1 > 0) && (L_var2 < 0))
+        {
+            Overflow = 1;
+            carry_int = 0;
+        }
+        else if ((L_test > 0) && (L_var1 < 0) && (L_var2 > 0))
+        {
+            Overflow = 1;
+            carry_int = 1;
+        }
+        else if ((L_test > 0) && ((L_var1 ^ L_var2) > 0))
+        {
+            Overflow = 0;
+            carry_int = 1;
+        }
+        if (L_test == MIN_32)
+        {
+            Overflow = 1;
+            Carry = carry_int;
+        }
+        else
+        {
+            Carry = carry_int;
+        }
+    }
+
+#if (WMOPS)
+    multiCounter[currCounter].L_sub_c++;
+#endif
+    return (L_var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_negate                                                |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Negate the 32 bit variable L_var1 with saturation; saturate in the case |
+ |   where input is -2147483648 (0x8000 0000).                               |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |___________________________________________________________________________|
+*/
+
+Word32 L_negate (Word32 L_var1)
+{
+    Word32 L_var_out;
+
+    L_var_out = (L_var1 == MIN_32) ? MAX_32 : -L_var1;
+#if (WMOPS)
+    multiCounter[currCounter].L_negate++;
+#endif
+    return (L_var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : mult_r                                                  |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Same as mult with rounding, i.e.:                                       |
+ |     mult_r(var1,var2) = extract_l(L_shr(((var1 * var2) + 16384),15)) and  |
+ |     mult_r(-32768,-32768) = 32767.                                        |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+
+Word16 mult_r (Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+    Word32 L_product_arr;
+
+    L_product_arr = (Word32) var1 *(Word32) var2;       /* product */
+    L_product_arr += (Word32) 0x00004000L;      /* round */
+    L_product_arr &= (Word32) 0xffff8000L;
+    L_product_arr >>= 15;       /* shift */
+
+    if (L_product_arr & (Word32) 0x00010000L)   /* sign extend when necessary */
+    {
+        L_product_arr |= (Word32) 0xffff0000L;
+    }
+    var_out = saturate (L_product_arr);
+#if (WMOPS)
+    multiCounter[currCounter].mult_r++;
+#endif
+    return (var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_shl                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Arithmetically shift the 32 bit input L_var1 left var2 positions. Zero  |
+ |   fill the var2 LSB of the result. If var2 is negative, arithmetically    |
+ |   shift L_var1 right by -var2 with sign extension. Saturate the result in |
+ |   case of underflows or overflows.                                        |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |___________________________________________________________________________|
+*/
+
+Word32 L_shl (Word32 L_var1, Word16 var2)
+{
+    Word32 L_var_out;
+
+    if (var2 <= 0)
+    {
+        if (var2 < -32)
+            var2 = -32;
+        L_var_out = L_shr (L_var1, -var2);
+#if (WMOPS)
+        multiCounter[currCounter].L_shr--;
+#endif
+    }
+    else
+    {
+        for (; var2 > 0; var2--)
+        {
+            if (L_var1 > (Word32) 0X3fffffffL)
+            {
+                Overflow = 1;
+                L_var_out = MAX_32;
+                break;
+            }
+            else
+            {
+                if (L_var1 < (Word32) 0xc0000000L)
+                {
+                    Overflow = 1;
+                    L_var_out = MIN_32;
+                    break;
+                }
+            }
+            L_var1 *= 2;
+            L_var_out = L_var1;
+        }
+    }
+#if (WMOPS)
+    multiCounter[currCounter].L_shl++;
+#endif
+    return (L_var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_shr                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Arithmetically shift the 32 bit input L_var1 right var2 positions with  |
+ |   sign extension. If var2 is negative, arithmetically shift L_var1 left   |
+ |   by -var2 and zero fill the -var2 LSB of the result. Saturate the result |
+ |   in case of underflows or overflows.                                     |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var_out <= 0x7fff ffff.              |
+ |___________________________________________________________________________|
+*/
+
+Word32 L_shr (Word32 L_var1, Word16 var2)
+{
+    Word32 L_var_out;
+
+    if (var2 < 0)
+    {
+        if (var2 < -32)
+            var2 = -32;
+        L_var_out = L_shl (L_var1, -var2);
+#if (WMOPS)
+        multiCounter[currCounter].L_shl--;
+#endif
+    }
+    else
+    {
+        if (var2 >= 31)
+        {
+            L_var_out = (L_var1 < 0L) ? -1 : 0;
+        }
+        else
+        {
+            if (L_var1 < 0)
+            {
+                L_var_out = ~((~L_var1) >> var2);
+            }
+            else
+            {
+                L_var_out = L_var1 >> var2;
+            }
+        }
+    }
+#if (WMOPS)
+    multiCounter[currCounter].L_shr++;
+#endif
+    return (L_var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : shr_r                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Same as shr(var1,var2) but with rounding. Saturate the result in case of|
+ |   underflows or overflows :                                               |
+ |    - If var2 is greater than zero :                                       |
+ |          if (sub(shl(shr(var1,var2),1),shr(var1,sub(var2,1))))            |
+ |          is equal to zero                                                 |
+ |                     then                                                  |
+ |                     shr_r(var1,var2) = shr(var1,var2)                     |
+ |                     else                                                  |
+ |                     shr_r(var1,var2) = add(shr(var1,var2),1)              |
+ |    - If var2 is less than or equal to zero :                              |
+ |                     shr_r(var1,var2) = shr(var1,var2).                    |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+
+Word16 shr_r (Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+
+    if (var2 > 15)
+    {
+        var_out = 0;
+    }
+    else
+    {
+        var_out = shr (var1, var2);
+#if (WMOPS)
+        multiCounter[currCounter].shr--;
+#endif
+
+        if (var2 > 0)
+        {
+            if ((var1 & ((Word16) 1 << (var2 - 1))) != 0)
+            {
+                var_out++;
+            }
+        }
+    }
+#if (WMOPS)
+    multiCounter[currCounter].shr_r++;
+#endif
+    return (var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : mac_r                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Multiply var1 by var2 and shift the result left by 1. Add the 32 bit    |
+ |   result to L_var3 with saturation. Round the LS 16 bits of the result    |
+ |   into the MS 16 bits with saturation and shift the result right by 16.   |
+ |   Return a 16 bit result.                                                 |
+ |            mac_r(L_var3,var1,var2) = round(L_mac(L_var3,var1,var2))       |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0x0000 8000 <= L_var_out <= 0x0000 7fff.              |
+ |___________________________________________________________________________|
+*/
+
+Word16 mac_r (Word32 L_var3, Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+
+    L_var3 = L_mac (L_var3, var1, var2);
+#if (WMOPS)
+    multiCounter[currCounter].L_mac--;
+#endif
+    L_var3 = L_add (L_var3, (Word32) 0x00008000L);
+#if (WMOPS)
+    multiCounter[currCounter].L_add--;
+#endif
+    var_out = extract_h (L_var3);
+#if (WMOPS)
+    multiCounter[currCounter].extract_h--;
+    multiCounter[currCounter].mac_r++;
+#endif
+    return (var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : msu_r                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Multiply var1 by var2 and shift the result left by 1. Subtract the 32   |
+ |   bit result to L_var3 with saturation. Round the LS 16 bits of the res-  |
+ |   ult into the MS 16 bits with saturation and shift the result right by   |
+ |   16. Return a 16 bit result.                                             |
+ |            msu_r(L_var3,var1,var2) = round(L_msu(L_var3,var1,var2))       |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var3   32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= L_var3 <= 0x7fff ffff.                 |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0x0000 8000 <= L_var_out <= 0x0000 7fff.              |
+ |___________________________________________________________________________|
+*/
+
+Word16 msu_r (Word32 L_var3, Word16 var1, Word16 var2)
+{
+    Word16 var_out;
+
+    L_var3 = L_msu (L_var3, var1, var2);
+#if (WMOPS)
+    multiCounter[currCounter].L_msu--;
+#endif
+    L_var3 = L_add (L_var3, (Word32) 0x00008000L);
+#if (WMOPS)
+    multiCounter[currCounter].L_add--;
+#endif
+    var_out = extract_h (L_var3);
+#if (WMOPS)
+    multiCounter[currCounter].extract_h--;
+    multiCounter[currCounter].msu_r++;
+#endif
+    return (var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_deposit_h                                             |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Deposit the 16 bit var1 into the 16 MS bits of the 32 bit output. The   |
+ |   16 LS bits of the output are zeroed.                                    |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= var_out <= 0x7fff 0000.                |
+ |___________________________________________________________________________|
+*/
+
+Word32 L_deposit_h (Word16 var1)
+{
+    Word32 L_var_out;
+
+    L_var_out = (Word32) var1 << 16;
+#if (WMOPS)
+    multiCounter[currCounter].L_deposit_h++;
+#endif
+    return (L_var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_deposit_l                                             |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Deposit the 16 bit var1 into the 16 LS bits of the 32 bit output. The   |
+ |   16 MS bits of the output are sign extended.                             |
+ |                                                                           |
+ |   Complexity weight : 2                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0xFFFF 8000 <= var_out <= 0x0000 7fff.                |
+ |___________________________________________________________________________|
+*/
+
+Word32 L_deposit_l (Word16 var1)
+{
+    Word32 L_var_out;
+
+    L_var_out = (Word32) var1;
+#if (WMOPS)
+    multiCounter[currCounter].L_deposit_l++;
+#endif
+    return (L_var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_shr_r                                                 |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Same as L_shr(L_var1,var2) but with rounding. Saturate the result in    |
+ |   case of underflows or overflows :                                       |
+ |    - If var2 is greater than zero :                                       |
+ |          if (L_sub(L_shl(L_shr(L_var1,var2),1),L_shr(L_var1,sub(var2,1))))|
+ |          is equal to zero                                                 |
+ |                     then                                                  |
+ |                     L_shr_r(L_var1,var2) = L_shr(L_var1,var2)             |
+ |                     else                                                  |
+ |                     L_shr_r(L_var1,var2) = L_add(L_shr(L_var1,var2),1)    |
+ |    - If var2 is less than or equal to zero :                              |
+ |                     L_shr_r(L_var1,var2) = L_shr(L_var1,var2).            |
+ |                                                                           |
+ |   Complexity weight : 3                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1                                                                 |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= var_out <= 0x7fff ffff.                |
+ |___________________________________________________________________________|
+*/
+
+Word32 L_shr_r (Word32 L_var1, Word16 var2)
+{
+    Word32 L_var_out;
+
+    if (var2 > 31)
+    {
+        L_var_out = 0;
+    }
+    else
+    {
+        L_var_out = L_shr (L_var1, var2);
+#if (WMOPS)
+        multiCounter[currCounter].L_shr--;
+#endif
+        if (var2 > 0)
+        {
+            if ((L_var1 & ((Word32) 1 << (var2 - 1))) != 0)
+            {
+                L_var_out++;
+            }
+        }
+    }
+#if (WMOPS)
+    multiCounter[currCounter].L_shr_r++;
+#endif
+    return (L_var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_abs                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |    Absolute value of L_var1; Saturate in case where the input is          |
+ |                                                               -214783648  |
+ |                                                                           |
+ |   Complexity weight : 3                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1                                                                 |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x0000 0000 <= var_out <= 0x7fff ffff.                |
+ |___________________________________________________________________________|
+*/
+
+Word32 L_abs (Word32 L_var1)
+{
+    Word32 L_var_out;
+
+    if (L_var1 == MIN_32)
+    {
+        L_var_out = MAX_32;
+    }
+    else
+    {
+        if (L_var1 < 0)
+        {
+            L_var_out = -L_var1;
+        }
+        else
+        {
+            L_var_out = L_var1;
+        }
+    }
+
+#if (WMOPS)
+    multiCounter[currCounter].L_abs++;
+#endif
+    return (L_var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : L_sat                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |    32 bit L_var1 is set to 2147483647 if an overflow occured or to        |
+ |    -2147483648 if an underflow occured on the most recent L_add_c,        |
+ |    L_sub_c, L_macNs or L_msuNs operations. The carry and overflow values  |
+ |    are binary values which can be tested and assigned values.             |
+ |                                                                           |
+ |   Complexity weight : 4                                                   |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1                                                                 |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    L_var_out                                                              |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= var_out <= 0x7fff ffff.                |
+ |___________________________________________________________________________|
+*/
+
+Word32 L_sat (Word32 L_var1)
+{
+    Word32 L_var_out;
+
+    L_var_out = L_var1;
+
+    if (Overflow)
+    {
+
+        if (Carry)
+        {
+            L_var_out = MIN_32;
+        }
+        else
+        {
+            L_var_out = MAX_32;
+        }
+
+        Carry = 0;
+        Overflow = 0;
+    }
+#if (WMOPS)
+    multiCounter[currCounter].L_sat++;
+#endif
+    return (L_var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : norm_s                                                  |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Produces the number of left shift needed to normalize the 16 bit varia- |
+ |   ble var1 for positive values on the interval with minimum of 16384 and  |
+ |   maximum of 32767, and for negative values on the interval with minimum  |
+ |   of -32768 and maximum of -16384; in order to normalize the result, the  |
+ |   following operation must be done :                                      |
+ |                    norm_var1 = shl(var1,norm_s(var1)).                    |
+ |                                                                           |
+ |   Complexity weight : 15                                                  |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0xffff 8000 <= var1 <= 0x0000 7fff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0x0000 0000 <= var_out <= 0x0000 000f.                |
+ |___________________________________________________________________________|
+*/
+
+Word16 norm_s (Word16 var1)
+{
+    Word16 var_out;
+
+    if (var1 == 0)
+    {
+        var_out = 0;
+    }
+    else
+    {
+        if (var1 == (Word16) 0xffff)
+        {
+            var_out = 15;
+        }
+        else
+        {
+            if (var1 < 0)
+            {
+                var1 = ~var1;
+            }
+            for (var_out = 0; var1 < 0x4000; var_out++)
+            {
+                var1 <<= 1;
+            }
+        }
+    }
+
+#if (WMOPS)
+    multiCounter[currCounter].norm_s++;
+#endif
+    return (var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : div_s                                                   |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Produces a result which is the fractional integer division of var1  by  |
+ |   var2; var1 and var2 must be positive and var2 must be greater or equal  |
+ |   to var1; the result is positive (leading bit equal to 0) and truncated  |
+ |   to 16 bits.                                                             |
+ |   If var1 = var2 then div(var1,var2) = 32767.                             |
+ |                                                                           |
+ |   Complexity weight : 18                                                  |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    var1                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0x0000 0000 <= var1 <= var2 and var2 != 0.            |
+ |                                                                           |
+ |    var2                                                                   |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : var1 <= var2 <= 0x0000 7fff and var2 != 0.            |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0x0000 0000 <= var_out <= 0x0000 7fff.                |
+ |             It's a Q15 value (point between b15 and b14).                 |
+ |___________________________________________________________________________|
+*/
+
+Word16 div_s (Word16 var1, Word16 var2)
+{
+    Word16 var_out = 0;
+    Word16 iteration;
+    Word32 L_num;
+    Word32 L_denom;
+
+    if ((var1 > var2) || (var1 < 0) || (var2 < 0))
+    {
+        printf ("Division Error var1=%d  var2=%d\n", var1, var2);
+        abort(); /* exit (0); */
+    }
+    if (var2 == 0)
+    {
+        printf ("Division by 0, Fatal error \n");
+        abort(); /* exit (0); */
+    }
+    if (var1 == 0)
+    {
+        var_out = 0;
+    }
+    else
+    {
+        if (var1 == var2)
+        {
+            var_out = MAX_16;
+        }
+        else
+        {
+            L_num = L_deposit_l (var1);
+#if (WMOPS)
+            multiCounter[currCounter].L_deposit_l--;
+#endif
+            L_denom = L_deposit_l (var2);
+#if (WMOPS)
+            multiCounter[currCounter].L_deposit_l--;
+#endif
+
+            for (iteration = 0; iteration < 15; iteration++)
+            {
+                var_out <<= 1;
+                L_num <<= 1;
+
+                if (L_num >= L_denom)
+                {
+                    L_num = L_sub (L_num, L_denom);
+#if (WMOPS)
+                    multiCounter[currCounter].L_sub--;
+#endif
+                    var_out = add (var_out, 1);
+#if (WMOPS)
+                    multiCounter[currCounter].add--;
+#endif
+                }
+            }
+        }
+    }
+
+#if (WMOPS)
+    multiCounter[currCounter].div_s++;
+#endif
+    return (var_out);
+}
+
+/*___________________________________________________________________________
+ |                                                                           |
+ |   Function Name : norm_l                                                  |
+ |                                                                           |
+ |   Purpose :                                                               |
+ |                                                                           |
+ |   Produces the number of left shifts needed to normalize the 32 bit varia-|
+ |   ble L_var1 for positive values on the interval with minimum of          |
+ |   1073741824 and maximum of 2147483647, and for negative values on the in-|
+ |   terval with minimum of -2147483648 and maximum of -1073741824; in order |
+ |   to normalize the result, the following operation must be done :         |
+ |                   norm_L_var1 = L_shl(L_var1,norm_l(L_var1)).             |
+ |                                                                           |
+ |   Complexity weight : 30                                                  |
+ |                                                                           |
+ |   Inputs :                                                                |
+ |                                                                           |
+ |    L_var1                                                                 |
+ |             32 bit long signed integer (Word32) whose value falls in the  |
+ |             range : 0x8000 0000 <= var1 <= 0x7fff ffff.                   |
+ |                                                                           |
+ |   Outputs :                                                               |
+ |                                                                           |
+ |    none                                                                   |
+ |                                                                           |
+ |   Return Value :                                                          |
+ |                                                                           |
+ |    var_out                                                                |
+ |             16 bit short signed integer (Word16) whose value falls in the |
+ |             range : 0x0000 0000 <= var_out <= 0x0000 001f.                |
+ |___________________________________________________________________________|
+*/
+
+Word16 norm_l (Word32 L_var1)
+{
+    Word16 var_out;
+
+    if (L_var1 == 0)
+    {
+        var_out = 0;
+    }
+    else
+    {
+        if (L_var1 == (Word32) 0xffffffffL)
+        {
+            var_out = 31;
+        }
+        else
+        {
+            if (L_var1 < 0)
+            {
+                L_var1 = ~L_var1;
+            }
+            for (var_out = 0; L_var1 < (Word32) 0x40000000L; var_out++)
+            {
+                L_var1 <<= 1;
+            }
+        }
+    }
+
+#if (WMOPS)
+    multiCounter[currCounter].norm_l++;
+#endif
+    return (var_out);
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/bgnscd.c FFMpeg-20050127-new/libavcodec/amr/bgnscd.c
--- FFMpeg-20050127/libavcodec/amr/bgnscd.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/bgnscd.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,289 @@
+/*************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : bgnscd.c
+*      Purpose          : Background noise source charateristic detector (SCD)
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "bgnscd.h"
+const char bgnscd_id[] = "@(#)$Id $" bgnscd_h;
+
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+#include "copy.h"
+#include "set_zero.h"
+#include "gmed_n.h"
+#include "sqrt_l.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+/*-----------------------------------------------------------------*
+ *   Decoder constant parameters (defined in "cnst.h")             *
+ *-----------------------------------------------------------------*
+ *   L_FRAME       : Frame size.                                   *
+ *   L_SUBFR       : Sub-frame size.                               *
+ *-----------------------------------------------------------------*/
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : Bgn_scd_init
+*  Purpose     : Allocates and initializes state memory
+*
+**************************************************************************
+*/
+Word16 Bgn_scd_init (Bgn_scdState **state)
+{
+   Bgn_scdState* s;
+   
+   if (state == (Bgn_scdState **) NULL){
+      fprintf(stderr, "Bgn_scd_init: invalid parameter\n");
+      return -1;
+   }
+   *state = NULL;
+   
+   /* allocate memory */
+   if ((s= (Bgn_scdState *) malloc(sizeof(Bgn_scdState))) == NULL){
+     fprintf(stderr, "Bgn_scd_init: can not malloc state structure\n");
+     return -1;
+   }
+   
+   Bgn_scd_reset(s);
+   *state = s;
+   
+   return 0;
+}
+
+/*
+**************************************************************************
+*
+*  Function    : Bgn_scd_reset
+*  Purpose     : Resets state memory
+*
+**************************************************************************
+*/
+Word16 Bgn_scd_reset (Bgn_scdState *state)
+{
+   if (state == (Bgn_scdState *) NULL){
+      fprintf(stderr, "Bgn_scd_reset: invalid parameter\n");
+      return -1;
+   }
+
+   /* Static vectors to zero */
+   Set_zero (state->frameEnergyHist, L_ENERGYHIST);
+
+   /* Initialize hangover handling */
+   state->bgHangover = 0;
+   
+   return 0;
+}
+
+/*
+**************************************************************************
+*
+*  Function    : Bgn_scd_exit
+*  Purpose     : The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void Bgn_scd_exit (Bgn_scdState **state)
+{
+   if (state == NULL || *state == NULL)
+      return;
+
+   /* deallocate memory */
+   free(*state);
+   *state = NULL;
+   
+   return;
+}
+
+/*
+**************************************************************************
+*
+*  Function    : Bgn_scd
+*  Purpose     : Charaterice synthesis speech and detect background noise
+*  Returns     : background noise decision; 0 = no bgn, 1 = bgn
+*
+**************************************************************************
+*/
+Word16 Bgn_scd (Bgn_scdState *st,      /* i : State variables for bgn SCD */
+                Word16 ltpGainHist[],  /* i : LTP gain history            */
+                Word16 speech[],       /* o : synthesis speech frame      */
+                Word16 *voicedHangover /* o : # of frames after last 
+                                              voiced frame                */
+                )
+{
+   Word16 i;
+   Word16 prevVoiced, inbgNoise;
+   Word16 temp;
+   Word16 ltpLimit, frameEnergyMin;
+   Word16 currEnergy, noiseFloor, maxEnergy, maxEnergyLastPart;
+   Word32 s;
+   
+   /* Update the inBackgroundNoise flag (valid for use in next frame if BFI) */
+   /* it now works as a energy detector floating on top                      */ 
+   /* not as good as a VAD.                                                  */
+
+   currEnergy = 0;                                   move16 ();
+   s = (Word32) 0;                                   move32 ();
+
+   for (i = 0; i < L_FRAME; i++)
+   {
+       s = L_mac (s, speech[i], speech[i]);
+   }
+
+   s = L_shl(s, 2);  
+
+   currEnergy = extract_h (s);
+
+   frameEnergyMin = 32767;                     move16 ();
+
+   for (i = 0; i < L_ENERGYHIST; i++)
+   {
+      test ();
+      if (sub(st->frameEnergyHist[i], frameEnergyMin) < 0)
+         frameEnergyMin = st->frameEnergyHist[i];           move16 ();
+   }
+
+   noiseFloor = shl (frameEnergyMin, 4); /* Frame Energy Margin of 16 */
+
+   maxEnergy = st->frameEnergyHist[0];               move16 ();
+   for (i = 1; i < L_ENERGYHIST-4; i++)
+   {
+      test ();
+      if ( sub (maxEnergy, st->frameEnergyHist[i]) < 0)
+      {
+         maxEnergy = st->frameEnergyHist[i];         move16 ();
+      }
+   }
+   
+   maxEnergyLastPart = st->frameEnergyHist[2*L_ENERGYHIST/3]; move16 ();
+   for (i = 2*L_ENERGYHIST/3+1; i < L_ENERGYHIST; i++)
+   {
+      test ();
+      if ( sub (maxEnergyLastPart, st->frameEnergyHist[i] ) < 0)
+      {
+         maxEnergyLastPart = st->frameEnergyHist[i]; move16 ();     
+      }
+   }
+
+   inbgNoise = 0;        /* false */                 move16 (); 
+
+   /* Do not consider silence as noise */
+   /* Do not consider continuous high volume as noise */
+   /* Or if the current noise level is very low */
+   /* Mark as noise if under current noise limit */
+   /* OR if the maximum energy is below the upper limit */
+
+   test (); test (); test (); test (); test (); 
+   if ( (sub(maxEnergy, LOWERNOISELIMIT) > 0) &&
+        (sub(currEnergy, FRAMEENERGYLIMIT) < 0) &&
+        (sub(currEnergy, LOWERNOISELIMIT) > 0) &&
+        ( (sub(currEnergy, noiseFloor) < 0) ||
+          (sub(maxEnergyLastPart, UPPERNOISELIMIT) < 0)))
+   {
+      test ();
+      if (sub(add(st->bgHangover, 1), 30) > 0)
+      {
+         st->bgHangover = 30;                         move16 ();
+      } else
+      {
+         st->bgHangover = add(st->bgHangover, 1);
+      }
+   }
+   else
+   {
+      st->bgHangover = 0;                             move16 ();    
+   }
+   
+   /* make final decision about frame state , act somewhat cautiosly */
+   test ();
+   if (sub(st->bgHangover,1) > 0)
+      inbgNoise = 1;       /* true  */               move16 ();  
+
+   for (i = 0; i < L_ENERGYHIST-1; i++)
+   {
+      st->frameEnergyHist[i] = st->frameEnergyHist[i+1]; move16 ();
+   }
+   st->frameEnergyHist[L_ENERGYHIST-1] = currEnergy;              move16 ();
+   
+   /* prepare for voicing decision; tighten the threshold after some 
+      time in noise */
+   ltpLimit = 13926;             /* 0.85  Q14 */     move16 (); 
+   test ();
+   if (sub(st->bgHangover, 8) > 0)
+   {
+      ltpLimit = 15565;          /* 0.95  Q14 */     move16 ();
+   }
+   test ();
+   if (sub(st->bgHangover, 15) > 0)
+   {
+      ltpLimit = 16383;          /* 1.00  Q14 */     move16 ();
+   }
+
+   /* weak sort of voicing indication. */
+   prevVoiced = 0;        /* false */                move16 ();
+   test ();
+
+   if (sub(gmed_n(&ltpGainHist[4], 5), ltpLimit) > 0)
+   {
+      prevVoiced = 1;     /* true  */                move16 ();
+   }
+   test ();   
+   if (sub(st->bgHangover, 20) > 0) {
+      if (sub(gmed_n(ltpGainHist, 9), ltpLimit) > 0)
+      {
+         prevVoiced = 1;  /* true  */                move16 ();
+      }
+      else
+      {
+         prevVoiced = 0;  /* false  */                move16 ();
+      }
+   }
+   
+   test ();
+   if (prevVoiced)
+   {
+      *voicedHangover = 0;                        move16 ();
+   }
+   else
+   {
+      temp = add(*voicedHangover, 1);
+      test ();
+      if (sub(temp, 10) > 0)
+      {
+         *voicedHangover = 10;                    move16 ();
+      }
+      else
+      {
+         *voicedHangover = temp;                  move16 ();
+      }
+   }
+
+   return inbgNoise;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/bgnscd.h FFMpeg-20050127-new/libavcodec/amr/bgnscd.h
--- FFMpeg-20050127/libavcodec/amr/bgnscd.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/bgnscd.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,110 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : bgnscd.h
+*      Purpose          : Background noise source charateristic detector (SCD)
+*
+********************************************************************************
+*/
+#ifndef bgnscd_h
+#define bgnscd_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#define L_ENERGYHIST 60
+#define INV_L_FRAME 102
+
+
+/* 2*(160*x)^2 / 65536  where x is FLP values 150,5 and 50 */
+#define FRAMEENERGYLIMIT  17578         /* 150 */
+#define LOWERNOISELIMIT      20         /*   5 */
+#define UPPERNOISELIMIT    1953         /*  50 */
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+typedef struct{
+   /* history vector of past synthesis speech energy */
+   Word16 frameEnergyHist[L_ENERGYHIST];
+   
+   /* state flags */
+   Word16 bgHangover;       /* counter; number of frames after last speech frame */
+
+} Bgn_scdState;
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : Bgn_scd_init
+*  Purpose     : Allocates initializes state memory
+*  Description : Stores pointer to filter status struct in *st. This
+*                pointer has to be passed to Bgn_scd in each call.
+*  Returns     : 0 on success
+*
+**************************************************************************
+*/
+Word16 Bgn_scd_init (Bgn_scdState **st);
+ 
+/*
+**************************************************************************
+*
+*  Function    : Bgn_scd_reset
+*  Purpose     : Resets state memory
+*  Returns     : 0 on success
+*
+**************************************************************************
+*/
+Word16 Bgn_scd_reset (Bgn_scdState *st);
+ 
+/*
+**************************************************************************
+*
+*  Function    : Bgn_scd_exit
+*  Purpose     : The memory used for state memory is freed
+*  Description : Stores NULL in *s
+*  Returns     : void
+*
+**************************************************************************
+*/
+void Bgn_scd_exit (Bgn_scdState **st);
+ 
+/*
+**************************************************************************
+*
+*  Function    : Bgn_scd
+*  Purpose     : Charaterice synthesis speech and detect background noise
+*  Returns     : background noise decision; 0 = bgn, 1 = no bgn
+*
+**************************************************************************
+*/
+Word16 Bgn_scd (Bgn_scdState *st,      /* i : State variables for bgn SCD         */
+                Word16 ltpGainHist[],  /* i : LTP gain history                    */
+                Word16 speech[],       /* o : synthesis speech frame              */
+                Word16 *voicedHangover /* o : # of frames after last voiced frame */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/bitno.tab FFMpeg-20050127-new/libavcodec/amr/bitno.tab
--- FFMpeg-20050127/libavcodec/amr/bitno.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/bitno.tab	2003-02-18 11:34:00.000000000 +0000
@@ -0,0 +1,339 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : bitno.tab
+*      Purpose          : Tables for bit2prm and prm2bit
+*
+********************************************************************************
+*/
+
+#ifndef bitno_tab
+#define bitno_tab
+static const char bitno_id[] = "@(#)$Id $";
+
+#include "cnst.h"   /* parameter sizes: MAX_PRM_SIZE */
+#include "mode.h"   /* N_MODES */
+
+#define BIT_0      0
+#define BIT_1      1
+
+#define PRMNO_MR475 17
+#define PRMNO_MR515 19
+#define PRMNO_MR59  19
+#define PRMNO_MR67  19
+#define PRMNO_MR74  19
+#define PRMNO_MR795 23
+#define PRMNO_MR102 39
+#define PRMNO_MR122 57
+#define PRMNO_MRDTX 5
+
+/* number of parameters per modes (values must be <= MAX_PRM_SIZE!) */
+static const Word16 prmno[N_MODES] = {
+  PRMNO_MR475,
+  PRMNO_MR515,
+  PRMNO_MR59,
+  PRMNO_MR67,
+  PRMNO_MR74,
+  PRMNO_MR795,
+  PRMNO_MR102,
+  PRMNO_MR122,
+  PRMNO_MRDTX
+};
+
+
+/* number of parameters to first subframe */
+#define PRMNOFSF_MR475 7
+#define PRMNOFSF_MR515 7
+#define PRMNOFSF_MR59  7
+#define PRMNOFSF_MR67  7
+#define PRMNOFSF_MR74  7
+#define PRMNOFSF_MR795 8
+#define PRMNOFSF_MR102 12
+#define PRMNOFSF_MR122 18
+
+/* number of parameters to first subframe per modes */
+static const Word16 prmnofsf[N_MODES - 1] = {
+  PRMNOFSF_MR475,
+  PRMNOFSF_MR515,
+  PRMNOFSF_MR59,
+  PRMNOFSF_MR67,
+  PRMNOFSF_MR74,
+  PRMNOFSF_MR795,
+  PRMNOFSF_MR102,
+  PRMNOFSF_MR122
+};
+
+
+
+/* parameter sizes (# of bits), one table per mode */
+
+static const Word16 bitno_MR475[PRMNO_MR475] = {
+   8, 8, 7,                                 /* LSP VQ          */
+   8, 7, 2, 8,                              /* first subframe  */
+   4, 7, 2,                                 /* second subframe */
+   4, 7, 2, 8,                              /* third subframe  */
+   4, 7, 2,                                 /* fourth subframe */
+};
+
+static const Word16 bitno_MR515[PRMNO_MR515] = {
+   8, 8, 7,                                 /* LSP VQ          */
+   8, 7, 2, 6,                              /* first subframe  */
+   4, 7, 2, 6,                              /* second subframe */
+   4, 7, 2, 6,                              /* third subframe  */
+   4, 7, 2, 6,                              /* fourth subframe */
+};
+
+static const Word16 bitno_MR59[PRMNO_MR59] = {
+   8, 9, 9,                                 /* LSP VQ          */
+   8, 9, 2, 6,                              /* first subframe  */
+   4, 9, 2, 6,                              /* second subframe */
+   8, 9, 2, 6,                              /* third subframe  */
+   4, 9, 2, 6,                              /* fourth subframe */
+};
+
+static const Word16 bitno_MR67[PRMNO_MR67] = {
+   8, 9, 9,                                 /* LSP VQ          */
+   8, 11, 3, 7,                             /* first subframe  */
+   4, 11, 3, 7,                             /* second subframe */
+   8, 11, 3, 7,                             /* third subframe  */
+   4, 11, 3, 7,                             /* fourth subframe */
+};
+
+static const Word16 bitno_MR74[PRMNO_MR74] = {
+   8, 9, 9,                                 /* LSP VQ          */
+   8, 13, 4, 7,                             /* first subframe  */
+   5, 13, 4, 7,                             /* second subframe */
+   8, 13, 4, 7,                             /* third subframe  */
+   5, 13, 4, 7,                             /* fourth subframe */
+};
+
+static const Word16 bitno_MR795[PRMNO_MR795] = {
+   9, 9, 9,                                 /* LSP VQ          */
+   8, 13, 4, 4, 5,                          /* first subframe  */
+   6, 13, 4, 4, 5,                          /* second subframe */
+   8, 13, 4, 4, 5,                          /* third subframe  */
+   6, 13, 4, 4, 5,                          /* fourth subframe */
+};
+
+static const Word16 bitno_MR102[PRMNO_MR102] = {
+   8, 9, 9,                                 /* LSP VQ          */
+   8, 1, 1, 1, 1, 10, 10, 7, 7,             /* first subframe  */
+   5, 1, 1, 1, 1, 10, 10, 7, 7,             /* second subframe */
+   8, 1, 1, 1, 1, 10, 10, 7, 7,             /* third subframe  */
+   5, 1, 1, 1, 1, 10, 10, 7, 7,             /* fourth subframe */
+};
+
+static const Word16 bitno_MR122[PRMNO_MR122] = {
+   7, 8, 9, 8, 6,                           /* LSP VQ          */
+   9, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5,   /* first subframe  */
+   6, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5,   /* second subframe */
+   9, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5,   /* third subframe  */
+   6, 4, 4, 4, 4, 4, 4, 3, 3, 3, 3, 3, 5    /* fourth subframe */
+};
+
+static const Word16 bitno_MRDTX[PRMNO_MRDTX] = {
+  3,
+  8, 9, 9,
+  6
+};
+
+/* overall table with all parameter sizes for all modes */
+static const Word16 *bitno[N_MODES] = {
+   bitno_MR475,
+   bitno_MR515,
+   bitno_MR59,
+   bitno_MR67,
+   bitno_MR74,
+   bitno_MR795,
+   bitno_MR102,
+   bitno_MR122,
+   bitno_MRDTX
+};
+
+#ifdef MMS_IO
+
+/* table of contents byte for each mode index */
+static UWord8 toc_byte[16] = {0x04, 0x0C, 0x14, 0x1C, 0x24, 0x2C, 0x34, 0x3C,
+                              0x44, 0x4C, 0x54, 0x5C, 0x64, 0x6C, 0x74, 0x7C};
+
+/* number of speech bits for all modes */
+static Word16 unpacked_size[16] = {95, 103, 118, 134, 148, 159, 204, 244,
+                                   35,   0,   0,   0,   0,   0,   0,   0};
+
+/* size of packed frame for each mode */
+static Word16 packed_size[16] = {13, 14, 16, 18, 20, 21, 27, 32,
+                                  6,  0,  0,  0,  0,  0,  0,  1};
+
+/* number of unused speech bits in packed format for each mode */
+static Word16 unused_size[16] = {1, 1, 2, 2, 4, 1, 4, 4, 1, 0, 0, 0, 0, 0, 0, 0};
+
+/* sorting tables for all modes */
+
+static Word16 sort_475[95] = {
+    0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
+   10, 11, 12, 13, 14, 15, 23, 24, 25, 26,
+   27, 28, 48, 49, 61, 62, 82, 83, 47, 46,
+   45, 44, 81, 80, 79, 78, 17, 18, 20, 22,
+   77, 76, 75, 74, 29, 30, 43, 42, 41, 40,
+   38, 39, 16, 19, 21, 50, 51, 59, 60, 63,
+   64, 72, 73, 84, 85, 93, 94, 32, 33, 35,
+   36, 53, 54, 56, 57, 66, 67, 69, 70, 87,
+   88, 90, 91, 34, 55, 68, 89, 37, 58, 71,
+   92, 31, 52, 65, 86
+};
+
+static Word16 sort_515[103] = {
+    7,  6,  5,   4,   3,   2,  1,  0, 15, 14,
+   13, 12, 11,  10,   9,   8, 23, 24, 25, 26,
+   27, 46, 65,  84,  45,  44, 43, 64, 63, 62,
+   83, 82, 81, 102, 101, 100, 42, 61, 80, 99,
+   28, 47, 66,  85,  18,  41, 60, 79, 98, 29,
+   48, 67, 17,  20,  22,  40, 59, 78, 97, 21,
+   30, 49, 68,  86,  19,  16, 87, 39, 38, 58,
+   57, 77, 35,  54,  73,  92, 76, 96, 95, 36,
+   55, 74, 93,  32,  51,  33, 52, 70, 71, 89,
+   90, 31, 50,  69,  88,  37, 56, 75, 94, 34,
+   53, 72, 91							
+};
+
+static Word16 sort_59[118] = {
+    0,   1,   4,   5,   3,   6,   7,   2,  13,  15,
+    8,   9,  11,  12,  14,  10,  16,  28,  74,  29,
+   75,  27,  73,  26,  72,  30,  76,  51,  97,  50,
+   71,  96, 117,  31,  77,  52,  98,  49,  70,  95,
+  116,  53,  99,  32,  78,  33,  79,  48,  69,  94,
+  115,  47,  68,  93, 114,  46,  67,  92, 113,  19,
+   21,  23,  22,  18,  17,  20,  24, 111,  43,  89,
+  110,  64,  65,  44,  90,  25,  45,  66,  91, 112,
+   54, 100,  40,  61,  86, 107,  39,  60,  85, 106,
+   36,  57,  82, 103,  35,  56,  81, 102,  34,  55,
+   80, 101,  42,  63,  88, 109,  41,  62,  87, 108,
+   38,  59,  84, 105,  37,  58,  83, 104
+};
+
+static Word16 sort_67[134] = {
+    0,   1,   4,   3,   5,   6,  13,   7,   2,   8,
+    9,  11,  15,  12,  14,  10,  28,  82,  29,  83,
+   27,  81,  26,  80,  30,  84,  16,  55, 109,  56,
+  110,  31,  85,  57, 111,  48,  73, 102, 127,  32,
+   86,  51,  76, 105, 130,  52,  77, 106, 131,  58,
+  112,  33,  87,  19,  23,  53,  78, 107, 132,  21,
+   22,  18,  17,  20,  24,  25,  50,  75, 104, 129,
+   47,  72, 101, 126,  54,  79, 108, 133,  46,  71,
+  100, 125, 128, 103,  74,  49,  45,  70,  99, 124,
+   42,  67,  96, 121,  39,  64,  93, 118,  38,  63,
+   92, 117,  35,  60,  89, 114,  34,  59,  88, 113,
+   44,  69,  98, 123,  43,  68,  97, 122,  41,  66,
+   95, 120,  40,  65,  94, 119,  37,  62,  91, 116,
+   36,  61,  90, 115						
+};
+
+static Word16 sort_74[148] = {
+    0,   1,	  2,   3,   4,   5,   6,   7,   8,   9,
+   10,  11,	 12,  13,  14,  15,  16,  26,  87,  27,
+   88,  28,	 89,  29,  90,  30,  91,  51,  80, 112,
+  141,  52,  81, 113, 142,  54,  83, 115, 144,  55,
+   84, 116, 145,  58, 119,  59, 120,  21,  22,  23,
+   17,  18,	 19,  31,  60,  92, 121,  56,  85, 117,
+  146,  20,	 24,  25,  50,  79, 111, 140,  57,  86,
+  118, 147,	 49,  78, 110, 139,  48,  77,  53,  82,
+  114, 143, 109, 138,  47,  76, 108, 137,  32,  33,
+   61,  62,	 93,  94, 122, 123,  41,  42,  43,  44,
+   45,  46,	 70,  71,  72,  73,  74,  75, 102, 103,
+  104, 105, 106, 107, 131, 132, 133, 134, 135, 136,
+   34,  63,	 95, 124,  35,  64,  96, 125,  36,  65,
+   97, 126,	 37,  66,  98, 127,	 38,  67,  99, 128,
+   39,  68, 100, 129,  40,  69, 101, 130
+};
+
+static Word16 sort_795[159] = {
+    8,   7,   6,   5,   4,   3,   2,  14,  16,   9,
+   10,  12,  13,  15,  11,  17,  20,  22,  24,  23,
+   19,  18,  21,  56,  88, 122, 154,  57,  89, 123,
+  155,  58,  90, 124, 156,  52,  84, 118, 150,  53,
+   85, 119, 151,  27,  93,  28,  94,  29,  95,  30,
+   96,  31,  97,  61, 127,  62, 128,  63, 129,  59,
+   91, 125, 157,  32,  98,  64, 130,   1,   0,  25,
+   26,  33,  99,  34, 100,  65, 131,  66, 132,  54,
+   86, 120, 152,  60,  92, 126, 158,  55,  87, 121,
+  153, 117, 116, 115,  46,  78, 112, 144,  43,  75,
+  109, 141,  40,  72, 106, 138,  36,  68, 102, 134,
+  114, 149, 148, 147, 146,  83,  82,  81,  80,  51,
+   50,  49,  48,  47,  45,  44,  42,  39,  35,  79,
+   77,  76,  74,  71,  67, 113, 111, 110, 108, 105,
+  101, 145, 143, 142, 140, 137, 133,  41,  73, 107,
+  139,  37,  69, 103, 135,  38,  70, 104, 136
+};
+
+static Word16 sort_102[204] = {
+    7,   6,   5,   4,   3,   2,   1,   0,  16,  15,
+   14,  13,  12,  11,  10,   9,   8,  26,  27,  28,
+   29,  30,  31, 115, 116, 117, 118, 119, 120,  72,
+   73, 161, 162,  65,  68,  69, 108, 111, 112, 154,
+  157, 158, 197, 200, 201,  32,  33, 121, 122,  74,
+   75, 163, 164,  66, 109, 155, 198,  19,  23,  21,
+   22,  18,  17,  20,  24,  25,  37,  36,  35,  34,
+   80,  79,  78,  77, 126, 125, 124, 123, 169, 168,
+  167, 166,  70,  67,  71, 113, 110, 114, 159, 156,
+  160, 202, 199, 203,  76, 165,  81,  82,  92,  91,
+   93,  83,  95,  85,  84,  94, 101, 102,  96, 104,
+   86, 103,  87,  97, 127, 128, 138, 137, 139, 129,
+  141, 131, 130, 140, 147, 148, 142, 150, 132, 149,
+  133, 143, 170, 171, 181, 180, 182, 172, 184, 174,
+  173, 183, 190, 191, 185, 193, 175, 192, 176, 186,
+   38,  39,  49,  48,  50,  40,  52,  42,  41,  51,
+   58,  59,  53,  61,  43,  60,  44,  54, 194, 179,
+  189, 196, 177, 195, 178, 187, 188, 151, 136, 146,
+  153, 134, 152, 135, 144, 145, 105,  90, 100, 107,
+   88, 106,  89,  98,  99,  62,  47,  57,  64,  45,
+   63,  46,  55,  56					
+};
+
+static Word16 sort_122[244] = {
+    0,   1,   2,   3,   4,   5,   6,   7,   8,   9,
+   10,  11,  12,  13,  14,  23,  15,  16,  17,  18,
+   19,  20,  21,  22,  24,  25,  26,  27,  28,  38,
+  141,  39, 142,  40, 143,  41, 144,  42, 145,  43,
+  146,  44, 147,  45, 148,  46, 149,  47,  97, 150,
+  200,  48,  98, 151, 201,  49,  99, 152, 202,  86,
+  136, 189, 239,  87, 137, 190, 240,  88, 138, 191,
+  241,  91, 194,  92, 195,  93, 196,  94, 197,  95,
+  198,  29,  30,  31,  32,  33,  34,  35,  50, 100,
+  153, 203,  89, 139, 192, 242,  51, 101, 154, 204,
+   55, 105, 158, 208,  90, 140, 193, 243,  59, 109,
+  162, 212,  63, 113, 166, 216,  67, 117, 170, 220,
+   36,  37,  54,  53,  52,  58,  57,  56,  62,  61,
+   60,  66,  65,  64,  70,  69,  68, 104, 103, 102,
+  108, 107, 106, 112, 111, 110, 116, 115, 114, 120,
+  119, 118, 157, 156, 155, 161, 160, 159, 165, 164,
+  163, 169, 168, 167, 173, 172, 171, 207, 206, 205,
+  211, 210, 209, 215, 214, 213, 219, 218, 217, 223,
+  222, 221,  73,  72,  71,  76,  75,  74,  79,  78,
+   77,  82,  81,  80,  85,  84,  83, 123, 122, 121,
+  126, 125, 124, 129, 128, 127, 132, 131, 130, 135,
+  134, 133, 176, 175, 174, 179, 178, 177, 182, 181,
+  180, 185, 184, 183, 188, 187, 186, 226, 225, 224,
+  229, 228, 227, 232, 231, 230, 235, 234, 233, 238,
+  237, 236,  96, 199						
+};
+
+static Word16 sort_SID[35] = {
+    0,  1,  2,  3,  4,  5,  6,  7,  8,  9,
+   10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
+   20, 21, 22, 23, 24, 25, 26, 27, 28, 29,
+   30, 31, 32, 33, 34
+};
+
+/* pointer table for bit sorting tables */
+static Word16 *sort_ptr[16] = {sort_475, sort_515, sort_59, sort_67, sort_74, sort_795, sort_102, sort_122,
+                               sort_SID,     NULL,   NULL,    NULL,     NULL,    NULL,     NULL,      NULL};
+
+#endif
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/bits2prm.c FFMpeg-20050127-new/libavcodec/amr/bits2prm.c
--- FFMpeg-20050127/libavcodec/amr/bits2prm.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/bits2prm.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,107 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : bits2prm.c
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "bits2prm.h"
+const char bits2prm_id[] = "@(#)$Id $" bits2prm_h;
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "mode.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#include "bitno.tab"
+
+/*
+********************************************************************************
+*                         LOCAL PROGRAM CODE
+********************************************************************************
+*/
+
+/*
+**************************************************************************
+*
+*  Function    : Bin2int
+*  Purpose     : Read "no_of_bits" bits from the array bitstream[] 
+*                and convert to integer.
+*
+**************************************************************************
+*/
+static Word16 Bin2int ( /* Reconstructed parameter                      */
+    Word16 no_of_bits,  /* input : number of bits associated with value */
+    Word16 *bitstream   /* output: address where bits are written       */
+)
+{
+    Word16 value, i, bit;
+
+    value = 0;                                  move16 (); 
+    for (i = 0; i < no_of_bits; i++)
+    {
+        value = shl (value, 1);
+        bit = *bitstream++;                     move16 (); 
+        test (); 
+        if (sub (bit, BIT_1) == 0)
+            value = add (value, 1);
+    }
+    return (value);
+}
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : Bits2prm
+*  Purpose     : Retrieves the vector of encoder parameters from 
+*                the received serial bits in a frame.
+*
+**************************************************************************
+*/
+void Bits2prm (
+    enum Mode mode,     /* i : AMR mode                                    */
+    Word16 bits[],      /* i : serial bits       (size <= MAX_SERIAL_SIZE) */
+    Word16 prm[]        /* o : analysis parameters  (size <= MAX_PRM_SIZE) */
+)
+{
+    Word16 i;
+
+    move16();           /* account for pointer init (bitno[mode])  */
+    
+    for (i = 0; i < prmno[mode]; i++)
+    {
+        prm[i] = Bin2int (bitno[mode][i], bits);      move16 (); 
+        bits += bitno[mode][i];
+        add(0,0);       /* account for above pointer update  */
+    }
+    
+   return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/bits2prm.h FFMpeg-20050127-new/libavcodec/amr/bits2prm.h
--- FFMpeg-20050127/libavcodec/amr/bits2prm.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/bits2prm.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,53 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : bits2prm.h
+*      Purpose          : Retrieves the vector of encoder parameters from 
+*                       : the received serial bits in a frame.
+*
+*****************************************************************************
+*/
+#ifndef bits2prm_h
+#define bits2prm_h "$Id $"
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+/*
+*****************************************************************************
+*                         DEFINITION OF DATA TYPES
+*****************************************************************************
+*/
+ 
+/*
+*****************************************************************************
+*                         DECLARATION OF PROTOTYPES
+*****************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : Bits2prm
+*  Purpose     : Retrieves the vector of encoder parameters from 
+*                the received serial bits in a frame.
+*  Returns     : void
+*
+**************************************************************************
+*/
+void Bits2prm (
+    enum Mode mode,
+    Word16 bits[],   /* input : serial bits, (244 + bfi)               */
+    Word16 prm[]     /* output: analysis parameters, (57+1 parameters) */
+); 
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/c1035pf.c FFMpeg-20050127-new/libavcodec/amr/c1035pf.c
--- FFMpeg-20050127/libavcodec/amr/c1035pf.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/c1035pf.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,259 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : c1035pf.c
+*      Purpose          : Searches a 35 bit algebraic codebook containing 
+*                       : 10 pulses in a frame of 40 samples.
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "c1035pf.h"
+const char c1035pf_id[] = "@(#)$Id $" c1035pf_h;
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+#include "inv_sqrt.h"
+#include "set_sign.h"
+#include "cor_h.h"
+#include "s10_8pf.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#define NB_PULSE  10
+
+#include "gray.tab"
+
+/*
+********************************************************************************
+*                         LOCAL PROGRAM CODE
+********************************************************************************
+*/
+void q_p (
+    Word16 *ind,        /* Pulse position */
+    Word16 n            /* Pulse number   */
+)
+{
+    Word16 tmp;
+    
+    tmp = *ind;                                  move16 (); 
+    
+    test ();
+    if (sub (n, 5) < 0)
+    {
+        *ind = (tmp & 0x8) | gray[tmp & 0x7];     logic16 (); logic16 ();
+                                                 logic16 (); move16 ();
+    }
+    else
+    {
+        *ind = gray[tmp & 0x7];                   logic16 (); move16 (); 
+    }
+}
+
+
+/*************************************************************************
+ *
+ *  FUNCTION:  build_code()
+ *
+ *  PURPOSE: Builds the codeword, the filtered codeword and index of the
+ *           codevector, based on the signs and positions of 10 pulses.
+ *
+ *************************************************************************/
+
+static void build_code (
+    Word16 codvec[], /* (i)  : position of pulses                           */
+    Word16 sign[],   /* (i)  : sign of d[n]                                 */
+    Word16 cod[],    /* (o)  : innovative code vector                       */
+    Word16 h[],      /* (i)  : impulse response of weighted synthesis filter*/
+    Word16 y[],      /* (o)  : filtered innovative code                     */
+    Word16 indx[]    /* (o)  : index of 10 pulses (sign+position)           */
+)
+{
+    Word16 i, j, k, track, index, _sign[NB_PULSE];
+    Word16 *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7, *p8, *p9;
+    Word32 s;
+
+    for (i = 0; i < L_CODE; i++)
+    {
+        cod[i] = 0;                              move16 (); 
+    }
+    for (i = 0; i < NB_TRACK; i++)
+    {
+        indx[i] = -1;                            move16 (); 
+    }
+    
+    for (k = 0; k < NB_PULSE; k++)
+    {
+        /* read pulse position */            
+        i = codvec[k];                           move16 ();
+        /* read sign           */        
+        j = sign[i];                             move16 (); 
+        
+        index = mult (i, 6554);                  /* index = pos/5       */
+        /* track = pos%5 */
+        track = sub (i, extract_l (L_shr (L_mult (index, 5), 1)));
+        test (); 
+        if (j > 0)
+        {
+            cod[i] = add (cod[i], 4096);         move16 ();
+            _sign[k] = 8192;                     move16 (); 
+            
+        }
+        else
+        {
+            cod[i] = sub (cod[i], 4096);         move16 ();
+            _sign[k] = -8192;                    move16 (); 
+            index = add (index, 8);
+        }
+        
+        test (); move16 ();
+        if (indx[track] < 0)
+        {
+            indx[track] = index;                 move16 (); 
+        }
+        else
+        {
+            test (); logic16 (); logic16 (); 
+            if (((index ^ indx[track]) & 8) == 0)
+            {
+                /* sign of 1st pulse == sign of 2nd pulse */
+                
+                test (); 
+                if (sub (indx[track], index) <= 0)
+                {
+                    indx[track + 5] = index;     move16 (); 
+                }
+                else
+                {
+                    indx[track + 5] = indx[track];
+                                                 move16 (); 
+                    indx[track] = index;         move16 (); 
+                }
+            }
+            else
+            {
+                /* sign of 1st pulse != sign of 2nd pulse */
+                
+                test (); logic16 (); logic16 (); 
+                if (sub ((indx[track] & 7), (index & 7)) <= 0)
+                {
+                    indx[track + 5] = indx[track];
+                                                 move16 (); 
+                    indx[track] = index;         move16 (); 
+                }
+                else
+                {
+                    indx[track + 5] = index;     move16 (); 
+                }
+            }
+        }
+    }
+    
+    p0 = h - codvec[0];                          move16 (); 
+    p1 = h - codvec[1];                          move16 (); 
+    p2 = h - codvec[2];                          move16 (); 
+    p3 = h - codvec[3];                          move16 (); 
+    p4 = h - codvec[4];                          move16 (); 
+    p5 = h - codvec[5];                          move16 (); 
+    p6 = h - codvec[6];                          move16 (); 
+    p7 = h - codvec[7];                          move16 (); 
+    p8 = h - codvec[8];                          move16 (); 
+    p9 = h - codvec[9];                          move16 (); 
+     
+    for (i = 0; i < L_CODE; i++)
+    {
+        s = 0;                                   move32 (); 
+        s = L_mac (s, *p0++, _sign[0]);
+        s = L_mac (s, *p1++, _sign[1]);
+        s = L_mac (s, *p2++, _sign[2]);
+        s = L_mac (s, *p3++, _sign[3]);
+        s = L_mac (s, *p4++, _sign[4]);
+        s = L_mac (s, *p5++, _sign[5]);
+        s = L_mac (s, *p6++, _sign[6]);
+        s = L_mac (s, *p7++, _sign[7]);
+        s = L_mac (s, *p8++, _sign[8]);
+        s = L_mac (s, *p9++, _sign[9]);
+        y[i] = round (s);                        move16 (); 
+    }
+}
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  code_10i40_35bits()
+ *
+ *  PURPOSE:  Searches a 35 bit algebraic codebook containing 10 pulses
+ *            in a frame of 40 samples.
+ *
+ *  DESCRIPTION:
+ *    The code contains 10 nonzero pulses: i0...i9.
+ *    All pulses can have two possible amplitudes: +1 or -1.
+ *    The 40 positions in a subframe are divided into 5 tracks of
+ *    interleaved positions. Each track contains two pulses.
+ *    The pulses can have the following possible positions:
+ *
+ *       i0, i5 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *       i1, i6 :  1, 6, 11, 16, 21, 26, 31, 36.
+ *       i2, i7 :  2, 7, 12, 17, 22, 27, 32, 37.
+ *       i3, i8 :  3, 8, 13, 18, 23, 28, 33, 38.
+ *       i4, i9 :  4, 9, 14, 19, 24, 29, 34, 39.
+ *
+ *    Each pair of pulses require 1 bit for their signs and 6 bits for their
+ *    positions (3 bits + 3 bits). This results in a 35 bit codebook.
+ *    The function determines the optimal pulse signs and positions, builds
+ *    the codevector, and computes the filtered codevector.
+ *
+ *************************************************************************/
+
+void code_10i40_35bits (
+    Word16 x[],   /* (i)   : target vector                                 */
+    Word16 cn[],  /* (i)   : residual after long term prediction           */
+    Word16 h[],   /* (i)   : impulse response of weighted synthesis filter
+                             h[-L_subfr..-1] must be set to zero           */
+    Word16 cod[], /* (o)   : algebraic (fixed) codebook excitation         */
+    Word16 y[],   /* (o)   : filtered fixed codebook excitation            */
+    Word16 indx[] /* (o)   : index of 10 pulses (sign + position)          */
+)
+{
+    Word16 ipos[NB_PULSE], pos_max[NB_TRACK], codvec[NB_PULSE];
+    Word16 dn[L_CODE], sign[L_CODE];
+    Word16 rr[L_CODE][L_CODE], i;
+
+    cor_h_x (h, x, dn, 2);
+    set_sign12k2 (dn, cn, sign, pos_max, NB_TRACK, ipos, STEP);
+    cor_h (h, sign, rr);
+
+    search_10and8i40 (NB_PULSE, STEP, NB_TRACK,
+                      dn, rr, ipos, pos_max, codvec);
+   
+    build_code (codvec, sign, cod, h, y, indx);
+    for (i = 0; i < 10; i++)
+    {
+        q_p (&indx[i], i);
+    }
+    return;
+}
+
diff -Nur FFMpeg-20050127/libavcodec/amr/c1035pf.h FFMpeg-20050127-new/libavcodec/amr/c1035pf.h
--- FFMpeg-20050127/libavcodec/amr/c1035pf.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/c1035pf.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,47 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : c1035pf.h
+*      Purpose          : Searches a 35 bit algebraic codebook containing 
+*                       : 10 pulses in a frame of 40 samples.
+*
+********************************************************************************
+*/
+#ifndef c1035pf_h
+#define c1035pf_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+void code_10i40_35bits (
+    Word16 x[],        /* (i)   : target vector                             */
+    Word16 cn[],       /* (i)   : residual after long term prediction       */
+    Word16 h[],        /* (i)   : impulse response of weighted synthesis
+                                  filter                                    */
+    Word16 cod[],      /* (o)   : algebraic (fixed) codebook excitation     */
+    Word16 y[],        /* (o)   : filtered fixed codebook excitation        */
+    Word16 indx[]      /* (o)   : index of 10 pulses (sign + position)      */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/c2_11pf.c FFMpeg-20050127-new/libavcodec/amr/c2_11pf.c
--- FFMpeg-20050127/libavcodec/amr/c2_11pf.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/c2_11pf.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,366 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File        : c2_11pf.c
+*      Purpose     : Searches a 11 bit algebraic codebook containing 2 pulses
+*                    in a frame of 40 samples.
+*
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "c2_11pf.h"
+const char c2_11pf_id[] = "@(#)$Id $" c2_11pf_h;
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "inv_sqrt.h"
+#include "cnst.h"
+#include "cor_h.h"
+#include "set_sign.h"
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+#define NB_PULSE  2
+
+#include "c2_11pf.tab"
+
+/*
+*****************************************************************************
+*                         DECLARATION OF PROTOTYPES
+*****************************************************************************
+*/
+static void search_2i40(
+    Word16 dn[],        /* i : correlation between target and h[]            */
+    Word16 rr[][L_CODE],/* i : matrix of autocorrelation                     */
+    Word16 codvec[]     /* o : algebraic codebook vector                     */
+);
+
+static Word16 build_code(
+    Word16 codvec[],    /* i : algebraic codebook vector                     */
+    Word16 dn_sign[],   /* i : sign of dn[]                                  */
+    Word16 cod[],       /* o : algebraic (fixed) codebook excitation         */
+    Word16 h[],         /* i : impulse response of weighted synthesis filter */
+    Word16 y[],         /* o : filtered fixed codebook excitation            */
+    Word16 sign[]       /* o : sign of 2 pulses                              */
+);
+
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  code_2i40_11bits()
+ *
+ *  PURPOSE:  Searches a 11 bit algebraic codebook containing 2 pulses
+ *            in a frame of 40 samples.
+ *
+ *  DESCRIPTION:
+ *    The code length is 40, containing 2 nonzero pulses: i0...i1.
+ *    All pulses can have two possible amplitudes: +1 or -1.
+ *    Pulse i0 can have 2x8=16 possible positions, pulse i1 can have
+ *    4x8=32 positions.
+ *
+ *       i0 :  1, 6, 11, 16, 21, 26, 31, 36.
+ *             3, 8, 13, 18, 23, 28, 33, 38.
+ *       i1 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *             1, 6, 11, 16, 21, 26, 31, 36. 
+ *             2, 7, 12, 17, 22, 27, 32, 37.
+ *             4, 9, 14, 19, 24, 29, 34, 39.
+ *
+ *************************************************************************/
+Word16 code_2i40_11bits(
+    Word16 x[],         /* i : target vector                                 */
+    Word16 h[],         /* i : impulse response of weighted synthesis filter */
+                        /*     h[-L_subfr..-1] must be set to zero.          */
+    Word16 T0,          /* i : Pitch lag                                     */
+    Word16 pitch_sharp, /* i : Last quantized pitch gain                     */
+    Word16 code[],      /* o : Innovative codebook                           */
+    Word16 y[],         /* o : filtered fixed codebook excitation            */
+    Word16 * sign       /* o : Signs of 2 pulses                             */
+)
+{
+    Word16 codvec[NB_PULSE];
+    Word16 dn[L_CODE], dn2[L_CODE], dn_sign[L_CODE];
+    Word16 rr[L_CODE][L_CODE];
+    Word16 i, index, sharp;
+
+    sharp = shl(pitch_sharp, 1);
+    test ();
+    if (sub(T0, L_CODE) < 0)
+    {
+       for (i = T0; i < L_CODE; i++) {
+          h[i] = add(h[i], mult(h[i - T0], sharp));    move16 ();
+       }
+    }
+    
+    cor_h_x(h, x, dn, 1);
+    set_sign(dn, dn_sign, dn2, 8); /* dn2[] not used in this codebook search */
+    cor_h(h, dn_sign, rr);
+    search_2i40(dn, rr, codvec);
+                                    move16 (); /* function result */
+    index = build_code(codvec, dn_sign, code, h, y, sign);
+
+  /*-----------------------------------------------------------------*
+  * Compute innovation vector gain.                                 *
+  * Include fixed-gain pitch contribution into code[].              *
+  *-----------------------------------------------------------------*/
+
+    test ();
+    if (sub(T0, L_CODE) < 0)
+    {
+       for (i = T0; i < L_CODE; i++)
+       {
+          code[i] = add(code[i], mult(code[i - T0], sharp));    move16 ();
+       }
+    }
+    return index;
+}
+
+/*
+*****************************************************************************
+*                         PRIVATE PROGRAM CODE
+*****************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION  search_2i40()
+ *
+ *  PURPOSE: Search the best codevector; determine positions of the 2 pulses
+ *           in the 40-sample frame.
+ *
+ *************************************************************************/
+
+#define _1_2    (Word16)(32768L/2)
+#define _1_4    (Word16)(32768L/4)
+#define _1_8    (Word16)(32768L/8)
+#define _1_16   (Word16)(32768L/16)
+
+static void search_2i40(
+    Word16 dn[],         /* i : correlation between target and h[] */
+    Word16 rr[][L_CODE], /* i : matrix of autocorrelation          */
+    Word16 codvec[]      /* o : algebraic codebook vector          */
+)
+{
+    Word16 i0, i1;
+    Word16 ix = 0; /* initialization only needed to keep gcc silent */
+    Word16 track1, track2, ipos[NB_PULSE];
+    Word16 psk, ps0, ps1, sq, sq1;
+    Word16 alpk, alp, alp_16;
+    Word32 s, alp0, alp1;
+    Word16 i;
+
+    psk = -1;                          move16 ();
+    alpk = 1;                          move16 ();
+    for (i = 0; i < NB_PULSE; i++)
+    {
+       codvec[i] = i;                  move16 ();
+    }
+
+    /*------------------------------------------------------------------*
+     * main loop: try 2x4  tracks.                                      *
+     *------------------------------------------------------------------*/
+
+    for (track1 = 0; track1 < 2; track1++)
+    {
+       for (track2 = 0; track2 < 4; track2++)
+       {		
+          /* fix starting position */          
+          ipos[0] = startPos1[track1]; move16 ();
+          ipos[1] = startPos2[track2]; move16 ();
+          
+          /*----------------------------------------------------------------*
+           * i0 loop: try 8 positions.                                      *
+           *----------------------------------------------------------------*/
+          move16 (); /* account for ptr. init. (rr[io]) */
+          for (i0 = ipos[0]; i0 < L_CODE; i0 += STEP)
+          {
+             ps0 = dn[i0];          move16 ();
+             alp0 = L_mult(rr[i0][i0], _1_4);
+             
+             /*-------------------------------------------------------------*
+              * i1 loop: 8 positions.                                       *
+              *-------------------------------------------------------------*/
+             
+             sq = -1;               move16 ();
+             alp = 1;               move16 ();
+             ix = ipos[1];          move16 ();
+             
+             /*---------------------------------------------------------------*
+              * These index have low complexity address computation because   *
+              * they are, in fact, pointers with fixed increment. For example,*
+              * "rr[i0][i2]" is a pointer initialized to "&rr[i0][ipos[2]]"   *
+              * and incremented by "STEP".                                    *
+              *---------------------------------------------------------------*/
+             
+             move16 (); /* account for ptr. init. (rr[i1]) */
+             move16 (); /* account for ptr. init. (dn[i1]) */
+             move16 (); /* account for ptr. init. (rr[io]) */
+             for (i1 = ipos[1]; i1 < L_CODE; i1 += STEP) {
+                ps1 = add(ps0, dn[i1]);   /* idx increment = STEP */
+                
+                /* alp1 = alp0 + rr[i0][i1] + 1/2*rr[i1][i1]; */
+                
+                alp1 = L_mac(alp0, rr[i1][i1], _1_4); /* idx incr = STEP */
+                alp1 = L_mac(alp1, rr[i0][i1], _1_2); /* idx incr = STEP */
+                
+                sq1 = mult(ps1, ps1);
+                
+                alp_16 = round(alp1);
+                
+                s = L_msu(L_mult(alp, sq1), sq, alp_16);
+                
+                test ();
+                if (s > 0)
+                {
+                   sq = sq1;        move16 ();
+                   alp = alp_16;    move16 ();
+                   ix = i1;         move16 ();
+                }
+             }
+             
+             /*---------------------------------------------------------------*
+              * memorise codevector if this one is better than the last one.  *
+              *---------------------------------------------------------------*/
+             
+             s = L_msu(L_mult(alpk, sq), psk, alp);
+             
+             test ();
+             if (s > 0)
+             {
+                psk = sq;           move16 ();
+                alpk = alp;         move16 ();
+                codvec[0] = i0;     move16 ();
+                codvec[1] = ix;     move16 ();
+             }
+          }
+       }
+    }
+    return;
+}
+
+/*************************************************************************
+ *
+ *  FUNCTION:  build_code()
+ *
+ *  PURPOSE: Builds the codeword, the filtered codeword and index of the
+ *           codevector, based on the signs and positions of 2 pulses.
+ *
+ *************************************************************************/
+
+static Word16 build_code(
+    Word16 codvec[],  /* i : position of pulses                            */
+    Word16 dn_sign[], /* i : sign of pulses                                */
+    Word16 cod[],     /* o : innovative code vector                        */
+    Word16 h[],       /* i : impulse response of weighted synthesis filter */
+    Word16 y[],       /* o : filtered innovative code                      */
+    Word16 sign[]     /* o : sign of 2 pulses                              */
+)
+{
+    Word16 i, j, k, track, index, _sign[NB_PULSE], indx, rsign;
+    Word16 *p0, *p1;
+    Word32 s;
+
+    for (i = 0; i < L_CODE; i++)
+    {
+        cod[i] = 0;                                      move16 ();
+    }
+
+    indx = 0;                                            move16 ();
+    rsign = 0;                                           move16 ();
+    for (k = 0; k < NB_PULSE; k++)
+    {
+        i = codvec[k];      /* read pulse position */    move16 ();
+        j = dn_sign[i];     /* read sign           */    move16 ();
+
+        index = mult(i, 6554);    /* index = pos/5 */
+                                  /* track = pos%5 */
+        track = sub(i, extract_l(L_shr(L_mult(index, 5), 1)));
+        
+        test (); test (); test (); test ();
+        if (sub(track, 0) == 0)
+        {                       
+           track = 1;                                    move16 ();                
+           index = shl(index, 6);           
+        }
+        else if (sub(track, 1) == 0)
+        {
+           test ();            
+           if (sub(k, 0) == 0)
+           {                      
+              track = 0;                                 move16 ();     
+              index = shl(index, 1);
+           }
+           else
+           {
+              track = 1;                                 move16 ();
+              index = add(shl(index, 6), 16);              
+           }
+        }
+        else if (sub(track, 2) == 0)
+        {      
+           track = 1;                                    move16 ();
+           index = add(shl(index, 6), 32);           
+        }
+        else if (sub(track, 3) == 0)
+        {
+           track = 0;                                    move16 ();     
+           index = add(shl(index, 1), 1);           
+        }
+        else if (sub(track, 4) == 0)
+        {      
+           track = 1;                                    move16 ();
+           index = add(shl(index, 6), 48);
+        }
+
+        test ();
+        if (j > 0)
+        {
+           cod[i] = 8191;                                move16 ();
+           _sign[k] = 32767;                             move16 ();
+           rsign = add(rsign, shl(1, track));
+        }
+        else
+        {
+           cod[i] = -8192;                               move16 ();
+           _sign[k] = (Word16) - 32768L;                 move16 ();
+        }
+        
+        indx = add(indx, index);
+    }
+    *sign = rsign;                                       move16 ();
+    
+    p0 = h - codvec[0];                                  move16 ();
+    p1 = h - codvec[1];                                  move16 ();
+
+    for (i = 0; i < L_CODE; i++)
+    {
+        s = 0;                                           move32 ();
+        s = L_mac(s, *p0++, _sign[0]);
+        s = L_mac(s, *p1++, _sign[1]);
+        y[i] = round(s);                                 move16 ();
+    }
+
+    return indx;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/c2_11pf.h FFMpeg-20050127-new/libavcodec/amr/c2_11pf.h
--- FFMpeg-20050127/libavcodec/amr/c2_11pf.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/c2_11pf.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,76 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : c2_11pf.h
+*      Purpose          : Searches a 11 bit algebraic codebook containing 2 pulses
+*                         in a frame of 40 samples.
+*
+********************************************************************************
+*/
+#ifndef c2_11pf_h
+#define c2_11pf_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  code_2i40_11bits()
+ *
+ *  PURPOSE:  Searches a 11 bit algebraic codebook containing 2 pulses
+ *            in a frame of 40 samples.
+ *
+ *  DESCRIPTION:
+ *    The code length is 40, containing 2 nonzero pulses: i0...i1.
+ *    All pulses can have two possible amplitudes: +1 or -1.
+ *    Pulse i0 can have 2x8=16 possible positions, pulse i1 can have
+ *    4x8=32 positions.
+ *
+ *       i0 :  1, 6, 11, 16, 21, 26, 31, 36.
+ *             3, 8, 13, 18, 23, 28, 33, 38.
+ *       i1 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *             1, 6, 11, 16, 21, 26, 31, 36. 
+ *             2, 7, 12, 17, 22, 27, 32, 37.
+ *             4, 9, 14, 19, 24, 29, 34, 39.
+ * 
+ *************************************************************************/
+
+Word16 code_2i40_11bits(
+    Word16 x[], /* i : target vector                                 */
+    Word16 h[], /* i : impulse response of weighted synthesis filter */
+                /*     h[-L_subfr..-1] must be set to zero.          */
+    Word16 T0,  /* i : Pitch lag                                     */
+    Word16 pitch_sharp, /* i : Last quantized pitch gain             */
+    Word16 code[],      /* o : Innovative codebook                   */
+    Word16 y[],         /* o : filtered fixed codebook excitation    */
+    Word16 * sign       /* o : Signs of 2 pulses                     */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/c2_11pf.tab FFMpeg-20050127-new/libavcodec/amr/c2_11pf.tab
--- FFMpeg-20050127/libavcodec/amr/c2_11pf.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/c2_11pf.tab	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,18 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : c2_11pf.tab
+*      Purpose          : track start positions for fixed codebook routines
+*                         in c2_11pf.c/d2_11pf.c
+*      $Id $
+*
+********************************************************************************
+*/
+static const Word16 startPos1[2] = {1, 3};
+static const Word16 startPos2[4] = {0, 1, 2, 4};
diff -Nur FFMpeg-20050127/libavcodec/amr/c2_9pf.c FFMpeg-20050127-new/libavcodec/amr/c2_9pf.c
--- FFMpeg-20050127/libavcodec/amr/c2_9pf.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/c2_9pf.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,367 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : c2_9pf.c
+*      Purpose          : Searches a 9 bit algebraic codebook containing 
+*                         2 pulses in a frame of 40 samples.
+*
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "c2_9pf.h"
+const char c2_9pf_id[] = "@(#)$Id $" c2_9pf_h;
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "inv_sqrt.h"
+#include "cnst.h"
+#include "cor_h.h"
+#include "set_sign.h"
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+#define NB_PULSE  2
+
+#include "c2_9pf.tab"
+
+/*
+*****************************************************************************
+*                         DECLARATION OF PROTOTYPES
+*****************************************************************************
+*/
+static void search_2i40(
+    Word16 subNr,       /* i : subframe number                               */
+    Word16 dn[],        /* i : correlation between target and h[]            */
+    Word16 rr[][L_CODE],/* i : matrix of autocorrelation                     */
+    Word16 codvec[]     /* o : algebraic codebook vector                     */
+);
+static Word16 build_code(
+    Word16 subNr,       /* i : subframe number                               */
+    Word16 codvec[],    /* i : algebraic codebook vector                     */
+    Word16 dn_sign[],   /* i : sign of dn[]                                  */
+    Word16 cod[],       /* o : algebraic (fixed) codebook excitation         */
+    Word16 h[],         /* i : impulse response of weighted synthesis filter */
+    Word16 y[],         /* o : filtered fixed codebook excitation            */
+    Word16 sign[]       /* o : sign of 2 pulses                              */
+);
+
+
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  code_2i40_9bits()
+ *
+ *  PURPOSE:  Searches a 9 bit algebraic codebook containing 2 pulses
+ *            in a frame of 40 samples.
+ *
+ *  DESCRIPTION:
+ *    The code length is 40, containing 2 nonzero pulses: i0...i1.
+ *    All pulses can have two possible amplitudes: +1 or -1.
+ *    Pulse i0 can have 8 possible positions, pulse i1 can have
+ *    8 positions. Also coded is which track pair should be used,
+ *    i.e. first or second pair. Where each pair contains 2 tracks.
+ *
+ *     First subframe:
+ *     first   i0 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *             i1 :  2, 7, 12, 17, 22, 27, 32, 37.
+ *     second  i0 :  1, 6, 11, 16, 21, 26, 31, 36.
+ *             i1 :  3, 8, 13, 18, 23, 28, 33, 38.
+ *
+ *     Second subframe:
+ *     first   i0 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *             i1 :  3, 8, 13, 18, 23, 28, 33, 38.
+ *     second  i0 :  2, 7, 12, 17, 22, 27, 32, 37.
+ *             i1 :  4, 9, 14, 19, 24, 29, 34, 39.
+ *
+ *     Third subframe:
+ *     first   i0 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *             i1 :  2, 7, 12, 17, 22, 27, 32, 37.
+ *     second  i0 :  1, 6, 11, 16, 21, 26, 31, 36.
+ *             i1 :  4, 9, 14, 19, 24, 29, 34, 39.
+ *
+ *     Fourth subframe:
+ *     first   i0 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *             i1 :  3, 8, 13, 18, 23, 28, 33, 38.
+ *     second  i0 :  1, 6, 11, 16, 21, 26, 31, 36.
+ *             i1 :  4, 9, 14, 19, 24, 29, 34, 39.
+ *
+ *************************************************************************/
+
+Word16 code_2i40_9bits(
+    Word16 subNr,       /* i : subframe number                               */
+    Word16 x[],         /* i : target vector                                 */
+    Word16 h[],         /* i : impulse response of weighted synthesis filter */
+                        /*     h[-L_subfr..-1] must be set to zero.          */
+    Word16 T0,          /* i : Pitch lag                                     */
+    Word16 pitch_sharp, /* i : Last quantized pitch gain                     */
+    Word16 code[],      /* o : Innovative codebook                           */
+    Word16 y[],         /* o : filtered fixed codebook excitation            */
+    Word16 * sign       /* o : Signs of 2 pulses                             */
+)
+{
+    Word16 codvec[NB_PULSE];
+    Word16 dn[L_CODE], dn2[L_CODE], dn_sign[L_CODE];
+    Word16 rr[L_CODE][L_CODE];
+    Word16 i, index, sharp;
+    
+    sharp = shl(pitch_sharp, 1);
+    test ();
+    if (sub(T0, L_CODE) < 0)
+       for (i = T0; i < L_CODE; i++) {
+          h[i] = add(h[i], mult(h[i - T0], sharp));         move16 ();
+       }
+    cor_h_x(h, x, dn, 1);
+    set_sign(dn, dn_sign, dn2, 8); /* dn2[] not used in this codebook search */
+    cor_h(h, dn_sign, rr);
+    search_2i40(subNr, dn, rr, codvec);
+                                    move16 (); /* function result */
+    index = build_code(subNr, codvec, dn_sign, code, h, y, sign);
+    
+  /*-----------------------------------------------------------------*
+   * Compute innovation vector gain.                                 *
+   * Include fixed-gain pitch contribution into code[].              *
+   *-----------------------------------------------------------------*/
+    
+    test ();
+    if (sub(T0, L_CODE) < 0)
+       for (i = T0; i < L_CODE; i++) {
+          code[i] = add(code[i], mult(code[i - T0], sharp));  move16 ();
+       }
+    return index;
+}
+
+
+/*
+*****************************************************************************
+*                         PRIVATE PROGRAM CODE
+*****************************************************************************
+*/
+
+/*************************************************************************
+ *
+ *  FUNCTION  search_2i40()
+ *
+ *  PURPOSE: Search the best codevector; determine positions of the 2 pulses
+ *           in the 40-sample frame.
+ *
+ *************************************************************************/
+
+#define _1_2    (Word16)(32768L/2)
+#define _1_4    (Word16)(32768L/4)
+#define _1_8    (Word16)(32768L/8)
+#define _1_16   (Word16)(32768L/16)
+
+static void search_2i40(
+    Word16 subNr,        /* i : subframe number                    */
+    Word16 dn[],         /* i : correlation between target and h[] */
+    Word16 rr[][L_CODE], /* i : matrix of autocorrelation          */
+    Word16 codvec[]      /* o : algebraic codebook vector          */
+)
+{
+    Word16 i0, i1;
+    Word16 ix = 0; /* initialization only needed to keep gcc silent */
+    Word16  track1, ipos[NB_PULSE];
+    Word16 psk, ps0, ps1, sq, sq1;
+    Word16 alpk, alp, alp_16;
+    Word32 s, alp0, alp1;
+    Word16 i;    
+
+    psk = -1;                     move16 ();
+    alpk = 1;                     move16 ();
+    for (i = 0; i < NB_PULSE; i++)
+    {
+       codvec[i] = i;             move16 ();
+    }
+ 
+    for (track1 = 0; track1 < 2; track1++) {		
+       /* fix starting position */
+       
+       ipos[0] = startPos[subNr*2+8*track1];     move16 ();
+       ipos[1] = startPos[subNr*2+1+8*track1];   move16 ();          
+       
+
+          /*----------------------------------------------------------------*
+           * i0 loop: try 8 positions.                                      *
+           *----------------------------------------------------------------*/
+          
+			                  move16 (); /* account for ptr. init. (rr[io]) */
+          for (i0 = ipos[0]; i0 < L_CODE; i0 += STEP) {
+             
+             ps0 = dn[i0];                    move16 ();
+             alp0 = L_mult(rr[i0][i0], _1_4);
+             
+          /*----------------------------------------------------------------*
+           * i1 loop: 8 positions.                                          *
+           *----------------------------------------------------------------*/
+             
+             sq = -1;                         move16 ();
+             alp = 1;                         move16 ();
+             ix = ipos[1];                    move16 ();
+             
+        /*-------------------------------------------------------------------*
+        *  These index have low complexity address computation because      *
+        *  they are, in fact, pointers with fixed increment.  For example,  *
+        *  "rr[i0][i2]" is a pointer initialized to "&rr[i0][ipos[2]]"      *
+        *  and incremented by "STEP".                                       *
+        *-------------------------------------------------------------------*/
+             
+             move16 (); /* account for ptr. init. (rr[i1]) */
+             move16 (); /* account for ptr. init. (dn[i1]) */
+             move16 (); /* account for ptr. init. (rr[io]) */
+             for (i1 = ipos[1]; i1 < L_CODE; i1 += STEP) {
+                ps1 = add(ps0, dn[i1]);   /* idx increment = STEP */
+                
+                /* alp1 = alp0 + rr[i0][i1] + 1/2*rr[i1][i1]; */
+                   
+                alp1 = L_mac(alp0, rr[i1][i1], _1_4); /* idx incr = STEP */
+                alp1 = L_mac(alp1, rr[i0][i1], _1_2); /* idx incr = STEP */
+                
+                sq1 = mult(ps1, ps1);
+                
+                alp_16 = round(alp1);
+                
+                s = L_msu(L_mult(alp, sq1), sq, alp_16);
+
+                test ();
+                if (s > 0) {
+                   sq = sq1;                  move16 ();
+                   alp = alp_16;              move16 ();
+                   ix = i1;                   move16 ();
+                }
+             }
+             
+          /*----------------------------------------------------------------*
+           * memorise codevector if this one is better than the last one.   *
+           *----------------------------------------------------------------*/
+             
+             s = L_msu(L_mult(alpk, sq), psk, alp);
+             
+             test ();
+             if (s > 0) {
+                psk = sq;                     move16 ();
+                alpk = alp;                   move16 ();
+                codvec[0] = i0;               move16 ();
+                codvec[1] = ix;               move16 ();
+             }
+          }
+    }
+    
+    return;
+}
+
+/*************************************************************************
+ *
+ *  FUNCTION:  build_code()
+ *
+ *  PURPOSE: Builds the codeword, the filtered codeword and index of the
+ *           codevector, based on the signs and positions of 2 pulses.
+ *
+ *************************************************************************/
+
+static Word16 build_code(
+    Word16 subNr,     /* i : subframe number                               */
+    Word16 codvec[],  /* i : position of pulses                            */
+    Word16 dn_sign[], /* i : sign of pulses                                */
+    Word16 cod[],     /* o : innovative code vector                        */
+    Word16 h[],       /* i : impulse response of weighted synthesis filter */
+    Word16 y[],       /* o : filtered innovative code                      */
+    Word16 sign[]     /* o : sign of 2 pulses                              */
+)
+{
+    Word16 i, j, k, track, first, index, _sign[NB_PULSE], indx, rsign;
+    Word16 *p0, *p1, *pt;
+    Word32 s;
+    static Word16 trackTable[4*5] = {
+       0, 1, 0, 1, -1, /* subframe 1; track to code; -1 do not code this position */
+       0, -1, 1, 0, 1, /* subframe 2 */
+       0, 1, 0, -1, 1, /* subframe 3 */
+       0, 1, -1, 0, 1};/* subframe 4 */
+
+    pt = &trackTable[add(subNr, shl(subNr, 2))];
+	
+    for (i = 0; i < L_CODE; i++) {
+        cod[i] = 0;                                 move16 ();
+    }
+    
+    indx = 0; move16 ();
+    rsign = 0; move16 ();
+    for (k = 0; k < NB_PULSE; k++) {
+       i = codvec[k];    /* read pulse position */  move16 ();
+       j = dn_sign[i];   /* read sign           */  move16 ();
+
+       index = mult(i, 6554);    /* index = pos/5 */
+                                 /* track = pos%5 */
+       track = sub(i, extract_l(L_shr(L_mult(index, 5), 1)));
+       
+       first = pt[track];                           move16 ();
+
+       test ();
+       if (first == 0) {
+          test ();
+          if (k == 0) {
+             track = 0;                             move16 ();
+          } else {
+             track = 1;                             move16 ();           
+             index = shl(index, 3);
+          }             
+       } else {
+          test ();
+          if (k == 0) {
+             track = 0;                             move16 ();            
+             index = add(index, 64);  /* table bit is MSB */
+          } else {
+             track = 1;                             move16 ();           
+             index = shl(index, 3);
+          }             
+       }
+
+       test ();
+       if (j > 0) {
+          cod[i] = 8191;                            move16 ();
+          _sign[k] = 32767;                         move16 ();
+          rsign = add(rsign, shl(1, track));
+       } else {
+          cod[i] = -8192;                           move16 ();
+          _sign[k] = (Word16) - 32768L;             move16 ();
+        }
+       
+       indx = add(indx, index);
+    }
+    *sign = rsign;                                  move16 ();
+                                  
+    p0 = h - codvec[0];                             move16 ();
+    p1 = h - codvec[1];                             move16 ();
+    
+    for (i = 0; i < L_CODE; i++) {
+       s = 0;                                       move32 ();
+       s = L_mac(s, *p0++, _sign[0]);
+       s = L_mac(s, *p1++, _sign[1]);
+       y[i] = round(s);                             move16 ();
+    }
+    
+    return indx;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/c2_9pf.h FFMpeg-20050127-new/libavcodec/amr/c2_9pf.h
--- FFMpeg-20050127/libavcodec/amr/c2_9pf.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/c2_9pf.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,95 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : c2_9pf.h
+*      Purpose          : Searches a 9 bit algebraic codebook containing 
+*                         2 pulses in a frame of 40 samples.
+*
+*****************************************************************************
+*/
+#ifndef c2_9pf_h
+#define c2_9pf_h "$Id $"
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include "typedef.h"
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         DEFINITION OF DATA TYPES
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         DECLARATION OF PROTOTYPES
+*****************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  code_2i40_9bits()
+ *
+ *  PURPOSE:  Searches a 9 bit algebraic codebook containing 2 pulses
+ *            in a frame of 40 samples.
+ *
+ *  DESCRIPTION:
+ *    The code length is 40, containing 2 nonzero pulses: i0...i1.
+ *    All pulses can have two possible amplitudes: +1 or -1.
+ *    Pulse i0 can have 8 possible positions, pulse i1 can have
+ *    8 positions. Also coded is which track pair should be used,
+ *    i.e. first or second pair. Where each pair contains 2 tracks.
+ *
+ *     First subframe:
+ *     first   i0 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *             i1 :  2, 7, 12, 17, 22, 27, 32, 37.
+ *     second  i0 :  1, 6, 11, 16, 21, 26, 31, 36.
+ *             i1 :  3, 8, 13, 18, 23, 28, 33, 38.
+ *
+ *     Second subframe:
+ *     first   i0 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *             i1 :  3, 8, 13, 18, 23, 28, 33, 38.
+ *     second  i0 :  2, 7, 12, 17, 22, 27, 32, 37.
+ *             i1 :  4, 9, 14, 19, 24, 29, 34, 39.
+ *
+ *     Third subframe:
+ *     first   i0 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *             i1 :  2, 7, 12, 17, 22, 27, 32, 37.
+ *     second  i0 :  1, 6, 11, 16, 21, 26, 31, 36.
+ *             i1 :  4, 9, 14, 19, 24, 29, 34, 39.
+ *
+ *     Fourth subframe:
+ *     first   i0 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *             i1 :  3, 8, 13, 18, 23, 28, 33, 38.
+ *     second  i0 :  1, 6, 11, 16, 21, 26, 31, 36.
+ *             i1 :  4, 9, 14, 19, 24, 29, 34, 39.
+ *
+ *************************************************************************/
+
+Word16 code_2i40_9bits(
+    Word16 subNr,       /* i : subframe number                               */
+    Word16 x[],         /* i : target vector                                 */
+    Word16 h[],         /* i : impulse response of weighted synthesis filter */
+                        /*     h[-L_subfr..-1] must be set to zero.          */
+    Word16 T0,          /* i : Pitch lag                                     */
+    Word16 pitch_sharp, /* i : Last quantized pitch gain                     */
+    Word16 code[],      /* o : Innovative codebook                           */
+    Word16 y[],         /* o : filtered fixed codebook excitation            */
+    Word16 * sign       /* o : Signs of 2 pulses                             */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/c2_9pf.tab FFMpeg-20050127-new/libavcodec/amr/c2_9pf.tab
--- FFMpeg-20050127/libavcodec/amr/c2_9pf.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/c2_9pf.tab	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,20 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : c2_9pf.tab
+*      Purpose          : track start positions for fixed codebook routines
+*                         in c2_9pf.c/d2_9pf.c
+*      $Id $
+*
+********************************************************************************
+*/
+static const Word16 startPos[2*4*2] = {0, 2, 0, 3,
+                                       0, 2, 0, 3,
+                                       1, 3, 2, 4,
+                                       1, 4, 1, 4};
diff -Nur FFMpeg-20050127/libavcodec/amr/c3_14pf.c FFMpeg-20050127-new/libavcodec/amr/c3_14pf.c
--- FFMpeg-20050127/libavcodec/amr/c3_14pf.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/c3_14pf.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,421 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : c3_14pf.c
+*      Purpose          : Searches a 14 bit algebraic codebook containing 3 pulses
+*                         in a frame of 40 samples.
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "c3_14pf.h"
+const char c3_14pf_id[] = "@(#)$Id $" c3_14pf_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "inv_sqrt.h"
+#include "cnst.h"
+#include "cor_h.h"
+#include "set_sign.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#define NB_PULSE  3
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+static void search_3i40(
+    Word16 dn[],        /* i : correlation between target and h[]            */
+    Word16 dn2[],       /* i : maximum of corr. in each track.               */
+    Word16 rr[][L_CODE],/* i : matrix of autocorrelation                     */
+    Word16 codvec[]     /* o : algebraic codebook vector                     */
+);
+
+static Word16 build_code(   
+    Word16 codvec[],    /* i : algebraic codebook vector                     */
+    Word16 dn_sign[],   /* i : sign of dn[]                                  */
+    Word16 cod[],       /* o : algebraic (fixed) codebook excitation         */
+    Word16 h[],         /* i : impulse response of weighted synthesis filter */
+    Word16 y[],         /* o : filtered fixed codebook excitation            */
+    Word16 sign[]       /* o : sign of 3 pulses                              */
+);
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  code_3i40_14bits()
+ *
+ *  PURPOSE:  Searches a 14 bit algebraic codebook containing 3 pulses
+ *            in a frame of 40 samples.
+ *
+ *  DESCRIPTION:
+ *    The code length is 40, containing 3 nonzero pulses: i0...i2.
+ *    All pulses can have two possible amplitudes: +1 or -1.
+ *    Pulse i0 can have 8 possible positions, pulses i1 and i2 can have
+ *    2x8=16 positions.
+ *
+ *       i0 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *       i1 :  1, 6, 11, 16, 21, 26, 31, 36.
+ *             3, 8, 13, 18, 23, 28, 33, 38.
+ *       i2 :  2, 7, 12, 17, 22, 27, 32, 37.
+ *             4, 9, 14, 19, 24, 29, 34, 39.
+ *
+ *************************************************************************/
+
+Word16 code_3i40_14bits(
+    Word16 x[],         /* i : target vector                                 */
+    Word16 h[],         /* i : impulse response of weighted synthesis filter */
+                        /*     h[-L_subfr..-1] must be set to zero.          */
+    Word16 T0,          /* i : Pitch lag                                     */
+    Word16 pitch_sharp, /* i : Last quantized pitch gain                     */
+    Word16 code[],      /* o : Innovative codebook                           */
+    Word16 y[],         /* o : filtered fixed codebook excitation            */
+    Word16 * sign       /* o : Signs of 3 pulses                             */
+)
+{
+    Word16 codvec[NB_PULSE];
+    Word16 dn[L_CODE], dn2[L_CODE], dn_sign[L_CODE];
+    Word16 rr[L_CODE][L_CODE];
+    Word16 i, index, sharp;
+
+    sharp = shl(pitch_sharp, 1);
+    test ();
+    if (sub(T0, L_CODE) < 0)
+    {
+       for (i = T0; i < L_CODE; i++) {
+          h[i] = add(h[i], mult(h[i - T0], sharp));      move16 ();
+       }
+    }
+    
+    cor_h_x(h, x, dn, 1);
+    set_sign(dn, dn_sign, dn2, 6);
+    cor_h(h, dn_sign, rr);
+    search_3i40(dn, dn2, rr, codvec);
+                                    move16 (); /* function result */
+    index = build_code(codvec, dn_sign, code, h, y, sign);
+
+  /*-----------------------------------------------------------------*
+  * Compute innovation vector gain.                                 *
+  * Include fixed-gain pitch contribution into code[].              *
+  *-----------------------------------------------------------------*/
+
+    test ();
+    if (sub(T0, L_CODE) < 0)
+    {
+       for (i = T0; i < L_CODE; i++) { 
+          code[i] = add(code[i], mult(code[i - T0], sharp));    move16 ();
+       }
+    }
+    return index;
+}
+
+/*
+********************************************************************************
+*                         PRIVATE PROGRAM CODE
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ *  FUNCTION  search_3i40()
+ *
+ *  PURPOSE: Search the best codevector; determine positions of the 3 pulses
+ *           in the 40-sample frame.
+ *
+ *************************************************************************/
+
+#define _1_2    (Word16)(32768L/2)
+#define _1_4    (Word16)(32768L/4)
+#define _1_8    (Word16)(32768L/8)
+#define _1_16   (Word16)(32768L/16)
+
+static void search_3i40(
+    Word16 dn[],         /* i : correlation between target and h[] */
+    Word16 dn2[],        /* i : maximum of corr. in each track.    */
+    Word16 rr[][L_CODE], /* i : matrix of autocorrelation          */
+    Word16 codvec[]      /* o : algebraic codebook vector          */
+)
+{
+    Word16 i0, i1, i2;
+    Word16 ix = 0; /* initialization only needed to keep gcc silent */
+    Word16 ps = 0; /* initialization only needed to keep gcc silent */
+    Word16 i, pos, track1, track2, ipos[NB_PULSE];
+    Word16 psk, ps0, ps1, sq, sq1;
+    Word16 alpk, alp, alp_16;
+    Word32 s, alp0, alp1;
+
+    psk = -1;     move16 ();
+    alpk = 1;     move16 ();
+    for (i = 0; i < NB_PULSE; i++)
+    {
+       codvec[i] = i;    move16 ();
+    }
+
+    for (track1 = 1; track1 < 4; track1 += 2)
+    {
+       for (track2 = 2; track2 < 5; track2 += 2)
+       {		
+          /* fix starting position */
+
+          ipos[0] = 0;       move16 ();
+          ipos[1] = track1;  move16 ();
+          ipos[2] = track2;  move16 ();
+          
+          /*------------------------------------------------------------------*
+           * main loop: try 3 tracks.                                         *
+           *------------------------------------------------------------------*/
+          
+          for (i = 0; i < NB_PULSE; i++)
+          {
+             /*----------------------------------------------------------------*
+              * i0 loop: try 8 positions.                                      *
+              *----------------------------------------------------------------*/
+             
+             move16 (); /* account for ptr. init. (rr[io]) */
+             for (i0 = ipos[0]; i0 < L_CODE; i0 += STEP)
+             {
+                test ();
+                if (dn2[i0] >= 0)
+                {
+                   ps0 = dn[i0];  move16 ();
+                   alp0 = L_mult(rr[i0][i0], _1_4);
+                   
+                   /*----------------------------------------------------------------*
+                    * i1 loop: 8 positions.                                          *
+                    *----------------------------------------------------------------*/
+                   
+                   sq = -1;          move16 ();
+                   alp = 1;          move16 ();
+                   ps = 0;           move16 ();
+                   ix = ipos[1];     move16 ();
+                
+                   /* initialize 4 index for next loop. */
+                   /*-------------------------------------------------------------------*
+                    *  These index have low complexity address computation because      *
+                    *  they are, in fact, pointers with fixed increment.  For example,  *
+                    *  "rr[i0][i2]" is a pointer initialized to "&rr[i0][ipos[2]]"      *
+                    *  and incremented by "STEP".                                       *
+                    *-------------------------------------------------------------------*/
+                   
+                   move16 (); /* account for ptr. init. (rr[i1]) */
+                   move16 (); /* account for ptr. init. (dn[i1]) */
+                   move16 (); /* account for ptr. init. (rr[io]) */
+                   for (i1 = ipos[1]; i1 < L_CODE; i1 += STEP)
+                   {
+                      ps1 = add(ps0, dn[i1]);   /* idx increment = STEP */
+                      
+                      /* alp1 = alp0 + rr[i0][i1] + 1/2*rr[i1][i1]; */
+                      
+                      alp1 = L_mac(alp0, rr[i1][i1], _1_4); /* idx incr = STEP */
+                      alp1 = L_mac(alp1, rr[i0][i1], _1_2); /* idx incr = STEP */
+                      
+                      sq1 = mult(ps1, ps1);
+                      
+                      alp_16 = round(alp1);
+                      
+                      s = L_msu(L_mult(alp, sq1), sq, alp_16);
+                      
+                      test ();
+                      if (s > 0)
+                      {
+                         sq = sq1;      move16 ();
+                         ps = ps1;      move16 ();
+                         alp = alp_16;  move16 ();
+                         ix = i1;       move16 ();
+                      }
+                   }
+                   i1 = ix;             move16 ();
+                   
+                   /*----------------------------------------------------------------*
+                    * i2 loop: 8 positions.                                          *
+                    *----------------------------------------------------------------*/
+                   
+                   ps0 = ps;            move16 ();
+                   alp0 = L_mult(alp, _1_4);
+                   
+                   sq = -1;             move16 ();
+                   alp = 1;             move16 ();
+                   ps = 0;              move16 ();
+                   ix = ipos[2];        move16 ();
+                   
+                   /* initialize 4 index for next loop (see i1 loop) */
+                   
+                   move16 (); /* account for ptr. init. (rr[i2]) */
+                   move16 (); /* account for ptr. init. (rr[i1]) */
+                   move16 (); /* account for ptr. init. (dn[i2]) */
+                   move16 (); /* account for ptr. init. (rr[io]) */
+                   for (i2 = ipos[2]; i2 < L_CODE; i2 += STEP)
+                   {
+                      ps1 = add(ps0, dn[i2]); /* index increment = STEP */
+                      
+                      /* alp1 = alp0 + rr[i0][i2] + rr[i1][i2] + 1/2*rr[i2][i2]; */
+                      
+                      alp1 = L_mac(alp0, rr[i2][i2], _1_16); /* idx incr = STEP */
+                      alp1 = L_mac(alp1, rr[i1][i2], _1_8);  /* idx incr = STEP */
+                      alp1 = L_mac(alp1, rr[i0][i2], _1_8);  /* idx incr = STEP */
+                      
+                      sq1 = mult(ps1, ps1);
+                      
+                      alp_16 = round(alp1);
+                      
+                      s = L_msu(L_mult(alp, sq1), sq, alp_16);
+                      
+                      test ();
+                      if (s > 0)
+                      {
+                         sq = sq1;      move16 ();
+                         ps = ps1;      move16 ();
+                         alp = alp_16;  move16 ();
+                         ix = i2;       move16 ();
+                      }
+                   }
+                   i2 = ix;             move16 ();
+                   
+                   /*----------------------------------------------------------------*
+                    * memorise codevector if this one is better than the last one.   *
+                    *----------------------------------------------------------------*/
+                   
+                   s = L_msu(L_mult(alpk, sq), psk, alp);
+                   
+                   test ();
+                   if (s > 0)
+                   {
+                      psk = sq;         move16 ();
+                      alpk = alp;       move16 ();
+                      codvec[0] = i0;   move16 ();
+                      codvec[1] = i1;   move16 ();
+                      codvec[2] = i2;   move16 ();
+                   }
+                }
+             }
+             /*----------------------------------------------------------------*
+              * Cyclic permutation of i0, i1 and i2.                           *
+              *----------------------------------------------------------------*/
+             
+             pos = ipos[2];          move16 ();
+             ipos[2] = ipos[1];      move16 ();
+             ipos[1] = ipos[0];      move16 ();
+             ipos[0] = pos;          move16 ();
+          }
+       }
+    }    
+    return;
+}
+
+/*************************************************************************
+ *
+ *  FUNCTION:  build_code()
+ *
+ *  PURPOSE: Builds the codeword, the filtered codeword and index of the
+ *           codevector, based on the signs and positions of 3 pulses.
+ *
+ *************************************************************************/
+
+static Word16
+build_code(
+    Word16 codvec[],  /* i : position of pulses                            */
+    Word16 dn_sign[], /* i : sign of pulses                                */
+    Word16 cod[],     /* o : innovative code vector                        */
+    Word16 h[],       /* i : impulse response of weighted synthesis filter */
+    Word16 y[],       /* o : filtered innovative code                      */
+    Word16 sign[]     /* o : sign of 3 pulses                              */
+)
+{
+    Word16 i, j, k, track, index, _sign[NB_PULSE], indx, rsign;
+    Word16 *p0, *p1, *p2;
+    Word32 s;
+
+    for (i = 0; i < L_CODE; i++) {
+       cod[i] = 0;         move16 ();
+    }
+    
+    indx = 0;               move16 ();
+    rsign = 0;              move16 ();
+    for (k = 0; k < NB_PULSE; k++)
+    {
+       i = codvec[k];      move16 ();  /* read pulse position */
+       j = dn_sign[i];     move16 ();  /* read sign           */
+       
+       index = mult(i, 6554);    /* index = pos/5 */
+                                 /* track = pos%5 */
+       track = sub(i, extract_l(L_shr(L_mult(index, 5), 1)));
+       
+       test ();
+       if (sub(track, 1) == 0)
+          index = shl(index, 4);
+       else if (sub(track, 2) == 0)
+       {
+          test ();
+          track = 2;                          move16 ();
+          index = shl(index, 8);
+       }
+       else if (sub(track, 3) == 0)
+       {
+          test (); test ();
+          track = 1;                          move16 ();         
+          index = add(shl(index, 4), 8);
+       }
+       else if (sub(track, 4) == 0)
+       {
+          test (); test (); test ();
+          track = 2;                          move16 ();
+          index = add(shl(index, 8), 128);
+       }
+       
+       test ();
+       if (j > 0)
+       {
+          cod[i] = 8191;                       move16 ();
+          _sign[k] = 32767;                    move16 ();
+          rsign = add(rsign, shl(1, track));
+       } else {
+          cod[i] = -8192;                      move16 ();
+          _sign[k] = (Word16) - 32768L;        move16 ();
+       }
+       
+       indx = add(indx, index);
+    }
+    *sign = rsign;                             move16 ();
+
+    p0 = h - codvec[0];                        move16 ();
+    p1 = h - codvec[1];                        move16 ();
+    p2 = h - codvec[2];                        move16 ();
+    
+    for (i = 0; i < L_CODE; i++)
+    {
+       s = 0;                                  move32 ();
+       s = L_mac(s, *p0++, _sign[0]);
+       s = L_mac(s, *p1++, _sign[1]);
+       s = L_mac(s, *p2++, _sign[2]);
+       y[i] = round(s);                        move16 ();
+    }
+    
+    return indx;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/c3_14pf.h FFMpeg-20050127-new/libavcodec/amr/c3_14pf.h
--- FFMpeg-20050127/libavcodec/amr/c3_14pf.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/c3_14pf.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,75 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : c3_14pf.h
+*      Purpose          : Searches a 14 bit algebraic codebook containing 3 pulses
+*                         in a frame of 40 samples.
+*
+********************************************************************************
+*/
+#ifndef c3_14pf_h
+#define c3_14pf_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  code_3i40_14bits()
+ *
+ *  PURPOSE:  Searches a 14 bit algebraic codebook containing 3 pulses
+ *            in a frame of 40 samples.
+ *
+ *  DESCRIPTION:
+ *    The code length is 40, containing 3 nonzero pulses: i0...i2.
+ *    All pulses can have two possible amplitudes: +1 or -1.
+ *    Pulse i0 can have 8 possible positions, pulses i1 and i2 can have
+ *    2x8=16 positions.
+ *
+ *       i0 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *       i1 :  1, 6, 11, 16, 21, 26, 31, 36.
+ *             3, 8, 13, 18, 23, 28, 33, 38.
+ *       i2 :  2, 7, 12, 17, 22, 27, 32, 37.
+ *             4, 9, 14, 19, 24, 29, 34, 39.
+ * 
+ *************************************************************************/
+
+Word16 code_3i40_14bits(
+    Word16 x[], /* (i)   : target vector                                 */
+    Word16 h[], /* (i)   : impulse response of weighted synthesis filter */
+                /*         h[-L_subfr..-1] must be set to zero.          */
+    Word16 T0,  /* (i)   : Pitch lag                                     */
+    Word16 pitch_sharp, /* (i)   : Last quantized pitch gain             */
+    Word16 code[],      /* (o)   : Innovative codebook                   */
+    Word16 y[],         /* (o)   : filtered fixed codebook excitation    */
+    Word16 * sign       /* (o)   : Signs of 3 pulses                     */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/c4_17pf.c FFMpeg-20050127-new/libavcodec/amr/c4_17pf.c
--- FFMpeg-20050127/libavcodec/amr/c4_17pf.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/c4_17pf.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,477 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : c4_17pf.c
+*      Purpose          : Searches a 17 bit algebraic codebook containing 4 pulses
+*                         in a frame of 40 samples.
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "c4_17pf.h"
+const char c4_17pf_id[] = "@(#)$Id $" c4_17pf_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "inv_sqrt.h"
+#include "cnst.h"
+#include "cor_h.h"
+#include "set_sign.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#define NB_PULSE  4
+
+#include "gray.tab"
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+static void search_4i40(
+    Word16 dn[],        /* i : correlation between target and h[]            */
+    Word16 dn2[],       /* i : maximum of corr. in each track.               */
+    Word16 rr[][L_CODE],/* i : matrix of autocorrelation                     */
+    Word16 codvec[]     /* o : algebraic codebook vector                     */
+);
+
+static Word16 build_code(   
+    Word16 codvec[],    /* i : algebraic codebook vector                     */
+    Word16 dn_sign[],   /* i : sign of dn[]                                  */
+    Word16 cod[],       /* o : algebraic (fixed) codebook excitation         */
+    Word16 h[],         /* i : impulse response of weighted synthesis filter */
+    Word16 y[],         /* o : filtered fixed codebook excitation            */
+    Word16 sign[]       /* o : index of 4 pulses (position+sign+ampl)*4      */
+);
+
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  code_4i40_17bits()
+ *
+ *  PURPOSE:  Searches a 17 bit algebraic codebook containing 4 pulses
+ *            in a frame of 40 samples.
+ *
+ *  DESCRIPTION:
+ *    The code length is 40, containing 4 nonzero pulses: i0...i3.
+ *    All pulses can have two possible amplitudes: +1 or -1.
+ *    Pulse i0 to i2 can have 8 possible positions, pulse i3 can have
+ *    2x8=16 positions.
+ *
+ *       i0 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *       i1 :  1, 6, 11, 16, 21, 26, 31, 36.
+ *       i2 :  2, 7, 12, 17, 22, 27, 32, 37.
+ *       i3 :  3, 8, 13, 18, 23, 28, 33, 38.
+ *             4, 9, 14, 19, 24, 29, 34, 39.
+ *
+ *************************************************************************/
+
+Word16 code_4i40_17bits(
+    Word16 x[],         /* i : target vector                                 */
+    Word16 h[],         /* i : impulse response of weighted synthesis filter */
+                        /*     h[-L_subfr..-1] must be set to zero.          */
+    Word16 T0,          /* i : Pitch lag                                     */
+    Word16 pitch_sharp, /* i : Last quantized pitch gain                     */
+    Word16 code[],      /* o : Innovative codebook                           */
+    Word16 y[],         /* o : filtered fixed codebook excitation            */
+    Word16 * sign       /* o : Signs of 4 pulses                             */
+)
+{
+    Word16 codvec[NB_PULSE];
+    Word16 dn[L_CODE], dn2[L_CODE], dn_sign[L_CODE];
+    Word16 rr[L_CODE][L_CODE];
+    Word16 i, index, sharp;
+
+    sharp = shl(pitch_sharp, 1);
+    test ();
+    if (sub(T0, L_CODE) < 0)
+    {
+       for (i = T0; i < L_CODE; i++) {
+          h[i] = add(h[i], mult(h[i - T0], sharp));   move16 ();
+       }
+    }
+    
+    cor_h_x(h, x, dn, 1);
+    set_sign(dn, dn_sign, dn2, 4);
+    cor_h(h, dn_sign, rr);
+    search_4i40(dn, dn2, rr, codvec);
+                                    move16 (); /* function result */
+    index = build_code(codvec, dn_sign, code, h, y, sign);
+
+  /*-----------------------------------------------------------------*
+  * Compute innovation vector gain.                                 *
+  * Include fixed-gain pitch contribution into code[].              *
+  *-----------------------------------------------------------------*/
+
+    test ();
+    if (sub(T0, L_CODE) < 0)
+    {
+       for (i = T0; i < L_CODE; i++) {
+          code[i] = add(code[i], mult(code[i - T0], sharp));  move16 ();
+       }
+    }
+    return index;
+}
+
+/*
+********************************************************************************
+*                         PRIVATE PROGRAM CODE
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ *  FUNCTION  search_4i40()
+ *
+ *  PURPOSE: Search the best codevector; determine positions of the 4 pulses
+ *           in the 40-sample frame.
+ *
+ *************************************************************************/
+
+#define _1_2    (Word16)(32768L/2)
+#define _1_4    (Word16)(32768L/4)
+#define _1_8    (Word16)(32768L/8)
+#define _1_16   (Word16)(32768L/16)
+
+static void search_4i40(
+    Word16 dn[],         /* i : correlation between target and h[]  */
+    Word16 dn2[],        /* i : maximum of corr. in each track.     */
+    Word16 rr[][L_CODE], /* i : matrix of autocorrelation           */
+    Word16 codvec[]      /* o : algebraic codebook vector           */
+)
+{
+    Word16 i0, i1, i2, i3;
+    Word16 ix = 0; /* initialization only needed to keep gcc silent */
+    Word16 ps = 0; /* initialization only needed to keep gcc silent */
+    Word16 i, pos, track, ipos[NB_PULSE];
+    Word16 psk, ps0, ps1, sq, sq1;
+    Word16 alpk, alp, alp_16;
+    Word32 s, alp0, alp1;
+    
+    /* Default value */
+    psk = -1;            move16 ();
+    alpk = 1;            move16 ();
+    for (i = 0; i < NB_PULSE; i++)
+    {
+       codvec[i] = i;    move16 ();
+    }
+
+    for (track = 3; track < 5; track++) {
+    /* fix starting position */
+
+       ipos[0] = 0;     move16 ();
+       ipos[1] = 1;     move16 ();
+       ipos[2] = 2;     move16 ();
+       ipos[3] = track; move16 ();
+       
+       /*------------------------------------------------------------------*
+        * main loop: try 4 tracks.                                         *
+        *------------------------------------------------------------------*/
+       
+       for (i = 0; i < NB_PULSE; i++)
+       {
+          /*----------------------------------------------------------------*
+           * i0 loop: try 4 positions (use position with max of corr.).     *
+           *----------------------------------------------------------------*/
+          
+          move16 (); /* account for ptr. init. (rr[io]) */
+          for (i0 = ipos[0]; i0 < L_CODE; i0 += STEP)
+          {
+             test (); move16 ();
+             if (dn2[i0] >= 0)
+             {
+                ps0 = dn[i0];     move16 ();
+                alp0 = L_mult(rr[i0][i0], _1_4);
+                
+                /*----------------------------------------------------------------*
+                 * i1 loop: 8 positions.                                          *
+                 *----------------------------------------------------------------*/
+                
+                sq = -1;          move16 ();
+                alp = 1;          move16 ();
+                ps = 0;           move16 ();
+                ix = ipos[1];     move16 ();
+                    
+                /* initialize 4 index for next loop. */
+                /*-------------------------------------------------------------------*
+                 *  These index have low complexity address computation because      *
+                 *  they are, in fact, pointers with fixed increment.  For example,  *
+                 *  "rr[i0][i3]" is a pointer initialized to "&rr[i0][ipos[3]]"      *
+                 *  and incremented by "STEP".                                       *
+                 *-------------------------------------------------------------------*/
+                
+                move16 (); /* account for ptr. init. (rr[i1]) */
+                move16 (); /* account for ptr. init. (dn[i1]) */
+                move16 (); /* account for ptr. init. (rr[io]) */
+                for (i1 = ipos[1]; i1 < L_CODE; i1 += STEP)
+                {
+                   ps1 = add(ps0, dn[i1]);   /* idx increment = STEP */
+                   
+                   /* alp1 = alp0 + rr[i0][i1] + 1/2*rr[i1][i1]; */
+                   
+                   alp1 = L_mac(alp0, rr[i1][i1], _1_4); /* idx incr = STEP */
+                   alp1 = L_mac(alp1, rr[i0][i1], _1_2); /* idx incr = STEP */
+                   
+                   sq1 = mult(ps1, ps1);
+                   
+                   alp_16 = round(alp1);
+                   
+                   s = L_msu(L_mult(alp, sq1), sq, alp_16);
+                   
+                   test ();
+                   if (s > 0)
+                   {
+                      sq = sq1;         move16 ();
+                      ps = ps1;         move16 ();
+                      alp = alp_16;     move16 ();
+                      ix = i1;          move16 ();
+                   }
+                }
+                i1 = ix;                  move16 ();
+                
+                /*----------------------------------------------------------------*
+                 * i2 loop: 8 positions.                                          *
+                 *----------------------------------------------------------------*/
+                
+                ps0 = ps;                 move16 ();
+                alp0 = L_mult(alp, _1_4);
+                
+                sq = -1;                  move16 ();
+                alp = 1;                  move16 ();
+                ps = 0;                   move16 ();
+                ix = ipos[2];             move16 ();
+                                    
+                /* initialize 4 index for next loop (see i1 loop) */
+                
+                move16 (); /* account for ptr. init. (rr[i2]) */
+                move16 (); /* account for ptr. init. (rr[i1]) */
+                move16 (); /* account for ptr. init. (dn[i2]) */
+                move16 (); /* account for ptr. init. (rr[io]) */
+                for (i2 = ipos[2]; i2 < L_CODE; i2 += STEP)
+                {
+                   ps1 = add(ps0, dn[i2]); /* index increment = STEP */
+                   
+                   /* alp1 = alp0 + rr[i0][i2] + rr[i1][i2] + 1/2*rr[i2][i2]; */
+                   
+                   alp1 = L_mac(alp0, rr[i2][i2], _1_16); /* idx incr = STEP */
+                   alp1 = L_mac(alp1, rr[i1][i2], _1_8);  /* idx incr = STEP */
+                   alp1 = L_mac(alp1, rr[i0][i2], _1_8);  /* idx incr = STEP */
+                   
+                   sq1 = mult(ps1, ps1);
+                   
+                   alp_16 = round(alp1);
+                   
+                   s = L_msu(L_mult(alp, sq1), sq, alp_16);
+                   
+                   test ();
+                   if (s > 0)
+                   {
+                      sq = sq1;         move16 ();
+                      ps = ps1;         move16 ();
+                      alp = alp_16;     move16 ();
+                      ix = i2;          move16 ();
+                   }
+                }
+                i2 = ix;                  move16 ();
+                
+                /*----------------------------------------------------------------*
+                 * i3 loop: 8 positions.                                          *
+                 *----------------------------------------------------------------*/
+                
+                ps0 = ps;                 move16 ();
+                alp0 = L_deposit_h(alp);
+                
+                sq = -1;                  move16 ();
+                alp = 1;                  move16 ();
+                ps = 0;                   move16 ();
+                ix = ipos[3];             move16 ();
+                                    
+                /* initialize 5 index for next loop (see i1 loop) */
+                
+                move16 (); /* account for ptr. init. (rr[i3]) */
+                move16 (); /* account for ptr. init. (rr[i2]) */
+                move16 (); /* account for ptr. init. (rr[i1]) */
+                move16 (); /* account for ptr. init. (dn[i3]) */
+                move16 (); /* account for ptr. init. (rr[io]) */
+                for (i3 = ipos[3]; i3 < L_CODE; i3 += STEP)
+                {
+                   ps1 = add(ps0, dn[i3]); /* index increment = STEP */
+                   
+                   /* alp1 = alp0 + rr[i0][i3] + rr[i1][i3] + rr[i2][i3] + 1/2*rr[i3][i3]; */
+                   
+                   alp1 = L_mac(alp0, rr[i3][i3], _1_16); /* idx incr = STEP */
+                   alp1 = L_mac(alp1, rr[i2][i3], _1_8);  /* idx incr = STEP */
+                   alp1 = L_mac(alp1, rr[i1][i3], _1_8);  /* idx incr = STEP */
+                   alp1 = L_mac(alp1, rr[i0][i3], _1_8);  /* idx incr = STEP */
+                   
+                   sq1 = mult(ps1, ps1);
+                   
+                   alp_16 = round(alp1);
+                   
+                   s = L_msu(L_mult(alp, sq1), sq, alp_16);
+                   
+                   test ();
+                   if (s > 0)
+                   {
+                      sq = sq1;         move16 ();
+                      ps = ps1;         move16 ();
+                      alp = alp_16;     move16 ();
+                      ix = i3;          move16 ();
+                   }
+                }
+                
+                
+                /*----------------------------------------------------------------*
+                 * memorise codevector if this one is better than the last one.   *
+                 *----------------------------------------------------------------*/
+                
+                s = L_msu(L_mult(alpk, sq), psk, alp);
+                
+                test ();
+                if (s > 0)
+                {
+                   psk = sq;            move16 ();
+                   alpk = alp;          move16 ();
+                   codvec[0] = i0;      move16 ();
+                   codvec[1] = i1;      move16 ();
+                   codvec[2] = i2;      move16 ();
+                   codvec[3] = ix;      move16 ();
+                }
+             }
+          }
+          
+          /*----------------------------------------------------------------*
+           * Cyclic permutation of i0,i1,i2 and i3.                         *
+           *----------------------------------------------------------------*/
+          
+          pos = ipos[3];                   move16 ();
+          ipos[3] = ipos[2];               move16 ();
+          ipos[2] = ipos[1];               move16 ();
+          ipos[1] = ipos[0];               move16 ();
+          ipos[0] = pos;                   move16 ();
+       }
+    }
+    
+    return;
+}
+
+/*************************************************************************
+ *
+ *  FUNCTION:  build_code()
+ *
+ *  PURPOSE: Builds the codeword, the filtered codeword and index of the
+ *           codevector, based on the signs and positions of 4 pulses.
+ *
+ *************************************************************************/
+
+static Word16
+build_code(
+    Word16 codvec[],  /* i : position of pulses                            */
+    Word16 dn_sign[], /* i : sign of pulses                                */
+    Word16 cod[],     /* o : innovative code vector                        */
+    Word16 h[],       /* i : impulse response of weighted synthesis filter */
+    Word16 y[],       /* o : filtered innovative code                      */
+    Word16 sign[]     /* o : index of 4 pulses (sign+position)             */
+)
+{
+    Word16 i, j, k, track, index, _sign[NB_PULSE], indx, rsign;
+    Word16 *p0, *p1, *p2, *p3;
+    Word32 s;
+
+    for (i = 0; i < L_CODE; i++)
+    {
+        cod[i] = 0;                         move16 ();
+    }          
+
+    indx = 0;                               move16 ();
+    rsign = 0;                              move16 ();
+    for (k = 0; k < NB_PULSE; k++)
+    {
+       i = codvec[k];            move16 (); /* read pulse position */
+       j = dn_sign[i];           move16 (); /* read sign          */
+       
+       index = mult(i, 6554);    /* index = pos/5 */
+       /* track = pos%5 */
+       track = sub(i, extract_l(L_shr(L_mult(index, 5), 1)));
+       
+       
+       index = gray[index];                 move16 ();
+       
+       test ();
+       if (sub(track, 1) == 0)
+          index = shl(index, 3);
+       else if (sub(track, 2) == 0)
+       {
+          test ();
+          index = shl(index, 6);
+       }
+       else if (sub(track, 3) == 0)
+       {
+          test ();test ();			
+          index = shl(index, 10);
+       }
+       else if (sub(track, 4) == 0)
+       {
+          test ();test ();test ();			
+          track = 3;                        move16 ();
+          index = add(shl(index, 10), 512);
+       }
+       
+       test ();
+       if (j > 0)
+       {
+          cod[i] = 8191;                    move16 ();
+          _sign[k] = 32767;                 move16 ();
+          rsign = add(rsign, shl(1, track));
+       } else {
+          cod[i] = -8192;                   move16 ();
+          _sign[k] = (Word16) - 32768L;     move16 ();
+       }
+       
+       indx = add(indx, index);
+    }
+    *sign = rsign;                          move16 ();
+    
+    p0 = h - codvec[0];                     move16 ();
+    p1 = h - codvec[1];                     move16 ();
+    p2 = h - codvec[2];                     move16 ();
+    p3 = h - codvec[3];                     move16 ();
+    
+    for (i = 0; i < L_CODE; i++)
+    {
+       s = 0;                               move32 ();
+       s = L_mac(s, *p0++, _sign[0]);
+       s = L_mac(s, *p1++, _sign[1]);
+       s = L_mac(s, *p2++, _sign[2]);
+       s = L_mac(s, *p3++, _sign[3]);
+       y[i] = round(s);                     move16 ();
+    }
+    
+    return indx;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/c4_17pf.h FFMpeg-20050127-new/libavcodec/amr/c4_17pf.h
--- FFMpeg-20050127/libavcodec/amr/c4_17pf.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/c4_17pf.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,75 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : c4_17pf.h
+*      Purpose          : Searches a 17 bit algebraic codebook containing 4 pulses
+*                         in a frame of 40 samples.
+*
+********************************************************************************
+*/
+#ifndef c4_17pf_h
+#define c4_17pf_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  code_4i40_17bits()
+ *
+ *  PURPOSE:  Searches a 17 bit algebraic codebook containing 4 pulses
+ *            in a frame of 40 samples.
+ *
+ *  DESCRIPTION:
+ *    The code length is 40, containing 4 nonzero pulses: i0...i3.
+ *    All pulses can have two possible amplitudes: +1 or -1.
+ *    Pulse i0 to i2 can have 8 possible positions, pulse i3 can have
+ *    2x8=16 positions.
+ *
+ *       i0 :  0, 5, 10, 15, 20, 25, 30, 35.
+ *       i1 :  1, 6, 11, 16, 21, 26, 31, 36.
+ *       i2 :  2, 7, 12, 17, 22, 27, 32, 37.
+ *       i3 :  3, 8, 13, 18, 23, 28, 33, 38.
+ *             4, 9, 14, 19, 24, 29, 34, 39.
+ *
+ *************************************************************************/
+
+Word16 code_4i40_17bits(
+    Word16 x[], /* (i)   : target vector                                 */
+    Word16 h[], /* (i)   : impulse response of weighted synthesis filter */
+                /*         h[-L_subfr..-1] must be set to zero.          */
+    Word16 T0,  /* (i)   : Pitch lag                                     */
+    Word16 pitch_sharp, /* (i)   : Last quantized pitch gain             */
+    Word16 code[],      /* (o)   : Innovative codebook                   */
+    Word16 y[],         /* (o)   : filtered fixed codebook excitation    */
+    Word16 * sign       /* (o)   : Signs of 4 pulses                     */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/c8_31pf.c FFMpeg-20050127-new/libavcodec/amr/c8_31pf.c
--- FFMpeg-20050127/libavcodec/amr/c8_31pf.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/c8_31pf.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,345 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : c8_31pf.c
+*      Purpose          : Searches a 31 bit algebraic codebook containing 
+*                       : 8 pulses in a frame of 40 samples.
+*                       : in the same manner as GSM-EFR
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "c8_31pf.h"
+const char c8_31pf_id[] = "@(#)$Id $" c8_31pf_h;
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+#include "inv_sqrt.h"
+#include "cor_h.h"
+#include "set_sign.h"
+#include "s10_8pf.h"
+#include <stdio.h>
+#include <stdlib.h>
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#define NB_PULSE 8
+
+/* define values/representation for output codevector and sign */
+#define POS_CODE  8191 
+#define NEG_CODE  8191 
+#define POS_SIGN  32767
+#define NEG_SIGN  (Word16) (-32768L) 
+
+/*
+********************************************************************************
+*                         LOCAL PROGRAM CODE
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ *  FUNCTION:  build_code()
+ *
+ *  PURPOSE: Builds the codeword, the filtered codeword and a 
+ *   linear uncombined version of  the index of the
+ *           codevector, based on the signs and positions of 8  pulses.
+ *
+ *************************************************************************/
+
+static void build_code (
+    Word16 codvec[],    /* i : position of pulses                           */
+    Word16 sign[],      /* i : sign of d[n]                                 */
+    Word16 cod[],       /* o : innovative code vector                       */
+    Word16 h[],         /* i : impulse response of weighted synthesis filter*/
+    Word16 y[],         /* o : filtered innovative code                     */
+    Word16 sign_indx[], /* o : signs of 4  pulses (signs only)              */
+    Word16 pos_indx[]   /* o : position index of 8 pulses(position only)    */
+)
+{
+    Word16 i, j, k, track, sign_index, pos_index, _sign[NB_PULSE];
+    Word16 *p0, *p1, *p2, *p3, *p4, *p5, *p6, *p7;
+    Word32 s;
+
+    for (i = 0; i < L_CODE; i++)
+    {
+        cod[i] = 0;                              move16 (); 
+    }
+    for (i = 0; i < NB_TRACK_MR102; i++)
+    {
+        pos_indx[i] = -1;                            move16 (); 
+        sign_indx[i] = -1;                            move16 (); 
+    }
+    
+    for (k = 0; k < NB_PULSE; k++)
+    {
+       /* read pulse position */            
+       i = codvec[k];                           move16 ();
+       /* read sign           */        
+       j = sign[i];                             move16 (); 
+       
+       pos_index = shr(i, 2);                      /* index = pos/4 */
+       track = i & 3;             logic16 ();      /* track = pos%4 */
+       
+       test (); 
+       if (j > 0)
+       {
+          cod[i] = add (cod[i], POS_CODE);         move16 ();
+          _sign[k] = POS_SIGN;                     move16 (); 
+          sign_index = 0;  /* bit=0 -> positive pulse */  move16 (); 
+       }
+       else
+       {
+          cod[i] = sub (cod[i], NEG_CODE);         move16 ();
+          _sign[k] = NEG_SIGN;                     move16 (); 
+          sign_index = 1;     move16 (); /* bit=1 => negative pulse */ 
+          /* index = add (index, 8); 1 = negative  old code */
+       }
+       
+       test (); move16 ();
+       if (pos_indx[track] < 0)
+       {   /* first set first NB_TRACK pulses  */
+          pos_indx[track] = pos_index;                 move16 (); 
+          sign_indx[track] = sign_index;              move16 (); 
+       }
+       else
+       {   /* 2nd row of pulses , test if positions needs to be switched */
+          test (); logic16 (); logic16 (); 
+          if (((sign_index ^ sign_indx[track]) & 1) == 0)
+          {
+             /* sign of 1st pulse == sign of 2nd pulse */
+             
+             test (); 
+             if (sub (pos_indx[track], pos_index) <= 0)
+             {   /* no swap */
+                pos_indx[track + NB_TRACK_MR102] = pos_index;     move16 (); 
+             }
+             else
+             {   /* swap*/
+                pos_indx[track + NB_TRACK_MR102] = pos_indx[track];
+                move16 (); 
+                
+                pos_indx[track] = pos_index;         move16 ();
+                sign_indx[track] = sign_index;       move16 ();
+             }
+          }
+          else
+          {
+             /* sign of 1st pulse != sign of 2nd pulse */
+             
+             test (); 
+             if (sub (pos_indx[track], pos_index) <= 0)
+             {  /*swap*/
+                pos_indx[track + NB_TRACK_MR102] = pos_indx[track];
+                move16 (); 
+                
+                pos_indx[track] = pos_index;         move16 (); 
+                sign_indx[track] = sign_index;       move16 (); 
+             }
+             else
+             {   /*no swap */
+                pos_indx[track + NB_TRACK_MR102] = pos_index;     move16 (); 
+             }
+          }
+       }
+    }
+    
+    p0 = h - codvec[0];                          move16 (); 
+    p1 = h - codvec[1];                          move16 (); 
+    p2 = h - codvec[2];                          move16 (); 
+    p3 = h - codvec[3];                          move16 (); 
+    p4 = h - codvec[4];                          move16 (); 
+    p5 = h - codvec[5];                          move16 (); 
+    p6 = h - codvec[6];                          move16 (); 
+    p7 = h - codvec[7];                          move16 (); 
+    
+    for (i = 0; i < L_CODE; i++)
+    {
+       s = 0;                                   move32 (); 
+       s = L_mac (s, *p0++, _sign[0]);
+       s = L_mac (s, *p1++, _sign[1]);
+       s = L_mac (s, *p2++, _sign[2]);
+       s = L_mac (s, *p3++, _sign[3]);
+       s = L_mac (s, *p4++, _sign[4]);
+       s = L_mac (s, *p5++, _sign[5]);
+       s = L_mac (s, *p6++, _sign[6]);
+       s = L_mac (s, *p7++, _sign[7]);
+       y[i] = round (s);                        move16 (); 
+    }
+}
+
+/*************************************************************************
+ *
+ *  FUNCTION:  compress_code()
+ *
+ *  PURPOSE: compression of three indeces [0..9] to one 10 bit index   
+ *           minimizing the phase shift of a bit error.
+ *
+ *************************************************************************/
+
+
+static Word16 compress10 (
+       Word16 pos_indxA, /* i : signs of 4 pulses (signs only)             */
+       Word16 pos_indxB,  /* i : position index of 8 pulses (pos only)     */
+       Word16 pos_indxC) /* i : position and sign of 8 pulses (compressed) */
+{
+   Word16 indx, ia,ib,ic;
+
+   ia = shr(pos_indxA, 1);
+   ib = extract_l(L_shr(L_mult(shr(pos_indxB, 1), 5), 1));
+   ic = extract_l(L_shr(L_mult(shr(pos_indxC, 1), 25), 1));            
+   indx = shl(add(ia, add(ib, ic)), 3);
+   ia = pos_indxA & 1;                                logic16 ();
+   ib = shl((pos_indxB & 1), 1);                      logic16 ();
+   ic = shl((pos_indxC & 1), 2);                      logic16 ();
+   indx = add(indx , add(ia, add(ib, ic)));  
+   
+   return indx;
+
+}
+
+/*************************************************************************
+ *
+ *  FUNCTION:  compress_code()
+ *
+ *  PURPOSE: compression of the linear codewords to 4+three indeces  
+ *           one bit from each pulse is made robust to errors by 
+ *           minimizing the phase shift of a bit error.
+ *           4 signs (one for each track) 
+ *           i0,i4,i1 => one index (7+3) bits, 3   LSBs more robust
+ *           i2,i6,i5 => one index (7+3) bits, 3   LSBs more robust
+ *           i3,i7    => one index (5+2) bits, 2-3 LSbs more robust
+ *
+ *************************************************************************/
+
+
+static void compress_code (
+    Word16 sign_indx[], /* i : signs of 4 pulses (signs only)             */
+    Word16 pos_indx[],  /* i : position index of 8 pulses (position only) */
+    Word16 indx[])      /* o : position and sign of 8 pulses (compressed) */
+{
+   Word16 i, ia, ib, ic;
+
+   for (i = 0; i < NB_TRACK_MR102; i++)
+   {
+      indx[i] = sign_indx[i];                            move16 (); 
+   }
+    
+    /* First index 
+      indx[NB_TRACK] = (ia/2+(ib/2)*5 +(ic/2)*25)*8 + ia%2 + (ib%2)*2 + (ic%2)*4; */
+   move16 (); 
+   indx[NB_TRACK_MR102] = compress10(pos_indx[0],pos_indx[4],pos_indx[1]);
+
+    /* Second index       
+      indx[NB_TRACK+1] = (ia/2+(ib/2)*5 +(ic/2)*25)*8 + ia%2 + (ib%2)*2 + (ic%2)*4; */
+    
+   move16 (); 
+   indx[NB_TRACK_MR102+1]= compress10(pos_indx[2],pos_indx[6],pos_indx[5]);
+    
+    /*
+      Third index      
+      if ((ib/2)%2 == 1)
+        indx[NB_TRACK+2] = ((((4-ia/2) + (ib/2)*5)*32+12)/25)*4 + ia%2 + (ib%2)*2;
+      else   
+        indx[NB_TRACK+2] = ((((ia/2) +   (ib/2)*5)*32+12)/25)*4 + ia%2 + (ib%2)*2;
+        */
+    
+    ib = shr(pos_indx[7], 1) & 1;                        logic16 ();
+    test ();
+    if (sub(ib, 1) == 0)
+       ia = sub(4, shr(pos_indx[3], 1));
+    else
+       ia = shr(pos_indx[3], 1);
+
+    ib = extract_l(L_shr(L_mult(shr(pos_indx[7], 1), 5), 1));       
+    ib = add(shl(add(ia, ib), 5), 12);
+    ic = shl(mult(ib, 1311), 2);
+    ia = pos_indx[3] & 1;                             logic16 ();
+    ib = shl((pos_indx[7] & 1), 1);                   logic16 ();
+    indx[NB_TRACK_MR102+2] = add(ia, add(ib, ic));
+}
+
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  code_8i40_31bits()
+ *
+ *  PURPOSE:  Searches a 31 bit algebraic codebook containing 8 pulses
+ *            in a frame of 40 samples.
+ *
+ *  DESCRIPTION:
+ *    The code contains 8 nonzero pulses: i0...i7.
+ *    All pulses can have two possible amplitudes: +1 or -1.
+ *    The 40 positions in a subframe are divided into 4 tracks of
+ *    interleaved positions. Each track contains two pulses.
+ *    The pulses can have the following possible positions:
+ *
+ *       i0, i4 :  0, 4, 8,  12, 16, 20, 24, 28, 32, 36
+ *       i1, i5 :  1, 5, 9,  13, 17, 21, 25, 29, 33, 37
+ *       i2, i6 :  2, 6, 10, 14, 18, 22, 26, 30, 34, 38
+ *       i3, i7 :  3, 7, 11, 15, 19, 23, 27, 31, 35, 39
+ *
+ *    Each pair of pulses require 1 bit for their signs. The positions 
+ *    are encoded together 3,3 and 2 resulting in   
+ *    (7+3) + (7+3) + (5+2) bits for their
+ *    positions. This results in a 31 (4 sign and 27 pos) bit codebook.
+ *    The function determines the optimal pulse signs and positions, builds
+ *    the codevector, and computes the filtered codevector.
+ *
+ *************************************************************************/
+
+void code_8i40_31bits (
+   Word16 x[],        /* i : target vector                                  */
+   Word16 cn[],       /* i : residual after long term prediction            */
+   Word16 h[],        /* i : impulse response of weighted synthesis
+                             filter                                         */
+   Word16 cod[],      /* o : algebraic (fixed) codebook excitation          */
+   Word16 y[],        /* o : filtered fixed codebook excitation             */
+   Word16 indx[]      /* o : 7 Word16, index of 8 pulses (signs+positions)  */
+)
+{
+   Word16 ipos[NB_PULSE], pos_max[NB_TRACK_MR102], codvec[NB_PULSE];
+   Word16 dn[L_CODE], sign[L_CODE];
+   Word16 rr[L_CODE][L_CODE];
+   Word16 linear_signs[NB_TRACK_MR102];
+   Word16 linear_codewords[NB_PULSE];
+
+   cor_h_x2 (h, x, dn, 2, NB_TRACK_MR102, STEP_MR102);
+   /* 2 = use GSMEFR scaling */
+
+   set_sign12k2 (dn, cn, sign, pos_max, NB_TRACK_MR102, ipos, STEP_MR102);
+   /* same setsign alg as GSM-EFR new constants though*/
+   
+   cor_h (h, sign, rr);
+   search_10and8i40 (NB_PULSE, STEP_MR102, NB_TRACK_MR102,
+                     dn, rr, ipos, pos_max, codvec);
+   
+   build_code (codvec, sign, cod, h, y, linear_signs, linear_codewords);
+   compress_code (linear_signs, linear_codewords, indx);
+   
+   return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/c8_31pf.h FFMpeg-20050127-new/libavcodec/amr/c8_31pf.h
--- FFMpeg-20050127/libavcodec/amr/c8_31pf.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/c8_31pf.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,47 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : c8_31pf.h
+*      Purpose          : Searches a 31 bit algebraic codebook containing 
+*                       : 8 pulses in a frame of 40 samples.
+*
+********************************************************************************
+*/
+#ifndef c8_31pf_h
+#define c8_31pf_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+void code_8i40_31bits (
+    Word16 x[],        /* i : target vector                                  */
+    Word16 cn[],       /* i : residual after long term prediction            */
+    Word16 h[],        /* i : impulse response of weighted synthesis
+                              filter                                         */
+    Word16 cod[],      /* o : algebraic (fixed) codebook excitation          */
+    Word16 y[],        /* o : filtered fixed codebook excitation             */
+    Word16 indx[]      /* o : 7 Word16, index of 8 pulses (signs+positions)  */
+    );
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/c_g_aver.c FFMpeg-20050127-new/libavcodec/amr/c_g_aver.c
--- FFMpeg-20050127/libavcodec/amr/c_g_aver.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/c_g_aver.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,319 @@
+/*************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : c_g_aver.c
+*      Purpose          : 
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "c_g_aver.h"
+const char c_g_aver_id[] = "@(#)$Id $" c_g_aver_h;
+
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "mode.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+#include "set_zero.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+/*-----------------------------------------------------------------*
+ *   Decoder constant parameters (defined in "cnst.h")             *
+ *-----------------------------------------------------------------*
+ *   L_FRAME       : Frame size.                                   *
+ *   L_SUBFR       : Sub-frame size.                               *
+ *-----------------------------------------------------------------*/
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : Cb_gain_average_init
+*  Purpose     : Allocates and initializes state memory
+*
+**************************************************************************
+*/
+Word16 Cb_gain_average_init (Cb_gain_averageState **state)
+{
+   Cb_gain_averageState* s;
+   
+   if (state == (Cb_gain_averageState **) NULL){
+      fprintf(stderr, "Cb_gain_average_init: invalid parameter\n");
+      return -1;
+   }
+   *state = NULL;
+   
+   /* allocate memory */
+   if ((s= (Cb_gain_averageState *) malloc(sizeof(Cb_gain_averageState))) == NULL){
+     fprintf(stderr, "Cb_gain_average_init: can not malloc state structure\n");
+     return -1;
+   }
+   
+   Cb_gain_average_reset(s);
+   *state = s;
+   
+   return 0;
+}
+
+/*
+**************************************************************************
+*
+*  Function    : Cb_gain_average_reset
+*  Purpose     : Resets state memory
+*
+**************************************************************************
+*/
+Word16 Cb_gain_average_reset (Cb_gain_averageState *state)
+{
+   if (state == (Cb_gain_averageState *) NULL){
+      fprintf(stderr, "Cb_gain_average_reset: invalid parameter\n");
+      return -1;
+   }
+
+   /* Static vectors to zero */
+   Set_zero (state->cbGainHistory, L_CBGAINHIST);
+
+   /* Initialize hangover handling */
+   state->hangVar = 0;
+   state->hangCount= 0;
+   
+   return 0;
+}
+
+/*
+**************************************************************************
+*
+*  Function    : Cb_gain_average_exit
+*  Purpose     : The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void Cb_gain_average_exit (Cb_gain_averageState **state) 
+{
+   if (state == NULL || *state == NULL)
+      return;
+
+   /* deallocate memory */
+   free(*state);
+   *state = NULL;
+   
+   return;
+}
+
+/*
+**************************************************************************
+*
+*  Function    : Cb_gain_average
+*  Purpose     : 
+*  Returns     : The mix cb gains for MR475, MR515, MR59, MR67, MR102; gain_code other modes 
+*
+**************************************************************************
+*/
+Word16 Cb_gain_average (    
+   Cb_gain_averageState *st, /* i/o : State variables for CB gain avergeing   */
+   enum Mode mode,           /* i   : AMR mode                                */
+   Word16 gain_code,         /* i   : CB gain                              Q1 */
+   Word16 lsp[],             /* i   : The LSP for the current frame       Q15 */
+   Word16 lspAver[],         /* i   : The average of LSP for 8 frames     Q15 */
+   Word16 bfi,               /* i   : bad frame indication flag               */
+   Word16 prev_bf,           /* i   : previous bad frame indication flag      */
+   Word16 pdfi,              /* i   : potential degraded bad frame ind flag   */
+   Word16 prev_pdf,          /* i   : prev pot. degraded bad frame ind flag   */
+   Word16 inBackgroundNoise, /* i   : background noise decision               */
+   Word16 voicedHangover     /* i   : # of frames after last voiced frame     */
+   )
+{
+   /*---------------------------------------------------------*
+    * Compute mixed cb gain, used to make cb gain more        *
+    * smooth in background noise for modes 5.15, 5.9 and 6.7  *
+    * states that needs to be updated by all                  *
+    *---------------------------------------------------------*/
+   Word16 i;
+   Word16 cbGainMix, diff, tmp_diff, bgMix, cbGainMean;
+   Word32 L_sum;
+   Word16 tmp[M], tmp1, tmp2, shift1, shift2, shift;
+
+   /* set correct cbGainMix for MR74, MR795, MR122 */
+   cbGainMix = gain_code;             move16 (); 
+   
+   /*-------------------------------------------------------*
+    *   Store list of CB gain needed in the CB gain         *
+    *   averaging                                           *
+    *-------------------------------------------------------*/
+   for (i = 0; i < (L_CBGAINHIST-1); i++)
+   {
+      st->cbGainHistory[i] = st->cbGainHistory[i+1];    move16 ();
+   }
+   st->cbGainHistory[L_CBGAINHIST-1] = gain_code;       move16 ();
+   
+   /* compute lsp difference */
+   for (i = 0; i < M; i++) {
+      tmp1 = abs_s(sub(lspAver[i], lsp[i]));  /* Q15       */
+      shift1 = sub(norm_s(tmp1), 1);          /* Qn        */
+      tmp1 = shl(tmp1, shift1);               /* Q15+Qn    */
+      shift2 = norm_s(lspAver[i]);            /* Qm        */
+      tmp2 = shl(lspAver[i], shift2);         /* Q15+Qm    */
+      tmp[i] = div_s(tmp1, tmp2);             /* Q15+(Q15+Qn)-(Q15+Qm) */
+                                              move16 ();
+      shift = sub(add(2, shift1), shift2);
+      test ();
+      if (shift >= 0)
+      {
+         tmp[i] = shr(tmp[i], shift); move16 ();          /* Q15+Qn-Qm-Qx=Q13 */
+      }
+      else
+      {
+         tmp[i] = shl(tmp[i], negate(shift));  move16 (); /* Q15+Qn-Qm-Qx=Q13 */
+      }
+   }
+   
+   diff = tmp[0];                                   move16 ();
+   for (i = 1; i < M; i++) { 
+      diff = add(diff, tmp[i]);       /* Q13 */
+   }   
+
+   /* Compute hangover */
+   test ();
+   if (sub(diff, 5325) > 0)  /* 0.65 in Q11 */
+   {
+      st->hangVar = add(st->hangVar, 1);
+   }
+   else
+   {
+      st->hangVar = 0;     move16 ();
+   }
+
+   test (); 
+   if (sub(st->hangVar, 10) > 0)
+   {
+      st->hangCount = 0;  /* Speech period, reset hangover variable */ move16 ();
+   }
+
+   /* Compute mix constant (bgMix) */   
+   bgMix = 8192;    /* 1 in Q13 */     move16 ();
+   test (); 
+   if ((sub(mode, MR67) <= 0) || (sub(mode, MR102) == 0))  
+      /* MR475, MR515, MR59, MR67, MR102 */
+   {
+      /* if errors and presumed noise make smoothing probability stronger */
+      test (); test (); test (); test (); test (); test(); test (); test (); test ();
+      if (((((pdfi != 0) && (prev_pdf != 0)) || (bfi != 0) || (prev_bf != 0)) &&
+          (sub(voicedHangover, 1) > 0) && (inBackgroundNoise != 0) && 
+          ((sub(mode, MR475) == 0) ||
+           (sub(mode, MR515) == 0) ||
+           (sub(mode, MR59) == 0)) ))
+      {
+         /* bgMix = min(0.25, max(0.0, diff-0.55)) / 0.25; */
+         tmp_diff = sub(diff, 4506);   /* 0.55 in Q13 */
+
+         /* max(0.0, diff-0.55) */
+         test ();
+         if (tmp_diff > 0)
+         {
+            tmp1 = tmp_diff;       move16 ();
+         }
+         else
+         {
+            tmp1 = 0;              move16 ();
+         }
+
+         /* min(0.25, tmp1) */
+         test ();
+         if (sub(2048, tmp1) < 0)
+         {
+            bgMix = 8192;              move16 ();
+         }
+         else
+         {
+            bgMix = shl(tmp1, 2);
+         }
+      }
+      else
+      {
+         /* bgMix = min(0.25, max(0.0, diff-0.40)) / 0.25; */        
+         tmp_diff = sub(diff, 3277); /* 0.4 in Q13 */
+
+         /* max(0.0, diff-0.40) */
+         test ();
+         if (tmp_diff > 0)
+         {
+            tmp1 = tmp_diff;        move16 ();
+         }
+         else
+         {
+            tmp1 = 0;               move16 ();
+         }
+
+         /* min(0.25, tmp1) */
+         test ();
+         if (sub(2048, tmp1) < 0)
+         {
+            bgMix = 8192;           move16 ();
+         }
+         else
+         {
+            bgMix = shl(tmp1, 2);
+         }
+      }
+
+      test (); test ();
+      if ((sub(st->hangCount, 40) < 0) || (sub(diff, 5325) > 0)) /* 0.65 in Q13 */
+      {
+         bgMix = 8192;  /* disable mix if too short time since */ move16 ();
+      }
+
+      /* Smoothen the cb gain trajectory  */
+      /* smoothing depends on mix constant bgMix */
+      L_sum = L_mult(6554, st->cbGainHistory[2]);     /* 0.2 in Q15; L_sum in Q17 */   
+      for (i = 3; i < L_CBGAINHIST; i++)
+      {
+         L_sum = L_mac(L_sum, 6554, st->cbGainHistory[i]);
+      }
+      cbGainMean = round(L_sum);                      /* Q1 */
+      
+      /* more smoothing in error and bg noise (NB no DFI used  here) */
+      test (); test (); test (); test (); test(); test();
+      if (((bfi != 0) || (prev_bf != 0)) && (inBackgroundNoise != 0) &&
+          ((sub(mode, MR475) == 0) ||
+           (sub(mode, MR515) == 0) ||
+           (sub(mode, MR59) == 0)) )
+      {
+         L_sum = L_mult(4681, st->cbGainHistory[0]);  /* 0.143 in Q15; L_sum in Q17 */     
+         for (i = 1; i < L_CBGAINHIST; i++)
+         {
+            L_sum = L_mac(L_sum, 4681, st->cbGainHistory[i]);
+         }
+         cbGainMean = round(L_sum);                   /* Q1 */
+      }
+      
+      /* cbGainMix = bgMix*cbGainMix + (1-bgMix)*cbGainMean; */
+      L_sum = L_mult(bgMix, cbGainMix);               /* L_sum in Q15 */
+      L_sum = L_mac(L_sum, 8192, cbGainMean);         
+      L_sum = L_msu(L_sum, bgMix, cbGainMean);
+      cbGainMix = round(L_shl(L_sum, 2));             /* Q1 */
+   }
+   
+   st->hangCount = add(st->hangCount, 1);
+   return cbGainMix;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/c_g_aver.h FFMpeg-20050127-new/libavcodec/amr/c_g_aver.h
--- FFMpeg-20050127/libavcodec/amr/c_g_aver.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/c_g_aver.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,113 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : c_g_aver.h
+*      Purpose          : Background noise source charateristic detector (SCD)
+*
+********************************************************************************
+*/
+#ifndef c_g_aver_h
+#define c_g_aver_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#define L_CBGAINHIST 7
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+typedef struct{
+   /* history vector of past synthesis speech energy */
+   Word16 cbGainHistory[L_CBGAINHIST];
+   
+   /* state flags */
+   Word16 hangVar;       /* counter; */
+   Word16 hangCount;     /* counter; */
+
+} Cb_gain_averageState;
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : Cb_gain_average_init
+*  Purpose     : Allocates initializes state memory
+*  Description : Stores pointer to filter status struct in *st. This
+*                pointer has to be passed to Cb_gain_average in each call.
+*  Returns     : 0 on success
+*
+**************************************************************************
+*/
+Word16 Cb_gain_average_init (Cb_gain_averageState **st);
+ 
+/*
+**************************************************************************
+*
+*  Function    : Cb_gain_average_reset
+*  Purpose     : Resets state memory
+*  Returns     : 0 on success
+*
+**************************************************************************
+*/
+Word16 Cb_gain_average_reset (Cb_gain_averageState *st);
+ 
+/*
+**************************************************************************
+*
+*  Function    : Cb_gain_average_exit
+*  Purpose     : The memory used for state memory is freed
+*  Description : Stores NULL in *s
+*  Returns     : void
+*
+**************************************************************************
+*/
+void Cb_gain_average_exit (Cb_gain_averageState **st);
+ 
+/*
+**************************************************************************
+*
+*  Function    : Cb_gain_average
+*  Purpose     : Charaterice synthesis speech and detect background noise
+*  Returns     : background noise decision; 0 = bgn, 1 = no bgn
+*
+**************************************************************************
+*/
+Word16 Cb_gain_average (
+   Cb_gain_averageState *st, /* i/o : State variables for CB gain avergeing   */
+   enum Mode mode,           /* i   : AMR mode                                */
+   Word16 gain_code,         /* i   : CB gain                              Q1 */
+   Word16 lsp[],             /* i   : The LSP for the current frame       Q15 */
+   Word16 lspAver[],         /* i   : The average of LSP for 8 frames     Q15 */
+   Word16 bfi,               /* i   : bad frame indication flag               */
+   Word16 prev_bf,           /* i   : previous bad frame indication flag      */
+   Word16 pdfi,              /* i   : potential degraded bad frame ind flag   */
+   Word16 prev_pdf,          /* i   : prev pot. degraded bad frame ind flag   */
+   Word16 inBackgroundNoise, /* i   : background noise decision               */
+   Word16 voicedHangover     /* i   : # of frames after last voiced frame     */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/calc_cor.c FFMpeg-20050127-new/libavcodec/amr/calc_cor.c
--- FFMpeg-20050127/libavcodec/amr/calc_cor.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/calc_cor.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,80 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : calc_cor.c
+*      Purpose          : Calculate all correlations for prior the OL LTP 
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "calc_cor.h"
+const char calc_cor_id[] = "@(#)$Id $" calc_cor_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION: comp_corr 
+ *
+ *  PURPOSE: Calculate all correlations of scal_sig[] in a given delay
+ *           range.
+ *
+ *  DESCRIPTION:
+ *      The correlation is given by
+ *           cor[t] = <scal_sig[n],scal_sig[n-t]>,  t=lag_min,...,lag_max
+ *      The functions outputs the all correlations 
+ *
+ *************************************************************************/
+void comp_corr ( 
+    Word16 scal_sig[],  /* i   : scaled signal.                          */
+    Word16 L_frame,     /* i   : length of frame to compute pitch        */
+    Word16 lag_max,     /* i   : maximum lag                             */
+    Word16 lag_min,     /* i   : minimum lag                             */
+    Word32 corr[])      /* o   : correlation of selected lag             */
+{
+    Word16 i, j;
+    Word16 *p, *p1;
+    Word32 t0;
+    
+    for (i = lag_max; i >= lag_min; i--)
+    {
+       p = scal_sig;           move16 (); 
+       p1 = &scal_sig[-i];     move16 (); 
+       t0 = 0;                 move32 (); 
+       
+       for (j = 0; j < L_frame; j++, p++, p1++)
+       {
+          t0 = L_mac (t0, *p, *p1);             
+       }
+       corr[-i] = t0;          move32 ();
+    }
+
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/calc_cor.h FFMpeg-20050127-new/libavcodec/amr/calc_cor.h
--- FFMpeg-20050127/libavcodec/amr/calc_cor.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/calc_cor.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,49 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : calc_cor.h
+*      Purpose          : Calculate all correlations for prior the OL LTP 
+*
+********************************************************************************
+*/
+#ifndef calc_cor_h
+#define calc_cor_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION: comp_corr 
+ *
+ *  PURPOSE: Calculate all correlations of scal_sig[] in a given delay
+ *           range.
+ *
+ *  DESCRIPTION:
+ *      The correlation is given by
+ *           cor[t] = <scal_sig[n], scal_sig[n-t]>,  t=lag_min,...,lag_max
+ *      The functions outputs all correlations in the given range 
+ *
+ *************************************************************************/
+void comp_corr (Word16 scal_sig[],  /* i   : scaled signal.                     */
+                Word16 L_frame,     /* i   : length of frame to compute pitch   */
+                Word16 lag_max,     /* i   : maximum lag                        */
+                Word16 lag_min,     /* i   : minimum lag                        */
+                Word32 corr[]       /* o   : correlation of selected lag        */
+                );
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/calc_en.c FFMpeg-20050127-new/libavcodec/amr/calc_en.c
--- FFMpeg-20050127/libavcodec/amr/calc_en.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/calc_en.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,311 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : calc_en.c
+*      Purpose          : (pre-) quantization of pitch gain for MR795
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "calc_en.h"
+const char calc_en_id[] = "@(#)$Id $" calc_en_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "cnst.h"
+#include "log2.h"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ * FUNCTION: calc_unfilt_energies
+ *
+ * PURPOSE:  calculation of several energy coefficients for unfiltered
+ *           excitation signals and the LTP coding gain
+ *
+ *       frac_en[0]*2^exp_en[0] = <res res>   // LP residual energy
+ *       frac_en[1]*2^exp_en[1] = <exc exc>   // LTP residual energy
+ *       frac_en[2]*2^exp_en[2] = <exc code>  // LTP/CB innovation dot product
+ *       frac_en[3]*2^exp_en[3] = <lres lres> // LTP residual energy
+ *                                            // (lres = res - gain_pit*exc)
+ *       ltpg = log2(LP_res_en / LTP_res_en)
+ *
+ *************************************************************************/
+void
+calc_unfilt_energies(
+    Word16 res[],     /* i  : LP residual,                               Q0  */
+    Word16 exc[],     /* i  : LTP excitation (unfiltered),               Q0  */
+    Word16 code[],    /* i  : CB innovation (unfiltered),                Q13 */
+    Word16 gain_pit,  /* i  : pitch gain,                                Q14 */
+    Word16 L_subfr,   /* i  : Subframe length                                */
+
+    Word16 frac_en[], /* o  : energy coefficients (4), fraction part,    Q15 */
+    Word16 exp_en[],  /* o  : energy coefficients (4), exponent part,    Q0  */
+    Word16 *ltpg      /* o  : LTP coding gain (log2()),                  Q13 */
+)
+{
+    Word32 s, L_temp;
+    Word16 i, exp, tmp;
+    Word16 ltp_res_en, pred_gain;
+    Word16 ltpg_exp, ltpg_frac;
+
+    /* Compute residual energy */
+    s = L_mac((Word32) 0, res[0], res[0]);
+    for (i = 1; i < L_subfr; i++)
+        s = L_mac(s, res[i], res[i]);
+
+    /* ResEn := 0 if ResEn < 200.0 (= 400 Q1) */
+    test();
+    if (L_sub (s, 400L) < 0)
+    {
+        frac_en[0] = 0;                      move16 ();
+        exp_en[0] = -15;                     move16 ();
+    }
+    else
+    {
+        exp = norm_l(s);
+        frac_en[0] = extract_h(L_shl(s, exp));   move16 ();
+        exp_en[0] = sub(15, exp);                move16 ();
+    }
+    
+    /* Compute ltp excitation energy */
+    s = L_mac((Word32) 0, exc[0], exc[0]);
+    for (i = 1; i < L_subfr; i++)
+        s = L_mac(s, exc[i], exc[i]);
+
+    exp = norm_l(s);
+    frac_en[1] = extract_h(L_shl(s, exp));   move16 ();
+    exp_en[1] = sub(15, exp);                move16 ();
+
+    /* Compute scalar product <exc[],code[]> */
+    s = L_mac((Word32) 0, exc[0], code[0]);
+    for (i = 1; i < L_subfr; i++)
+        s = L_mac(s, exc[i], code[i]);
+
+    exp = norm_l(s);
+    frac_en[2] = extract_h(L_shl(s, exp));   move16 ();
+    exp_en[2] = sub(16-14, exp);             move16 ();
+
+    /* Compute energy of LTP residual */
+    s = 0L;                                  move32 ();
+    for (i = 0; i < L_subfr; i++)
+    {
+        L_temp = L_mult(exc[i], gain_pit);
+        L_temp = L_shl(L_temp, 1);
+        tmp = sub(res[i], round(L_temp));           /* LTP residual, Q0 */
+        s = L_mac (s, tmp, tmp);
+    }
+
+    exp = norm_l(s);
+    ltp_res_en = extract_h (L_shl (s, exp));
+    exp = sub (15, exp);
+
+    frac_en[3] = ltp_res_en;                 move16 ();
+    exp_en[3] = exp;                         move16 ();
+    
+    /* calculate LTP coding gain, i.e. energy reduction LP res -> LTP res */
+    test (); test ();
+    if (ltp_res_en > 0 && frac_en[0] != 0)
+    {
+        /* gain = ResEn / LTPResEn */
+        pred_gain = div_s (shr (frac_en[0], 1), ltp_res_en);
+        exp = sub (exp, exp_en[0]);
+
+        /* L_temp = ltpGain * 2^(30 + exp) */
+        L_temp = L_deposit_h (pred_gain);
+        /* L_temp = ltpGain * 2^27 */
+        L_temp = L_shr (L_temp, add (exp, 3));
+
+        /* Log2 = log2() + 27 */
+        Log2(L_temp, &ltpg_exp, &ltpg_frac);
+
+        /* ltpg = log2(LtpGain) * 2^13 --> range: +- 4 = +- 12 dB */
+        L_temp = L_Comp (sub (ltpg_exp, 27), ltpg_frac);
+        *ltpg = round (L_shl (L_temp, 13)); /* Q13 */
+    }
+    else
+    {
+        *ltpg = 0;                           move16 ();
+    }
+}
+
+/*************************************************************************
+ *
+ * FUNCTION: calc_filt_energies
+ *
+ * PURPOSE:  calculation of several energy coefficients for filtered
+ *           excitation signals
+ *
+ *     Compute coefficients need for the quantization and the optimum
+ *     codebook gain gcu (for MR475 only).
+ *
+ *      coeff[0] =    y1 y1
+ *      coeff[1] = -2 xn y1
+ *      coeff[2] =    y2 y2
+ *      coeff[3] = -2 xn y2
+ *      coeff[4] =  2 y1 y2
+ *
+ *
+ *      gcu = <xn2, y2> / <y2, y2> (0 if <xn2, y2> <= 0)
+ *
+ *     Product <y1 y1> and <xn y1> have been computed in G_pitch() and
+ *     are in vector g_coeff[].
+ *
+ *************************************************************************/
+void
+calc_filt_energies(
+    enum Mode mode,     /* i  : coder mode                                   */
+    Word16 xn[],        /* i  : LTP target vector,                       Q0  */
+    Word16 xn2[],       /* i  : CB target vector,                        Q0  */
+    Word16 y1[],        /* i  : Adaptive codebook,                       Q0  */
+    Word16 Y2[],        /* i  : Filtered innovative vector,              Q12 */
+    Word16 g_coeff[],   /* i  : Correlations <xn y1> <y1 y1>                 */
+                        /*      computed in G_pitch()                        */
+
+    Word16 frac_coeff[],/* o  : energy coefficients (5), fraction part,  Q15 */
+    Word16 exp_coeff[], /* o  : energy coefficients (5), exponent part,  Q0  */
+    Word16 *cod_gain_frac,/* o: optimum codebook gain (fraction part),   Q15 */
+    Word16 *cod_gain_exp  /* o: optimum codebook gain (exponent part),   Q0  */
+)
+{
+    Word32 s, ener_init;
+    Word16 i, exp, frac;
+    Word16 y2[L_SUBFR];
+
+    if (test(), sub(mode, MR795) == 0 || sub(mode, MR475) == 0)
+    {
+        ener_init = 0L; move32 ();
+    }
+    else
+    {
+        ener_init = 1L; move32 ();
+    }
+    
+    for (i = 0; i < L_SUBFR; i++) {
+        y2[i] = shr(Y2[i], 3);         move16 ();
+    }
+
+    frac_coeff[0] = g_coeff[0];          move16 ();
+    exp_coeff[0] = g_coeff[1];           move16 ();
+    frac_coeff[1] = negate(g_coeff[2]);  move16 ();   /* coeff[1] = -2 xn y1 */
+    exp_coeff[1] = add(g_coeff[3], 1);   move16 ();
+
+
+    /* Compute scalar product <y2[],y2[]> */
+
+    s = L_mac(ener_init, y2[0], y2[0]);
+    for (i = 1; i < L_SUBFR; i++)
+        s = L_mac(s, y2[i], y2[i]);
+
+    exp = norm_l(s);
+    frac_coeff[2] = extract_h(L_shl(s, exp)); move16 ();
+    exp_coeff[2] = sub(15 - 18, exp);    move16();
+
+    /* Compute scalar product -2*<xn[],y2[]> */
+
+    s = L_mac(ener_init, xn[0], y2[0]);
+    for (i = 1; i < L_SUBFR; i++)
+        s = L_mac(s, xn[i], y2[i]);
+
+    exp = norm_l(s);
+    frac_coeff[3] = negate(extract_h(L_shl(s, exp))); move16 ();
+    exp_coeff[3] = sub(15 - 9 + 1, exp);         move16 ();
+
+
+    /* Compute scalar product 2*<y1[],y2[]> */
+
+    s = L_mac(ener_init, y1[0], y2[0]);
+    for (i = 1; i < L_SUBFR; i++)
+        s = L_mac(s, y1[i], y2[i]);
+
+    exp = norm_l(s);
+    frac_coeff[4] = extract_h(L_shl(s, exp)); move16 ();
+    exp_coeff[4] = sub(15 - 9 + 1, exp);  move16();
+
+    if (test(), test (), sub(mode, MR475) == 0 || sub(mode, MR795) == 0)
+    {
+        /* Compute scalar product <xn2[],y2[]> */
+
+        s = L_mac(ener_init, xn2[0], y2[0]);
+        for (i = 1; i < L_SUBFR; i++)
+            s = L_mac(s, xn2[i], y2[i]);
+        
+        exp = norm_l(s);
+        frac = extract_h(L_shl(s, exp));
+        exp = sub(15 - 9, exp);
+
+        
+        if (test (), frac <= 0)
+        {
+            *cod_gain_frac = 0; move16 ();
+            *cod_gain_exp = 0;  move16 ();
+        }
+        else
+        {
+            /*
+              gcu = <xn2, y2> / c[2]
+                  = (frac>>1)/frac[2]             * 2^(exp+1-exp[2])
+                  = div_s(frac>>1, frac[2])*2^-15 * 2^(exp+1-exp[2])
+                  = div_s * 2^(exp-exp[2]-14)
+             */  
+            *cod_gain_frac = div_s (shr (frac,1), frac_coeff[2]); move16 ();
+            *cod_gain_exp = sub (sub (exp, exp_coeff[2]), 14);    move16 ();
+
+        }
+    }
+}
+
+/*************************************************************************
+ *
+ * FUNCTION: calc_target_energy
+ *
+ * PURPOSE:  calculation of target energy
+ *
+ *      en = <xn, xn>
+ *
+ *************************************************************************/
+void
+calc_target_energy(
+    Word16 xn[],     /* i: LTP target vector,                       Q0  */
+    Word16 *en_exp,  /* o: optimum codebook gain (exponent part),   Q0  */
+    Word16 *en_frac  /* o: optimum codebook gain (fraction part),   Q15 */
+)
+{
+    Word32 s;
+    Word16 i, exp;
+
+    /* Compute scalar product <xn[], xn[]> */
+    s = L_mac(0L, xn[0], xn[0]);
+    for (i = 1; i < L_SUBFR; i++)
+        s = L_mac(s, xn[i], xn[i]);
+
+    /* s = SUM 2*xn(i) * xn(i) = <xn xn> * 2 */
+    exp = norm_l(s);
+    *en_frac = extract_h(L_shl(s, exp));
+    *en_exp = sub(16, exp);    move16();
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/calc_en.h FFMpeg-20050127-new/libavcodec/amr/calc_en.h
--- FFMpeg-20050127/libavcodec/amr/calc_en.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/calc_en.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,114 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : calc_en.h
+*      Purpose          : calculation of energy coefficients for quantizers
+*
+********************************************************************************
+*/
+#ifndef calc_en_h
+#define calc_en_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ * FUNCTION: calc_unfilt_energies
+ *
+ * PURPOSE:  calculation of several energy coefficients for unfiltered
+ *           excitation signals and the LTP coding gain
+ *
+ *       frac_en[0]*2^exp_en[0] = <res res>   // LP residual energy
+ *       frac_en[1]*2^exp_en[1] = <exc exc>   // LTP residual energy
+ *       frac_en[2]*2^exp_en[2] = <exc code>  // LTP/CB innovation dot product
+ *       frac_en[3]*2^exp_en[3] = <lres lres> // LTP residual energy
+ *                                            // (lres = res - gain_pit*exc)
+ *       ltpg = log2(LP_res_en / LTP_res_en)
+ *
+ *************************************************************************/
+void
+calc_unfilt_energies(
+    Word16 res[],     /* i  : LP residual,                               Q0  */
+    Word16 exc[],     /* i  : LTP excitation (unfiltered),               Q0  */
+    Word16 code[],    /* i  : CB innovation (unfiltered),                Q13 */
+    Word16 gain_pit,  /* i  : pitch gain,                                Q14 */
+    Word16 L_subfr,   /* i  : Subframe length                                */
+
+    Word16 frac_en[], /* o  : energy coefficients (3), fraction part,    Q15 */
+    Word16 exp_en[],  /* o  : energy coefficients (3), exponent part,    Q0  */
+    Word16 *ltpg      /* o  : LTP coding gain (log2()),                  Q13 */
+);
+
+/*************************************************************************
+ *
+ * FUNCTION: calc_filt_energies
+ *
+ * PURPOSE:  calculation of several energy coefficients for filtered
+ *           excitation signals
+ *
+ *     Compute coefficients need for the quantization and the optimum
+ *     codebook gain gcu (for MR475 only).
+ *
+ *      coeff[0] =    y1 y1
+ *      coeff[1] = -2 xn y1
+ *      coeff[2] =    y2 y2
+ *      coeff[3] = -2 xn y2
+ *      coeff[4] =  2 y1 y2
+ *
+ *
+ *      gcu = <xn2, y2> / <y2, y2> (0 if <xn2, y2> <= 0)
+ *
+ *     Product <y1 y1> and <xn y1> have been computed in G_pitch() and
+ *     are in vector g_coeff[].
+ *
+ *************************************************************************/
+void
+calc_filt_energies(
+    enum Mode mode,     /* i  : coder mode                                   */
+    Word16 xn[],        /* i  : LTP target vector,                       Q0  */
+    Word16 xn2[],       /* i  : CB target vector,                        Q0  */
+    Word16 y1[],        /* i  : Adaptive codebook,                       Q0  */
+    Word16 Y2[],        /* i  : Filtered innovative vector,              Q12 */
+    Word16 g_coeff[],   /* i  : Correlations <xn y1> <y1 y1>                 */
+                        /*      computed in G_pitch()                        */
+
+    Word16 frac_coeff[],/* o  : energy coefficients (5), fraction part,  Q15 */
+    Word16 exp_coeff[], /* o  : energy coefficients (5), exponent part,  Q0  */
+    Word16 *cod_gain_frac,/* o: optimum codebook gain (fraction part),   Q15 */
+    Word16 *cod_gain_exp  /* o: optimum codebook gain (exponent part),   Q0  */
+);
+
+/*************************************************************************
+ *
+ * FUNCTION: calc_target_energy
+ *
+ * PURPOSE:  calculation of target energy
+ *
+ *      en = <xn, xn>
+ *
+ *************************************************************************/
+void
+calc_target_energy(
+    Word16 xn[],     /* i: LTP target vector,                       Q0  */
+    Word16 *en_exp,  /* o: optimum codebook gain (exponent part),   Q0  */
+    Word16 *en_frac  /* o: optimum codebook gain (fraction part),   Q15 */
+);
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/cbsearch.c FFMpeg-20050127-new/libavcodec/amr/cbsearch.c
--- FFMpeg-20050127/libavcodec/amr/cbsearch.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/cbsearch.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,158 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : cbsearch.c
+*      Purpose          : Inovative codebook search (find index and gain)
+*
+*****************************************************************************
+*/
+ 
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "cbsearch.h"
+const char cbsearch_id[] = "@(#)$Id $" cbsearch_h;
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "c2_9pf.h"
+#include "c2_11pf.h"
+#include "c3_14pf.h"
+#include "c4_17pf.h"
+#include "c8_31pf.h"
+#include "c1035pf.h"
+#include "mode.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+int cbsearch(Word16 x[],    /* i : target vector, Q0                       */
+             Word16 h[],    /* i : impulse response of weighted synthesis  */
+                            /*     filter h[-L_subfr..-1] must be set to   */
+                            /*     zero. Q12                               */
+             Word16 T0,     /* i : Pitch lag                               */
+             Word16 pitch_sharp, /* i : Last quantized pitch gain, Q14     */
+             Word16 gain_pit,    /* i : Pitch gain, Q14                    */ 
+             Word16 res2[], /* i : Long term prediction residual, Q0       */
+             Word16 code[], /* o : Innovative codebook, Q13                */
+             Word16 y[],    /* o : filtered fixed codebook excitation, Q12 */
+             Word16 **anap, /* o : Signs of the pulses                     */
+             enum Mode mode,/* i : coder mode                              */
+             Word16 subNr)  /* i : subframe number                         */
+             {
+   Word16 index;
+   Word16 i, temp, pit_sharpTmp;
+   
+   /* For MR74, the pre and post CB pitch sharpening is included in the
+    * codebook search routine, while for MR122 is it not.
+    */
+   
+   test (); test (); 
+   if ((sub (mode, MR475) == 0) || (sub (mode, MR515) == 0))
+   {   /* MR475, MR515 */ move16 ();
+      *(*anap)++ = code_2i40_9bits(subNr, x, h, T0, pitch_sharp,
+                                   code, y, &index);
+      *(*anap)++ = index;    /* sign index */                  move16 ();
+   }
+   else if (sub (mode, MR59) == 0)
+   {   /* MR59 */
+      test (); move16 ();
+      *(*anap)++ = code_2i40_11bits(x, h, T0, pitch_sharp, code, y, &index);
+      *(*anap)++ = index;    /* sign index */                  move16 ();
+   }
+   else if (sub (mode, MR67) == 0)
+   {   /* MR67 */
+      test (); test (); move16 ();
+      *(*anap)++ = code_3i40_14bits(x, h, T0, pitch_sharp, code, y, &index);
+      *(*anap)++ = index;    /* sign index */                  move16 ();
+   }
+   else if (sub (mode, MR74) == 0 || sub (mode, MR795) == 0)
+   {   /* MR74, MR795 */
+      test (); test (); test (); move16 ();
+      *(*anap)++ = code_4i40_17bits(x, h, T0, pitch_sharp, code, y, &index);
+      *(*anap)++ = index;    /* sign index */                  move16 ();
+   }
+   else if (sub (mode, MR102) == 0)
+   {   /* MR102 */
+      test (); test (); test ();
+      /*-------------------------------------------------------------*
+       * - include pitch contribution into impulse resp. h1[]        *
+       *-------------------------------------------------------------*/
+      /* pit_sharpTmp = pit_sharp;                     */
+      /* if (pit_sharpTmp > 1.0) pit_sharpTmp = 1.0;   */
+      pit_sharpTmp = shl (pitch_sharp, 1);
+      for (i = T0; i < L_SUBFR; i++)
+      {
+         temp = mult(h[i - T0], pit_sharpTmp);
+         h[i] = add(h[i], temp);                               move16 ();
+      }
+
+      /*--------------------------------------------------------------*
+       * - Innovative codebook search (find index and gain)           *
+       *--------------------------------------------------------------*/
+      code_8i40_31bits (x, res2, h, code, y, *anap);
+      *anap += 7;                                              add(0,0);
+
+      /*-------------------------------------------------------*
+       * - Add the pitch contribution to code[].               *
+       *-------------------------------------------------------*/ 
+      for (i = T0; i < L_SUBFR; i++)
+      {
+         temp = mult (code[i - T0], pit_sharpTmp);
+         code[i] = add (code[i], temp);                        move16 ();
+      }
+   }
+   else
+   {  /* MR122 */
+      /*-------------------------------------------------------------*
+       * - include pitch contribution into impulse resp. h1[]        *
+       *-------------------------------------------------------------*/
+      test (); test (); test ();
+      
+      /* pit_sharpTmp = gain_pit;                      */
+      /* if (pit_sharpTmp > 1.0) pit_sharpTmp = 1.0;   */
+      pit_sharpTmp = shl (gain_pit, 1);
+      
+      for (i = T0; i < L_SUBFR; i++)
+      {
+         temp = mult(h[i - T0], pit_sharpTmp);
+         h[i] = add(h[i], temp);                               move16 ();
+      }
+      /*--------------------------------------------------------------*
+       * - Innovative codebook search (find index and gain)           *
+       *--------------------------------------------------------------*/
+      
+      code_10i40_35bits (x, res2, h, code, y, *anap);
+      *anap += 10;      	                                   add(0,0);
+      
+      /*-------------------------------------------------------*
+       * - Add the pitch contribution to code[].               *
+       *-------------------------------------------------------*/ 
+      for (i = T0; i < L_SUBFR; i++)
+      {
+         temp = mult (code[i - T0], pit_sharpTmp);
+         code[i] = add (code[i], temp);                        move16 ();
+      }     
+   }
+
+   return 0;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/cbsearch.h FFMpeg-20050127-new/libavcodec/amr/cbsearch.h
--- FFMpeg-20050127/libavcodec/amr/cbsearch.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/cbsearch.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,58 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : cbsearch.h
+*      Purpose          : Inovative codebook search (find index and gain)
+*
+*****************************************************************************
+*/
+#ifndef cbsearch_h
+#define cbsearch_h "$Id $"
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES                               
+*****************************************************************************
+*/                                                                    
+#include "typedef.h"                                                  
+#include "mode.h"                                                     
+                                                                      
+/*                                                                    
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES                  
+*****************************************************************************
+*/                                                                    
+                                                                      
+/*                                                                    
+*****************************************************************************
+*                         DEFINITION OF DATA TYPES                    
+*****************************************************************************
+*/
+ 
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+int cbsearch(Word16 x[],     /* i : target vector, Q0                      */
+             Word16 h[],     /* i : impulse response of weighted synthesis */
+                             /*     filter h[-L_subfr..-1] must be set to  */
+                             /*    zero. Q12                               */
+             Word16 T0,      /* i : Pitch lag                              */
+             Word16 pitch_sharp, /* i : Last quantized pitch gain, Q14     */
+             Word16 gain_pit,/* i : Pitch gain, Q14                        */ 
+             Word16 res2[],  /* i : Long term prediction residual, Q0      */
+             Word16 code[],  /* o : Innovative codebook, Q13               */
+             Word16 y[],     /* o : filtered fixed codebook excitation, Q12 */
+             Word16 **anap,  /* o : Signs of the pulses                    */
+             enum Mode mode, /* i : coder mode                             */
+             Word16 subNr)   /* i : subframe number                        */
+;
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/cl_ltp.c FFMpeg-20050127-new/libavcodec/amr/cl_ltp.c
--- FFMpeg-20050127/libavcodec/amr/cl_ltp.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/cl_ltp.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,247 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : cl_ltp.c
+*
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "cl_ltp.h"
+const char cl_ltp_id[] = "@(#)$Id $" cl_ltp_h;
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "oper_32b.h"
+#include "cnst.h"
+#include "convolve.h"
+#include "g_pitch.h"
+#include "pred_lt.h"
+#include "pitch_fr.h"
+#include "enc_lag3.h"
+#include "enc_lag6.h"
+#include "q_gain_p.h"
+#include "ton_stab.h"
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+/*************************************************************************
+*
+*  Function:   cl_ltp_init
+*  Purpose:    Allocates state memory and initializes state memory
+*
+**************************************************************************
+*/
+int cl_ltp_init (clLtpState **state)
+{
+    clLtpState* s;
+    
+    if (state == (clLtpState **) NULL){
+        fprintf(stderr, "cl_ltp_init: invalid parameter\n");
+        return -1;
+    }
+    *state = NULL;
+    
+    /* allocate memory */
+    if ((s= (clLtpState *) malloc(sizeof(clLtpState))) == NULL){
+        fprintf(stderr, "cl_ltp_init: can not malloc state structure\n");
+        return -1;
+  }
+    
+    /* init the sub state */
+    if (Pitch_fr_init(&s->pitchSt)) {
+        cl_ltp_exit(&s);
+        return -1;
+    }
+    
+    cl_ltp_reset(s);
+    
+    *state = s;
+    
+    return 0;
+}
+ 
+/*************************************************************************
+*
+*  Function:   cl_ltp_reset
+*  Purpose:    Initializes state memory to zero
+*
+**************************************************************************
+*/
+int cl_ltp_reset (clLtpState *state)
+{
+    if (state == (clLtpState *) NULL){
+        fprintf(stderr, "cl_ltp_reset: invalid parameter\n");
+        return -1;
+    }
+    
+    /* Reset pitch search states */
+    Pitch_fr_reset (state->pitchSt);
+    
+    return 0;
+}
+
+/*************************************************************************
+*
+*  Function:   cl_ltp_exit
+*  Purpose:    The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void cl_ltp_exit (clLtpState **state)
+{
+    if (state == NULL || *state == NULL)
+        return;
+
+    /* dealloc members */
+    Pitch_fr_exit(&(*state)->pitchSt);
+    
+    /* deallocate memory */
+    free(*state);
+    *state = NULL;
+    
+    return;
+}
+
+/*************************************************************************
+*
+*  Function:   cl_ltp
+*  Purpose:    closed-loop fractional pitch search
+*
+**************************************************************************
+*/
+int cl_ltp (
+    clLtpState *clSt,    /* i/o : State struct                              */
+    tonStabState *tonSt, /* i/o : State struct                              */
+    enum Mode mode,      /* i   : coder mode                                */
+    Word16 frameOffset,  /* i   : Offset to subframe                        */
+    Word16 T_op[],       /* i   : Open loop pitch lags                      */
+    Word16 *h1,          /* i   : Impulse response vector               Q12 */
+    Word16 *exc,         /* i/o : Excitation vector                      Q0 */
+    Word16 res2[],       /* i/o : Long term prediction residual          Q0 */
+    Word16 xn[],         /* i   : Target vector for pitch search         Q0 */
+    Word16 lsp_flag,     /* i   : LSP resonance flag                        */
+    Word16 xn2[],        /* o   : Target vector for codebook search      Q0 */
+    Word16 y1[],         /* o   : Filtered adaptive excitation           Q0 */
+    Word16 *T0,          /* o   : Pitch delay (integer part)                */
+    Word16 *T0_frac,     /* o   : Pitch delay (fractional part)             */
+    Word16 *gain_pit,    /* o   : Pitch gain                            Q14 */
+    Word16 g_coeff[],    /* o   : Correlations between xn, y1, & y2         */
+    Word16 **anap,       /* o   : Analysis parameters                       */
+    Word16 *gp_limit     /* o   : pitch gain limit                          */
+)
+{
+    Word16 i;
+    Word16 index;
+    Word32 L_temp;     /* temporarily variable */
+    Word16 resu3;      /* flag for upsample resolution */
+    Word16 gpc_flag;
+    
+   /*----------------------------------------------------------------------*
+    *                 Closed-loop fractional pitch search                  *
+    *----------------------------------------------------------------------*/
+   *T0 = Pitch_fr(clSt->pitchSt,
+                  mode, T_op, exc, xn, h1, 
+                  L_SUBFR, frameOffset,
+                  T0_frac, &resu3, &index); move16 ();
+   
+   *(*anap)++ = index;                              move16 ();
+   
+   /*-----------------------------------------------------------------*
+    *   - find unity gain pitch excitation (adapitve codebook entry)  *
+    *     with fractional interpolation.                              *
+    *   - find filtered pitch exc. y1[]=exc[] convolve with h1[])     *
+    *   - compute pitch gain and limit between 0 and 1.2              *
+    *   - update target vector for codebook search                    *
+    *   - find LTP residual.                                          *
+    *-----------------------------------------------------------------*/
+   
+   Pred_lt_3or6(exc, *T0, *T0_frac, L_SUBFR, resu3);
+   
+   Convolve(exc, h1, y1, L_SUBFR);
+   
+   /* gain_pit is Q14 for all modes */
+   *gain_pit = G_pitch(mode, xn, y1, g_coeff, L_SUBFR); move16 ();
+
+   
+   /* check if the pitch gain should be limit due to resonance in LPC filter */
+   gpc_flag = 0;                                        move16 ();
+   *gp_limit = MAX_16;                                  move16 ();
+   test (); test ();
+   if ((lsp_flag != 0) &&
+       (sub(*gain_pit, GP_CLIP) > 0))
+   {
+       gpc_flag = check_gp_clipping(tonSt, *gain_pit);  move16 ();
+   }
+
+   /* special for the MR475, MR515 mode; limit the gain to 0.85 to */
+   /* cope with bit errors in the decoder in a better way.         */
+   test (); test (); 
+   if ((sub (mode, MR475) == 0) || (sub (mode, MR515) == 0)) {
+      test ();
+      if ( sub (*gain_pit, 13926) > 0) {
+         *gain_pit = 13926;   /* 0.85 in Q14 */    move16 ();
+      }
+
+      test ();
+      if (gpc_flag != 0) {
+          *gp_limit = GP_CLIP;                     move16 ();
+      }
+   }
+   else
+   {
+       test ();
+       if (gpc_flag != 0)
+       {
+           *gp_limit = GP_CLIP;                    move16 ();
+           *gain_pit = GP_CLIP;                    move16 ();
+       }           
+       /* For MR122, gain_pit is quantized here and not in gainQuant */
+       if (test (), sub(mode, MR122)==0)
+       {
+           *(*anap)++ = q_gain_pitch(MR122, *gp_limit, gain_pit,
+                                     NULL, NULL);
+                                                   move16 ();
+       }
+   }
+
+   /* update target vector und evaluate LTP residual */
+   for (i = 0; i < L_SUBFR; i++) {
+       L_temp = L_mult(y1[i], *gain_pit);
+       L_temp = L_shl(L_temp, 1);
+       xn2[i] = sub(xn[i], extract_h(L_temp));     move16 ();
+      
+       L_temp = L_mult(exc[i], *gain_pit);
+       L_temp = L_shl(L_temp, 1);
+       res2[i] = sub(res2[i], extract_h(L_temp));  move16 ();
+   }
+   
+   return 0;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/cl_ltp.h FFMpeg-20050127-new/libavcodec/amr/cl_ltp.h
--- FFMpeg-20050127/libavcodec/amr/cl_ltp.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/cl_ltp.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,87 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : cl_ltp.h
+*      Purpose          : Closed-loop fractional pitch search
+*
+********************************************************************************
+*/
+#ifndef cl_ltp_h
+#define cl_ltp_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+#include "pitch_fr.h"
+#include "ton_stab.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+
+/* state variable */
+typedef struct {
+    Pitch_frState *pitchSt;
+} clLtpState;
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+int cl_ltp_init (clLtpState **st);
+/* initialize one instance of the pre processing state.
+   Stores pointer to filter status struct in *st. This pointer has to
+   be passed to cl_ltp in each call.
+   returns 0 on success
+ */
+ 
+int cl_ltp_reset (clLtpState *st);
+/* reset of pre processing state (i.e. set state memory to zero)
+   returns 0 on success
+ */
+void cl_ltp_exit (clLtpState **st);
+/* de-initialize pre processing state (i.e. free status struct)
+   stores NULL in *st
+ */
+
+int cl_ltp(
+    clLtpState *clSt,    /* i/o : State struct                              */
+    tonStabState *tonSt, /* i/o : State struct                              */
+    enum Mode mode,      /* i   : coder mode                                */
+    Word16 frameOffset,  /* i   : Offset to subframe                        */
+    Word16 T_op[],       /* i   : Open loop pitch lags                      */
+    Word16 *h1,          /* i   : Impulse response vector               Q12 */
+    Word16 *exc,         /* i/o : Excitation vector                      Q0 */
+    Word16 res2[],       /* i/o : Long term prediction residual          Q0 */
+    Word16 xn[],         /* i   : Target vector for pitch search         Q0 */
+    Word16 lsp_flag,     /* i   : LSP resonance flag                        */
+    Word16 xn2[],        /* o   : Target vector for codebook search      Q0 */
+    Word16 y1[],         /* o   : Filtered adaptive excitation           Q0 */
+    Word16 *T0,          /* o   : Pitch delay (integer part)                */
+    Word16 *T0_frac,     /* o   : Pitch delay (fractional part)             */
+    Word16 *gain_pit,    /* o   : Pitch gain                            Q14 */
+    Word16 g_coeff[],    /* o   : Correlations between xn, y1, & y2         */
+    Word16 **anap,       /* o   : Analysis parameters                       */
+    Word16 *gp_limit     /* o   : pitch gain limit                          */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/cnst.h FFMpeg-20050127-new/libavcodec/amr/cnst.h
--- FFMpeg-20050127/libavcodec/amr/cnst.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/cnst.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,58 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : cnst.h
+*      Purpose          : Speech codec constant parameters
+*                       :  (encoder, decoder, and postfilter)
+*
+*****************************************************************************
+*/
+#ifndef cnst_h
+#define cnst_h "$Id $"
+
+#define L_TOTAL      320       /* Total size of speech buffer.             */
+#define L_WINDOW     240       /* Window size in LP analysis               */
+#define L_FRAME      160       /* Frame size                               */
+#define L_FRAME_BY2  80        /* Frame size divided by 2                  */
+#define L_SUBFR      40        /* Subframe size                            */
+#define L_CODE       40        /* codevector length                        */
+#define NB_TRACK     5         /* number of tracks                         */
+#define STEP         5         /* codebook step size                       */
+#define NB_TRACK_MR102  4      /* number of tracks mode mr102              */
+#define STEP_MR102      4      /* codebook step size mode mr102            */
+#define M            10        /* Order of LP filter                       */
+#define MP1          (M+1)     /* Order of LP filter + 1                   */
+#define LSF_GAP      205       /* Minimum distance between LSF after quan-
+                                  tization; 50 Hz = 205                    */
+#define LSP_PRED_FAC_MR122 21299 /* MR122 LSP prediction factor (0.65 Q15) */
+#define AZ_SIZE       (4*M+4)  /* Size of array of LP filters in 4 subfr.s */
+#define PIT_MIN_MR122 18       /* Minimum pitch lag (MR122 mode)           */
+#define PIT_MIN       20       /* Minimum pitch lag (all other modes)      */
+#define PIT_MAX       143      /* Maximum pitch lag                        */
+#define L_INTERPOL    (10+1)   /* Length of filter for interpolation       */
+#define L_INTER_SRCH  4        /* Length of filter for CL LTP search
+                                  interpolation                            */
+        
+#define MU       26214         /* Factor for tilt compensation filter 0.8  */
+#define AGC_FAC  29491         /* Factor for automatic gain control 0.9    */
+        
+#define L_NEXT       40        /* Overhead in LP analysis                  */
+#define SHARPMAX  13017        /* Maximum value of pitch sharpening        */
+#define SHARPMIN  0            /* Minimum value of pitch sharpening        */
+                                                                          
+                                                                          
+#define MAX_PRM_SIZE    57     /* max. num. of params                      */
+#define MAX_SERIAL_SIZE 244    /* max. num. of serial bits                 */
+                                                                          
+#define GP_CLIP   15565        /* Pitch gain clipping = 0.95               */
+#define N_FRAME   7            /* old pitch gains in average calculation   */
+
+#define EHF_MASK 0x0008        /* encoder homing frame pattern             */
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/cnst_vad.h FFMpeg-20050127-new/libavcodec/amr/cnst_vad.h
--- FFMpeg-20050127/libavcodec/amr/cnst_vad.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/cnst_vad.h	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,105 @@
+/*
+********************************************************************************
+**-------------------------------------------------------------------------**
+**                                                                         **
+**     GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001       **
+**                               R99   Version 3.3.0                       **
+**                               REL-4 Version 4.1.0                       **
+**                                                                         **
+**-------------------------------------------------------------------------**
+********************************************************************************
+*
+*      File             : cnst_vad.h
+*      Purpose          : Constants and definitions for VAD
+*
+********************************************************************************
+*/
+#ifndef cnst_vad_h
+#define cnst_vad_h "$Id $"
+
+#define FRAME_LEN 160    /* Length (samples) of the input frame          */
+#define COMPLEN 9        /* Number of sub-bands used by VAD              */
+#define INV_COMPLEN 3641 /* 1.0/COMPLEN*2^15                             */
+#define LOOKAHEAD 40     /* length of the lookahead used by speech coder */
+
+#define UNITY 512        /* Scaling used with SNR calculation            */
+#define UNIRSHFT 6       /* = log2(MAX_16/UNITY)                         */
+
+#define TONE_THR (Word16)(0.65*MAX_16) /* Threshold for tone detection   */
+
+/* Constants for background spectrum update */
+#define ALPHA_UP1   (Word16)((1.0 - 0.95)*MAX_16)  /* Normal update, upwards:   */
+#define ALPHA_DOWN1 (Word16)((1.0 - 0.936)*MAX_16) /* Normal update, downwards  */
+#define ALPHA_UP2   (Word16)((1.0 - 0.985)*MAX_16) /* Forced update, upwards    */
+#define ALPHA_DOWN2 (Word16)((1.0 - 0.943)*MAX_16) /* Forced update, downwards  */
+#define ALPHA3      (Word16)((1.0 - 0.95)*MAX_16)  /* Update downwards          */
+#define ALPHA4      (Word16)((1.0 - 0.9)*MAX_16)   /* For stationary estimation */
+#define ALPHA5      (Word16)((1.0 - 0.5)*MAX_16)   /* For stationary estimation */
+
+/* Constants for VAD threshold */
+#define VAD_THR_HIGH 1260 /* Highest threshold                 */
+#define VAD_THR_LOW  720  /* Lowest threshold                  */
+#define VAD_P1 0          /* Noise level for highest threshold */
+#define VAD_P2 6300       /* Noise level for lowest threshold  */
+#define VAD_SLOPE (Word16)(MAX_16*(float)(VAD_THR_LOW-VAD_THR_HIGH)/(float)(VAD_P2-VAD_P1))
+
+/* Parameters for background spectrum recovery function */
+#define STAT_COUNT 20         /* threshold of stationary detection counter         */
+#define STAT_COUNT_BY_2 10    /* threshold of stationary detection counter         */
+#define CAD_MIN_STAT_COUNT 5  /* threshold of stationary detection counter         */
+
+#define STAT_THR_LEVEL 184    /* Threshold level for stationarity detection        */
+#define STAT_THR 1000         /* Threshold for stationarity detection              */
+
+/* Limits for background noise estimate */
+#define NOISE_MIN 40          /* minimum */
+#define NOISE_MAX 16000       /* maximum */
+#define NOISE_INIT 150        /* initial */
+
+/* Constants for VAD hangover addition */
+#define HANG_NOISE_THR 100
+#define BURST_LEN_HIGH_NOISE 4
+#define HANG_LEN_HIGH_NOISE 7
+#define BURST_LEN_LOW_NOISE 5
+#define HANG_LEN_LOW_NOISE 4
+
+/* Thresholds for signal power */
+#define VAD_POW_LOW (Word32)15000     /* If input power is lower,                    */
+                                      /*     VAD is set to 0                         */
+#define POW_PITCH_THR (Word32)343040  /* If input power is lower, pitch              */
+                                      /*     detection is ignored                    */
+
+#define POW_COMPLEX_THR (Word32)15000 /* If input power is lower, complex            */
+                                      /* flags  value for previous frame  is un-set  */
+ 
+
+/* Constants for the filter bank */
+#define LEVEL_SHIFT 0      /* scaling                                  */
+#define COEFF3   13363     /* coefficient for the 3rd order filter     */
+#define COEFF5_1 21955     /* 1st coefficient the for 5th order filter */
+#define COEFF5_2 6390      /* 2nd coefficient the for 5th order filter */
+
+/* Constants for pitch detection */
+#define LTHRESH 4
+#define NTHRESH 4
+
+/* Constants for complex signal VAD  */
+#define CVAD_THRESH_ADAPT_HIGH  (Word16)(0.6 * MAX_16) /* threshold for adapt stopping high    */
+#define CVAD_THRESH_ADAPT_LOW  (Word16)(0.5 * MAX_16)  /* threshold for adapt stopping low     */
+#define CVAD_THRESH_IN_NOISE  (Word16)(0.65 * MAX_16)  /* threshold going into speech on
+                                                          a short term basis                   */
+
+#define CVAD_THRESH_HANG  (Word16)(0.70 * MAX_16)      /* threshold                            */
+#define CVAD_HANG_LIMIT  (Word16)(100)                 /* 2 second estimation time             */
+#define CVAD_HANG_LENGTH  (Word16)(250)                /* 5 second hangover                    */
+
+#define CVAD_LOWPOW_RESET (Word16) (0.40 * MAX_16)     /* init in low power segment            */
+#define CVAD_MIN_CORR (Word16) (0.40 * MAX_16)         /* lowest adaptation value              */
+
+#define CVAD_BURST 20                                  /* speech burst length for speech reset */
+#define CVAD_ADAPT_SLOW (Word16)(( 1.0 - 0.98) * MAX_16)        /* threshold for slow adaption */
+#define CVAD_ADAPT_FAST (Word16)((1.0 - 0.92) * MAX_16)         /* threshold for fast adaption */
+#define CVAD_ADAPT_REALLY_FAST (Word16)((1.0 - 0.80) * MAX_16)  /* threshold for really fast
+                                                                   adaption                    */
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/cod_amr.c FFMpeg-20050127-new/libavcodec/amr/cod_amr.c
--- FFMpeg-20050127/libavcodec/amr/cod_amr.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/cod_amr.c	2001-12-12 20:08:00.000000000 +0000
@@ -0,0 +1,713 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : cod_amr.c
+*      Purpose          : Main encoder routine operating on a frame basis.
+*
+*****************************************************************************
+*/
+#include "cod_amr.h"
+const char cod_amr_id[] = "@(#)$Id $" cod_amr_h;
+
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+#include "copy.h"
+#include "set_zero.h"
+#include "qua_gain.h"
+
+#include "lpc.h"
+#include "lsp.h"
+#include "pre_big.h"
+#include "ol_ltp.h"
+#include "p_ol_wgh.h"
+#include "spreproc.h"
+#include "cl_ltp.h"
+#include "pred_lt.h"
+#include "spstproc.h"
+#include "cbsearch.h"
+#include "gain_q.h"
+#include "copy.h"
+#include "convolve.h"
+#include "ton_stab.h"
+#include "vad.h"
+#include "dtx_enc.h"
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         PUBLIC VARIABLES AND TABLES
+*****************************************************************************
+*/
+/* Spectral expansion factors */
+
+static const Word16 gamma1[M] =
+{
+   30802, 28954, 27217, 25584, 24049,
+   22606, 21250, 19975, 18777, 17650
+};
+
+/* gamma1 differs for the 12k2 coder */
+static const Word16 gamma1_12k2[M] =
+{
+    29491, 26542, 23888, 21499, 19349,
+    17414, 15672, 14105, 12694, 11425
+};
+
+static const Word16 gamma2[M] =
+{
+   19661, 11797, 7078, 4247, 2548,
+   1529, 917, 550, 330, 198
+};
+
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : cod_amr_init
+*  Purpose     : Allocates memory and initializes state variables
+*
+**************************************************************************
+*/
+int cod_amr_init (cod_amrState **state, Flag dtx)
+{
+  cod_amrState* s;
+
+  if (state == (cod_amrState **) NULL){
+      fprintf(stderr, "cod_amr_init: invalid parameter\n");
+      return -1;
+  }
+  *state = NULL;
+ 
+  /* allocate memory */
+  if ((s= (cod_amrState *) malloc(sizeof(cod_amrState))) == NULL){
+      fprintf(stderr, "cod_amr_init: can not malloc state structure\n");
+      return -1;
+  }
+
+  s->lpcSt = NULL;
+  s->lspSt = NULL;
+  s->clLtpSt = NULL;
+  s->gainQuantSt = NULL;
+  s->pitchOLWghtSt = NULL;
+  s->tonStabSt = NULL;    
+  s->vadSt = NULL;
+  s->dtx_encSt = NULL;
+  s->dtx = dtx;
+  
+  /* Init sub states */
+  if (cl_ltp_init(&s->clLtpSt) ||
+      lsp_init(&s->lspSt) ||
+      gainQuant_init(&s->gainQuantSt) ||
+      p_ol_wgh_init(&s->pitchOLWghtSt) ||
+      ton_stab_init(&s->tonStabSt) ||      
+#ifndef VAD2
+      vad1_init(&s->vadSt) ||
+#else
+      vad2_init(&s->vadSt) ||
+#endif
+      dtx_enc_init(&s->dtx_encSt) ||
+      lpc_init(&s->lpcSt)) {
+     cod_amr_exit(&s);
+     return -1;
+  }
+  
+  cod_amr_reset(s);
+  
+  *state = s;
+  
+  return 0;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : cod_amr_reset
+*  Purpose     : Resets state memory
+*
+**************************************************************************
+*/
+int cod_amr_reset (cod_amrState *st)
+{
+   Word16 i;
+    
+   if (st == (cod_amrState *) NULL){
+      fprintf(stderr, "cod_amr_reset: invalid parameter\n");
+      return -1;
+   }
+  
+   /*-----------------------------------------------------------------------*
+    *          Initialize pointers to speech vector.                        *
+    *-----------------------------------------------------------------------*/
+      
+   st->new_speech = st->old_speech + L_TOTAL - L_FRAME;   /* New speech     */
+   
+   st->speech = st->new_speech - L_NEXT;                  /* Present frame  */
+   
+   st->p_window = st->old_speech + L_TOTAL - L_WINDOW;    /* For LPC window */
+   st->p_window_12k2 = st->p_window - L_NEXT; /* EFR LPC window: no lookahead */
+   
+   /* Initialize static pointers */
+   
+   st->wsp = st->old_wsp + PIT_MAX;
+   st->exc = st->old_exc + PIT_MAX + L_INTERPOL;
+   st->zero = st->ai_zero + MP1;
+   st->error = st->mem_err + M;
+   st->h1 = &st->hvec[L_SUBFR];
+   
+   /* Static vectors to zero */
+   
+   Set_zero(st->old_speech, L_TOTAL);
+   Set_zero(st->old_exc,    PIT_MAX + L_INTERPOL);
+   Set_zero(st->old_wsp,    PIT_MAX);
+   Set_zero(st->mem_syn,    M);
+   Set_zero(st->mem_w,      M);
+   Set_zero(st->mem_w0,     M);
+   Set_zero(st->mem_err,    M);
+   Set_zero(st->zero,       L_SUBFR);
+   Set_zero(st->hvec,       L_SUBFR);    /* set to zero "h1[-L_SUBFR..-1]" */
+
+   /* OL LTP states */
+   for (i = 0; i < 5; i++)
+   {
+      st->old_lags[i] = 40; 
+   }
+   
+   /* Reset lpc states */
+   lpc_reset(st->lpcSt);
+   
+   /* Reset lsp states */
+   lsp_reset(st->lspSt);
+    
+   /* Reset clLtp states */
+   cl_ltp_reset(st->clLtpSt);
+   
+   gainQuant_reset(st->gainQuantSt);
+
+   p_ol_wgh_reset(st->pitchOLWghtSt);
+
+   ton_stab_reset(st->tonStabSt);   
+
+#ifndef VAD2
+   vad1_reset(st->vadSt);
+#else
+   vad2_reset(st->vadSt);
+#endif 
+   
+   dtx_enc_reset(st->dtx_encSt);
+
+   st->sharp = SHARPMIN;
+   
+   return 0;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : cod_amr_exit
+*  Purpose     : The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void cod_amr_exit (cod_amrState **state)
+{
+   if (state == NULL || *state == NULL)
+      return;
+   
+   /* dealloc members */
+   lpc_exit(&(*state)->lpcSt);
+   lsp_exit(&(*state)->lspSt);
+   gainQuant_exit(&(*state)->gainQuantSt);
+   cl_ltp_exit(&(*state)->clLtpSt);
+   p_ol_wgh_exit(&(*state)->pitchOLWghtSt);
+   ton_stab_exit(&(*state)->tonStabSt);
+#ifndef VAD2
+   vad1_exit(&(*state)->vadSt);
+#else
+   vad2_exit(&(*state)->vadSt);
+#endif 
+   dtx_enc_exit(&(*state)->dtx_encSt);
+
+   /* deallocate memory */
+   free(*state);
+   *state = NULL;
+   
+   return;
+}
+
+/***************************************************************************
+ *   FUNCTION:   cod_amr_first
+ *
+ *   PURPOSE:  Copes with look-ahead.
+ *
+ *   INPUTS:
+ *       No input argument are passed to this function. However, before
+ *       calling this function, 40 new speech data should be copied to the
+ *       vector new_speech[]. This is a global pointer which is declared in
+ *       this file (it points to the end of speech buffer minus 200).
+ *
+ ***************************************************************************/
+ 
+int cod_amr_first(cod_amrState *st,     /* i/o : State struct           */
+                  Word16 new_speech[])  /* i   : speech input (L_FRAME) */
+{ 
+   Copy(new_speech,&st->new_speech[-L_NEXT], L_NEXT);
+   /*   Copy(new_speech,st->new_speech,L_FRAME); */
+  
+   return 0;
+}
+
+
+/***************************************************************************
+ *   FUNCTION: cod_amr
+ *
+ *   PURPOSE:  Main encoder routine.
+ *
+ *   DESCRIPTION: This function is called every 20 ms speech frame,
+ *       operating on the newly read 160 speech samples. It performs the
+ *       principle encoding functions to produce the set of encoded parameters
+ *       which include the LSP, adaptive codebook, and fixed codebook
+ *       quantization indices (addresses and gains).
+ *
+ *   INPUTS:
+ *       No input argument are passed to this function. However, before
+ *       calling this function, 160 new speech data should be copied to the
+ *       vector new_speech[]. This is a global pointer which is declared in
+ *       this file (it points to the end of speech buffer minus 160).
+ *
+ *   OUTPUTS:
+ *
+ *       ana[]:     vector of analysis parameters.
+ *       synth[]:   Local synthesis speech (for debugging purposes)
+ *
+ ***************************************************************************/
+int cod_amr(
+    cod_amrState *st,          /* i/o : State struct                   */
+    enum Mode mode,            /* i   : AMR mode                       */
+    Word16 new_speech[],       /* i   : speech input (L_FRAME)         */
+    Word16 ana[],              /* o   : Analysis parameters            */
+    enum Mode *usedMode,       /* o   : used mode                    */
+    Word16 synth[]             /* o   : Local synthesis                */
+)
+{
+   /* LPC coefficients */
+   Word16 A_t[(MP1) * 4];      /* A(z) unquantized for the 4 subframes */
+   Word16 Aq_t[(MP1) * 4];     /* A(z)   quantized for the 4 subframes */
+   Word16 *A, *Aq;             /* Pointer on A_t and Aq_t              */
+   Word16 lsp_new[M];
+   
+   /* Other vectors */
+   Word16 xn[L_SUBFR];         /* Target vector for pitch search       */
+   Word16 xn2[L_SUBFR];        /* Target vector for codebook search    */
+   Word16 code[L_SUBFR];       /* Fixed codebook excitation            */
+   Word16 y1[L_SUBFR];         /* Filtered adaptive excitation         */
+   Word16 y2[L_SUBFR];         /* Filtered fixed codebook excitation   */
+   Word16 gCoeff[6];           /* Correlations between xn, y1, & y2:   */
+   Word16 res[L_SUBFR];        /* Short term (LPC) prediction residual */
+   Word16 res2[L_SUBFR];       /* Long term (LTP) prediction residual  */
+
+   /* Vector and scalars needed for the MR475 */
+   Word16 xn_sf0[L_SUBFR];     /* Target vector for pitch search       */
+   Word16 y2_sf0[L_SUBFR];     /* Filtered codebook innovation         */   
+   Word16 code_sf0[L_SUBFR];   /* Fixed codebook excitation            */
+   Word16 h1_sf0[L_SUBFR];     /* The impulse response of sf0          */
+   Word16 mem_syn_save[M];     /* Filter memory                        */
+   Word16 mem_w0_save[M];      /* Filter memory                        */
+   Word16 mem_err_save[M];     /* Filter memory                        */
+   Word16 sharp_save;          /* Sharpening                           */
+   Word16 evenSubfr;           /* Even subframe indicator              */ 
+   Word16 T0_sf0 = 0;          /* Integer pitch lag of sf0             */  
+   Word16 T0_frac_sf0 = 0;     /* Fractional pitch lag of sf0          */  
+   Word16 i_subfr_sf0 = 0;     /* Position in exc[] for sf0            */
+   Word16 gain_pit_sf0;        /* Quantized pitch gain for sf0         */
+   Word16 gain_code_sf0;       /* Quantized codebook gain for sf0      */
+    
+   /* Scalars */
+   Word16 i_subfr, subfrNr;
+   Word16 T_op[L_FRAME/L_FRAME_BY2];
+   Word16 T0, T0_frac;
+   Word16 gain_pit, gain_code;
+
+   /* Flags */
+   Word16 lsp_flag = 0;        /* indicates resonance in LPC filter */   
+   Word16 gp_limit;            /* pitch gain limit value            */
+   Word16 vad_flag;            /* VAD decision flag                 */
+   Word16 compute_sid_flag;    /* SID analysis  flag                 */
+
+   Copy(new_speech, st->new_speech, L_FRAME);
+
+   *usedMode = mode;                     move16 ();
+
+   /* DTX processing */
+   if (st->dtx)
+   {  /* no test() call since this if is only in simulation env */
+      /* Find VAD decision */
+
+#ifdef  VAD2
+      vad_flag = vad2 (st->new_speech,    st->vadSt);
+      vad_flag = vad2 (st->new_speech+80, st->vadSt) || vad_flag;      logic16();
+#else
+      vad_flag = vad1(st->vadSt, st->new_speech);     
+#endif
+      fwc ();                 /* function worst case */
+
+      /* NB! usedMode may change here */
+      compute_sid_flag = tx_dtx_handler(st->dtx_encSt,
+                                        vad_flag, 
+                                        usedMode);
+   }
+   else 
+   {
+      compute_sid_flag = 0;              move16 ();
+   }
+   
+   /*------------------------------------------------------------------------*
+    *  - Perform LPC analysis:                                               *
+    *       * autocorrelation + lag windowing                                *
+    *       * Levinson-durbin algorithm to find a[]                          *
+    *       * convert a[] to lsp[]                                           *
+    *       * quantize and code the LSPs                                     *
+    *       * find the interpolated LSPs and convert to a[] for all          *
+    *         subframes (both quantized and unquantized)                     *
+    *------------------------------------------------------------------------*/
+   
+   /* LP analysis */
+   lpc(st->lpcSt, mode, st->p_window, st->p_window_12k2, A_t);
+
+   fwc ();                 /* function worst case */
+
+   /* From A(z) to lsp. LSP quantization and interpolation */
+   lsp(st->lspSt, mode, *usedMode, A_t, Aq_t, lsp_new, &ana);
+   
+   fwc ();                 /* function worst case */
+
+   /* Buffer lsp's and energy */
+   dtx_buffer(st->dtx_encSt,
+	      lsp_new,
+	      st->new_speech);
+
+   /* Check if in DTX mode */
+   test();
+   if (sub(*usedMode, MRDTX) == 0)
+   {
+      dtx_enc(st->dtx_encSt,
+              compute_sid_flag,
+              st->lspSt->qSt, 
+              st->gainQuantSt->gc_predSt,
+              &ana);
+      
+      Set_zero(st->old_exc,    PIT_MAX + L_INTERPOL);
+      Set_zero(st->mem_w0,     M);
+      Set_zero(st->mem_err,    M);
+      Set_zero(st->zero,       L_SUBFR);
+      Set_zero(st->hvec,       L_SUBFR);    /* set to zero "h1[-L_SUBFR..-1]" */
+      /* Reset lsp states */
+      lsp_reset(st->lspSt);
+      Copy(lsp_new, st->lspSt->lsp_old, M);
+      Copy(lsp_new, st->lspSt->lsp_old_q, M);
+      
+      /* Reset clLtp states */
+      cl_ltp_reset(st->clLtpSt);
+      st->sharp = SHARPMIN;       move16 ();
+   }
+   else
+   {
+       /* check resonance in the filter */
+      lsp_flag = check_lsp(st->tonStabSt, st->lspSt->lsp_old);  move16 ();
+   }
+   
+   /*----------------------------------------------------------------------*
+    * - Find the weighted input speech w_sp[] for the whole speech frame   *
+    * - Find the open-loop pitch delay for first 2 subframes               *
+    * - Set the range for searching closed-loop pitch in 1st subframe      *
+    * - Find the open-loop pitch delay for last 2 subframes                *
+    *----------------------------------------------------------------------*/
+
+#ifdef VAD2
+   if (st->dtx)
+   {  /* no test() call since this if is only in simulation env */
+       st->vadSt->L_Rmax = 0;			move32 ();
+       st->vadSt->L_R0 = 0;			move32 ();
+   }
+#endif
+   for(subfrNr = 0, i_subfr = 0; 
+       subfrNr < L_FRAME/L_FRAME_BY2; 
+       subfrNr++, i_subfr += L_FRAME_BY2)
+   {
+      /* Pre-processing on 80 samples */
+      pre_big(mode, gamma1, gamma1_12k2, gamma2, A_t, i_subfr, st->speech,
+              st->mem_w, st->wsp);
+    
+      test (); test ();
+      if ((sub(mode, MR475) != 0) && (sub(mode, MR515) != 0))
+      {
+         /* Find open loop pitch lag for two subframes */
+         ol_ltp(st->pitchOLWghtSt, st->vadSt, mode, &st->wsp[i_subfr],
+                &T_op[subfrNr], st->old_lags, st->ol_gain_flg, subfrNr,
+                st->dtx);
+      }
+   }
+   fwc ();                 /* function worst case */
+
+   test (); test();
+   if ((sub(mode, MR475) == 0) || (sub(mode, MR515) == 0))
+   {
+      /* Find open loop pitch lag for ONE FRAME ONLY */
+      /* search on 160 samples */
+      
+      ol_ltp(st->pitchOLWghtSt, st->vadSt, mode, &st->wsp[0], &T_op[0],
+             st->old_lags, st->ol_gain_flg, 1, st->dtx);
+      T_op[1] = T_op[0];                                     move16 ();
+   }         
+   fwc ();                 /* function worst case */
+   
+#ifdef VAD2
+   if (st->dtx)
+   {  /* no test() call since this if is only in simulation env */
+      LTP_flag_update(st->vadSt, mode);
+   }
+#endif
+
+#ifndef VAD2
+   /* run VAD pitch detection */
+   if (st->dtx)
+   {  /* no test() call since this if is only in simulation env */
+      vad_pitch_detection(st->vadSt, T_op);
+   } 
+#endif
+   fwc ();                 /* function worst case */
+
+   if (sub(*usedMode, MRDTX) == 0)
+   {
+      goto the_end;
+   }
+   
+   /*------------------------------------------------------------------------*
+    *          Loop for every subframe in the analysis frame                 *
+    *------------------------------------------------------------------------*
+    *  To find the pitch and innovation parameters. The subframe size is     *
+    *  L_SUBFR and the loop is repeated L_FRAME/L_SUBFR times.               *
+    *     - find the weighted LPC coefficients                               *
+    *     - find the LPC residual signal res[]                               *
+    *     - compute the target signal for pitch search                       *
+    *     - compute impulse response of weighted synthesis filter (h1[])     *
+    *     - find the closed-loop pitch parameters                            *
+    *     - encode the pitch dealy                                           *
+    *     - update the impulse response h1[] by including fixed-gain pitch   *
+    *     - find target vector for codebook search                           *
+    *     - codebook search                                                  *
+    *     - encode codebook address                                          *
+    *     - VQ of pitch and codebook gains                                   *
+    *     - find synthesis speech                                            *
+    *     - update states of weighting filter                                *
+    *------------------------------------------------------------------------*/
+
+   A = A_t;      /* pointer to interpolated LPC parameters */
+   Aq = Aq_t;    /* pointer to interpolated quantized LPC parameters */
+
+   evenSubfr = 0;                                                  move16 ();
+   subfrNr = -1;                                                   move16 ();
+   for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR)
+   {
+      subfrNr = add(subfrNr, 1);
+      evenSubfr = sub(1, evenSubfr);
+
+      /* Save states for the MR475 mode */
+      test(); test();
+      if ((evenSubfr != 0) && (sub(*usedMode, MR475) == 0))
+      {
+         Copy(st->mem_syn, mem_syn_save, M);
+         Copy(st->mem_w0, mem_w0_save, M);         
+         Copy(st->mem_err, mem_err_save, M);         
+         sharp_save = st->sharp;
+      }
+      
+      /*-----------------------------------------------------------------*
+       * - Preprocessing of subframe                                     *
+       *-----------------------------------------------------------------*/
+      test();
+      if (sub(*usedMode, MR475) != 0)
+      {
+         subframePreProc(*usedMode, gamma1, gamma1_12k2,
+                         gamma2, A, Aq, &st->speech[i_subfr],
+                         st->mem_err, st->mem_w0, st->zero,
+                         st->ai_zero, &st->exc[i_subfr],
+                         st->h1, xn, res, st->error);
+      }
+      else
+      { /* MR475 */
+         subframePreProc(*usedMode, gamma1, gamma1_12k2, 
+                         gamma2, A, Aq, &st->speech[i_subfr],
+                         st->mem_err, mem_w0_save, st->zero,
+                         st->ai_zero, &st->exc[i_subfr],
+                         st->h1, xn, res, st->error);
+
+         /* save impulse response (modified in cbsearch) */
+         test ();
+         if (evenSubfr != 0)
+         {
+             Copy (st->h1, h1_sf0, L_SUBFR);
+         }
+      }
+      
+      /* copy the LP residual (res2 is modified in the CL LTP search)    */
+      Copy (res, res2, L_SUBFR);
+
+      fwc ();                 /* function worst case */
+    
+      /*-----------------------------------------------------------------*
+       * - Closed-loop LTP search                                        *
+       *-----------------------------------------------------------------*/
+      cl_ltp(st->clLtpSt, st->tonStabSt, *usedMode, i_subfr, T_op, st->h1, 
+             &st->exc[i_subfr], res2, xn, lsp_flag, xn2, y1, 
+             &T0, &T0_frac, &gain_pit, gCoeff, &ana,
+             &gp_limit);
+
+      /* update LTP lag history */
+      move16 (); test(); test ();
+      if ((subfrNr == 0) && (st->ol_gain_flg[0] > 0))
+      {
+         st->old_lags[1] = T0;     move16 ();
+      }
+      
+      move16 (); test(); test ();
+      if ((sub(subfrNr, 3) == 0) && (st->ol_gain_flg[1] > 0))
+      {
+         st->old_lags[0] = T0;     move16 ();
+      }      
+
+      fwc ();                 /* function worst case */
+      
+      /*-----------------------------------------------------------------*
+       * - Inovative codebook search (find index and gain)               *
+       *-----------------------------------------------------------------*/
+      cbsearch(xn2, st->h1, T0, st->sharp, gain_pit, res2, 
+               code, y2, &ana, *usedMode, subfrNr);
+      
+      fwc ();                 /* function worst case */
+    
+      /*------------------------------------------------------*
+       * - Quantization of gains.                             *
+       *------------------------------------------------------*/
+      gainQuant(st->gainQuantSt, *usedMode, res, &st->exc[i_subfr], code,
+                xn, xn2,  y1, y2, gCoeff, evenSubfr, gp_limit,
+                &gain_pit_sf0, &gain_code_sf0,
+                &gain_pit, &gain_code, &ana);
+      
+      fwc ();                 /* function worst case */
+
+      /* update gain history */
+      update_gp_clipping(st->tonStabSt, gain_pit);
+      
+      test(); 
+      if (sub(*usedMode, MR475) != 0)
+      {
+         /* Subframe Post Porcessing */
+         subframePostProc(st->speech, *usedMode, i_subfr, gain_pit,
+                          gain_code, Aq, synth, xn, code, y1, y2, st->mem_syn,
+                          st->mem_err, st->mem_w0, st->exc, &st->sharp);
+      }
+      else
+      {
+         test();
+         if (evenSubfr != 0)
+         {
+            i_subfr_sf0 = i_subfr;             move16 ();
+            Copy(xn, xn_sf0, L_SUBFR);
+            Copy(y2, y2_sf0, L_SUBFR);          
+            Copy(code, code_sf0, L_SUBFR);
+            T0_sf0 = T0;                       move16 ();
+            T0_frac_sf0 = T0_frac;             move16 ();
+            
+            /* Subframe Post Porcessing */
+            subframePostProc(st->speech, *usedMode, i_subfr, gain_pit,
+                             gain_code, Aq, synth, xn, code, y1, y2,
+                             mem_syn_save, st->mem_err, mem_w0_save,
+                             st->exc, &st->sharp);
+            st->sharp = sharp_save;                         move16();
+         }
+         else
+         {
+            /* update both subframes for the MR475 */
+            
+            /* Restore states for the MR475 mode */
+            Copy(mem_err_save, st->mem_err, M);         
+            
+            /* re-build excitation for sf 0 */
+            Pred_lt_3or6(&st->exc[i_subfr_sf0], T0_sf0, T0_frac_sf0,
+                         L_SUBFR, 1);
+            Convolve(&st->exc[i_subfr_sf0], h1_sf0, y1, L_SUBFR);
+            
+            Aq -= MP1;
+            subframePostProc(st->speech, *usedMode, i_subfr_sf0,
+                             gain_pit_sf0, gain_code_sf0, Aq,
+                             synth, xn_sf0, code_sf0, y1, y2_sf0,
+                             st->mem_syn, st->mem_err, st->mem_w0, st->exc,
+                             &sharp_save); /* overwrites sharp_save */
+            Aq += MP1;
+            
+            /* re-run pre-processing to get xn right (needed by postproc) */
+            /* (this also reconstructs the unsharpened h1 for sf 1)       */
+            subframePreProc(*usedMode, gamma1, gamma1_12k2,
+                            gamma2, A, Aq, &st->speech[i_subfr],
+                            st->mem_err, st->mem_w0, st->zero,
+                            st->ai_zero, &st->exc[i_subfr],
+                            st->h1, xn, res, st->error);
+            
+            /* re-build excitation sf 1 (changed if lag < L_SUBFR) */
+            Pred_lt_3or6(&st->exc[i_subfr], T0, T0_frac, L_SUBFR, 1);
+            Convolve(&st->exc[i_subfr], st->h1, y1, L_SUBFR);
+            
+            subframePostProc(st->speech, *usedMode, i_subfr, gain_pit,
+                             gain_code, Aq, synth, xn, code, y1, y2,
+                             st->mem_syn, st->mem_err, st->mem_w0,
+                             st->exc, &st->sharp);
+         }
+      }      
+               
+      fwc ();                 /* function worst case */
+          
+      A += MP1;    /* interpolated LPC parameters for next subframe */
+      Aq += MP1;
+   }
+
+   Copy(&st->old_exc[L_FRAME], &st->old_exc[0], PIT_MAX + L_INTERPOL);
+   
+the_end:
+   
+   /*--------------------------------------------------*
+    * Update signal for next frame.                    *
+    *--------------------------------------------------*/
+   Copy(&st->old_wsp[L_FRAME], &st->old_wsp[0], PIT_MAX);
+   
+   Copy(&st->old_speech[L_FRAME], &st->old_speech[0], L_TOTAL - L_FRAME);
+
+   fwc ();                 /* function worst case */
+       
+   return 0;
+}
+
diff -Nur FFMpeg-20050127/libavcodec/amr/cod_amr.h FFMpeg-20050127-new/libavcodec/amr/cod_amr.h
--- FFMpeg-20050127/libavcodec/amr/cod_amr.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/cod_amr.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,191 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : cod_amr.h
+*      Purpose          : Main encoder routine operating on a frame basis.
+*
+*****************************************************************************
+*/
+#ifndef cod_amr_h
+#define cod_amr_h "$Id $"
+
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include "typedef.h"
+#include "cnst.h"
+#include "mode.h"
+#include "lpc.h"
+#include "lsp.h"
+#include "cl_ltp.h"
+#include "gain_q.h"
+#include "p_ol_wgh.h"
+#include "ton_stab.h"
+#include "vad.h"
+#include "dtx_enc.h"
+ 
+/*
+*****************************************************************************
+*                         DEFINITION OF DATA TYPES
+*****************************************************************************
+*/
+/*-----------------------------------------------------------*
+ *    Coder constant parameters (defined in "cnst.h")        *
+ *-----------------------------------------------------------*
+ *   L_WINDOW    : LPC analysis window size.                 *
+ *   L_NEXT      : Samples of next frame needed for autocor. *
+ *   L_FRAME     : Frame size.                               *
+ *   L_FRAME_BY2 : Half the frame size.                      *
+ *   L_SUBFR     : Sub-frame size.                           *
+ *   M           : LPC order.                                *
+ *   MP1         : LPC order+1                               *
+ *   L_TOTAL7k4  : Total size of speech buffer.              *
+ *   PIT_MIN7k4  : Minimum pitch lag.                        *
+ *   PIT_MAX     : Maximum pitch lag.                        *
+ *   L_INTERPOL  : Length of filter for interpolation        *
+ *-----------------------------------------------------------*/
+typedef struct {
+   /* Speech vector */
+   Word16 old_speech[L_TOTAL];
+   Word16 *speech, *p_window, *p_window_12k2;
+   Word16 *new_speech;             /* Global variable */
+   
+   /* Weight speech vector */
+   Word16 old_wsp[L_FRAME + PIT_MAX];
+   Word16 *wsp;
+
+   /* OL LTP states */
+   Word16 old_lags[5];
+   Word16 ol_gain_flg[2];
+
+   /* Excitation vector */
+   Word16 old_exc[L_FRAME + PIT_MAX + L_INTERPOL];
+   Word16 *exc;
+
+   /* Zero vector */
+   Word16 ai_zero[L_SUBFR + MP1];
+   Word16 *zero;
+
+   /* Impulse response vector */
+   Word16 *h1;
+   Word16 hvec[L_SUBFR * 2];
+
+   /* Substates */
+   lpcState   *lpcSt;
+   lspState   *lspSt;
+   clLtpState *clLtpSt;
+   gainQuantState  *gainQuantSt;
+   pitchOLWghtState *pitchOLWghtSt;
+   tonStabState *tonStabSt;
+   vadState *vadSt;
+   Flag dtx;
+   dtx_encState *dtx_encSt;
+
+   /* Filter's memory */
+   Word16 mem_syn[M], mem_w0[M], mem_w[M];
+   Word16 mem_err[M + L_SUBFR], *error;
+
+   Word16 sharp;
+} cod_amrState;
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : cod_amr_init
+*  Purpose     : Allocates memory and initializes state variables
+*  Description : Stores pointer to filter status struct in *st. This
+*                pointer has to be passed to cod_amr in each call.
+ *                 - initilize pointers to speech buffer
+ *                 - initialize static  pointers
+ *                 - set static vectors to zero
+*  Returns     : 0 on success
+*
+**************************************************************************
+*/ 
+int cod_amr_init (cod_amrState **st, Flag dtx);
+ 
+/*
+**************************************************************************
+*
+*  Function    : cod_amr_reset
+*  Purpose     : Resets state memory
+*  Returns     : 0 on success
+*
+**************************************************************************
+*/
+int cod_amr_reset (cod_amrState *st);
+
+/*
+**************************************************************************
+*
+*  Function    : cod_amr_exit
+*  Purpose     : The memory used for state memory is freed
+*  Description : Stores NULL in *st
+*
+**************************************************************************
+*/
+void cod_amr_exit (cod_amrState **st);
+ 
+/***************************************************************************
+ *   FUNCTION:   cod_amr_first
+ *
+ *   PURPOSE:  Copes with look-ahead.
+ *
+ *   INPUTS:
+ *       No input argument are passed to this function. However, before
+ *       calling this function, 40 new speech data should be copied to the
+ *       vector new_speech[]. This is a global pointer which is declared in
+ *       this file (it points to the end of speech buffer minus 200).
+ *
+ ***************************************************************************/
+ 
+int cod_amr_first(cod_amrState *st,     /* i/o : State struct            */
+                  Word16 new_speech[]   /* i   : speech input (L_FRAME)  */
+);
+
+/***************************************************************************
+ *   FUNCTION:   cod_amr
+ *
+ *   PURPOSE:  Main encoder routine.
+ *
+ *   DESCRIPTION: This function is called every 20 ms speech frame,
+ *       operating on the newly read 160 speech samples. It performs the
+ *       principle encoding functions to produce the set of encoded parameters
+ *       which include the LSP, adaptive codebook, and fixed codebook
+ *       quantization indices (addresses and gains).
+ *
+ *   INPUTS:
+ *       No input argument are passed to this function. However, before
+ *       calling this function, 160 new speech data should be copied to the
+ *       vector new_speech[]. This is a global pointer which is declared in
+ *       this file (it points to the end of speech buffer minus 160).
+ *
+ *   OUTPUTS:
+ *
+ *       ana[]:     vector of analysis parameters.
+ *       synth[]:   Local synthesis speech (for debugging purposes)
+ *
+ ***************************************************************************/
+
+int cod_amr(cod_amrState *st,         /* i/o : State struct                 */
+            enum Mode mode,           /* i   : AMR mode                     */
+            Word16 new_speech[],      /* i   : speech input (L_FRAME)       */
+            Word16 ana[],             /* o   : Analysis parameters          */
+            enum Mode *usedMode,      /* o   : used mode                    */
+            Word16 synth[]            /* o   : Local synthesis              */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/coder.c FFMpeg-20050127-new/libavcodec/amr/coder.c
--- FFMpeg-20050127/libavcodec/amr/coder.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/coder.c	2003-02-17 15:34:00.000000000 +0000
@@ -0,0 +1,330 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : coder.c
+*      Purpose          : Speech encoder main program.
+*
+*****************************************************************************
+*
+*    Usage : coder speech_file  bitstream_file
+*
+*    Format for speech_file:
+*      Speech is read from a binary file of 16 bits data.
+*
+*    Format for bitstream_file:
+*        1 word (2-byte) for the TX frame type
+*          (see frame.h for possible values)
+*      244 words (2-byte) containing 244 bits.
+*          Bit 0 = 0x0000 and Bit 1 = 0x0001
+*        1 word (2-byte) for the mode indication
+*          (see mode.h for possible values)
+*        4 words for future use, currently written as zero
+*
+*****************************************************************************
+*/
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include "typedef.h"
+#include "cnst.h"
+#include "n_proc.h"
+#include "mode.h"
+#include "frame.h"
+#include "strfunc.h"
+#include "sp_enc.h"
+#include "pre_proc.h"
+#include "sid_sync.h"
+#include "vadname.h"
+#include "e_homing.h"
+
+#ifdef MMS_IO
+#define AMR_MAGIC_NUMBER "#!AMR\n"
+#define MAX_PACKED_SIZE (MAX_SERIAL_SIZE / 8 + 2)
+#endif
+
+const char coder_id[] = "@(#)$Id $";
+
+/* frame size in serial bitstream file (frame type + serial stream + flags) */
+#define SERIAL_FRAMESIZE (1+MAX_SERIAL_SIZE+5)
+
+/*
+*****************************************************************************
+*                         LOCAL PROGRAM CODE
+*****************************************************************************
+*/
+/*
+ * read_mode  read next mode from mode file
+ *
+ * return 0 on success, EOF on end of file, 1 on other error
+ */
+int read_mode(FILE *file_modes, enum Mode *mode)
+{
+    char buf[10];
+    
+    if (fscanf(file_modes, "%9s\n", buf) != 1) {
+        if (feof(file_modes))
+            return EOF;
+
+        fprintf(stderr, "\nerror reading mode control file: %s\n",
+                strerror(errno));
+        return 1;
+    }
+
+    if (str2mode(buf, mode) != 0 || *mode == MRDTX) {
+        fprintf(stderr, "\ninvalid amr_mode found in mode control file: '%s'\n",
+                buf);
+        return 1;
+    }
+
+    return 0;
+}
+
+
+/*
+*****************************************************************************
+*                             MAIN PROGRAM 
+*****************************************************************************
+*/
+int main (int argc, char *argv[])
+{
+  char *progname = argv[0];
+  char *modeStr = NULL;
+  char *usedModeStr = NULL;
+  char *fileName = NULL;
+  char *modefileName = NULL;
+  char *serialFileName = NULL;
+  
+  FILE *file_speech = NULL;           /* File of speech data               */
+  FILE *file_serial = NULL;           /* File of coded bits                */
+  FILE *file_modes = NULL;            /* File with mode information        */
+  
+  Word16 new_speech[L_FRAME];         /* Pointer to new speech data        */
+  Word16 serial[SERIAL_FRAMESIZE];    /* Output bitstream buffer           */
+
+#ifdef MMS_IO
+  UWord8 packed_bits[MAX_PACKED_SIZE];
+  Word16 packed_size;
+#endif
+
+  Word32 frame;
+  Word16 dtx = 0;                     /* enable encoder DTX                */
+  
+  /* changed eedodr */
+  Word16 reset_flag;
+
+  int i;
+  enum Mode mode;
+  enum Mode used_mode;
+  enum TXFrameType tx_type;
+
+  int useModeFile = 0;
+  
+  Speech_Encode_FrameState *speech_encoder_state = NULL;
+  sid_syncState *sid_state = NULL;
+
+  proc_head ("Encoder");
+  fprintf(stderr, "Code compiled with VAD option: %s\n\n", get_vadname());
+
+  /*----------------------------------------------------------------------*
+   * Process command line options                                         *
+   *----------------------------------------------------------------------*/
+  while (argc > 1) {
+      if (strcmp(argv[1], "-dtx") == 0) {
+          dtx = 1;
+      } else if (strncmp(argv[1], "-modefile=", 10) == 0) {
+          useModeFile = 1;
+          modefileName = argv[1]+10;
+      } else
+          break;
+      argc--;
+      argv++;
+  }
+  
+  /*----------------------------------------------------------------------*
+   * Check number of arguments                                            *
+   *----------------------------------------------------------------------*/
+  if (   (argc != 4 && !useModeFile)
+      || (argc != 3 &&  useModeFile))
+  {
+    fprintf (stderr,
+      " Usage:\n\n"
+      "   %s [-dtx] amr_mode            speech_file  bitstream_file\n\n"
+      " or \n\n"
+      "   %s [-dtx] -modefile=mode_file speech_file  bitstream_file\n\n"
+      " -dtx                enables DTX mode\n"
+      " -modefile=mode_file reads AMR modes from text file (one line per frame)\n\n",
+             progname, progname);
+      exit (1);
+  }
+
+  /*----------------------------------------------------------------------*
+   * Open mode file or convert mode string                                *
+   *----------------------------------------------------------------------*/
+  if (useModeFile) {
+      fileName = argv[1];
+      serialFileName = argv[2];
+      
+      /* Open mode control file */
+      if (strcmp(modefileName, "-") == 0) {
+          file_modes = stdin;
+      }
+      else if ((file_modes = fopen (modefileName, "rt")) == NULL)
+      {
+          fprintf (stderr, "Error opening mode control file  %s !!\n",
+                   modefileName);
+          exit (1);
+      }
+      fprintf (stderr, " Mode control file:      %s\n", modefileName);
+
+  } else {
+      
+      modeStr = argv[1];
+      fileName = argv[2];
+      serialFileName = argv[3];
+      
+      /* check and convert mode string */
+      if (str2mode(modeStr, &mode) != 0 && mode != MRDTX) {
+          fprintf(stderr, "Invalid amr_mode specified: '%s'\n",
+                  modeStr);
+          exit(1);
+      }
+  }
+  
+
+  /*----------------------------------------------------------------------*
+   * Open speech file and result file (output serial bit stream)          *
+   *----------------------------------------------------------------------*/
+  if (strcmp(fileName, "-") == 0) {
+     file_speech = stdin;
+  }
+  else if ((file_speech = fopen (fileName, "rb")) == NULL)
+  {
+      fprintf (stderr, "Error opening input file  %s !!\n", fileName);
+      exit (1);
+  }
+  fprintf (stderr, " Input speech file:      %s\n", fileName);
+
+  if (strcmp(serialFileName, "-") == 0) {
+     file_serial = stdout;
+  }
+  else if ((file_serial = fopen (serialFileName, "wb")) == NULL)
+  {
+      fprintf (stderr,"Error opening output bitstream file %s !!\n",serialFileName);
+      exit (1);
+  }
+  fprintf (stderr, " Output bitstream file:  %s\n", serialFileName);
+
+
+  /*-----------------------------------------------------------------------*
+   * Initialisation of the coder.                                          *
+   *-----------------------------------------------------------------------*/
+  if (   Speech_Encode_Frame_init(&speech_encoder_state, dtx, "encoder")
+      || sid_sync_init (&sid_state))
+      exit(-1);
+
+#ifdef MMS_IO
+  /* write magic number to indicate single channel AMR file storage format */
+  fwrite(AMR_MAGIC_NUMBER, sizeof(UWord8), strlen(AMR_MAGIC_NUMBER), file_serial);
+#endif
+
+  /*-----------------------------------------------------------------------*
+   * Process speech frame by frame                                         *
+   *-----------------------------------------------------------------------*/
+  frame = 0;
+  while (fread (new_speech, sizeof (Word16), L_FRAME, file_speech) == L_FRAME)
+  {
+     /* read new mode string from file if required */
+     if (useModeFile) {
+         int res;
+         if ((res = read_mode(file_modes, &mode)) == EOF) {
+             fprintf(stderr, "\nend of mode control file reached");
+             break;
+         } else if (res == 1)
+             exit(-1);
+     }
+      
+     frame++;
+     
+     /* zero flags and parameter bits */
+     for (i = 0; i < SERIAL_FRAMESIZE; i++)
+         serial[i] = 0;
+
+     /* check for homing frame */
+     reset_flag = encoder_homing_frame_test(new_speech);
+     
+     /* encode speech */
+     Speech_Encode_Frame(speech_encoder_state, mode,
+                         new_speech, &serial[1], &used_mode); 
+
+     /* print frame number and mode information */
+     mode2str(mode, &modeStr);
+     mode2str(used_mode, &usedModeStr);
+     if ( (frame%50) == 0) {
+        fprintf (stderr, "\rframe=%-8d mode=%-5s used_mode=%-5s",
+                 frame, modeStr, usedModeStr);
+     }
+
+     /* include frame type and mode information in serial bitstream */
+     sid_sync (sid_state, used_mode, &tx_type);
+
+#ifndef MMS_IO
+     serial[0] = tx_type;
+     if (tx_type != TX_NO_DATA) {
+       serial[1+MAX_SERIAL_SIZE] = mode;
+     }
+     else {
+       serial[1+MAX_SERIAL_SIZE] = -1;
+     }
+
+     /* write bitstream to output file */
+     if (fwrite (serial, sizeof (Word16), SERIAL_FRAMESIZE, file_serial)
+         != SERIAL_FRAMESIZE) {
+         fprintf(stderr, "\nerror writing output file: %s\n",
+                 strerror(errno));
+         exit(-1);
+     }
+#else
+
+     packed_size = PackBits(used_mode, mode, tx_type, &serial[1], packed_bits);
+
+     /* write file storage format bitstream to output file */
+     if (fwrite (packed_bits, sizeof (UWord8), packed_size, file_serial)
+         != packed_size) {
+         fprintf(stderr, "\nerror writing output file: %s\n",
+                 strerror(errno));
+         exit(-1);
+     }
+#endif
+
+     fflush(file_serial);
+
+     /* perform homing if homing frame was detected at encoder input */
+     if (reset_flag != 0)
+     {
+         Speech_Encode_Frame_reset(speech_encoder_state);
+         sid_sync_reset(sid_state);
+     }
+  }
+  fprintf (stderr, "\n%d frame(s) processed\n", frame);
+  
+  /*-----------------------------------------------------------------------*
+   * Close down speech coder                                               *
+   *-----------------------------------------------------------------------*/
+  Speech_Encode_Frame_exit(&speech_encoder_state);
+  sid_sync_exit (&sid_state);
+  
+  return (0);
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/convolve.c FFMpeg-20050127-new/libavcodec/amr/convolve.c
--- FFMpeg-20050127/libavcodec/amr/convolve.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/convolve.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,83 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : convolve.c
+*      Purpose          : Perform the convolution between two vectors x[]
+*                       : and h[] and write the result in the vector y[].
+*                       : All vectors are of length L and only the first
+*                       : L samples of the convolution are computed.
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "convolve.h"
+const char convolve_id[] = "@(#)$Id $" convolve_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+ 
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:   Convolve
+ *
+ *  PURPOSE:
+ *     Perform the convolution between two vectors x[] and h[] and
+ *     write the result in the vector y[]. All vectors are of length L
+ *     and only the first L samples of the convolution are computed.
+ *
+ *  DESCRIPTION:
+ *     The convolution is given by
+ *
+ *          y[n] = sum_{i=0}^{n} x[i] h[n-i],        n=0,...,L-1
+ *
+ *************************************************************************/
+void Convolve (
+    Word16 x[],        /* (i)     : input vector                           */
+    Word16 h[],        /* (i)     : impulse response                       */
+    Word16 y[],        /* (o)     : output vector                          */
+    Word16 L           /* (i)     : vector size                            */
+)
+{
+    Word16 i, n;
+    Word32 s;
+
+    for (n = 0; n < L; n++)
+    {
+        s = 0;                  move32 (); 
+        for (i = 0; i <= n; i++)
+        {
+            s = L_mac (s, x[i], h[n - i]);
+        }
+        s = L_shl (s, 3);
+        y[n] = extract_h (s);   move16 (); 
+    }
+
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/convolve.h FFMpeg-20050127-new/libavcodec/amr/convolve.h
--- FFMpeg-20050127/libavcodec/amr/convolve.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/convolve.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,46 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : convolve.h
+*      Purpose          : Perform the convolution between two vectors x[]
+*                       : and h[] and write the result in the vector y[].
+*                       : All vectors are of length L and only the first
+*                       : L samples of the convolution are computed.
+*
+********************************************************************************
+*/
+#ifndef convolve_h
+#define convolve_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+void Convolve (
+    Word16 x[],        /* (i)  : input vector                               */
+    Word16 h[],        /* (i)  : impulse response                           */
+    Word16 y[],        /* (o)  : output vector                              */
+    Word16 L           /* (i)  : vector size                                */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/copy.c FFMpeg-20050127-new/libavcodec/amr/copy.c
--- FFMpeg-20050127/libavcodec/amr/copy.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/copy.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,66 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*      File             : copy.h
+*
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "copy.h"
+const char copy_id[] = "@(#)$Id $" copy_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *   FUNCTION:   Copy
+ *
+ *   PURPOSE:   Copy vector x[] to y[]
+ *
+ *
+ *************************************************************************/
+/*
+**************************************************************************
+*
+*  Function    : Copy
+*  Purpose     : Copy vector x[] to y[]
+*
+**************************************************************************
+*/
+void Copy (
+    const Word16 x[],   /* i : input vector (L)  */
+    Word16 y[],         /* o : output vector (L) */
+    Word16 L            /* i : vector length     */
+)
+{
+    Word16 i;
+
+    for (i = 0; i < L; i++)
+    {
+        y[i] = x[i];            move16 (); 
+    }
+
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/copy.h FFMpeg-20050127-new/libavcodec/amr/copy.h
--- FFMpeg-20050127/libavcodec/amr/copy.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/copy.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,51 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*      File             : copy.h
+*      Purpose          : Copy vector x[] to y[]
+*
+********************************************************************************
+*/
+#ifndef copy_h
+#define copy_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+ 
+/*
+**************************************************************************
+*
+*  Function    : Copy
+*  Purpose     : Copy vector x[] to y[], vector length L
+*  Returns     : void
+*
+**************************************************************************
+*/
+void Copy (
+    const Word16 x[],  /* i : input vector (L)    */
+    Word16 y[],        /* o : output vector (L)   */
+    Word16 L           /* i : vector length       */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/cor_h.c FFMpeg-20050127-new/libavcodec/amr/cor_h.c
--- FFMpeg-20050127/libavcodec/amr/cor_h.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/cor_h.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,194 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+******************************************************************************
+*
+*      File             : cor_h.c
+*      Purpose          : correlation functions for codebook search
+*
+*****************************************************************************
+*/
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "cor_h.h"
+const char cor_h_id[] = "@(#)$Id $" cor_h_h;
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "inv_sqrt.h"
+#include "cnst.h" 
+ 
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  cor_h_x()
+ *
+ *  PURPOSE:  Computes correlation between target signal "x[]" and
+ *            impulse response"h[]".
+ *
+ *  DESCRIPTION:
+ *    The correlation is given by:
+ *       d[n] = sum_{i=n}^{L-1} x[i] h[i-n]      n=0,...,L-1
+ *
+ *    d[n] is normalized such that the sum of 5 maxima of d[n] corresponding
+ *    to each position track does not saturate.
+ *
+ *************************************************************************/
+void cor_h_x (
+    Word16 h[],    /* (i): impulse response of weighted synthesis filter */
+    Word16 x[],    /* (i): target                                        */
+    Word16 dn[],   /* (o): correlation between target and h[]            */
+    Word16 sf      /* (i): scaling factor: 2 for 12.2, 1 for others      */
+)
+{
+    cor_h_x2(h, x, dn, sf, NB_TRACK, STEP);
+}
+
+/*************************************************************************
+ *
+ *  FUNCTION:  cor_h_x2()
+ *
+ *  PURPOSE:  Computes correlation between target signal "x[]" and
+ *            impulse response"h[]".
+ *
+ *  DESCRIPTION:
+ *            See cor_h_x, d[n] can be normalized regards to sum of the
+ *            five MR122 maxima or the four MR102 maxima.
+ *
+ *************************************************************************/
+void cor_h_x2 (
+    Word16 h[],    /* (i): impulse response of weighted synthesis filter */
+    Word16 x[],    /* (i): target                                        */
+    Word16 dn[],   /* (o): correlation between target and h[]            */
+    Word16 sf,     /* (i): scaling factor: 2 for 12.2, 1 for others      */
+    Word16 nb_track,/* (i): the number of ACB tracks                     */
+    Word16 step    /* (i): step size from one pulse position to the next
+                           in one track                                  */
+)
+{
+    Word16 i, j, k;
+    Word32 s, y32[L_CODE], max, tot;
+
+    /* first keep the result on 32 bits and find absolute maximum */
+
+    tot = 5;                                     move32 (); 
+
+    for (k = 0; k < nb_track; k++)
+    {
+        max = 0;                                 move32 (); 
+        for (i = k; i < L_CODE; i += step)
+        {
+            s = 0;                               move32 (); 
+            for (j = i; j < L_CODE; j++)
+                s = L_mac (s, x[j], h[j - i]);
+            
+            y32[i] = s;                          move32 (); 
+            
+            s = L_abs (s);
+            test (); 
+            if (L_sub (s, max) > (Word32) 0L)
+                max = s;                         move32 (); 
+        }
+        tot = L_add (tot, L_shr (max, 1));
+    }
+    
+    j = sub (norm_l (tot), sf);
+    
+    for (i = 0; i < L_CODE; i++)
+    {
+        dn[i] = round (L_shl (y32[i], j));       move16 (); 
+    }
+}
+
+/*************************************************************************
+ *
+ *  FUNCTION:  cor_h()
+ *
+ *  PURPOSE:  Computes correlations of h[] needed for the codebook search;
+ *            and includes the sign information into the correlations.
+ *
+ *  DESCRIPTION: The correlations are given by
+ *         rr[i][j] = sum_{n=i}^{L-1} h[n-i] h[n-j];   i>=j; i,j=0,...,L-1
+ *
+ *  and the sign information is included by
+ *         rr[i][j] = rr[i][j]*sign[i]*sign[j]
+ *
+ *************************************************************************/
+
+void cor_h (
+    Word16 h[],         /* (i) : impulse response of weighted synthesis
+                                 filter                                  */
+    Word16 sign[],      /* (i) : sign of d[n]                            */
+    Word16 rr[][L_CODE] /* (o) : matrix of autocorrelation               */
+)
+{
+    Word16 i, j, k, dec, h2[L_CODE];
+    Word32 s;
+
+    /* Scaling for maximum precision */
+
+    s = 2;                                       move32 (); 
+    for (i = 0; i < L_CODE; i++)
+        s = L_mac (s, h[i], h[i]);
+    
+    j = sub (extract_h (s), 32767);
+    test (); 
+    if (j == 0)
+    {
+        for (i = 0; i < L_CODE; i++)
+        {
+            h2[i] = shr (h[i], 1);               move16 (); 
+        }
+    }
+    else
+    {
+        s = L_shr (s, 1);
+        k = extract_h (L_shl (Inv_sqrt (s), 7));
+        k = mult (k, 32440);                     /* k = 0.99*k */
+        
+        for (i = 0; i < L_CODE; i++)
+        {
+            h2[i] = round (L_shl (L_mult (h[i], k), 9));
+                                                 move16 (); 
+        }
+    }
+    
+    /* build matrix rr[] */
+    s = 0;                                       move32 (); 
+    i = L_CODE - 1;
+    for (k = 0; k < L_CODE; k++, i--)
+    {
+        s = L_mac (s, h2[k], h2[k]);
+        rr[i][i] = round (s);                    move16 (); 
+    }
+    
+    for (dec = 1; dec < L_CODE; dec++)
+    {
+        s = 0;                                   move32 (); 
+        j = L_CODE - 1;
+        i = sub (j, dec);
+        for (k = 0; k < (L_CODE - dec); k++, i--, j--)
+        {
+            s = L_mac (s, h2[k], h2[k + dec]);
+            rr[j][i] = mult (round (s), mult (sign[i], sign[j]));
+                                                 move16 (); 
+            rr[i][j] = rr[j][i];                 move16 (); 
+        }
+    }
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/cor_h.h FFMpeg-20050127-new/libavcodec/amr/cor_h.h
--- FFMpeg-20050127/libavcodec/amr/cor_h.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/cor_h.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,59 @@
+/*
+*****************************************************************************
+*                                                                     
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*                                                                     
+*****************************************************************************
+*                                                                     
+*      File             : cor_h.h                                     
+*      Purpose          : correlation functions for codebook search   
+*                                                                     
+*****************************************************************************
+*/                                                                    
+/*                                                                    
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID          
+*****************************************************************************
+*/
+#ifndef cor_h_h
+#define cor_h_h "@(#)$Id $"
+/*
+*****************************************************************************
+*                         INCLUDE FILES                                      
+*****************************************************************************
+*/                                                                           
+#include "typedef.h"                                                         
+#include "cnst.h"                                                            
+                                                                             
+/*                                                                           
+*****************************************************************************
+*                         DECLARATION OF PROTOTYPES                          
+*****************************************************************************
+*/
+void cor_h_x (
+    Word16 h[],     /* (i) : impulse response of weighted synthesis filter */
+    Word16 x[],     /* (i) : target                                        */
+    Word16 dn[],    /* (o) : correlation between target and h[]            */
+    Word16 sf       /* (i) : scaling factor: 2 for 12.2, 1 for 7.4         */
+);
+
+void cor_h_x2 (
+    Word16 h[],     /* (i) : impulse response of weighted synthesis filter */
+    Word16 x[],     /* (i) : target                                        */
+    Word16 dn[],    /* (o) : correlation between target and h[]            */
+    Word16 sf,      /* (i) : scaling factor: 2 for 12.2, 1 for 7.4         */
+    Word16 nb_track,/* (i) : the number of ACB tracks                      */
+    Word16 step     /* (i) : step size from one pulse position to the next
+                             in one track                                  */
+);
+
+void cor_h (
+    Word16 h[],     /* (i) : impulse response of weighted synthesis filter */
+    Word16 sign[],      /* (i) : sign of d[n]                              */
+    Word16 rr[][L_CODE] /* (o) : matrix of autocorrelation                 */
+);
+
+#endif
+  
diff -Nur FFMpeg-20050127/libavcodec/amr/corrwght.tab FFMpeg-20050127-new/libavcodec/amr/corrwght.tab
--- FFMpeg-20050127/libavcodec/amr/corrwght.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/corrwght.tab	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,52 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : corrwght.tab
+*      Purpose          : Tables for correlation weights
+*      $Id $
+*
+********************************************************************************
+*/
+static const Word16 corrweight[251] = {
+	20473,	20506,	20539,	20572,	20605,	20644,	20677,
+	20716,	20749,	20788,	20821,	20860,	20893,	20932,
+	20972,	21011,	21050,	21089,	21129,	21168,	21207,
+	21247,	21286,	21332,	21371,	21417,	21456,	21502,
+	21542,	21588,	21633,	21679,	21725,	21771,	21817,
+	21863,	21909,	21961,	22007,	22059,	22105,	22158,
+	22210,	22263,	22315,	22367,	22420,	22472,	22531,
+	22584,	22643,	22702,	22761,	22820,	22879,	22938,
+	23003,	23062,	23128,	23193,	23252,	23324,	23390,
+	23455,	23527,	23600,	23665,	23744,	23816,	23888,
+	23967,	24045,	24124,	24202,	24288,	24366,	24451,
+	24537,	24628,	24714,	24805,	24904,	24995,	25094,
+	25192,	25297,	25395,	25500,	25611,	25723,	25834,
+	25952,	26070,	26188,	26313,	26444,	26575,	26706,
+	26844,	26988,	27132,	27283,	27440,	27597,	27761,
+	27931,	28108,	28285,	28475,	28665,	28869,	29078,
+	29295,	29524,	29760,	30002,	30258,	30527,	30808,
+	31457,	32767,	32767,	32767,	32767,	32767,
+	32767,	32767,	31457,	30808,	30527,	30258,	30002,
+	29760,	29524,	29295,	29078,	28869,	28665,	28475,
+	28285,	28108,	27931,	27761,	27597,	27440,	27283,
+	27132,	26988,	26844,	26706,	26575,	26444,	26313,
+	26188,	26070,	25952,	25834,	25723,	25611,	25500,
+	25395,	25297,	25192,	25094,	24995,	24904,	24805,
+	24714,	24628,	24537,	24451,	24366,	24288,	24202,
+	24124,	24045,	23967,	23888,	23816,	23744,	23665,
+	23600,	23527,	23455,	23390,	23324,	23252,	23193,
+	23128,	23062,	23003,	22938,	22879,	22820,	22761,
+	22702,	22643,	22584,	22531,	22472,	22420,	22367,
+	22315,	22263,	22210,	22158,	22105,	22059,	22007,
+	21961,	21909,	21863,	21817,	21771,	21725,	21679,
+	21633,	21588,	21542,	21502,	21456,	21417,	21371,
+	21332,	21286,	21247,	21207,	21168,	21129,	21089,
+	21050,	21011,	20972,	20932,	20893,	20860,	20821,
+	20788,	20749,	20716,	20677,	20644,	20605,	20572,
+	20539,	20506,	20473,	20434,	20401,	20369,	20336};
diff -Nur FFMpeg-20050127/libavcodec/amr/count.c FFMpeg-20050127-new/libavcodec/amr/count.c
--- FFMpeg-20050127/libavcodec/amr/count.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/count.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,294 @@
+/***********************************************************************
+ *
+ *   This file contains functions for the automatic complexity calculation
+ * $Id $
+ *************************************************************************/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include "typedef.h"
+#include "count.h"
+
+/* Global counter variable for calculation of complexity weight */
+
+BASIC_OP multiCounter[MAXCOUNTERS];
+int currCounter=0; /* Zero equals global counter */
+
+/*BASIC_OP counter;*/
+const BASIC_OP op_weight =
+{
+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+    3, 3, 3, 4, 15, 18, 30, 1, 2, 1, 2, 2
+};
+
+/* function prototypes */
+Word32 TotalWeightedOperation (void);
+Word32 DeltaWeightedOperation (void);
+
+/* local variable */
+#if WMOPS
+
+/* Counters for separating counting for different objects */
+static int maxCounter=0;
+static char* objectName[MAXCOUNTERS+1];
+static Word16 fwc_corr[MAXCOUNTERS+1];
+
+#define NbFuncMax  1024
+
+static Word16 funcid[MAXCOUNTERS], nbframe[MAXCOUNTERS];
+static Word32 glob_wc[MAXCOUNTERS], wc[MAXCOUNTERS][NbFuncMax];
+static float total_wmops[MAXCOUNTERS];
+
+static Word32 LastWOper[MAXCOUNTERS];
+
+static char* my_strdup(const char *s)
+/*
+ * duplicates UNIX function strdup() which is not ANSI standard:
+ * -- malloc() memory area big enough to hold the string s
+ * -- copy string into new area
+ * -- return pointer to new area
+ *
+ * returns NULL if either s==NULL or malloc() fails
+ */
+{
+    char *dup;
+    
+    if (s == NULL)
+        return NULL;
+
+    /* allocate memory for copy of ID string (including string terminator) */
+    /* NOTE: the ID strings will never be deallocated because there is no
+             way to "destroy" a counter that is not longer needed          */
+    if ((dup = (char *) malloc(strlen(s)+1)) == NULL)
+        return NULL;
+
+    return strcpy(dup, s);
+}
+
+#endif
+
+int getCounterId(char *objectNameArg)
+{
+#if WMOPS
+  if(maxCounter>=MAXCOUNTERS-1) return 0;
+  objectName[++maxCounter]=my_strdup(objectNameArg);
+  return maxCounter;
+#else
+  return 0; /* Dummy */
+#endif
+}
+
+void setCounter(int counterId)
+{
+#if WMOPS
+  if(counterId>maxCounter || counterId<0)
+    {
+      currCounter=0;
+      return;
+    }
+  currCounter=counterId;
+#endif
+}
+
+#if WMOPS
+static Word32 WMOPS_frameStat()
+/* calculate the WMOPS seen so far and update the global
+   per-frame maximum (glob_wc)
+ */
+{
+    Word32 tot;
+
+    tot = TotalWeightedOperation ();
+    if (tot > glob_wc[currCounter])
+        glob_wc[currCounter] = tot;
+
+    /* check if fwc() was forgotten at end of last frame */
+    if (tot > LastWOper[currCounter]) {
+        if (!fwc_corr[currCounter]) {
+            fprintf(stderr,
+                    "count: operations counted after last fwc() for '%s'; "
+                    "-> fwc() called\n",
+                    objectName[currCounter]?objectName[currCounter]:"");
+        }
+        fwc();
+    }
+    
+    return tot;
+}
+
+static void WMOPS_clearMultiCounter()
+{
+    Word16 i;
+    
+    Word32 *ptr = (Word32 *) &multiCounter[currCounter];
+    for (i = 0; i < (sizeof (multiCounter[currCounter])/ sizeof (Word32)); i++)
+    {
+        *ptr++ = 0;
+    }
+}
+#endif
+
+Word32 TotalWeightedOperation ()
+{
+#if WMOPS
+    Word16 i;
+    Word32 tot, *ptr, *ptr2;
+
+    tot = 0;
+    ptr = (Word32 *) &multiCounter[currCounter];
+    ptr2 = (Word32 *) &op_weight;
+    for (i = 0; i < (sizeof (multiCounter[currCounter])/ sizeof (Word32)); i++)
+    {
+        tot += ((*ptr++) * (*ptr2++));
+    }
+
+    return ((Word32) tot);
+#else
+    return 0; /* Dummy */
+#endif
+}
+
+Word32 DeltaWeightedOperation ()
+{
+#if WMOPS
+    Word32 NewWOper, delta;
+
+    NewWOper = TotalWeightedOperation ();
+    delta = NewWOper - LastWOper[currCounter];
+    LastWOper[currCounter] = NewWOper;
+    return (delta);
+#else
+    return 0; /* Dummy */
+#endif
+}
+
+void move16 (void)
+{
+#if WMOPS
+    multiCounter[currCounter].DataMove16++;
+#endif
+}
+
+void move32 (void)
+{
+#if WMOPS
+    multiCounter[currCounter].DataMove32++;
+#endif
+}
+
+void test (void)
+{
+#if WMOPS
+    multiCounter[currCounter].Test++;
+#endif
+}
+
+void logic16 (void)
+{
+#if WMOPS
+    multiCounter[currCounter].Logic16++;
+#endif
+}
+
+void logic32 (void)
+{
+#if WMOPS
+    multiCounter[currCounter].Logic32++;
+#endif
+}
+
+void Init_WMOPS_counter (void)
+{
+#if WMOPS
+    Word16 i;
+
+    /* reset function weight operation counter variable */
+
+    for (i = 0; i < NbFuncMax; i++)
+        wc[currCounter][i] = (Word32) 0;
+    glob_wc[currCounter] = 0;
+    nbframe[currCounter] = 0;
+    total_wmops[currCounter] = 0.0;
+
+    /* initially clear all counters */
+    WMOPS_clearMultiCounter();
+    LastWOper[currCounter] = 0;
+    funcid[currCounter] = 0;
+#endif
+}
+
+
+void Reset_WMOPS_counter (void)
+{
+#if WMOPS
+    Word32 tot = WMOPS_frameStat();
+        
+    /* increase the frame counter --> a frame is counted WHEN IT BEGINS */
+    nbframe[currCounter]++;
+    /* add wmops used in last frame to count, then reset counter */
+    /* (in first frame, this is a no-op                          */
+    total_wmops[currCounter] += ((float) tot) * 0.00005;
+    
+    /* clear counter before new frame starts */
+    WMOPS_clearMultiCounter();
+    LastWOper[currCounter] = 0;
+    funcid[currCounter] = 0;           /* new frame, set function id to zero */
+#endif
+}
+
+Word32 fwc (void)                      /* function worst case */
+{
+#if WMOPS
+    Word32 tot;
+
+    tot = DeltaWeightedOperation ();
+    if (tot > wc[currCounter][funcid[currCounter]])
+        wc[currCounter][funcid[currCounter]] = tot;
+
+    funcid[currCounter]++;
+
+    return (tot);
+#else
+    return 0; /* Dummy */
+#endif
+}
+
+void WMOPS_output (Word16 dtx_mode)
+{
+#if WMOPS
+    Word16 i;
+    Word32 tot, tot_wm, tot_wc;
+
+    /* get operations since last reset (or init),
+       but do not update the counters (except the glob_wc[] maximum)
+       so output CAN be called in each frame without problems.
+       The frame counter is NOT updated!
+     */
+    tot = WMOPS_frameStat();
+    tot_wm = total_wmops[currCounter] + ((float) tot) * 0.00005;
+
+    fprintf (stdout, "%10s:WMOPS=%.3f",
+	     objectName[currCounter]?objectName[currCounter]:"",
+	     ((float) tot) * 0.00005);
+
+    if (nbframe[currCounter] != 0)
+        fprintf (stdout, "  Average=%.3f",
+                 tot_wm / (float) nbframe[currCounter]);
+    
+    fprintf (stdout, "  WorstCase=%.3f",
+             ((float) glob_wc[currCounter]) * 0.00005);
+
+    /* Worst worst case printed only when not in DTX mode */
+    if (dtx_mode == 0)
+    {
+        tot_wc = 0L;
+        for (i = 0; i < funcid[currCounter]; i++)
+            tot_wc += wc[currCounter][i];
+        fprintf (stdout, "  WorstWC=%.3f", ((float) tot_wc) * 0.00005);
+    }
+    fprintf (stdout, " (%d frames)\n", nbframe[currCounter]);
+    
+#endif
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/count.h FFMpeg-20050127-new/libavcodec/amr/count.h
--- FFMpeg-20050127/libavcodec/amr/count.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/count.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,174 @@
+/*
+ * functions for counting operations
+ *
+ * These functions, and the ones in basic_op.h, makes it possible to measure
+ * the wMOPS of a codec.
+ *
+ * All functions in this file, and in basic_op.h, uppdates a structure so that
+ * it will be possible the see how many calls to add, mul mulAdd ... that the
+ * code made, and estimate the wMOPS (and MIPS) for a sertain part of code
+ *
+ * It is also possible to measure the wMOPS separatly for different parts
+ * of the codec.
+ *
+ * This is done by creating a counter group (getCounterId) for each part of the
+ * code that one wants a separte measure for. Before a part of the code
+ * is executed a call to the "setCounter" function is needed to identify
+ * which counter group to use.
+ *
+ * Currently there is a limit of 255 different counter groups.
+ *
+ * In the end of this file there is a pice of code illustration how the
+ * functions can be used.
+ */
+#ifndef count_h
+#define count_h "$Id $"
+
+#define MAXCOUNTERS 256
+
+int getCounterId(char *objectName);
+/*
+ * Create a counter group, the "objectname" will be used when printing
+ * statistics for this counter group.
+ *
+ * Returns 0 if no more counter groups are available.
+ */
+
+void setCounter(int counterId);
+/*
+ * Defines which counter group to use, default is zero.
+ */
+
+void Init_WMOPS_counter (void);
+/*
+ * Initiates the current counter group.
+ */
+
+void Reset_WMOPS_counter (void);
+/*
+ * Resets the current counter group.
+ */
+
+void WMOPS_output (Word16 notPrintWorstWorstCase);
+/*
+ * Prints the statistics to the screen, if the argument if non zero
+ * the statistics for worst worst case will not be printed. This is typically
+ * done for dtx frames.
+ *
+ */
+
+Word32 fwc (void);
+/*
+ * worst worst case counter.
+ *
+ * This function calculates the worst possible case that can be reached.
+ *
+ * This is done by calling this function for each subpart of the calculations
+ * for a frame. This function then stores the maximum wMOPS for each part.
+ *
+ * The WMOPS_output function add together all parts and presents the sum.
+ */
+
+void move16 (void);
+void move32 (void);
+void logic16 (void);
+void logic32 (void);
+void test (void);
+/*
+ * The functions above increases the corresponding operation counter for
+ * the current counter group.
+ */
+
+typedef struct
+{
+    Word32 add;        /* Complexity Weight of 1 */
+    Word32 sub;
+    Word32 abs_s;
+    Word32 shl;
+    Word32 shr;
+    Word32 extract_h;
+    Word32 extract_l;
+    Word32 mult;
+    Word32 L_mult;
+    Word32 negate;
+    Word32 round;
+    Word32 L_mac;
+    Word32 L_msu;
+    Word32 L_macNs;
+    Word32 L_msuNs;
+    Word32 L_add;      /* Complexity Weight of 2 */
+    Word32 L_sub;
+    Word32 L_add_c;
+    Word32 L_sub_c;
+    Word32 L_negate;
+    Word32 L_shl;
+    Word32 L_shr;
+    Word32 mult_r;
+    Word32 shr_r;
+    Word32 shift_r;
+    Word32 mac_r;
+    Word32 msu_r;
+    Word32 L_deposit_h;
+    Word32 L_deposit_l;
+    Word32 L_shr_r;    /* Complexity Weight of 3 */
+    Word32 L_shift_r;
+    Word32 L_abs;
+    Word32 L_sat;      /* Complexity Weight of 4 */
+    Word32 norm_s;     /* Complexity Weight of 15 */
+    Word32 div_s;      /* Complexity Weight of 18 */
+    Word32 norm_l;     /* Complexity Weight of 30 */
+    Word32 DataMove16; /* Complexity Weight of 1 */
+    Word32 DataMove32; /* Complexity Weight of 2 */
+    Word32 Logic16;    /* Complexity Weight of 1 */
+    Word32 Logic32;    /* Complexity Weight of 2 */
+    Word32 Test;       /* Complexity Weight of 2 */
+}
+BASIC_OP;
+
+/*
+ * Example of how count.h could be used.
+ *
+ * In the example below it is assumed that the init_OBJECT functions
+ * does not use any calls to counter.h or basic_op.h. If this is the case
+ * a call to the function Reset_WMOPS_counter() must be done after each call
+ * to init_OBJECT if these operations is not to be included in the statistics.
+
+int main(){ 
+ int spe1Id,spe2Id,cheId;
+ 
+ // initiate counters and objects 
+ spe1Id=getCounterId("Spe 5k8"); 
+ setCounter(spe1Id); 
+ Init_WMOPS_counter (); 
+ init_spe1(...);
+ 
+ spe2Id=getCounterId("Spe 12k2"); 
+ setCounter(spe2Id); 
+ Init_WMOPS_counter (); 
+ init_spe2(...);
+ 
+ cheId=getCounterId("Channel encoder"); 
+ setCounter(cheId); 
+ Init_WMOPS_counter (); 
+ init_che(...); 
+ ... 
+ while(data){ 
+    test();             // Note this call to test();
+    if(useSpe1)
+        setCounter(spe1Id); 
+    else 
+        setCounter(spe2Id); 
+    Reset_WMOPS_counter();
+    speEncode(...);
+    WMOPS_output(0);    // Normal routine for displaying WMOPS info
+    
+    setCounter(cheId); 
+    Reset_WMOPS_counter();
+    preChannelInter(...); fwc(); // Note the call to fwc() for each part
+    convolve(...); fwc();        // of the channel encoder.
+    interleave(...); fwc();
+    WMOPS_output(0);    // Normal routine for displaying WMOPS info
+}
+*/
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/d1035pf.c FFMpeg-20050127-new/libavcodec/amr/d1035pf.c
--- FFMpeg-20050127/libavcodec/amr/d1035pf.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d1035pf.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,114 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : d1035pf.c
+*      Purpose          : Builds the innovative codevector
+*
+********************************************************************************
+*/
+ 
+ 
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "d1035pf.h"
+const char d1035pf_id[] = "@(#)$Id $" d1035pf_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#define NB_PULSE  10            /* number of pulses  */
+
+#include "gray.tab"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:   dec_10i40_35bits()
+ *
+ *  PURPOSE:  Builds the innovative codevector from the received
+ *            index of algebraic codebook.
+ *
+ *   See  c1035pf.c  for more details about the algebraic codebook structure.
+ *
+ *************************************************************************/
+void dec_10i40_35bits (
+    Word16 index[],    /* (i)     : index of 10 pulses (sign+position)       */
+    Word16 cod[]       /* (o)     : algebraic (fixed) codebook excitation    */
+)
+{
+    Word16 i, j, pos1, pos2, sign, tmp;
+
+    for (i = 0; i < L_CODE; i++)
+    {
+        cod[i] = 0;                                     move16 (); 
+    }
+
+    /* decode the positions and signs of pulses and build the codeword */
+
+    for (j = 0; j < NB_TRACK; j++)
+    {
+        /* compute index i */
+
+        tmp = index[j];                                 move16 ();
+        i = tmp & 7;                                    logic16 (); 
+        i = dgray[i];                                   move16 (); 
+
+        i = extract_l (L_shr (L_mult (i, 5), 1));
+        pos1 = add (i, j); /* position of pulse "j" */
+
+        i = shr (tmp, 3) & 1;                           logic16 (); 
+        test (); 
+        if (i == 0)
+        {
+            sign = 4096;                                move16 (); /* +1.0 */
+        }
+        else
+        {
+            sign = -4096;                               move16 (); /* -1.0 */
+        }
+
+        cod[pos1] = sign;                               move16 (); 
+
+        /* compute index i */
+
+        i = index[add (j, 5)] & 7;                      logic16 (); 
+        i = dgray[i];                                   move16 (); 
+        i = extract_l (L_shr (L_mult (i, 5), 1));
+
+        pos2 = add (i, j);      /* position of pulse "j+5" */
+
+        test (); 
+        if (sub (pos2, pos1) < 0)
+        {
+            sign = negate (sign);
+        }
+        cod[pos2] = add (cod[pos2], sign);              move16 (); 
+    }
+
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/d1035pf.h FFMpeg-20050127-new/libavcodec/amr/d1035pf.h
--- FFMpeg-20050127/libavcodec/amr/d1035pf.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d1035pf.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,41 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : d1035pf.h
+*      Purpose          : Builds the innovative codevector
+*
+********************************************************************************
+*/
+#ifndef d1035pf_h
+#define d1035pf_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/ 
+void dec_10i40_35bits (
+    Word16 index[],    /* (i)   : index of 10 pulses (sign+position)        */
+    Word16 cod[]       /* (o)   : algebraic (fixed) codebook excitation     */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/d2_11pf.c FFMpeg-20050127-new/libavcodec/amr/d2_11pf.c
--- FFMpeg-20050127/libavcodec/amr/d2_11pf.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d2_11pf.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,110 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : d2_11pf.c
+*      Purpose          : Algebraic codebook decoder
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "d2_11pf.h"
+const char d2_11pf_c_id[] = "@(#)$Id $" d2_11pf_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#define NB_PULSE 2           /* number of pulses */
+ 
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  decode_2i40_11bits (decod_ACELP())
+ *
+ *  PURPOSE:   Algebraic codebook decoder
+ *
+ *************************************************************************/
+
+void decode_2i40_11bits(
+    Word16 sign,   /* i : signs of 2 pulses.                       */
+    Word16 index,  /* i : Positions of the 2 pulses.               */
+    Word16 cod[]   /* o : algebraic (fixed) codebook excitation    */
+)
+{
+    Word16 i, j;
+    Word16 pos[NB_PULSE];
+
+    /* Decode the positions */
+
+    j = index & 1;                                       logic16 ();
+    index = shr(index, 1);
+    i = index & 7;                                       logic16 ();
+
+    i = add(i, shl(i, 2));        /* pos0 =i*5+1+j*2 */
+    i = add(i, 1);
+    j = shl(j, 1);  
+    pos[0] = add(i, j);                                  move16 ();
+       
+    index = shr(index, 3);
+    j = index & 3;                                       logic16 ();
+    index = shr(index, 2);
+    i = index & 7;                                       logic16 ();
+
+    test();
+	if (sub(j, 3) == 0)
+    {       
+       i = add(i, shl(i, 2));        /* pos1 =i*5+4 */
+       pos[1] = add(i, 4);                               move16 ();
+    }
+    else
+    {       
+       i = add(i, shl(i, 2));        /* pos1 =i*5+j */
+       pos[1] = add(i, j);                               move16 ();
+    }
+       
+    /* decode the signs  and build the codeword */
+
+    for (i = 0; i < L_SUBFR; i++) {
+        cod[i] = 0;                                      move16 ();
+    }
+
+    for (j = 0; j < NB_PULSE; j++) {
+        i = sign & 1;                                    logic16 ();
+        sign = shr(sign, 1);
+
+        test ();
+        if (i != 0) {
+            cod[pos[j]] = 8191;                          move16 (); /* +1.0 */
+        } else {
+            cod[pos[j]] = -8192;                         move16 (); /* -1.0 */
+        }
+    }
+
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/d2_11pf.h FFMpeg-20050127-new/libavcodec/amr/d2_11pf.h
--- FFMpeg-20050127/libavcodec/amr/d2_11pf.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d2_11pf.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,56 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : d2_11pf.h
+*      Purpose          : Algebraic codebook decoder
+*
+********************************************************************************
+*/
+#ifndef d2_11pf_h
+#define d2_11pf_h "$Id $"
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  decode_2i40_11bits (decod_ACELP())
+ *
+ *  PURPOSE:   Algebraic codebook decoder for 2 pulses coded with 11 bits
+ *
+ *************************************************************************/
+
+void decode_2i40_11bits(
+    Word16 sign,   /* i : signs of 2 pulses.                       */
+    Word16 index,  /* i : Positions of the 2 pulses.               */
+    Word16 cod[]   /* o : algebraic (fixed) codebook excitation    */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/d2_9pf.c FFMpeg-20050127-new/libavcodec/amr/d2_9pf.c
--- FFMpeg-20050127/libavcodec/amr/d2_9pf.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d2_9pf.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,103 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : d2_9pf.c
+*      Purpose          : Algebraic codebook decoder
+*
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "d2_9pf.h"
+const char d2_9pf_c_id[] = "@(#)$Id $" d2_9pf_h;
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#define NB_PULSE 2           /* number of pulses */
+ 
+#include "c2_9pf.tab"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  decode_2i40_9bits (decod_ACELP())
+ *
+ *  PURPOSE:   Algebraic codebook decoder. For details about the encoding se
+ *             c2_9pf.c
+ *
+ *************************************************************************/
+
+void decode_2i40_9bits(
+    Word16 subNr,  /* i : subframe number                          */
+    Word16 sign,   /* i : signs of 2 pulses.                       */
+    Word16 index,  /* i : Positions of the 2 pulses.               */
+    Word16 cod[]   /* o : algebraic (fixed) codebook excitation    */
+)
+{
+    Word16 i, j, k;
+    Word16 pos[NB_PULSE];
+
+    /* Decode the positions */
+    /* table bit  is the MSB */ 
+    j = shr((index & 64),6);                                 logic16 ();
+
+    i = index & 7;                                       logic16 ();
+
+    i = add(i, shl(i, 2));       /* pos0 =i*5+startPos[j*8+subNr*2] */
+    k = startPos[add(shl(j, 3), shl(subNr, 1))];
+    pos[0] = add(i, k);                                  move16 ();    
+
+    index = shr(index, 3);
+    i = index & 7;                                       logic16 ();
+
+    i = add(i, shl(i, 2));       /* pos1 =i*5+startPos[j*8+subNr*2+1] */
+    k = startPos[add(add(shl(j, 3), shl(subNr, 1)), 1)];
+    pos[1] = add(i, k);                                  move16 ();
+
+    /* decode the signs  and build the codeword */
+
+    for (i = 0; i < L_SUBFR; i++) {
+        cod[i] = 0;                                      move16 ();
+    }
+
+    for (j = 0; j < NB_PULSE; j++) {
+        i = sign & 1;                                    logic16 ();
+        sign = shr(sign, 1);
+
+        test ();
+        if (i != 0) {
+            cod[pos[j]] = 8191;                          move16 (); /* +1.0 */
+        } else {
+            cod[pos[j]] = -8192;                         move16 (); /* -1.0 */
+        }
+    }
+
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/d2_9pf.h FFMpeg-20050127-new/libavcodec/amr/d2_9pf.h
--- FFMpeg-20050127/libavcodec/amr/d2_9pf.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d2_9pf.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,57 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : d2_9pf.h
+*      Purpose          : Algebraic codebook decoder
+*
+*****************************************************************************
+*/
+#ifndef d2_9pf_h
+#define d2_9pf_h "$Id $"
+
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include "typedef.h"
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+ 
+/*
+*****************************************************************************
+*                         DEFINITION OF DATA TYPES
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         DECLARATION OF PROTOTYPES
+*****************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  decode_2i40_9bits (decod_ACELP())
+ *
+ *  PURPOSE:   Algebraic codebook decoder for 2 pulses coded with 9 bits
+ *
+ *************************************************************************/
+
+void decode_2i40_9bits(
+    Word16 subNr,  /* i : subframe number                          */
+    Word16 sign,   /* i : signs of 2 pulses.                       */
+    Word16 index,  /* i : Positions of the 2 pulses.               */
+    Word16 cod[]   /* o : algebraic (fixed) codebook excitation    */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/d3_14pf.c FFMpeg-20050127-new/libavcodec/amr/d3_14pf.c
--- FFMpeg-20050127/libavcodec/amr/d3_14pf.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d3_14pf.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,108 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : d3_14pf.c
+*      Purpose          : Algebraic codebook decoder
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "d3_14pf.h"
+const char d3_14pf_c_id[] = "@(#)$Id $" d3_14pf_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#define NB_PULSE 3           /* number of pulses  */
+ 
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  decode_3i40_14bits (decod_ACELP())
+ *
+ *  PURPOSE:   Algebraic codebook decoder
+ *
+ *************************************************************************/
+
+void decode_3i40_14bits(
+    Word16 sign,   /* i : signs of 3 pulses.                       */
+    Word16 index,  /* i : Positions of the 3 pulses.               */
+    Word16 cod[]   /* o : algebraic (fixed) codebook excitation    */
+)
+{
+    Word16 i, j;
+    Word16 pos[NB_PULSE];
+
+    /* Decode the positions */
+
+    i = index & 7;                                       logic16 ();
+
+    pos[0] = add(i, shl(i, 2));   /* pos0 =i*5 */        move16 ();
+
+    index = shr(index, 3);
+    j = index & 1;                                       logic16 ();
+    index = shr(index, 1);
+    i = index & 7;                                       logic16 ();
+
+    i = add(i, shl(i, 2));        /* pos1 =i*5+1+j*2 */
+    i = add(i, 1);
+    j = shl(j, 1);     
+    pos[1] = add(i, j);                                  move16 ();
+
+    index = shr(index, 3);
+    j = index & 1;                                       logic16 ();
+    index = shr(index, 1);
+    i = index & 7;                                       logic16 ();
+
+    i = add(i, shl(i, 2));        /* pos2 =i*5+2+j*2 */
+    i = add(i, 2); 
+    j = shl(j, 1); 
+    pos[2] = add(i, j);                                  move16 ();
+
+    /* decode the signs  and build the codeword */
+
+    for (i = 0; i < L_SUBFR; i++) {
+        cod[i] = 0;                                      move16 ();
+    }
+
+    for (j = 0; j < NB_PULSE; j++) {
+        i = sign & 1;                                    logic16 ();
+        sign = shr(sign, 1);
+
+        test ();
+        if (i > 0) {
+            cod[pos[j]] = 8191;                          move16 (); /* +1.0 */
+        } else {
+            cod[pos[j]] = -8192;                         move16 (); /* -1.0 */
+        }
+    }
+
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/d3_14pf.h FFMpeg-20050127-new/libavcodec/amr/d3_14pf.h
--- FFMpeg-20050127/libavcodec/amr/d3_14pf.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d3_14pf.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,56 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : d3_14pf.h
+*      Purpose          : Algebraic codebook decoder
+*
+********************************************************************************
+*/
+#ifndef d3_14pf_h
+#define d3_14pf_h "$Id $"
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  decode_3i40_14bits (decod_ACELP())
+ *
+ *  PURPOSE:   Algebraic codebook decoder for 3 pulses coded with 14 bits
+ *
+ *************************************************************************/
+
+void decode_3i40_14bits(
+    Word16 sign,   /* i : signs of 3 pulses.                       */
+    Word16 index,  /* i : Positions of the 3 pulses.               */
+    Word16 cod[]   /* o : algebraic (fixed) codebook excitation    */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/d4_17pf.c FFMpeg-20050127-new/libavcodec/amr/d4_17pf.c
--- FFMpeg-20050127/libavcodec/amr/d4_17pf.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d4_17pf.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,115 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : d4_17pf.c
+*      Purpose          : Algebraic codebook decoder
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "d4_17pf.h"
+const char d4_17pf_c_id[] = "@(#)$Id $" d4_17pf_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#define NB_PULSE 4
+
+#include "gray.tab"
+ 
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  decod_ACELP()
+ *
+ *  PURPOSE:   Algebraic codebook decoder
+ *
+ *************************************************************************/
+
+void decode_4i40_17bits(
+    Word16 sign,   /* i : signs of 4 pulses.                       */
+    Word16 index,  /* i : Positions of the 4 pulses.               */
+    Word16 cod[]   /* o : algebraic (fixed) codebook excitation    */
+)
+{
+    Word16 i, j;
+    Word16 pos[NB_PULSE];
+
+    /* Decode the positions */
+
+    i = index & 7;                                       logic16 ();
+    i = dgray[i];                                        move16 ();
+
+    pos[0] = add(i, shl(i, 2));   /* pos0 =i*5 */        move16 ();
+
+    index = shr(index, 3);
+    i = index & 7;                                       logic16 ();
+    i = dgray[i];                                        move16 ();
+
+    i = add(i, shl(i, 2));        /* pos1 =i*5+1 */
+    pos[1] = add(i, 1);                                  move16 ();
+
+    index = shr(index, 3);
+    i = index & 7;                                       logic16 ();
+    i = dgray[i];                                        move16 ();
+
+    i = add(i, shl(i, 2));        /* pos2 =i*5+1 */
+    pos[2] = add(i, 2);                                  move16 ();
+
+    index = shr(index, 3);
+    j = index & 1;                                       logic16 ();
+    index = shr(index, 1);
+    i = index & 7;                                       logic16 ();
+    i = dgray[i];                                        move16 ();
+
+    i = add(i, shl(i, 2));        /* pos3 =i*5+3+j */
+    i = add(i, 3);
+    pos[3] = add(i, j);                                  move16 ();
+
+    /* decode the signs  and build the codeword */
+
+    for (i = 0; i < L_SUBFR; i++) {
+        cod[i] = 0;                                      move16 ();
+    }
+
+    for (j = 0; j < NB_PULSE; j++) {
+        i = sign & 1;                                    logic16 ();
+        sign = shr(sign, 1);
+
+        test ();
+        if (i != 0) {
+            cod[pos[j]] = 8191;                          move16 ();
+        } else {
+            cod[pos[j]] = -8192;                         move16 ();
+        }
+    }
+
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/d4_17pf.h FFMpeg-20050127-new/libavcodec/amr/d4_17pf.h
--- FFMpeg-20050127/libavcodec/amr/d4_17pf.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d4_17pf.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,56 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : d4_17pf.h
+*      Purpose          : Algebraic codebook decoder
+*
+********************************************************************************
+*/
+#ifndef d4_17pf_h
+#define d4_17pf_h "$Id $"
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  decod_ACELP()
+ *
+ *  PURPOSE:   Algebraic codebook decoder
+ *
+ *************************************************************************/
+
+void decode_4i40_17bits(
+    Word16 sign,   /* i : signs of 4 pulses.                       */
+    Word16 index,  /* i : Positions of the 4 pulses.               */
+    Word16 cod[]   /* o : algebraic (fixed) codebook excitation    */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/d8_31pf.c FFMpeg-20050127-new/libavcodec/amr/d8_31pf.c
--- FFMpeg-20050127/libavcodec/amr/d8_31pf.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d8_31pf.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,226 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : d8_31pf.c
+*      Purpose          : Builds the innovative codevector
+*
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "d8_31pf.h"
+const char d8_31pf_id[] = "@(#)$Id $" d8_31pf_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#define NB_PULSE  8           /* number of pulses  */
+
+/* define values/representation for output codevector and sign */
+#define POS_CODE  8191 
+#define NEG_CODE  8191 
+
+static void decompress10 (
+   Word16 MSBs,        /* i : MSB part of the index                 */
+   Word16 LSBs,        /* i : LSB part of the index                 */
+   Word16 index1,      /* i : index for first pos in pos_index[]    */ 
+   Word16 index2,      /* i : index for second pos in pos_index[]   */ 
+   Word16 index3,      /* i : index for third pos in pos_index[]    */ 
+   Word16 pos_indx[])  /* o : position of 3 pulses (decompressed)   */
+{
+   Word16 ia, ib, ic;
+
+   /*
+     pos_indx[index1] = ((MSBs-25*(MSBs/25))%5)*2 + (LSBs-4*(LSBs/4))%2;
+     pos_indx[index2] = ((MSBs-25*(MSBs/25))/5)*2 + (LSBs-4*(LSBs/4))/2;
+     pos_indx[index3] = (MSBs/25)*2 + LSBs/4;
+     */
+
+   test ();
+   if (sub(MSBs, 124) > 0)
+   {
+      MSBs = 124;                                              move16 (); 
+   }
+   
+   ia = mult(MSBs, 1311);
+   ia = sub(MSBs, extract_l(L_shr(L_mult(ia, 25), 1)));    
+   ib = shl(sub(ia, extract_l(L_shr(L_mult(mult(ia, 6554), 5), 1))), 1);
+   
+   ic = shl(shr(LSBs, 2), 2);
+   ic = sub(LSBs, ic);
+   pos_indx[index1] = add(ib, (ic & 1));                        logic16 ();
+   
+   ib = shl(mult(ia, 6554), 1);
+   pos_indx[index2] = add(ib, shr(ic, 1));
+   
+   pos_indx[index3] = add(shl(mult(MSBs, 1311), 1), shr(LSBs, 2));    
+
+   return;
+}    
+
+/*************************************************************************
+ *
+ *  FUNCTION:  decompress_code()
+ *
+ *  PURPOSE: decompression of the linear codewords to 4+three indeces  
+ *           one bit from each pulse is made robust to errors by 
+ *           minimizing the phase shift of a bit error.
+ *           4 signs (one for each track) 
+ *           i0,i4,i1 => one index (7+3) bits, 3   LSBs more robust
+ *           i2,i6,i5 => one index (7+3) bits, 3   LSBs more robust
+ *           i3,i7    => one index (5+2) bits, 2-3 LSbs more robust
+ *
+ *************************************************************************/
+static void decompress_code (
+    Word16 indx[],      /* i : position and sign of 8 pulses (compressed) */
+    Word16 sign_indx[], /* o : signs of 4 pulses (signs only)             */
+    Word16 pos_indx[]   /* o : position index of 8 pulses (position only) */
+)
+{
+    Word16 i, ia, ib, MSBs, LSBs, MSBs0_24;
+
+    for (i = 0; i < NB_TRACK_MR102; i++)
+    {
+       sign_indx[i] = indx[i];                                  move16 (); 
+    }
+    
+    /*
+      First index: 10x10x10 -> 2x5x2x5x2x5-> 125x2x2x2 -> 7+1x3 bits 
+      MSBs = indx[NB_TRACK]/8;
+      LSBs = indx[NB_TRACK]%8;
+      */
+    MSBs = shr(indx[NB_TRACK_MR102], 3);
+    LSBs = indx[NB_TRACK_MR102] & 7;                            logic16 ();
+    decompress10 (MSBs, LSBs, 0, 4, 1, pos_indx);               
+    
+    /*
+      Second index: 10x10x10 -> 2x5x2x5x2x5-> 125x2x2x2 -> 7+1x3 bits       
+      MSBs = indx[NB_TRACK+1]/8;
+      LSBs = indx[NB_TRACK+1]%8;
+      */
+    MSBs = shr(indx[NB_TRACK_MR102+1], 3);
+    LSBs = indx[NB_TRACK_MR102+1] & 7;                          logic16 ();
+    decompress10 (MSBs, LSBs, 2, 6, 5, pos_indx);               
+    
+    /*
+      Third index: 10x10 -> 2x5x2x5-> 25x2x2 -> 5+1x2 bits    
+      MSBs = indx[NB_TRACK+2]/4;
+      LSBs = indx[NB_TRACK+2]%4;
+      MSBs0_24 = (MSBs*25+12)/32;
+      if ((MSBs0_24/5)%2==1)
+         pos_indx[3] = (4-(MSBs0_24%5))*2 + LSBs%2;
+      else
+         pos_indx[3] = (MSBs0_24%5)*2 + LSBs%2;
+      pos_indx[7] = (MSBs0_24/5)*2 + LSBs/2;
+      */
+    MSBs = shr(indx[NB_TRACK_MR102+2], 2);
+    LSBs = indx[NB_TRACK_MR102+2] & 3;                          logic16 ();
+
+    MSBs0_24 = shr(add(extract_l(L_shr(L_mult(MSBs, 25), 1)), 12), 5);
+    
+    ia = mult(MSBs0_24, 6554) & 1;
+    ib = sub(MSBs0_24, extract_l(L_shr(L_mult(mult(MSBs0_24, 6554), 5), 1)));
+
+    test ();
+    if (sub(ia, 1) == 0)
+    {
+       ib = sub(4, ib);
+    }
+    pos_indx[3] = add(shl(ib, 1), (LSBs & 1));               logic16 ();           
+    
+    ia = shl(mult(MSBs0_24, 6554), 1);
+    pos_indx[7] = add(ia, shr(LSBs, 1));
+}
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:   dec_8i40_31bits()
+ *
+ *  PURPOSE:  Builds the innovative codevector from the received
+ *            index of algebraic codebook.
+ *
+ *   See  c8_31pf.c  for more details about the algebraic codebook structure.
+ *
+ *************************************************************************/
+
+void dec_8i40_31bits (
+    Word16 index[],    /* i : index of 8 pulses (sign+position)         */
+    Word16 cod[]       /* o : algebraic (fixed) codebook excitation     */
+)
+{
+    Word16 i, j, pos1, pos2, sign;
+    Word16 linear_signs[NB_TRACK_MR102];
+    Word16 linear_codewords[NB_PULSE];
+    
+    for (i = 0; i < L_CODE; i++)
+    {
+        cod[i] = 0;                                    move16 (); 
+    }
+    
+    decompress_code (index, linear_signs, linear_codewords);
+    
+    /* decode the positions and signs of pulses and build the codeword */
+
+    for (j = 0; j < NB_TRACK_MR102; j++)
+    {
+       /* compute index i */
+       
+       i = linear_codewords[j];
+       i = extract_l (L_shr (L_mult (i, 4), 1));
+       pos1 = add (i, j);   /* position of pulse "j" */
+       
+       test (); 
+       if (linear_signs[j] == 0)
+       {
+          sign = POS_CODE;                             move16 (); /* +1.0 */
+       }
+       else
+       {
+          sign = -NEG_CODE;                            move16 (); /* -1.0 */
+       }
+       
+       cod[pos1] = sign;                               move16 (); 
+       
+       /* compute index i */
+       
+       i = linear_codewords[add (j, 4)];        
+       i = extract_l (L_shr (L_mult (i, 4), 1));
+       pos2 = add (i, j);      /* position of pulse "j+4" */
+       
+       test (); 
+       if (sub (pos2, pos1) < 0)
+       {
+          sign = negate (sign);
+       }
+       cod[pos2] = add (cod[pos2], sign);              move16 (); 
+    }
+    
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/d8_31pf.h FFMpeg-20050127-new/libavcodec/amr/d8_31pf.h
--- FFMpeg-20050127/libavcodec/amr/d8_31pf.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d8_31pf.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,41 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : d8_31pf.h
+*      Purpose          : Builds the innovative codevector
+*
+********************************************************************************
+*/
+#ifndef d8_31pf_h
+#define d8_31pf_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/ 
+void dec_8i40_31bits (
+    Word16 index[],    /* i : index of 8 pulses (sign+position)         */
+    Word16 cod[]       /* o : algebraic (fixed) codebook excitation     */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/d_gain_c.c FFMpeg-20050127-new/libavcodec/amr/d_gain_c.c
--- FFMpeg-20050127/libavcodec/amr/d_gain_c.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d_gain_c.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,117 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : d_gain_c.c
+*
+********************************************************************************
+*/
+ 
+ 
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "d_gain_c.h"
+const char d_gain_c_id[] = "@(#)$Id $" d_gain_c_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "mode.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "cnst.h"
+#include "log2.h"
+#include "pow2.h"
+#include "gc_pred.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#include "gains.tab"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+
+/*
+**************************************************************************
+*
+*  Function    : d_gain_code
+*  Purpose     : Decode the fixed codebook gain using the received index.
+*
+**************************************************************************
+*/
+void d_gain_code (
+    gc_predState *pred_state, /* i/o : MA predictor state               */
+    enum Mode mode,           /* i   : AMR mode (MR795 or MR122)        */
+    Word16 index,             /* i   : received quantization index      */
+    Word16 code[],            /* i   : innovation codevector            */
+    Word16 *gain_code         /* o   : decoded innovation gain          */
+)
+{
+    Word16 gcode0, exp, frac;
+    const Word16 *p;
+    Word16 qua_ener_MR122, qua_ener;
+    Word16 exp_inn_en;
+    Word16 frac_inn_en;
+    Word32 L_tmp;
+    
+    /*-------------- Decode codebook gain ---------------*/
+    
+    /*-------------------------------------------------------------------*
+     *  predict codebook gain                                            *
+     *  ~~~~~~~~~~~~~~~~~~~~~                                            *
+     *  gc0     = Pow2(int(d)+frac(d))                                   *
+     *          = 2^exp + 2^frac                                         *
+     *                                                                   *
+     *-------------------------------------------------------------------*/
+
+    gc_pred(pred_state, mode, code, &exp, &frac,
+            &exp_inn_en, &frac_inn_en);
+    
+    p = &qua_gain_code[add (add (index, index), index)];
+
+    /* Different scalings between MR122 and the other modes */
+    test ();
+    if (sub(mode, MR122) == 0)
+    {
+        gcode0 = extract_l (Pow2 (exp, frac));  /* predicted gain */
+        gcode0 = shl (gcode0, 4);                                   
+        *gain_code = shl (mult (gcode0, *p++), 1);  move16 ();
+    }
+    else
+    {
+        gcode0 = extract_l (Pow2 (14, frac)); 
+        L_tmp = L_mult(*p++, gcode0);         
+        L_tmp = L_shr(L_tmp, sub(9, exp));    
+        *gain_code = extract_h(L_tmp);          /* Q1 */
+    }
+    
+    /*-------------------------------------------------------------------*
+     *  update table of past quantized energies                          *
+     *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                          *
+     *-------------------------------------------------------------------*/
+    qua_ener_MR122 = *p++;                 move16();
+    qua_ener = *p++;                       move16();
+    gc_pred_update(pred_state, qua_ener_MR122, qua_ener);
+
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/d_gain_c.h FFMpeg-20050127-new/libavcodec/amr/d_gain_c.h
--- FFMpeg-20050127/libavcodec/amr/d_gain_c.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d_gain_c.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,54 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : d_gain_c.h
+*      Purpose          : Decode the fixed codebook gain using the received index.
+*
+********************************************************************************
+*/
+#ifndef d_gain_c_h
+#define d_gain_c_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+#include "gc_pred.h"
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : d_gain_code
+*  Purpose     : Decode the fixed codebook gain using the received index.
+*  Description : The received index gives the gain correction factor
+*                gamma. The quantized gain is given by   g_q = g0 * gamma
+*                where g0 is the predicted gain. To find g0, 4th order
+*                MA prediction is applied to the mean-removed innovation
+*                energy in dB.
+*  Returns     : void
+*
+**************************************************************************
+*/
+void d_gain_code (
+    gc_predState *pred_state, /* i/o : MA predictor state               */
+    enum Mode mode,           /* i   : AMR mode                         */
+    Word16 index,             /* i   : received quantization index      */
+    Word16 code[],            /* i   : innovation codevector            */
+    Word16 *gain_code         /* o   : decoded innovation gain          */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/d_gain_p.c FFMpeg-20050127-new/libavcodec/amr/d_gain_p.c
--- FFMpeg-20050127/libavcodec/amr/d_gain_p.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d_gain_p.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,79 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : d_gain_p.c
+*
+********************************************************************************
+*/
+ 
+ 
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "d_gain_p.h"
+const char d_gain_p_id[] = "@(#)$Id $" d_gain_p_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "mode.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#include "gains.tab"
+ 
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+
+/*
+**************************************************************************
+*
+*  Function    : d_gain_pitch
+*  Purpose     : Decodes the pitch gain using the received index.
+*                output is in Q14 
+*
+**************************************************************************
+*/
+Word16 d_gain_pitch (      /* return value: gain (Q14)                */
+    enum Mode mode,        /* i   : AMR mode                          */   
+    Word16 index           /* i   : index of quantization             */
+)
+{
+    Word16 gain;
+
+    test ();
+    if (sub(mode, MR122) == 0)
+    {
+       /* clear 2 LSBits */
+       gain = shl (shr (qua_gain_pitch[index], 2), 2);    move16 ();
+    }
+    else
+    {
+       gain = qua_gain_pitch[index];                      move16 (); 
+    }
+    
+    return gain;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/d_gain_p.h FFMpeg-20050127-new/libavcodec/amr/d_gain_p.h
--- FFMpeg-20050127/libavcodec/amr/d_gain_p.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d_gain_p.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,43 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : d_gain_p.h
+*      Purpose          : Decodes the pitch gain using the received index.
+*
+********************************************************************************
+*/
+#ifndef d_gain_p_h
+#define d_gain_p_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+ 
+/*
+**************************************************************************
+*
+*  Function    : d_gain_pitch
+*  Purpose     : Decodes the pitch gain using the received index.
+*  Description : In case of no frame erasure, the gain is obtained 
+*                from the quantization table at the given index; 
+*                otherwise, a downscaled past gain is used.
+*  Returns     : Quantized pitch gain
+*
+**************************************************************************
+*/
+Word16 d_gain_pitch (      /* return value: gain (Q14)                */
+    enum Mode mode,        /* i : AMR mode                            */
+    Word16 index           /* i   : index of quantization             */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/d_homing.c FFMpeg-20050127-new/libavcodec/amr/d_homing.c
--- FFMpeg-20050127/libavcodec/amr/d_homing.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d_homing.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,153 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : d_homing.c
+*
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+
+#include "d_homing.h"
+const char d_homing_id[] = "@(#)$Id $" d_homing_h;
+
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+
+#include <stdlib.h>
+#include "typedef.h"
+#include "mode.h"
+#include "bits2prm.h"
+
+#include "d_homing.tab"
+
+/* get rid of compiler warning "`bitno' defined but never used" */
+static void* dummy[] = { (void *) bitno, (void *) dummy };
+
+
+/*
+*****************************************************************************
+*                         PRIVATE PROGRAM CODE
+*****************************************************************************
+*/
+
+/*
+********************************************************************************
+*
+*     Function        : dhf_test
+*     In              : input_frame[]  one frame of encoded serial bits
+*                       mode           mode type
+*                       nparms         number of parameters to check
+*     Out             : none
+*     Calls           : Bits2prm
+*     Tables          : d_homing.tab
+*     Compile Defines : none
+*     Return          : 0  input frame does not match the decoder homing
+*                          frame pattern (up to nparms)
+*                       1  input frame matches the decoder homing frame pattern
+*                          (for the first nparms parameters)
+*     Information     : The encoded serial bits are converted to all parameters
+*                       of the corresponding mode. These parameters are compared
+*                       with all parameters of the corresponding decoder homing frame.
+*
+********************************************************************************
+*/
+
+static Word16 dhf_test (Word16 input_frame[], enum Mode mode, Word16 nparms)
+{
+    Word16 i, j;
+    Word16 param[MAX_PRM_SIZE];
+
+        
+    /* retrieve the encoded parameters from the received serial bits */
+    Bits2prm(mode, input_frame, param);
+    
+    j = 0;
+
+    /* check if the encoded parameters matches the parameters
+       of the corresponding decoder homing frame */
+    for (i = 0; i < nparms; i++)
+    {
+        j = param[i] ^ dhf[mode][i];
+
+        if (j)
+            break;
+    }
+
+    return !j;
+}
+
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+
+
+/*
+********************************************************************************
+*
+*     Function        : decoder_homing_frame_test
+*     In              : input_frame[]  one frame of encoded serial bits
+*                       mode           mode type
+*     Out             : none
+*     Calls           : dhf_test
+*     Tables          : d_homing.tab
+*     Compile Defines : none
+*     Return          : 0  input frame does not match the decoder homing frame
+*                          pattern
+*                       1  input frame matches the decoder homing frame pattern
+*     Information     : The encoded serial bits are converted to all parameters
+*                       of the corresponding mode. These parameters are compared
+*                       with all parameters of the corresponding decoder homing frame.
+*
+********************************************************************************
+*/
+
+Word16 decoder_homing_frame_test (Word16 input_frame[], enum Mode mode)
+{
+    /* perform test for COMPLETE parameter frame */
+    return dhf_test(input_frame, mode, prmno[mode]);
+}
+
+
+/*
+********************************************************************************
+*
+*     Function        : decoder_homing_frame_test_first
+*     In              : input_frame[]  one frame of encoded serial bits
+*                       mode           mode type
+*     Out             : none
+*     Calls           : Bits2prm
+*     Tables          : d_homing.tab
+*     Compile Defines : none
+*     Return          : 0  input frame does not match the decoder homing frame
+*                          pattern (up to and including the first subframe)
+*                       1  input frame matches the decoder homing frame pattern
+*                          (up to and including the first subframe)
+*     Information     : The encoded serial bits are converted to all parameters
+*                       of the corresponding mode. These parameters are
+*                       compared with the parameters for LPC and first subframe
+*                       of the decoder homing frame.
+*
+********************************************************************************
+*/
+
+Word16 decoder_homing_frame_test_first (Word16 input_frame[], enum Mode mode)
+{
+    /* perform test for FIRST SUBFRAME of parameter frame ONLY */
+    return dhf_test(input_frame, mode, prmnofsf[mode]);
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/d_homing.h FFMpeg-20050127-new/libavcodec/amr/d_homing.h
--- FFMpeg-20050127/libavcodec/amr/d_homing.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d_homing.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,36 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*      File             : d_homing.h
+*      Purpose          : Declarations of decoder homing function prototypes.
+*
+********************************************************************************
+*/
+
+#ifndef d_homing_h
+#define d_homing_h "$Id $"
+
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+
+#include "typedef.h"
+#include "mode.h"
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+
+Word16 decoder_homing_frame_test (Word16 input_frame[], enum Mode mode);
+Word16 decoder_homing_frame_test_first (Word16 input_frame[], enum Mode mode);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/d_homing.tab FFMpeg-20050127-new/libavcodec/amr/d_homing.tab
--- FFMpeg-20050127/libavcodec/amr/d_homing.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d_homing.tab	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,287 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : d_homing.tab
+*      Purpose          : definitions for decoder homing frames
+*
+*      $Id $
+*
+********************************************************************************
+*/
+
+#ifndef d_homing_tab
+#define d_homing_tab
+
+#include "typedef.h"
+#include "mode.h"
+
+#include "bitno.tab"
+
+
+static const Word16 dhf_MR475[PRMNO_MR475] =
+{
+    0x00F8,
+    0x009D,
+    0x001C,
+    0x0066,
+    0x0000,
+    0x0003,
+    0x0028,
+    0x000F,
+    0x0038,
+    0x0001,
+    0x000F,
+    0x0031,
+    0x0002,
+    0x0008,
+    0x000F,
+    0x0026,
+    0x0003 
+};
+   
+static const Word16 dhf_MR515[PRMNO_MR515] =
+{
+    0x00F8,
+    0x009D,
+    0x001C,
+    0x0066,
+    0x0000,
+    0x0003,
+    0x0037,
+    0x000F,
+    0x0000,
+    0x0003,
+    0x0005,
+    0x000F,
+    0x0037,
+    0x0003,
+    0x0037,
+    0x000F,
+    0x0023,
+    0x0003,
+    0x001F 
+};
+
+static const Word16 dhf_MR59[PRMNO_MR59] =
+{
+    0x00F8,
+    0x00E3,
+    0x002F,
+    0x00BD,
+    0x0000,
+    0x0003,
+    0x0037,
+    0x000F,
+    0x0001,
+    0x0003,
+    0x000F,
+    0x0060,
+    0x00F9,
+    0x0003,
+    0x0037,
+    0x000F,
+    0x0000,
+    0x0003,
+    0x0037 
+};
+
+static const Word16 dhf_MR67[PRMNO_MR67] =
+{
+    0x00F8,
+    0x00E3,
+    0x002F,
+    0x00BD,
+    0x0002,
+    0x0007,
+    0x0000,
+    0x000F,
+    0x0098,
+    0x0007,
+    0x0061,
+    0x0060,
+    0x05C5,
+    0x0007,
+    0x0000,
+    0x000F,
+    0x0318,
+    0x0007,
+    0x0000 
+};
+
+static const Word16 dhf_MR74[PRMNO_MR74] =
+{
+    0x00F8,
+    0x00E3,
+    0x002F,
+    0x00BD,
+    0x0006,
+    0x000F,
+    0x0000,
+    0x001B,
+    0x0208,
+    0x000F,
+    0x0062,
+    0x0060,
+    0x1BA6,
+    0x000F,
+    0x0000,
+    0x001B,
+    0x0006,
+    0x000F,
+    0x0000 
+};
+
+static const Word16 dhf_MR795[PRMNO_MR795] =
+{
+    0x00C2,
+    0x00E3,
+    0x002F,
+    0x00BD,
+    0x0006,
+    0x000F,
+    0x000A,
+    0x0000,
+    0x0039,
+    0x1C08,
+    0x0007,
+    0x000A,
+    0x000B,
+    0x0063,
+    0x11A6,
+    0x000F,
+    0x0001,
+    0x0000,
+    0x0039,
+    0x09A0,
+    0x000F,
+    0x0002,
+    0x0001 
+};
+
+static const Word16 dhf_MR102[PRMNO_MR102] =
+{
+    0x00F8,
+    0x00E3,
+    0x002F,
+    0x0045,
+    0x0000,
+    0x0000,
+    0x0000,
+    0x0000,
+    0x0000,
+    0x0000,
+    0x0000,
+    0x0000,
+    0x001B,
+    0x0000,
+    0x0001,
+    0x0000,
+    0x0001,
+    0x0326,
+    0x00CE,
+    0x007E,
+    0x0051,
+    0x0062,
+    0x0000,
+    0x0000,
+    0x0000,
+    0x0000,
+    0x015A,
+    0x0359,
+    0x0076,
+    0x0000,
+    0x001B,
+    0x0000,
+    0x0000,
+    0x0000,
+    0x0000,
+    0x017C,
+    0x0215,
+    0x0038,
+    0x0030 
+};
+
+static const Word16 dhf_MR122[PRMNO_MR122] =
+{
+    0x0004,
+    0x002A,
+    0x00DB,
+    0x0096,
+    0x002A,
+    0x0156,
+    0x000B,
+    0x0000,
+    0x0000,
+    0x0000,
+    0x0000,
+    0x0000,
+    0x0000,
+    0x0000,
+    0x0000,
+    0x0000,
+    0x0000,
+    0x0000,
+    0x0036,
+    0x000B,
+    0x0000,
+    0x000F,
+    0x000E,
+    0x000C,
+    0x000D,
+    0x0000,
+    0x0001,
+    0x0005,
+    0x0007,
+    0x0001,
+    0x0008,
+    0x0024,
+    0x0000,
+    0x0001,
+    0x0000,
+    0x0005,
+    0x0006,
+    0x0001,
+    0x0002,
+    0x0004,
+    0x0007,
+    0x0004,
+    0x0002,
+    0x0003,
+    0x0036,
+    0x000B,
+    0x0000,
+    0x0002,
+    0x0004,
+    0x0000,
+    0x0003,
+    0x0006,
+    0x0001,
+    0x0007,
+    0x0006,
+    0x0005,
+    0x0000 
+};
+        
+
+
+/* overall table with the parameters of the
+   decoder homing frames for all modes */
+static const Word16 *dhf[] =
+{
+   dhf_MR475,
+   dhf_MR515,
+   dhf_MR59,
+   dhf_MR67,
+   dhf_MR74,
+   dhf_MR795,
+   dhf_MR102,
+   dhf_MR122
+};
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/d_plsf.c FFMpeg-20050127-new/libavcodec/amr/d_plsf.c
--- FFMpeg-20050127/libavcodec/amr/d_plsf.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d_plsf.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,128 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : d_plsf.c
+*      Purpose          : common part (init, exit, reset) of LSF decoder
+*                         module (rest in d_plsf_3.c and d_plsf_5.c)
+*
+*****************************************************************************
+*/
+ 
+ 
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "d_plsf.h"
+const char d_plsf_id[] = "@(#)$Id $" d_plsf_h;
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+#include "copy.h"
+#include "q_plsf_5.tab"
+
+/*
+*--------------------------------------------------*
+* Constants (defined in cnst.h)                    *
+*--------------------------------------------------*
+*  M                    : LPC order
+*--------------------------------------------------*
+*/
+ 
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : D_plsf_init
+*  Purpose     : Allocates and initializes state memory
+*
+**************************************************************************
+*/
+int D_plsf_init (D_plsfState **state)
+{
+  D_plsfState* s;
+ 
+  if (state == (D_plsfState **) NULL){
+      fprintf(stderr, "D_plsf_init: invalid parameter\n");
+      return -1;
+  }
+  *state = NULL;
+ 
+  /* allocate memory */
+  if ((s= (D_plsfState *) malloc(sizeof(D_plsfState))) == NULL){
+      fprintf(stderr, "D_plsf_init: can not malloc state structure\n");
+      return -1;
+  }
+  
+  D_plsf_reset(s);
+  *state = s;
+  
+  return 0;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : D_plsf_reset
+*  Purpose     : Resets state memory
+*
+**************************************************************************
+*/
+int D_plsf_reset (D_plsfState *state)
+{
+  Word16 i;
+  
+  if (state == (D_plsfState *) NULL){
+      fprintf(stderr, "D_plsf_reset: invalid parameter\n");
+      return -1;
+  }
+  
+  for (i = 0; i < M; i++){
+      state->past_r_q[i] = 0;             /* Past quantized prediction error */
+  }
+  
+  /* Past dequantized lsfs */
+  Copy(mean_lsf, &state->past_lsf_q[0], M);
+
+  return 0;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : D_plsf_exit
+*  Purpose     : The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void D_plsf_exit (D_plsfState **state)
+{
+  if (state == NULL || *state == NULL)
+      return;
+ 
+  /* deallocate memory */
+  free(*state);
+  *state = NULL;
+  
+  return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/d_plsf.h FFMpeg-20050127-new/libavcodec/amr/d_plsf.h
--- FFMpeg-20050127/libavcodec/amr/d_plsf.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d_plsf.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,148 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : d_plsf.h
+*      Purpose          : common part (init, exit, reset) of LSF decoder
+*                         module (rest in d_plsf_3.c and d_plsf_5.c)
+*
+********************************************************************************
+*/
+#ifndef d_plsf_h
+#define d_plsf_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "cnst.h"
+#include "mode.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+/*
+*--------------------------------------------------*
+* Constants (defined in cnst.h)                    *
+*--------------------------------------------------*
+* M            : LPC Order                         *
+*--------------------------------------------------*
+*/
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+typedef struct {
+  Word16 past_r_q[M];   /* Past quantized prediction error, Q15 */
+  Word16 past_lsf_q[M]; /* Past dequantized lsfs,           Q15 */
+} D_plsfState;
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+ 
+/*
+**************************************************************************
+*
+*  Function    : D_plsf_init
+*  Purpose     : Allocates and initializes state memory
+*  Description : Stores pointer to state struct in *st. This
+*                pointer has to be passed to D_plsf in each call.
+*  Returns     : 0 on success
+*
+**************************************************************************
+*/
+int D_plsf_init (D_plsfState **st);
+ 
+/*
+**************************************************************************
+*
+*  Function    : D_plsf_reset
+*  Purpose     : Resets state memory
+*  Returns     : 0 on success
+*
+**************************************************************************
+*/
+int D_plsf_reset (D_plsfState *st);
+
+/*
+**************************************************************************
+*
+*  Function    : D_plsf_exit
+*  Purpose     : The memory used for state memory is freed
+*  Description : Stores NULL in *st
+*  Returns     : void
+*
+**************************************************************************
+*/
+void D_plsf_exit (D_plsfState **st);
+ 
+/*
+**************************************************************************
+*
+*  Function    : D_plsf_5
+*  Purpose     : Decodes the 2 sets of LSP parameters in a frame 
+*                using the received quantization indices.
+*  Description : The two sets of LSFs are quantized using split by 
+*                5 matrix quantization (split-MQ) with 1st order MA
+*                prediction.
+*                See "q_plsf_5.c" for more details about the
+*                quantization procedure
+*  Returns     : 0
+*
+**************************************************************************
+*/
+int D_plsf_5 (
+    D_plsfState *st,  /* i/o: State variables                            */
+    Word16 bfi,       /* i  : bad frame indicator (set to 1 if a bad    
+                              frame is received)                         */
+    Word16 *indice,   /* i  : quantization indices of 5 submatrices, Q0  */
+    Word16 *lsp1_q,   /* o  : quantized 1st LSP vector (M)           Q15 */
+    Word16 *lsp2_q    /* o  : quantized 2nd LSP vector (M)           Q15 */
+);
+
+/*************************************************************************
+ *
+ *  FUNCTION:   D_plsf_3()
+ *
+ *  PURPOSE: Decodes the LSP parameters using the received quantization
+ *           indices.1st order MA prediction and split by 3 matrix
+ *           quantization (split-MQ)
+ *
+ *************************************************************************/
+
+void D_plsf_3(
+    D_plsfState *st,  /* i/o: State struct                               */
+    enum Mode mode,   /* i  : coder mode                                 */
+    Word16 bfi,       /* i  : bad frame indicator (set to 1 if a         */
+                      /*      bad frame is received)                     */
+    Word16 * indice,  /* i  : quantization indices of 3 submatrices, Q0  */
+    Word16 * lsp1_q   /* o  : quantized 1st LSP vector,              Q15 */
+);
+
+/*************************************************************************
+ *
+ *  FUNCTION:   Init_D_plsf_3()
+ *
+ *  PURPOSE: Set the past_r_q[M] vector to one of the eight
+ *           past_rq_init vectors.
+ *
+ *************************************************************************/
+void Init_D_plsf_3(D_plsfState *st,  /* i/o: State struct                */
+		   Word16 index      /* i  : past_rq_init[] index [0, 7] */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/d_plsf_3.c FFMpeg-20050127-new/libavcodec/amr/d_plsf_3.c
--- FFMpeg-20050127/libavcodec/amr/d_plsf_3.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d_plsf_3.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,201 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : d_plsf_3.c
+*      Purpose          : Decodes the LSP parameters using the received
+*                         quantization indices. 1st order MA prediction and
+*                         split by 3 vector quantization (split-VQ)
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "d_plsf.h"
+const char d_plsf_3_id[] = "@(#)$Id $" d_plsf_h;
+
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "lsp_lsf.h"
+#include "reorder.h"
+#include "copy.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#include "q_plsf_3.tab"    /* Codebooks of LSF prediction residual */
+
+/* ALPHA    ->  0.9                                            */
+/* ONE_ALPHA-> (1.0-ALPHA)                                     */
+
+#define ALPHA     29491
+#define ONE_ALPHA 3277
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:   D_plsf_3()
+ *
+ *  PURPOSE: Decodes the LSP parameters using the received quantization
+ *           indices.1st order MA prediction and split by 3 vector
+ *           quantization (split-VQ)
+ *
+ *************************************************************************/
+
+void D_plsf_3(
+    D_plsfState *st,   /* i/o: State struct                               */
+    enum Mode mode,    /* i  : coder mode                                 */
+    Word16 bfi,        /* i  : bad frame indicator (set to 1 if a         */
+                       /*      bad frame is received)                     */
+    Word16 * indice,   /* i  : quantization indices of 3 submatrices, Q0  */
+    Word16 * lsp1_q    /* o  : quantized 1st LSP vector,              Q15 */
+)
+{
+    Word16 i, index;
+    Word16 *p_cb1, *p_cb2, *p_cb3, *p_dico, temp;
+    Word16 lsf1_r[M];
+    Word16 lsf1_q[M];
+    
+    test ();
+    if (bfi != 0)   /* if bad frame */
+    {
+        /* use the past LSFs slightly shifted towards their mean */
+
+        for (i = 0; i < M; i++)
+        {
+            /* lsfi_q[i] = ALPHA*past_lsf_q[i] + ONE_ALPHA*mean_lsf[i]; */
+
+            lsf1_q[i] = add(mult(st->past_lsf_q[i], ALPHA),
+                            mult(mean_lsf[i], ONE_ALPHA));
+                                                move16 ();
+        }
+
+        /* estimate past quantized residual to be used in next frame */
+	test();
+	if (sub(mode, MRDTX) != 0) {
+	  for (i = 0; i < M; i++) {
+            /* temp  = mean_lsf[i] +  past_r2_q[i] * PRED_FAC; */
+	    
+            temp = add(mean_lsf[i], mult(st->past_r_q[i], pred_fac[i]));
+	    
+            st->past_r_q[i] = sub(lsf1_q[i], temp);                   move16 ();
+	  }
+	} else {
+	  for (i = 0; i < M; i++) {
+            /* temp  = mean_lsf[i] +  past_r2_q[i]; */
+	    
+            temp = add(mean_lsf[i], st->past_r_q[i]);
+            st->past_r_q[i] = sub(lsf1_q[i], temp);                   move16 ();
+	  }	  
+	}
+    }
+    else  /* if good LSFs received */
+    {
+       test (); test ();
+       if (sub (mode, MR475) == 0 || sub (mode, MR515) == 0)
+       {   /* MR475, MR515 */
+          p_cb1 = dico1_lsf;                  move16 ();
+          p_cb2 = dico2_lsf;                  move16 ();
+          p_cb3 = mr515_3_lsf;                move16 ();
+       }
+       else if (sub (mode, MR795) == 0)
+       {   /* MR795 */
+          test();
+          p_cb1 = mr795_1_lsf;                move16 ();
+          p_cb2 = dico2_lsf;                  move16 ();
+          p_cb3 = dico3_lsf;                  move16 ();
+       }
+       else 
+       {   /* MR59, MR67, MR74, MR102, MRDTX */
+          test();          
+          p_cb1 = dico1_lsf;                  move16 ();
+          p_cb2 = dico2_lsf;                  move16 ();
+          p_cb3 = dico3_lsf;                  move16 ();
+       }
+       
+       /* decode prediction residuals from 3 received indices */
+
+        index = *indice++;                      move16 ();
+        p_dico = &p_cb1[add(index, add(index, index))];               move16 ();
+        lsf1_r[0] = *p_dico++;                  move16 ();
+        lsf1_r[1] = *p_dico++;                  move16 ();
+        lsf1_r[2] = *p_dico++;                  move16 ();
+
+        index = *indice++;                      move16 ();
+        
+        test (); test ();
+        if ((sub (mode, MR475) == 0) || (sub (mode, MR515) == 0))
+        {   /* MR475, MR515 only using every second entry */
+            index = shl(index,1);
+        }
+        
+        p_dico = &p_cb2[add(index, add(index, index))];               move16 ();
+        lsf1_r[3] = *p_dico++;                  move16 ();
+        lsf1_r[4] = *p_dico++;                  move16 ();
+        lsf1_r[5] = *p_dico++;                  move16 ();
+
+        index = *indice++;                      move16 ();
+        p_dico = &p_cb3[shl(index, 2)];         move16 ();
+        lsf1_r[6] = *p_dico++;                  move16 ();
+        lsf1_r[7] = *p_dico++;                  move16 ();
+        lsf1_r[8] = *p_dico++;                  move16 ();
+        lsf1_r[9] = *p_dico++;                  move16 ();
+
+        /* Compute quantized LSFs and update the past quantized residual */
+
+	if (sub(mode, MRDTX) != 0) 
+           for (i = 0; i < M; i++) {
+              temp = add(mean_lsf[i], mult(st->past_r_q[i], pred_fac[i]));
+              lsf1_q[i] = add(lsf1_r[i], temp);   move16 ();
+              st->past_r_q[i] = lsf1_r[i];        move16 ();
+           }
+        else
+           for (i = 0; i < M; i++) {
+              temp = add(mean_lsf[i], st->past_r_q[i]);
+              lsf1_q[i] = add(lsf1_r[i], temp);   move16 ();
+              st->past_r_q[i] = lsf1_r[i];        move16 ();
+           }
+    }
+
+    /* verification that LSFs has minimum distance of LSF_GAP Hz */
+
+    Reorder_lsf(lsf1_q, LSF_GAP, M);
+
+    Copy (lsf1_q, st->past_lsf_q, M);
+
+    /*  convert LSFs to the cosine domain */
+
+    Lsf_lsp(lsf1_q, lsp1_q, M);
+
+    return;
+}
+
+void Init_D_plsf_3(D_plsfState *st,  /* i/o: State struct                */
+		   Word16 index      /* i  : past_rq_init[] index [0, 7] */)
+{
+  Copy(&past_rq_init[index * M], st->past_r_q, M);
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/d_plsf_5.c FFMpeg-20050127-new/libavcodec/amr/d_plsf_5.c
--- FFMpeg-20050127/libavcodec/amr/d_plsf_5.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/d_plsf_5.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,193 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : d_plsf_5.c
+*
+*****************************************************************************
+*/
+ 
+ 
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "d_plsf.h"
+const char d_plsf_5_id[] = "@(#)$Id $" d_plsf_h;
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "lsp_lsf.h"
+#include "reorder.h"
+#include "cnst.h"
+#include "copy.h"
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+#include "q_plsf_5.tab"         /* Codebooks of LSF prediction residual */
+
+
+/* ALPHA    ->  0.95       */
+/* ONE_ALPHA-> (1.0-ALPHA) */
+#define ALPHA     31128
+#define ONE_ALPHA 1639
+
+/*
+*--------------------------------------------------*
+* Constants (defined in cnst.h)                    *
+*--------------------------------------------------*
+*  M                    : LPC order
+*--------------------------------------------------*
+*/
+ 
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : D_plsf_5
+*  Purpose     : Decodes the 2 sets of LSP parameters in a frame 
+*                using the received quantization indices.
+*
+**************************************************************************
+*/
+int D_plsf_5 (
+    D_plsfState *st,    /* i/o: State variables                            */
+    Word16 bfi,         /* i  : bad frame indicator (set to 1 if a bad    
+                                frame is received)                         */  
+    Word16 *indice,     /* i  : quantization indices of 5 submatrices, Q0  */
+    Word16 *lsp1_q,     /* o  : quantized 1st LSP vector (M),          Q15 */
+    Word16 *lsp2_q      /* o  : quantized 2nd LSP vector (M),          Q15 */
+)
+{
+    Word16 i;
+    const Word16 *p_dico;
+    Word16 temp, sign;
+    Word16 lsf1_r[M], lsf2_r[M];
+    Word16 lsf1_q[M], lsf2_q[M];
+
+    test (); 
+    if (bfi != 0)                               /* if bad frame */
+    {
+        /* use the past LSFs slightly shifted towards their mean */
+
+        for (i = 0; i < M; i++)
+        {
+            /* lsfi_q[i] = ALPHA*st->past_lsf_q[i] + ONE_ALPHA*mean_lsf[i]; */
+
+            lsf1_q[i] = add (mult (st->past_lsf_q[i], ALPHA),
+                             mult (mean_lsf[i], ONE_ALPHA));
+                                                move16 (); 
+
+            lsf2_q[i] = lsf1_q[i];              move16 (); 
+        }
+
+        /* estimate past quantized residual to be used in next frame */
+
+        for (i = 0; i < M; i++)
+        {
+            /* temp  = mean_lsf[i] +  st->past_r_q[i] * LSP_PRED_FAC_MR122; */
+
+            temp = add (mean_lsf[i], mult (st->past_r_q[i],
+                                           LSP_PRED_FAC_MR122));
+
+            st->past_r_q[i] = sub (lsf2_q[i], temp);
+                                                move16 (); 
+        }
+    }
+    else
+        /* if good LSFs received */
+    {
+        /* decode prediction residuals from 5 received indices */
+
+        p_dico = &dico1_lsf[shl (indice[0], 2)];move16 ();
+        lsf1_r[0] = *p_dico++;                  move16 (); 
+        lsf1_r[1] = *p_dico++;                  move16 (); 
+        lsf2_r[0] = *p_dico++;                  move16 (); 
+        lsf2_r[1] = *p_dico++;                  move16 (); 
+
+        p_dico = &dico2_lsf[shl (indice[1], 2)];move16 ();
+        lsf1_r[2] = *p_dico++;                  move16 (); 
+        lsf1_r[3] = *p_dico++;                  move16 (); 
+        lsf2_r[2] = *p_dico++;                  move16 (); 
+        lsf2_r[3] = *p_dico++;                  move16 (); 
+
+        sign = indice[2] & 1;                   logic16 (); 
+        i = shr (indice[2], 1);
+        p_dico = &dico3_lsf[shl (i, 2)];        move16 (); 
+
+        test (); 
+        if (sign == 0)
+        {
+            lsf1_r[4] = *p_dico++;              move16 (); 
+            lsf1_r[5] = *p_dico++;              move16 (); 
+            lsf2_r[4] = *p_dico++;              move16 (); 
+            lsf2_r[5] = *p_dico++;              move16 (); 
+        }
+        else
+        {
+            lsf1_r[4] = negate (*p_dico++);     move16 (); 
+            lsf1_r[5] = negate (*p_dico++);     move16 (); 
+            lsf2_r[4] = negate (*p_dico++);     move16 (); 
+            lsf2_r[5] = negate (*p_dico++);     move16 (); 
+        }
+
+        p_dico = &dico4_lsf[shl (indice[3], 2)];move16 (); 
+        lsf1_r[6] = *p_dico++;                  move16 (); 
+        lsf1_r[7] = *p_dico++;                  move16 (); 
+        lsf2_r[6] = *p_dico++;                  move16 (); 
+        lsf2_r[7] = *p_dico++;                  move16 (); 
+
+        p_dico = &dico5_lsf[shl (indice[4], 2)];move16 (); 
+        lsf1_r[8] = *p_dico++;                  move16 (); 
+        lsf1_r[9] = *p_dico++;                  move16 (); 
+        lsf2_r[8] = *p_dico++;                  move16 (); 
+        lsf2_r[9] = *p_dico++;                  move16 (); 
+
+        /* Compute quantized LSFs and update the past quantized residual */
+        for (i = 0; i < M; i++)
+        {
+            temp = add (mean_lsf[i], mult (st->past_r_q[i],
+                                           LSP_PRED_FAC_MR122));
+            lsf1_q[i] = add (lsf1_r[i], temp);
+                                                move16 (); 
+            lsf2_q[i] = add (lsf2_r[i], temp);
+                                                move16 (); 
+            st->past_r_q[i] = lsf2_r[i];        move16 (); 
+        }
+    }
+
+    /* verification that LSFs have minimum distance of LSF_GAP Hz */
+
+    Reorder_lsf (lsf1_q, LSF_GAP, M);
+    Reorder_lsf (lsf2_q, LSF_GAP, M);
+
+    Copy (lsf2_q, st->past_lsf_q, M);
+
+    /*  convert LSFs to the cosine domain */
+
+    Lsf_lsp (lsf1_q, lsp1_q, M);
+    Lsf_lsp (lsf2_q, lsp2_q, M);
+
+    return 0;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/dec_amr.c FFMpeg-20050127-new/libavcodec/amr/dec_amr.c
--- FFMpeg-20050127/libavcodec/amr/dec_amr.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/dec_amr.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,1140 @@
+/*************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : dec_amr.c
+*      Purpose          : Decoding of one speech frame using given codec mode
+*
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "dec_amr.h"
+const char dec_amr_id[] = "@(#)$Id $" dec_amr_h;
+
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+#include "copy.h"
+#include "set_zero.h"
+#include "syn_filt.h"
+#include "d_plsf.h"
+#include "agc.h"
+#include "int_lpc.h"
+#include "dec_gain.h"
+#include "dec_lag3.h"
+#include "dec_lag6.h"
+#include "d2_9pf.h"
+#include "d2_11pf.h"
+#include "d3_14pf.h"
+#include "d4_17pf.h"
+#include "d8_31pf.h"
+#include "d1035pf.h"
+#include "pred_lt.h"
+#include "d_gain_p.h"
+#include "d_gain_c.h"
+#include "dec_gain.h"
+#include "ec_gains.h"
+#include "ph_disp.h"
+#include "c_g_aver.h"
+#include "int_lsf.h"
+#include "lsp_lsf.h"
+#include "lsp_avg.h"
+#include "bgnscd.h"
+#include "ex_ctrl.h"
+#include "sqrt_l.h"
+#include "frame.h"
+
+#include "lsp.tab"
+#include "bitno.tab"
+#include "b_cn_cod.h"
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+/*-----------------------------------------------------------------*
+ *   Decoder constant parameters (defined in "cnst.h")             *
+ *-----------------------------------------------------------------*
+ *   L_FRAME       : Frame size.                                   *
+ *   L_FRAME_BY2   : Half the frame size.                          *
+ *   L_SUBFR       : Sub-frame size.                               *
+ *   M             : LPC order.                                    *
+ *   MP1           : LPC order+1                                   *
+ *   PIT_MIN       : Minimum pitch lag.                            *
+ *   PIT_MIN_MR122 : Minimum pitch lag for the MR122 mode.         *
+ *   PIT_MAX       : Maximum pitch lag.                            *
+ *   L_INTERPOL    : Length of filter for interpolation            *
+ *   PRM_SIZE      : size of vector containing analysis parameters *
+ *-----------------------------------------------------------------*/
+
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : Decoder_amr_init
+*  Purpose     : Allocates and initializes state memory
+*
+**************************************************************************
+*/
+int Decoder_amr_init (Decoder_amrState **state)
+{
+  Decoder_amrState* s;
+  Word16 i;
+ 
+  if (state == (Decoder_amrState **) NULL){
+      fprintf(stderr, "Decoder_amr_init: invalid parameter\n");
+      return -1;
+  }
+  *state = NULL;
+ 
+  /* allocate memory */
+  if ((s= (Decoder_amrState *) malloc(sizeof(Decoder_amrState))) == NULL){
+      fprintf(stderr, "Decoder_amr_init: can not malloc state structure\n");
+      return -1;
+  }
+  
+  s->T0_lagBuff = 40;
+  s->inBackgroundNoise = 0;
+  s->voicedHangover = 0;
+  for (i = 0; i < 9; i++)
+     s->ltpGainHistory[i] = 0;
+
+  s->lsfState = NULL;
+  s->ec_gain_p_st = NULL;
+  s->ec_gain_c_st = NULL;  
+  s->pred_state = NULL;
+  s->ph_disp_st = NULL;
+  s->dtxDecoderState = NULL;
+  
+  if (D_plsf_init(&s->lsfState) ||
+      ec_gain_pitch_init(&s->ec_gain_p_st) ||
+      ec_gain_code_init(&s->ec_gain_c_st) ||
+      gc_pred_init(&s->pred_state) ||
+      Cb_gain_average_init(&s->Cb_gain_averState) ||
+      lsp_avg_init(&s->lsp_avg_st) ||      
+      Bgn_scd_init(&s->background_state) ||      
+      ph_disp_init(&s->ph_disp_st) || 
+      dtx_dec_init(&s->dtxDecoderState)) {
+      Decoder_amr_exit(&s);
+      return -1;
+  }
+      
+  Decoder_amr_reset(s, (enum Mode)0);
+  *state = s;
+  
+  return 0;
+}
+
+/*
+**************************************************************************
+*
+*  Function    : Decoder_amr_reset
+*  Purpose     : Resets state memory
+*
+**************************************************************************
+*/
+int Decoder_amr_reset (Decoder_amrState *state, enum Mode mode)
+{
+  Word16 i;
+
+  if (state == (Decoder_amrState *) NULL){
+      fprintf(stderr, "Decoder_amr_reset: invalid parameter\n");
+      return -1;
+  }
+  
+  /* Initialize static pointer */
+  state->exc = state->old_exc + PIT_MAX + L_INTERPOL;
+
+  /* Static vectors to zero */
+  Set_zero (state->old_exc, PIT_MAX + L_INTERPOL);
+
+  if (mode != MRDTX)
+     Set_zero (state->mem_syn, M);
+
+  /* initialize pitch sharpening */
+  state->sharp = SHARPMIN;
+  state->old_T0 = 40;
+     
+  /* Initialize state->lsp_old [] */ 
+
+  if (mode != MRDTX) {
+      Copy(lsp_init_data, &state->lsp_old[0], M);
+  }
+
+  /* Initialize memories of bad frame handling */
+  state->prev_bf = 0;
+  state->prev_pdf = 0;
+  state->state = 0;
+  
+  state->T0_lagBuff = 40;
+  state->inBackgroundNoise = 0;
+  state->voicedHangover = 0;
+  if (mode != MRDTX) {
+      for (i=0;i<9;i++)
+          state->excEnergyHist[i] = 0;
+  }
+  
+  for (i = 0; i < 9; i++)
+     state->ltpGainHistory[i] = 0;
+
+  Cb_gain_average_reset(state->Cb_gain_averState);
+  if (mode != MRDTX)
+     lsp_avg_reset(state->lsp_avg_st);
+  D_plsf_reset(state->lsfState);
+  ec_gain_pitch_reset(state->ec_gain_p_st);
+  ec_gain_code_reset(state->ec_gain_c_st);
+
+  if (mode != MRDTX)
+     gc_pred_reset(state->pred_state);
+
+  Bgn_scd_reset(state->background_state);
+  state->nodataSeed = 21845;
+  ph_disp_reset(state->ph_disp_st);
+  if (mode != MRDTX)
+     dtx_dec_reset(state->dtxDecoderState);
+  
+  return 0;
+}
+
+/*
+**************************************************************************
+*
+*  Function    : Decoder_amr_exit
+*  Purpose     : The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void Decoder_amr_exit (Decoder_amrState **state)
+{
+  if (state == NULL || *state == NULL)
+      return;
+ 
+  D_plsf_exit(&(*state)->lsfState);
+  ec_gain_pitch_exit(&(*state)->ec_gain_p_st);
+  ec_gain_code_exit(&(*state)->ec_gain_c_st);
+  gc_pred_exit(&(*state)->pred_state);
+  Bgn_scd_exit(&(*state)->background_state);
+  ph_disp_exit(&(*state)->ph_disp_st);
+  Cb_gain_average_exit(&(*state)->Cb_gain_averState);
+  lsp_avg_exit(&(*state)->lsp_avg_st);
+  dtx_dec_exit(&(*state)->dtxDecoderState);
+  
+  /* deallocate memory */
+  free(*state);
+  *state = NULL;
+  
+  return;
+}
+
+/*
+**************************************************************************
+*
+*  Function    : Decoder_amr
+*  Purpose     : Speech decoder routine.
+*
+**************************************************************************
+*/
+int Decoder_amr (
+    Decoder_amrState *st,      /* i/o : State variables                   */
+    enum Mode mode,            /* i   : AMR mode                          */
+    Word16 parm[],             /* i   : vector of synthesis parameters
+                                        (PRM_SIZE)                        */
+    enum RXFrameType frame_type, /* i   : received frame type             */
+    Word16 synth[],            /* o   : synthesis speech (L_FRAME)        */
+    Word16 A_t[]               /* o   : decoded LP filter in 4 subframes
+                                        (AZ_SIZE)                         */
+)
+{
+    /* LPC coefficients */
+   
+    Word16 *Az;                /* Pointer on A_t */
+    
+    /* LSPs */
+
+    Word16 lsp_new[M];
+    Word16 lsp_mid[M];
+
+    /* LSFs */
+    
+    Word16 prev_lsf[M];
+    Word16 lsf_i[M];    
+
+    /* Algebraic codevector */
+
+    Word16 code[L_SUBFR];
+
+    /* excitation */
+
+    Word16 excp[L_SUBFR];
+    Word16 exc_enhanced[L_SUBFR];
+
+    /* Scalars */
+
+    Word16 i, i_subfr;
+    Word16 T0, T0_frac, index, index_mr475 = 0;
+    Word16 gain_pit, gain_code, gain_code_mix, pit_sharp, pit_flag, pitch_fac;
+    Word16 t0_min, t0_max;
+    Word16 delta_frc_low, delta_frc_range;
+    Word16 tmp_shift;
+    Word16 temp;
+    Word32 L_temp;
+    Word16 flag4;
+    Word16 carefulFlag;
+    Word16 excEnergy;
+    Word16 subfrNr; 
+    Word16 evenSubfr = 0;
+
+    Word16 bfi = 0;   /* bad frame indication flag                          */
+    Word16 pdfi = 0;  /* potential degraded bad frame flag                  */
+
+    enum DTXStateType newDTXState;  /* SPEECH , DTX, DTX_MUTE */
+
+    /* find the new  DTX state  SPEECH OR DTX */
+    newDTXState = rx_dtx_handler(st->dtxDecoderState, frame_type);
+    move16 ();   /* function result */
+    
+    /* DTX actions */
+    test();
+    if (sub(newDTXState, SPEECH) != 0 )
+    {
+       Decoder_amr_reset (st, MRDTX);
+
+       dtx_dec(st->dtxDecoderState, 
+               st->mem_syn, 
+               st->lsfState, 
+               st->pred_state,
+               st->Cb_gain_averState,
+               newDTXState,
+               mode, 
+               parm, synth, A_t);
+       /* update average lsp */
+       
+       Lsf_lsp(st->lsfState->past_lsf_q, st->lsp_old, M);
+       lsp_avg(st->lsp_avg_st, st->lsfState->past_lsf_q);
+       goto the_end;
+    }
+
+    /* SPEECH action state machine  */
+    test (); test (); test (); 
+    if ((sub(frame_type, RX_SPEECH_BAD) == 0) || 
+        (sub(frame_type, RX_NO_DATA) == 0) ||
+        (sub(frame_type, RX_ONSET) == 0)) 
+    {
+       bfi = 1;                                          move16 ();
+       test(); test();
+       if ((sub(frame_type, RX_NO_DATA) == 0) ||
+           (sub(frame_type, RX_ONSET) == 0))
+       {
+	  build_CN_param(&st->nodataSeed,
+			 prmno[mode],
+			 bitno[mode],
+			 parm);
+       }       
+    }
+    else if (sub(frame_type, RX_SPEECH_DEGRADED) == 0)
+    {
+       pdfi = 1;                                         move16 ();
+    }
+   
+    
+    test();
+    if (bfi != 0)
+    {
+        st->state = add (st->state, 1);
+    }
+    else if (sub (st->state, 6) == 0)
+
+    {
+        st->state = 5;                                   move16 ();
+    }
+    else
+    {
+        st->state = 0;                                   move16 ();
+    }
+    
+    test (); 
+    if (sub (st->state, 6) > 0)
+    {
+        st->state = 6;                                   move16 ();
+    }
+
+    /* If this frame is the first speech frame after CNI period,     */
+    /* set the BFH state machine to an appropriate state depending   */
+    /* on whether there was DTX muting before start of speech or not */
+    /* If there was DTX muting, the first speech frame is muted.     */
+    /* If there was no DTX muting, the first speech frame is not     */
+    /* muted. The BFH state machine starts from state 5, however, to */
+    /* keep the audible noise resulting from a SID frame which is    */
+    /* erroneously interpreted as a good speech frame as small as    */
+    /* possible (the decoder output in this case is quickly muted)   */
+
+    test(); 
+    if (sub(st->dtxDecoderState->dtxGlobalState, DTX) == 0)
+    {
+       st->state = 5;                                    move16 ();
+       st->prev_bf = 0;                                  move16 ();
+    }
+    else if (test (), sub(st->dtxDecoderState->dtxGlobalState, DTX_MUTE) == 0)
+    {
+       st->state = 5;                                    move16 ();
+       st->prev_bf = 1;                                  move16 ();
+    }
+    
+    /* save old LSFs for CB gain smoothing */
+    Copy (st->lsfState->past_lsf_q, prev_lsf, M);
+    
+    /* decode LSF parameters and generate interpolated lpc coefficients
+       for the 4 subframes */
+    test ();
+    if (sub (mode, MR122) != 0)
+    {
+       D_plsf_3(st->lsfState, mode, bfi, parm, lsp_new);
+
+       fwc ();                     /* function worst case */
+
+       /* Advance synthesis parameters pointer */
+       parm += 3;                  move16 ();
+       
+       Int_lpc_1to3(st->lsp_old, lsp_new, A_t);
+    }
+    else
+    {
+       D_plsf_5 (st->lsfState, bfi, parm, lsp_mid, lsp_new);
+
+       fwc ();                     /* function worst case */
+
+       /* Advance synthesis parameters pointer */
+       parm += 5;                  move16 ();
+       
+       Int_lpc_1and3 (st->lsp_old, lsp_mid, lsp_new, A_t);
+    }
+       
+    /* update the LSPs for the next frame */
+    for (i = 0; i < M; i++)
+    {
+       st->lsp_old[i] = lsp_new[i];        move16 (); 
+    }
+
+    fwc ();                     /* function worst case */
+
+   /*------------------------------------------------------------------------*
+    *          Loop for every subframe in the analysis frame                 *
+    *------------------------------------------------------------------------*
+    * The subframe size is L_SUBFR and the loop is repeated L_FRAME/L_SUBFR  *
+    *  times                                                                 *
+    *     - decode the pitch delay                                           *
+    *     - decode algebraic code                                            *
+    *     - decode pitch and codebook gains                                  *
+    *     - find the excitation and compute synthesis speech                 *
+    *------------------------------------------------------------------------*/
+    
+    /* pointer to interpolated LPC parameters */
+    Az = A_t;                                                       move16 (); 
+    
+    evenSubfr = 0;                                                  move16();
+    subfrNr = -1;                                                   move16();
+    for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR)
+    {
+       subfrNr = add(subfrNr, 1);
+       evenSubfr = sub(1, evenSubfr);
+
+       /* flag for first and 3th subframe */
+       pit_flag = i_subfr;             move16 ();
+
+       test();
+       if (sub (i_subfr, L_FRAME_BY2) == 0)
+       {
+          test(); test();
+          if (sub(mode, MR475) != 0 && sub(mode, MR515) != 0) 
+          {
+             pit_flag = 0;             move16 ();
+          }
+       }
+       
+       /* pitch index */
+       index = *parm++;                move16 ();
+
+       /*-------------------------------------------------------*
+        * - decode pitch lag and find adaptive codebook vector. *
+        *-------------------------------------------------------*/
+       
+       test ();
+       if (sub(mode, MR122) != 0)
+       {
+          /* flag4 indicates encoding with 4 bit resolution;     */
+          /* this is needed for mode MR475, MR515, MR59 and MR67 */
+          
+          flag4 = 0;                                 move16 ();
+          test (); test (); test (); test ();        
+          if ((sub (mode, MR475) == 0) ||
+              (sub (mode, MR515) == 0) ||
+              (sub (mode, MR59) == 0) ||
+              (sub (mode, MR67) == 0) ) {
+             flag4 = 1;                              move16 ();
+          }
+          
+          /*-------------------------------------------------------*
+           * - get ranges for the t0_min and t0_max                *
+           * - only needed in delta decoding                       *
+           *-------------------------------------------------------*/
+
+          delta_frc_low = 5;                      move16();
+          delta_frc_range = 9;                    move16();
+
+          test ();
+          if ( sub(mode, MR795) == 0 )
+          {
+             delta_frc_low = 10;                  move16();
+             delta_frc_range = 19;                move16();
+          }
+             
+          t0_min = sub(st->old_T0, delta_frc_low);
+          test ();
+          if (sub(t0_min, PIT_MIN) < 0)
+          {
+             t0_min = PIT_MIN;                    move16();
+          }
+          t0_max = add(t0_min, delta_frc_range);
+          test ();
+          if (sub(t0_max, PIT_MAX) > 0)
+          {
+             t0_max = PIT_MAX;                    move16();
+             t0_min = sub(t0_max, delta_frc_range);
+          }
+             
+          Dec_lag3 (index, t0_min, t0_max, pit_flag, st->old_T0,
+                    &T0, &T0_frac, flag4);
+
+          st->T0_lagBuff = T0;                        move16 ();
+
+          test ();
+          if (bfi != 0)
+          {
+             test ();
+             if (sub (st->old_T0, PIT_MAX) < 0)     
+             {                                      /* Graceful pitch */
+                st->old_T0 = add(st->old_T0, 1);    /* degradation    */
+             }
+             T0 = st->old_T0;                     move16 (); 
+             T0_frac = 0;                         move16 (); 
+
+             test (); test (); test (); test (); test ();
+             if ( st->inBackgroundNoise != 0 && 
+                  sub(st->voicedHangover, 4) > 0 &&
+                  ((sub(mode, MR475) == 0 ) ||
+                   (sub(mode, MR515) == 0 ) ||
+                   (sub(mode, MR59) == 0) )
+                  )
+             {
+                T0 = st->T0_lagBuff;                  move16 ();
+             }
+          }
+
+          fwc ();             /* function worst case */
+
+          Pred_lt_3or6 (st->exc, T0, T0_frac, L_SUBFR, 1);
+       }
+       else
+       {
+          Dec_lag6 (index, PIT_MIN_MR122,
+                    PIT_MAX, pit_flag, &T0, &T0_frac);
+
+          test (); test (); test ();
+          if ( bfi == 0 && (pit_flag == 0 || sub (index, 61) < 0))
+          {
+          }                
+          else
+          {
+             st->T0_lagBuff = T0;                 move16 ();
+             T0 = st->old_T0;                     move16 (); 
+             T0_frac = 0;                         move16 (); 
+          }
+
+          fwc ();             /* function worst case */
+
+          Pred_lt_3or6 (st->exc, T0, T0_frac, L_SUBFR, 0);
+       }
+       
+       fwc ();             /* function worst case */
+       
+       /*-------------------------------------------------------*
+        * - (MR122 only: Decode pitch gain.)                    *
+        * - Decode innovative codebook.                         *
+        * - set pitch sharpening factor                         *
+        *-------------------------------------------------------*/
+
+        test (); test (); 
+        if (sub (mode, MR475) == 0 || sub (mode, MR515) == 0)
+        {   /* MR475, MR515 */
+           index = *parm++;        /* index of position */ move16 ();
+           i = *parm++;            /* signs             */ move16 ();
+           
+           fwc ();                 /* function worst case */
+
+           decode_2i40_9bits (subfrNr, i, index, code);
+           
+           fwc ();                 /* function worst case */
+
+           pit_sharp = shl (st->sharp, 1);
+        }
+        else if (sub (mode, MR59) == 0)
+        {   /* MR59 */
+           test (); 
+           index = *parm++;        /* index of position */ move16 ();
+           i = *parm++;            /* signs             */ move16 ();
+           
+           fwc ();                 /* function worst case */
+
+           decode_2i40_11bits (i, index, code);
+           
+           fwc ();                 /* function worst case */
+
+           pit_sharp = shl (st->sharp, 1);
+        }
+        else if (sub (mode, MR67) == 0)
+        {   /* MR67 */
+           test (); test ();
+           index = *parm++;        /* index of position */ move16 ();
+           i = *parm++;            /* signs             */ move16 ();
+           
+           fwc ();                 /* function worst case */
+
+           decode_3i40_14bits (i, index, code);
+            
+           fwc ();                 /* function worst case */
+
+           pit_sharp = shl (st->sharp, 1);
+        }
+        else if (sub (mode, MR795) <= 0)
+        {   /* MR74, MR795 */
+           test (); test (); test ();
+           index = *parm++;        /* index of position */ move16 ();
+           i = *parm++;            /* signs             */ move16 ();
+           
+           fwc ();                 /* function worst case */
+
+           decode_4i40_17bits (i, index, code);
+           
+           fwc ();                 /* function worst case */
+
+           pit_sharp = shl (st->sharp, 1);
+        }
+        else if (sub (mode, MR102) == 0)
+        {  /* MR102 */
+           test (); test (); test ();
+
+           fwc ();                 /* function worst case */
+
+           dec_8i40_31bits (parm, code);
+           parm += 7;                                       move16 (); 
+
+           fwc ();                 /* function worst case */
+
+           pit_sharp = shl (st->sharp, 1);
+        }
+        else
+        {  /* MR122 */
+           test (); test (); test ();
+           index = *parm++;                                move16 ();
+           test();
+           if (bfi != 0)
+           {
+              ec_gain_pitch (st->ec_gain_p_st, st->state, &gain_pit);
+           }
+           else
+           {
+              gain_pit = d_gain_pitch (mode, index);        move16 ();
+           }
+           ec_gain_pitch_update (st->ec_gain_p_st, bfi, st->prev_bf,
+                                 &gain_pit);
+           
+
+           fwc ();                 /* function worst case */
+
+
+           dec_10i40_35bits (parm, code);
+           parm += 10;                                     move16 (); 
+
+           fwc ();                 /* function worst case */
+
+           /* pit_sharp = gain_pit;                   */
+           /* if (pit_sharp > 1.0) pit_sharp = 1.0;   */
+           
+           pit_sharp = shl (gain_pit, 1);
+        }
+        
+        /*-------------------------------------------------------*
+         * - Add the pitch contribution to code[].               *
+         *-------------------------------------------------------*/
+        for (i = T0; i < L_SUBFR; i++)
+        {
+           temp = mult (code[i - T0], pit_sharp);
+           code[i] = add (code[i], temp);
+           move16 (); 
+        }
+        
+        fwc ();                 /* function worst case */
+        
+        /*------------------------------------------------------------*
+         * - Decode codebook gain (MR122) or both pitch               *
+         *   gain and codebook gain (all others)                      *
+         * - Update pitch sharpening "sharp" with quantized gain_pit  *
+         *------------------------------------------------------------*/
+
+        if (test(), sub (mode, MR475) == 0)
+        {
+           /* read and decode pitch and code gain */
+           test();      
+           if (evenSubfr != 0) 
+           {
+              index_mr475 = *parm++;        move16 (); /* index of gain(s) */
+           }
+
+           test();
+           if (bfi == 0)
+           {
+              Dec_gain(st->pred_state, mode, index_mr475, code,
+                       evenSubfr, &gain_pit, &gain_code); 
+           }
+           else
+           {
+              ec_gain_pitch (st->ec_gain_p_st, st->state, &gain_pit);
+              ec_gain_code (st->ec_gain_c_st, st->pred_state, st->state,
+                            &gain_code);
+           }
+           ec_gain_pitch_update (st->ec_gain_p_st, bfi, st->prev_bf,
+                                 &gain_pit);
+           ec_gain_code_update (st->ec_gain_c_st, bfi, st->prev_bf,
+                                &gain_code);
+           
+           fwc ();                 /* function worst case */
+
+           pit_sharp = gain_pit;                                move16 ();
+           test ();
+           if (sub (pit_sharp, SHARPMAX) > 0) 
+           {
+               pit_sharp = SHARPMAX;                            move16 ();
+           }
+
+        }
+        else if (test(), test(), (sub (mode, MR74) <= 0) || 
+                 (sub (mode, MR102) == 0))
+        {
+            /* read and decode pitch and code gain */
+            index = *parm++;                move16 (); /* index of gain(s) */
+           
+            test();
+            if (bfi == 0)
+            {
+               Dec_gain(st->pred_state, mode, index, code,
+                        evenSubfr, &gain_pit, &gain_code);
+            }
+            else
+            {
+               ec_gain_pitch (st->ec_gain_p_st, st->state, &gain_pit);
+               ec_gain_code (st->ec_gain_c_st, st->pred_state, st->state,
+                             &gain_code);
+            }
+            ec_gain_pitch_update (st->ec_gain_p_st, bfi, st->prev_bf,
+                                  &gain_pit);
+            ec_gain_code_update (st->ec_gain_c_st, bfi, st->prev_bf,
+                                 &gain_code);
+
+            fwc ();                 /* function worst case */
+            
+            pit_sharp = gain_pit;                               move16 ();
+            test ();
+            if (sub (pit_sharp, SHARPMAX) > 0) 
+            {
+               pit_sharp = SHARPMAX;                           move16 ();
+            }
+
+            if (sub (mode, MR102) == 0)
+            {
+               if (sub (st->old_T0, add(L_SUBFR, 5)) > 0)
+               {
+                  pit_sharp = shr(pit_sharp, 2);
+               }
+            }
+        }
+        else
+        {
+           /* read and decode pitch gain */
+           index = *parm++;                move16 (); /* index of gain(s) */
+           
+           test (); 
+           if (sub (mode, MR795) == 0)
+           {
+              /* decode pitch gain */
+              test();
+              if (bfi != 0)
+              {
+                 ec_gain_pitch (st->ec_gain_p_st, st->state, &gain_pit);
+              }
+              else
+              {
+                 gain_pit = d_gain_pitch (mode, index);       move16 ();
+              }
+              ec_gain_pitch_update (st->ec_gain_p_st, bfi, st->prev_bf,
+                                    &gain_pit);
+              
+              /* read and decode code gain */
+              index = *parm++;                                move16 ();
+              test();
+              if (bfi == 0)
+              {
+                 d_gain_code (st->pred_state, mode, index, code, &gain_code);
+              }
+              else
+              {
+                 ec_gain_code (st->ec_gain_c_st, st->pred_state, st->state,
+                               &gain_code);
+              }
+              ec_gain_code_update (st->ec_gain_c_st, bfi, st->prev_bf,
+                                   &gain_code);
+              
+              fwc ();                 /* function worst case */
+              
+              pit_sharp = gain_pit;                               move16 ();
+              test ();
+              if (sub (pit_sharp, SHARPMAX) > 0)
+              {
+                 pit_sharp = SHARPMAX;                           move16 ();
+              }
+           }
+           else 
+           { /* MR122 */
+              test();
+              if (bfi == 0)
+              {
+                 d_gain_code (st->pred_state, mode, index, code, &gain_code);
+              }
+              else
+              {
+                 ec_gain_code (st->ec_gain_c_st, st->pred_state, st->state,
+                               &gain_code);
+              }
+              ec_gain_code_update (st->ec_gain_c_st, bfi, st->prev_bf,
+                                   &gain_code);
+                            
+              fwc ();                 /* function worst case */
+                
+              pit_sharp = gain_pit;                                move16 ();
+           }
+        }
+        
+        /* store pitch sharpening for next subframe          */
+        /* (for modes which use the previous pitch gain for 
+           pitch sharpening in the search phase)             */
+        /* do not update sharpening in even subframes for MR475 */
+        test(); test();
+        if (sub(mode, MR475) != 0 || evenSubfr == 0)
+        {
+            st->sharp = gain_pit;                                   move16 (); 
+            test ();
+            if (sub (st->sharp, SHARPMAX) > 0)
+            {
+                st->sharp = SHARPMAX;                                move16 ();
+            }
+        }
+
+        pit_sharp = shl (pit_sharp, 1);
+        test ();
+        if (sub (pit_sharp, 16384) > 0)
+        {
+           for (i = 0; i < L_SUBFR; i++)
+            {
+               temp = mult (st->exc[i], pit_sharp);
+               L_temp = L_mult (temp, gain_pit);
+               test ();
+               if (sub(mode, MR122)==0)
+               {
+                  L_temp = L_shr (L_temp, 1);
+               }
+               excp[i] = round (L_temp);                        move16 (); 
+            }
+        }
+        
+        /*-------------------------------------------------------*
+         * - Store list of LTP gains needed in the source        *
+         *   characteristic detector (SCD)                       *
+         *-------------------------------------------------------*/
+        test ();
+        if ( bfi == 0 )
+        {
+           for (i = 0; i < 8; i++)
+           {
+              st->ltpGainHistory[i] = st->ltpGainHistory[i+1];     move16 ();
+           }
+           st->ltpGainHistory[8] = gain_pit;                       move16 ();
+        }
+
+        /*-------------------------------------------------------*
+         * - Limit gain_pit if in background noise and BFI       *
+         *   for MR475, MR515, MR59                              *
+         *-------------------------------------------------------*/
+
+        test (); test (); test (); test (); test (); test ();
+        if ( (st->prev_bf != 0 || bfi != 0) && st->inBackgroundNoise != 0 &&
+             ((sub(mode, MR475) == 0) ||
+              (sub(mode, MR515) == 0) ||
+              (sub(mode, MR59) == 0))
+             )
+        {
+           test ();
+           if ( sub (gain_pit, 12288) > 0)    /* if (gain_pit > 0.75) in Q14*/
+              gain_pit = add( shr( sub(gain_pit, 12288), 1 ), 12288 );
+              /* gain_pit = (gain_pit-0.75)/2.0 + 0.75; */
+
+           test ();
+           if ( sub (gain_pit, 14745) > 0)    /* if (gain_pit > 0.90) in Q14*/
+           {
+              gain_pit = 14745;                                 move16 ();
+           }
+        }
+
+        /*-------------------------------------------------------*
+         *  Calculate CB mixed gain                              *
+         *-------------------------------------------------------*/
+        Int_lsf(prev_lsf, st->lsfState->past_lsf_q, i_subfr, lsf_i); 
+        gain_code_mix = Cb_gain_average(
+            st->Cb_gain_averState, mode, gain_code, 
+            lsf_i, st->lsp_avg_st->lsp_meanSave, bfi, 
+            st->prev_bf, pdfi, st->prev_pdf,  
+            st->inBackgroundNoise, st->voicedHangover);         move16 ();
+        
+        /* make sure that MR74, MR795, MR122 have original code_gain*/
+        test();
+        if ((sub(mode, MR67) > 0) && (sub(mode, MR102) != 0) ) 
+           /* MR74, MR795, MR122 */
+        {
+           gain_code_mix = gain_code;                 move16 ();
+        }
+        
+        /*-------------------------------------------------------*
+         * - Find the total excitation.                          *
+         * - Find synthesis speech corresponding to st->exc[].   *
+         *-------------------------------------------------------*/
+        test ();
+        if (sub(mode, MR102) <= 0) /* MR475, MR515, MR59, MR67, MR74, MR795, MR102*/
+        {
+           pitch_fac = gain_pit;                                move16 ();
+           tmp_shift = 1;                                       move16 ();
+        }
+        else       /* MR122 */
+        {
+           pitch_fac = shr (gain_pit, 1);                       move16 ();
+           tmp_shift = 2;                                       move16 ();
+        }
+
+        /* copy unscaled LTP excitation to exc_enhanced (used in phase
+         * dispersion below) and compute total excitation for LTP feedback
+         */
+        for (i = 0; i < L_SUBFR; i++)
+        {
+           exc_enhanced[i] = st->exc[i];                        move16 ();
+
+           /* st->exc[i] = gain_pit*st->exc[i] + gain_code*code[i]; */
+           L_temp = L_mult (st->exc[i], pitch_fac);
+                                                      /* 12.2: Q0 * Q13 */
+                                                      /*  7.4: Q0 * Q14 */
+           L_temp = L_mac (L_temp, code[i], gain_code);
+                                                      /* 12.2: Q12 * Q1 */
+                                                      /*  7.4: Q13 * Q1 */
+           L_temp = L_shl (L_temp, tmp_shift);                   /* Q16 */
+           st->exc[i] = round (L_temp);                         move16 (); 
+        }
+        
+        /*-------------------------------------------------------*
+         * - Adaptive phase dispersion                           *
+         *-------------------------------------------------------*/
+        ph_disp_release(st->ph_disp_st); /* free phase dispersion adaption */
+
+        test (); test (); test (); test (); test (); test ();
+        if ( ((sub(mode, MR475) == 0) ||
+              (sub(mode, MR515) == 0) ||
+              (sub(mode, MR59) == 0))   &&
+             sub(st->voicedHangover, 3) > 0 &&
+             st->inBackgroundNoise != 0 &&
+             bfi != 0 )
+        {
+           ph_disp_lock(st->ph_disp_st); /* Always Use full Phase Disp. */
+        }                                /* if error in bg noise       */
+
+        /* apply phase dispersion to innovation (if enabled) and
+           compute total excitation for synthesis part           */
+        ph_disp(st->ph_disp_st, mode,
+                exc_enhanced, gain_code_mix, gain_pit, code,
+                pitch_fac, tmp_shift);       
+        
+        /*-------------------------------------------------------*
+         * - The Excitation control module are active during BFI.*
+         * - Conceal drops in signal energy if in bg noise.      *
+         *-------------------------------------------------------*/
+
+        L_temp = 0;                                   move32 ();
+        for (i = 0; i < L_SUBFR; i++)
+        {
+            L_temp = L_mac (L_temp, exc_enhanced[i], exc_enhanced[i] );
+        }
+
+        L_temp = L_shr (L_temp, 1);     /* excEnergy = sqrt(L_temp) in Q0 */
+        L_temp = sqrt_l_exp(L_temp, &temp); move32 (); /* function result */
+        L_temp = L_shr(L_temp, add( shr(temp, 1), 15));
+        L_temp = L_shr(L_temp, 2);       /* To cope with 16-bit and  */
+        excEnergy = extract_l(L_temp);   /* scaling in ex_ctrl()     */
+
+        test (); test (); test (); test (); test (); 
+        test (); test (); test (); test (); test ();
+        if ( ((sub (mode, MR475) == 0) ||
+              (sub (mode, MR515) == 0) ||
+              (sub (mode, MR59) == 0))  &&
+             sub(st->voicedHangover, 5) > 0 &&
+             st->inBackgroundNoise != 0 &&
+             sub(st->state, 4) < 0 &&
+             ( (pdfi != 0 && st->prev_pdf != 0) ||
+                bfi != 0 ||
+                st->prev_bf != 0) )
+        {
+           carefulFlag = 0;                          move32 ();
+           test (); test ();           
+           if ( pdfi != 0 && bfi == 0 )       
+           {
+              carefulFlag = 1;                       move16 ();
+           }
+
+           Ex_ctrl(exc_enhanced,     
+                   excEnergy,
+                   st->excEnergyHist,
+                   st->voicedHangover,
+                   st->prev_bf,
+                   carefulFlag);
+        }
+
+        test (); test (); test (); test ();
+        if ( st->inBackgroundNoise != 0 &&
+             ( bfi != 0 || st->prev_bf != 0 ) &&
+             sub(st->state, 4) < 0 )
+        { 
+           ; /* do nothing! */
+        }
+        else
+        {
+           /* Update energy history for all modes */
+           for (i = 0; i < 8; i++)
+           {
+              st->excEnergyHist[i] = st->excEnergyHist[i+1]; move16 ();
+           }
+           st->excEnergyHist[8] = excEnergy;   move16 ();
+        }
+        /*-------------------------------------------------------*
+         * Excitation control module end.                        *
+         *-------------------------------------------------------*/
+        
+        fwc ();                 /* function worst case */
+
+        test (); 
+        if (sub (pit_sharp, 16384) > 0)
+        {
+           for (i = 0; i < L_SUBFR; i++)
+           {
+              excp[i] = add (excp[i], exc_enhanced[i]);              
+              move16 (); 
+           }
+           agc2 (exc_enhanced, excp, L_SUBFR);
+           Overflow = 0;                 move16 ();
+           Syn_filt (Az, excp, &synth[i_subfr], L_SUBFR,
+                     st->mem_syn, 0);
+        }
+        else
+        {
+           Overflow = 0;                 move16 ();
+           Syn_filt (Az, exc_enhanced, &synth[i_subfr], L_SUBFR,
+                     st->mem_syn, 0);
+        }
+
+        test ();
+        if (Overflow != 0)    /* Test for overflow */
+        {
+           for (i = 0; i < PIT_MAX + L_INTERPOL + L_SUBFR; i++)
+           {
+              st->old_exc[i] = shr(st->old_exc[i], 2);       move16 ();
+           }
+           for (i = 0; i < L_SUBFR; i++)
+           {
+              exc_enhanced[i] = shr(exc_enhanced[i], 2);     move16 ();
+           }
+           Syn_filt(Az, exc_enhanced, &synth[i_subfr], L_SUBFR, st->mem_syn, 1);
+        }
+        else
+        {
+           Copy(&synth[i_subfr+L_SUBFR-M], st->mem_syn, M);
+        }
+        
+        /*--------------------------------------------------*
+         * Update signal for next frame.                    *
+         * -> shift to the left by L_SUBFR  st->exc[]       *
+         *--------------------------------------------------*/
+        
+        Copy (&st->old_exc[L_SUBFR], &st->old_exc[0], PIT_MAX + L_INTERPOL);
+
+        fwc ();                 /* function worst case */
+
+        /* interpolated LPC parameters for next subframe */
+        Az += MP1;                      move16 ();
+        
+        /* store T0 for next subframe */ 
+        st->old_T0 = T0;                move16 ();
+    }
+    
+    /*-------------------------------------------------------*
+     * Call the Source Characteristic Detector which updates *
+     * st->inBackgroundNoise and st->voicedHangover.         *
+     *-------------------------------------------------------*/
+
+                            move16 (); /* function result */
+    st->inBackgroundNoise = Bgn_scd(st->background_state,
+                                    &(st->ltpGainHistory[0]),
+                                    &(synth[0]),
+                                    &(st->voicedHangover) );
+
+    dtx_dec_activity_update(st->dtxDecoderState, 
+                            st->lsfState->past_lsf_q, 
+                            synth);
+    
+    fwc ();                     /* function worst case */
+
+    /* store bfi for next subframe */
+    st->prev_bf = bfi;                  move16 (); 
+    st->prev_pdf = pdfi;                move16 (); 
+    
+    /*--------------------------------------------------*
+     * Calculate the LSF averages on the eight          *
+     * previous frames                                  *
+     *--------------------------------------------------*/
+    
+    lsp_avg(st->lsp_avg_st, st->lsfState->past_lsf_q);
+    fwc ();                 /* function worst case */
+
+the_end:
+    st->dtxDecoderState->dtxGlobalState = newDTXState;  move16();
+    
+    return 0;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/dec_amr.h FFMpeg-20050127-new/libavcodec/amr/dec_amr.h
--- FFMpeg-20050127/libavcodec/amr/dec_amr.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/dec_amr.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,161 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : dec_amr.h
+*      Purpose          : Speech decoder routine.
+*
+*****************************************************************************
+*/
+#ifndef dec_amr_h
+#define dec_amr_h "$Id $"
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include "typedef.h"
+#include "cnst.h"
+#include "mode.h"
+#include "dtx_dec.h"
+#include "d_plsf.h"
+#include "gc_pred.h"
+#include "ec_gains.h"
+#include "ph_disp.h"
+#include "c_g_aver.h"
+#include "bgnscd.h"
+#include "lsp_avg.h"
+#include "frame.h"
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+/*---------------------------------------------------------------*
+ *    Postfilter constant parameters (defined in "cnst.h")       *
+ *---------------------------------------------------------------*
+ *   L_FRAME     : Frame size.                                   *
+ *   PIT_MAX     : Maximum pitch lag.                            *
+ *   L_INTERPOL  : Length of filter for interpolation.           *
+ *   M           : LPC order.                                    *
+ *---------------------------------------------------------------*/
+
+/*
+*****************************************************************************
+*                         DEFINITION OF DATA TYPES
+*****************************************************************************
+*/
+typedef struct{
+  /* Excitation vector */
+  Word16 old_exc[L_SUBFR + PIT_MAX + L_INTERPOL];
+  Word16 *exc;
+    
+  /* Lsp (Line spectral pairs) */
+   /* Word16 lsp[M]; */      /* Used by CN codec */
+  Word16 lsp_old[M];
+ 
+  /* Filter's memory */
+  Word16 mem_syn[M];
+
+  /* pitch sharpening */
+  Word16 sharp;
+  Word16 old_T0;
+
+  /* Memories for bad frame handling */
+  Word16 prev_bf;
+  Word16 prev_pdf;   
+  Word16 state;
+  Word16 excEnergyHist[9];
+
+  /* Variable holding received ltpLag, used in background noise and BFI */
+  Word16 T0_lagBuff;
+
+  /* Variables for the source characteristic detector (SCD) */
+  Word16 inBackgroundNoise;
+  Word16 voicedHangover;
+  Word16 ltpGainHistory[9];
+
+  Bgn_scdState* background_state;
+  Word16 nodataSeed;
+  
+  Cb_gain_averageState *Cb_gain_averState;
+  lsp_avgState *lsp_avg_st;
+   
+   D_plsfState* lsfState;
+   ec_gain_pitchState* ec_gain_p_st;
+   ec_gain_codeState* ec_gain_c_st;  
+   gc_predState* pred_state;
+   ph_dispState* ph_disp_st;
+   dtx_decState* dtxDecoderState;
+} Decoder_amrState;
+ 
+
+/*
+*****************************************************************************
+*                         DECLARATION OF PROTOTYPES
+*****************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : Decoder_amr_init
+*  Purpose     : Allocates initializes state memory
+*  Description : Stores pointer to filter status struct in *st. This
+*                pointer has to be passed to Decoder_amr in each call.
+*  Returns     : 0 on success
+*
+**************************************************************************
+*/
+int Decoder_amr_init (Decoder_amrState **st);
+ 
+/*
+**************************************************************************
+*
+*  Function    : Decoder_amr_reset
+*  Purpose     : Resets state memory
+*  Returns     : 0 on success
+*
+**************************************************************************
+*/
+int Decoder_amr_reset (Decoder_amrState *st,enum Mode mode);
+ 
+/*
+**************************************************************************
+*
+*  Function    : Decoder_amr_exit
+*  Purpose     : The memory used for state memory is freed
+*  Description : Stores NULL in *s
+*  Returns     : void
+*
+**************************************************************************
+*/
+void Decoder_amr_exit (Decoder_amrState **st);
+ 
+/*
+**************************************************************************
+*
+*  Function    : Decoder_amr
+*  Purpose     : Speech decoder routine.
+*  Returns     : 0
+*
+**************************************************************************
+*/
+int Decoder_amr (
+    Decoder_amrState *st,  /* i/o : State variables                       */
+    enum Mode mode,        /* i   : AMR mode                              */
+    Word16 parm[],         /* i   : vector of synthesis parameters
+                                    (PRM_SIZE)                            */
+    enum RXFrameType frame_type, /* i   : received frame type               */
+    Word16 synth[],        /* o   : synthesis speech (L_FRAME)            */
+    Word16 A_t[]           /* o   : decoded LP filter in 4 subframes
+                                    (AZ_SIZE)                             */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/dec_gain.c FFMpeg-20050127-new/libavcodec/amr/dec_gain.c
--- FFMpeg-20050127/libavcodec/amr/dec_gain.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/dec_gain.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,165 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : dec_gain.c
+*      Purpose          : Decode the pitch and codebook gains
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "dec_gain.h"
+const char dec_gain_id[] = "@(#)$Id $" dec_gain_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "mode.h"
+#include "cnst.h"
+#include "pow2.h"
+#include "log2.h"
+#include "gc_pred.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+#include "qua_gain.tab"
+#include "qgain475.tab"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ *   FUNCTION:  Dec_gain()
+ *
+ *   PURPOSE: Decode the pitch and codebook gains
+ *
+ ************************************************************************/
+void Dec_gain(
+    gc_predState *pred_state, /* i/o: MA predictor state           */
+    enum Mode mode,           /* i  : AMR mode                     */
+    Word16 index,             /* i  : index of quantization.       */
+    Word16 code[],            /* i  : Innovative vector.           */
+    Word16 evenSubfr,         /* i  : Flag for even subframes      */     
+    Word16 * gain_pit,        /* o  : Pitch gain.                  */
+    Word16 * gain_cod         /* o  : Code gain.                   */
+)
+{
+    const Word16 *p;
+    Word16 frac, gcode0, exp, qua_ener, qua_ener_MR122;
+    Word16 g_code;
+    Word32 L_tmp;
+    
+    /* Read the quantized gains (table depends on mode) */
+    index = shl (index, 2);
+    
+    test(); test(); test();
+    if (    sub (mode, MR102) == 0
+         || sub (mode, MR74) == 0
+         || sub (mode, MR67) == 0)
+    {
+        p = &table_gain_highrates[index];                  move16 ();
+        
+        *gain_pit = *p++;                                  move16 ();
+        g_code = *p++;                                     move16 ();
+        qua_ener_MR122 = *p++;                             move16 ();
+        qua_ener = *p;                                     move16 ();
+    }
+    else
+    {
+        test();
+        if (sub (mode, MR475) == 0)
+        {
+            index = add (index, shl(sub(1, evenSubfr), 1));
+            p = &table_gain_MR475[index];                  move16 ();
+            
+            *gain_pit = *p++;                              move16 ();
+            g_code = *p++;                                 move16 ();
+            
+            /*---------------------------------------------------------*
+             *  calculate predictor update values (not stored in 4.75  *
+             *  quantizer table to save space):                        *
+             *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  *
+             *                                                         *
+             *   qua_ener       = log2(g)                              *
+             *   qua_ener_MR122 = 20*log10(g)                          *
+             *---------------------------------------------------------*/
+
+            /* Log2(x Q12) = log2(x) + 12 */
+            Log2 (L_deposit_l (g_code), &exp, &frac); 
+            exp = sub(exp, 12);
+    
+            qua_ener_MR122 = add (shr_r (frac, 5), shl (exp, 10));
+    
+            /* 24660 Q12 ~= 6.0206 = 20*log10(2) */
+            L_tmp = Mpy_32_16(exp, frac, 24660);
+            qua_ener = round (L_shl (L_tmp, 13)); /* Q12 * Q0 = Q13 -> Q10 */
+        }
+        else
+        {
+            p = &table_gain_lowrates[index];                move16 ();
+            
+            *gain_pit = *p++;                               move16 ();
+            g_code = *p++;                                  move16 ();
+            qua_ener_MR122 = *p++;                          move16 ();
+            qua_ener = *p;                                  move16 ();
+        }
+    }
+    
+    /*-------------------------------------------------------------------*
+     *  predict codebook gain                                            *
+     *  ~~~~~~~~~~~~~~~~~~~~~                                            *
+     *  gc0     = Pow2(int(d)+frac(d))                                   *
+     *          = 2^exp + 2^frac                                         *
+     *                                                                   *
+     *  gcode0 (Q14) = 2^14*2^frac = gc0 * 2^(14-exp)                    *
+     *-------------------------------------------------------------------*/
+
+    gc_pred(pred_state, mode, code, &exp, &frac, NULL, NULL);
+
+    gcode0 = extract_l(Pow2(14, frac));
+
+    /*------------------------------------------------------------------*
+     *  read quantized gains, update table of past quantized energies   *
+     *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   *
+     *  st->past_qua_en(Q10) = 20 * Log10(g_fac) / constant             *
+     *                       = Log2(g_fac)                              *
+     *                       = qua_ener                                 *
+     *                                           constant = 20*Log10(2) *
+     *------------------------------------------------------------------*/
+
+    L_tmp = L_mult(g_code, gcode0);
+    L_tmp = L_shr(L_tmp, sub(10, exp));
+    *gain_cod = extract_h(L_tmp);
+
+    /* update table of past quantized energies */
+
+    gc_pred_update(pred_state, qua_ener_MR122, qua_ener);
+
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/dec_gain.h FFMpeg-20050127-new/libavcodec/amr/dec_gain.h
--- FFMpeg-20050127/libavcodec/amr/dec_gain.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/dec_gain.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,50 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : dec_gain.h
+*      Purpose          : Decode the pitch and codebook gains
+*
+********************************************************************************
+*/
+#ifndef dec_gain_h
+#define dec_gain_h "$Id $"
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "gc_pred.h"
+#include "mode.h"
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ *   FUNCTION:  Dec_gain()
+ *
+ *   PURPOSE: Decode the pitch and codebook gains
+ *
+ ************************************************************************/
+void Dec_gain(
+    gc_predState *pred_state, /* i/o: MA predictor state           */
+    enum Mode mode,           /* i  : AMR mode                     */
+    Word16 index,             /* i  : index of quantization.       */
+    Word16 code[],            /* i  : Innovative vector.           */
+    Word16 evenSubfr,         /* i  : Flag for even subframes      */     
+    Word16 * gain_pit,        /* o  : Pitch gain.                  */
+    Word16 * gain_cod         /* o  : Code gain.                   */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/dec_lag3.c FFMpeg-20050127-new/libavcodec/amr/dec_lag3.c
--- FFMpeg-20050127/libavcodec/amr/dec_lag3.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/dec_lag3.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,145 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : dec_lag3.c
+*      Purpose          : Decoding of fractional pitch lag with 1/3 resolution.
+*                         Extract the integer and fraction parts of the pitch lag from
+*                         the received adaptive codebook index.
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "dec_lag3.h"
+const char dec_lag3_id[] = "@(#)$Id $" dec_lag3_h;
+
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *   FUNCTION:   Dec_lag3
+ *
+ *   PURPOSE:  Decoding of fractional pitch lag with 1/3 resolution.
+ *             Extract the integer and fraction parts of the pitch lag from
+ *             the received adaptive codebook index.
+ *
+ *    See "Enc_lag3.c" for more details about the encoding procedure.
+ *
+ *    The fractional lag in 1st and 3rd subframes is encoded with 8 bits
+ *    while that in 2nd and 4th subframes is relatively encoded with 4, 5
+ *    and 6 bits depending on the mode.
+ *
+ *************************************************************************/
+void Dec_lag3(Word16 index,     /* i : received pitch index                 */
+              Word16 t0_min,    /* i : minimum of search range              */
+              Word16 t0_max,    /* i : maximum of search range              */
+              Word16 i_subfr,   /* i : subframe flag                        */
+              Word16 T0_prev,   /* i : integer pitch delay of last subframe
+                                       used in 2nd and 4th subframes        */
+              Word16 * T0,      /* o : integer part of pitch lag            */ 
+              Word16 * T0_frac, /* o : fractional part of pitch lag         */
+              Word16 flag4      /* i : flag for encoding with 4 bits        */
+              )
+{
+    Word16 i;
+    Word16 tmp_lag;
+    
+    test (); 
+    if (i_subfr == 0) {    /* if 1st or 3rd subframe */
+       test ();
+	   if (sub(index, 197) < 0) {
+          
+          *T0 = add(mult(add(index, 2), 10923), 19);
+           
+          i = add(add(*T0, *T0), *T0);
+          *T0_frac = add(sub(index, i), 58);
+       } else {
+          *T0 = sub(index, 112);
+          *T0_frac = 0;                                        move16 ();
+       }
+       
+    } else {    /* 2nd or 4th subframe */
+
+       test ();
+       if (flag4 == 0) {
+          
+          /* 'normal' decoding: either with 5 or 6 bit resolution */
+          
+          i = sub(mult(add(index, 2), 10923), 1);
+          *T0 = add(i, t0_min);
+          
+          i = add(add(i, i), i);
+          *T0_frac = sub(sub(index, 2), i);
+       }
+       else {
+          
+          /* decoding with 4 bit resolution */
+          
+          tmp_lag = T0_prev;                                   move16 ();
+
+          test ();
+          if ( sub( sub(tmp_lag, t0_min), 5) > 0)
+             tmp_lag = add (t0_min, 5);
+          test ();
+          if ( sub( sub(t0_max, tmp_lag), 4) > 0)
+             tmp_lag = sub (t0_max, 4);
+          
+          test ();          
+          if (sub(index, 4) < 0)
+          {
+             i = sub(tmp_lag, 5);
+             *T0 = add(i, index);
+             *T0_frac = 0;                                     move16 ();
+          }
+          else
+          {
+             test ();
+             if (sub(index, 12) < 0)
+             {
+                i = sub(mult(sub(index, 5), 10923), 1);
+                *T0 = add(i, tmp_lag);
+                
+                i = add(add(i, i), i);
+                *T0_frac = sub(sub(index, 9), i);
+             }
+             else
+             {
+                i = add( sub (index, 12), tmp_lag);
+                *T0 = add (i, 1);                
+                *T0_frac = 0;                                  move16 ();
+             }
+          }
+          
+       } /* end if (decoding with 4 bit resolution) */
+    }
+    
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/dec_lag3.h FFMpeg-20050127-new/libavcodec/amr/dec_lag3.h
--- FFMpeg-20050127/libavcodec/amr/dec_lag3.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/dec_lag3.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,69 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : dec_lag3.h
+*      Purpose          : Decoding of fractional pitch lag with 1/3 resolution.
+*                         Extract the integer and fraction parts of the pitch lag from
+*                         the received adaptive codebook index.
+*
+********************************************************************************
+*/
+#ifndef dec_lag3_h
+#define dec_lag3_h "$Id $"
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*************************************************************************
+ *   FUNCTION:   Dec_lag3
+ *
+ *   PURPOSE:  Decoding of fractional pitch lag with 1/3 resolution.
+ *             Extract the integer and fraction parts of the pitch lag from
+ *             the received adaptive codebook index.
+ *
+ *    See "Enc_lag3.c" for more details about the encoding procedure.
+ *
+ *    The fractional lag in 1st and 3rd subframes is encoded with 8 bits
+ *    while that in 2nd and 4th subframes is relatively encoded with 4, 5
+ *    and 6 bits depending on the mode.
+ *
+ *************************************************************************/
+void Dec_lag3(Word16 index,     /* i : received pitch index                 */
+              Word16 T0_min,    /* i : minimum of search range              */
+              Word16 T0_max,    /* i : maximum of search range              */
+              Word16 i_subfr,   /* i : subframe flag                        */
+              Word16 T0_prev,   /* i : integer pitch delay of last subframe
+                                       used in 2nd and 4th subframes        */
+              Word16 * T0,      /* o : integer part of pitch lag            */ 
+              Word16 * T0_frac, /* o : fractional part of pitch lag         */
+              Word16 flag4      /* i : flag for encoding with 4 bits        */
+              );
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/dec_lag6.c FFMpeg-20050127-new/libavcodec/amr/dec_lag6.c
--- FFMpeg-20050127/libavcodec/amr/dec_lag6.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/dec_lag6.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,119 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : dec_lag6.c
+*      Purpose          : Decoding of fractional pitch lag with 1/6 resolution.
+*
+********************************************************************************
+*/
+ 
+ 
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "dec_lag6.h"
+const char dec_lag6_id[] = "@(#)$Id $" dec_lag6_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+ 
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*
+************************************************************************
+*   FUNCTION:   Dec_lag6
+*
+*   PURPOSE:  Decoding of fractional pitch lag with 1/6 resolution.
+*             Extract the integer and fraction parts of the pitch lag from
+*             the received adaptive codebook index.
+*
+*    See "Enc_lag6.c" for more details about the encoding procedure.
+*
+*    The fractional lag in 1st and 3rd subframes is encoded with 9 bits
+*    while that in 2nd and 4th subframes is relatively encoded with 6 bits.
+*    Note that in relative encoding only 61 values are used. If the
+*    decoder receives 61, 62, or 63 as the relative pitch index, it means
+*    that a transmission error occurred. In this case, the pitch lag from
+*    previous subframe (actually from previous frame) is used.
+*
+************************************************************************
+*/
+void Dec_lag6 (
+    Word16 index,      /* input : received pitch index           */
+    Word16 pit_min,    /* input : minimum pitch lag              */
+    Word16 pit_max,    /* input : maximum pitch lag              */
+    Word16 i_subfr,    /* input : subframe flag                  */
+    Word16 *T0,        /* in/out: integer part of pitch lag      */
+    Word16 *T0_frac    /* output: fractional part of pitch lag   */
+)
+{
+    Word16 i;
+    Word16 T0_min, T0_max;
+
+    test ();
+    if (i_subfr == 0)          /* if 1st or 3rd subframe */
+    {
+       test (); 
+       if (sub (index, 463) < 0)
+       {
+          /* T0 = (index+5)/6 + 17 */
+          *T0 = add (mult (add (index, 5), 5462), 17);
+          i = add (add (*T0, *T0), *T0);
+          /* *T0_frac = index - T0*6 + 105 */
+          *T0_frac = add (sub (index, add (i, i)), 105);
+                                            move16 (); 
+       }
+       else
+       {
+          *T0 = sub (index, 368);
+          *T0_frac = 0;                     move16 (); 
+       }
+    }
+    else
+       /* second or fourth subframe */
+    {
+       /* find T0_min and T0_max for 2nd (or 4th) subframe */
+        
+       T0_min = sub (*T0, 5);
+
+       test (); 
+       if (sub (T0_min, pit_min) < 0)
+       {
+          T0_min = pit_min;                 move16 (); 
+       }
+       T0_max = add (T0_min, 9);
+
+       test (); 
+       if (sub (T0_max, pit_max) > 0)
+       {
+          T0_max = pit_max;                 move16 (); 
+          T0_min = sub (T0_max, 9);
+       }
+       
+       /* i = (index+5)/6 - 1 */
+       i = sub (mult (add (index, 5), 5462), 1);
+       *T0 = add (i, T0_min);
+       i = add (add (i, i), i);
+       *T0_frac = sub (sub (index, 3), add (i, i));
+                                            move16 (); 
+    }
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/dec_lag6.h FFMpeg-20050127-new/libavcodec/amr/dec_lag6.h
--- FFMpeg-20050127/libavcodec/amr/dec_lag6.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/dec_lag6.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,40 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : dec_lag6.h
+*      Purpose          : Decoding of fractional pitch lag with 1/6 resolution.
+*
+********************************************************************************
+*/
+#ifndef dec_lag6_h
+#define dec_lag6_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+ 
+void Dec_lag6 (
+    Word16 index,      /* input : received pitch index           */
+    Word16 pit_min,    /* input : minimum pitch lag              */
+    Word16 pit_max,    /* input : maximum pitch lag              */
+    Word16 i_subfr,    /* input : subframe flag                  */
+    Word16 *T0,        /* in/out: integer part of pitch lag      */
+    Word16 *T0_frac    /* output: fractional part of pitch lag   */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/decoder.c FFMpeg-20050127-new/libavcodec/amr/decoder.c
--- FFMpeg-20050127/libavcodec/amr/decoder.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/decoder.c	2003-10-01 12:24:00.000000000 +0000
@@ -0,0 +1,291 @@
+
+/*************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : decoder.c
+*      Purpose          : Speech decoder main program.
+*
+********************************************************************************
+*
+*         Usage : decoder  bitstream_file  synth_file
+*
+*
+*         Format for bitstream_file:
+*             1 word (2-byte) for the frame type
+*               (see frame.h for possible values)
+*               Normally, the TX frame type is expected.
+*               RX frame type can be forced with "-rxframetype"
+*           244 words (2-byte) containing 244 bits.
+*               Bit 0 = 0x0000 and Bit 1 = 0x0001
+*             1 word (2-byte) for the mode indication
+*               (see mode.h for possible values)
+*             4 words for future use, currently unused
+*
+*         Format for synth_file:
+*           Synthesis is written to a binary file of 16 bits data.
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+#include "typedef.h"
+#include "n_proc.h"
+#include "cnst.h"
+#include "mode.h"
+#include "frame.h"
+#include "strfunc.h"
+#include "sp_dec.h"
+#include "d_homing.h"
+
+#ifdef MMS_IO
+#define AMR_MAGIC_NUMBER "#!AMR\n"
+#define MAX_PACKED_SIZE (MAX_SERIAL_SIZE / 8 + 2)
+#endif
+
+const char decoder_id[] = "@(#)$Id $";
+
+/* frame size in serial bitstream file (frame type + serial stream + flags) */
+#define SERIAL_FRAMESIZE (1+MAX_SERIAL_SIZE+5)
+
+/*
+********************************************************************************
+*                         LOCAL PROGRAM CODE
+********************************************************************************
+*/
+static enum RXFrameType tx_to_rx (enum TXFrameType tx_type)
+{
+    switch (tx_type) {
+      case TX_SPEECH_GOOD:      return RX_SPEECH_GOOD;
+      case TX_SPEECH_DEGRADED:  return RX_SPEECH_DEGRADED;
+      case TX_SPEECH_BAD:       return RX_SPEECH_BAD;
+      case TX_SID_FIRST:        return RX_SID_FIRST;
+      case TX_SID_UPDATE:       return RX_SID_UPDATE;
+      case TX_SID_BAD:          return RX_SID_BAD;
+      case TX_ONSET:            return RX_ONSET;
+      case TX_NO_DATA:          return RX_NO_DATA;
+      default:
+        fprintf(stderr, "tx_to_rx: unknown TX frame type %d\n", tx_type);
+        exit(1);
+    }
+}
+
+/*
+********************************************************************************
+*                             MAIN PROGRAM 
+********************************************************************************
+*/
+
+int main (int argc, char *argv[])
+{
+  Speech_Decode_FrameState *speech_decoder_state = NULL;
+  
+  Word16 serial[SERIAL_FRAMESIZE];   /* coded bits                    */
+  Word16 synth[L_FRAME];             /* Synthesis                     */
+  Word32 frame;
+
+  char *progname = argv[0];
+  char *fileName = NULL;
+  char *serialFileName = NULL;
+  
+  FILE *file_syn, *file_serial;
+
+  int rxframetypeMode = 0;           /* use RX frame type codes       */
+  enum Mode mode = (enum Mode)0;
+  enum RXFrameType rx_type = (enum RXFrameType)0;
+  enum TXFrameType tx_type = (enum TXFrameType)0;
+     
+  Word16 reset_flag = 0;
+  Word16 reset_flag_old = 1;
+  Word16 i;
+  
+#ifdef MMS_IO
+  UWord8 toc, q, ft;
+  Word8 magic[8];
+  UWord8 packed_bits[MAX_PACKED_SIZE];
+  Word16 packed_size[16] = {12, 13, 15, 17, 19, 20, 26, 31, 5, 0, 0, 0, 0, 0, 0, 0};
+#endif
+
+   proc_head ("Decoder");
+
+#ifndef MMS_IO
+  /*----------------------------------------------------------------------*
+   * process command line options                                         *
+   *----------------------------------------------------------------------*/
+  while (argc > 1) {
+      if (strcmp(argv[1], "-rxframetype") == 0)
+          rxframetypeMode = 1;
+      else break;
+
+      argc--;
+      argv++;
+  }
+#endif
+
+  /*----------------------------------------------------------------------*
+   * check number of arguments                                            *
+   *----------------------------------------------------------------------*/
+  if (argc != 3)
+  {
+    fprintf (stderr,
+      " Usage:\n\n"
+#ifndef MMS_IO
+      "   %s  [-rxframetype] bitstream_file synth_file\n\n"
+      " -rxframetype expects the RX frame type in bitstream_file (instead of TX)\n\n",
+#else
+      "   %s  bitstream_file synth_file\n\n",
+#endif
+             progname);
+      exit (1);
+  }
+  
+  serialFileName = argv[1];
+  fileName = argv[2];
+
+  /*----------------------------------------------------------------------*
+   * Open serial bit stream and output speech file                        *
+   *----------------------------------------------------------------------*/
+  if (strcmp(serialFileName, "-") == 0) {
+     file_serial = stdin;
+  }
+  else if ((file_serial = fopen (serialFileName, "rb")) == NULL)
+  {
+      fprintf (stderr, "Input file '%s' does not exist !!\n", serialFileName);
+      exit (0);
+  }
+  fprintf (stderr, "Input bitstream file:   %s\n", serialFileName);
+
+  if (strcmp(fileName, "-") == 0) {
+     file_syn = stdout;
+  }
+  else if ((file_syn = fopen (fileName, "wb")) == NULL)
+  {
+      fprintf (stderr, "Cannot create output file '%s' !!\n", fileName);
+      exit (0);
+  }
+  fprintf (stderr, "Synthesis speech file:  %s\n", fileName);
+
+#ifdef MMS_IO
+   /* read and verify magic number */
+  fread(magic, sizeof(Word8), strlen(AMR_MAGIC_NUMBER), file_serial);
+  if (strncmp((const char *)magic, AMR_MAGIC_NUMBER, strlen(AMR_MAGIC_NUMBER)))
+  {
+	   fprintf(stderr, "%s%s\n", "Invalid magic number: ", magic);
+	   fclose(file_serial);
+	   fclose(file_syn);
+	   return 1;
+   }
+#endif
+
+  /*-----------------------------------------------------------------------*
+   * Initialization of decoder                                             *
+   *-----------------------------------------------------------------------*/
+  if (Speech_Decode_Frame_init(&speech_decoder_state, "Decoder"))
+      exit(-1);
+    
+  /*-----------------------------------------------------------------------*
+   * process serial bitstream frame by frame                               *
+   *-----------------------------------------------------------------------*/
+  frame = 0;
+
+#ifndef MMS_IO
+  while (fread (serial, sizeof (Word16), SERIAL_FRAMESIZE, file_serial)
+         == SERIAL_FRAMESIZE)
+  {
+     /* get frame type and mode information from frame */
+     if (rxframetypeMode) {
+         rx_type = (enum RXFrameType)serial[0];
+     } else {
+         tx_type = (enum TXFrameType)serial[0];
+         rx_type = tx_to_rx (tx_type);
+     }
+     mode = (enum Mode) serial[1+MAX_SERIAL_SIZE];
+
+#else
+
+  while (fread (&toc, sizeof(UWord8), 1, file_serial) == 1)
+  {
+	  /* read rest of the frame based on ToC byte */
+	  q  = (toc >> 2) & 0x01;
+	  ft = (toc >> 3) & 0x0F;
+	  fread (packed_bits, sizeof(UWord8), packed_size[ft], file_serial);
+
+	  rx_type = UnpackBits(q, ft, packed_bits, &mode, &serial[1]);
+
+#endif
+
+     ++frame;
+     if ( (frame%50) == 0) {
+        fprintf (stderr, "\rframe=%d  ", frame);
+     }
+
+     if (rx_type == RX_NO_DATA) {
+       mode = speech_decoder_state->prev_mode;
+     }
+     else {
+       speech_decoder_state->prev_mode = mode;
+     }
+
+     /* if homed: check if this frame is another homing frame */
+     if (reset_flag_old == 1)
+     {
+         /* only check until end of first subframe */
+         reset_flag = decoder_homing_frame_test_first(&serial[1], mode);
+     }
+     /* produce encoder homing frame if homed & input=decoder homing frame */
+     if ((reset_flag != 0) && (reset_flag_old != 0))
+     {
+         for (i = 0; i < L_FRAME; i++)
+         {
+             synth[i] = EHF_MASK;
+         }
+     }
+     else
+     {     
+         /* decode frame */
+         Speech_Decode_Frame(speech_decoder_state, mode, &serial[1],
+                             rx_type, synth);
+     }
+     
+     /* write synthesized speech to file */
+     if (fwrite (synth, sizeof (Word16), L_FRAME, file_syn) != L_FRAME) {
+         fprintf(stderr, "\nerror writing output file: %s\n",
+                 strerror(errno));
+     };
+     fflush(file_syn);
+
+     /* if not homed: check whether current frame is a homing frame */
+     if (reset_flag_old == 0)
+     {
+         /* check whole frame */
+         reset_flag = decoder_homing_frame_test(&serial[1], mode);
+     }
+     /* reset decoder if current frame is a homing frame */
+     if (reset_flag != 0)
+     {
+         Speech_Decode_Frame_reset(speech_decoder_state);
+     }
+     reset_flag_old = reset_flag;
+
+  }
+  fprintf (stderr, "\n%d frame(s) processed\n", frame);
+  
+  /*-----------------------------------------------------------------------*
+   * Close down speech decoder                                             *
+   *-----------------------------------------------------------------------*/
+  Speech_Decode_Frame_exit(&speech_decoder_state);
+  
+  return 0;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/dtx_dec.c FFMpeg-20050127-new/libavcodec/amr/dtx_dec.c
--- FFMpeg-20050127/libavcodec/amr/dtx_dec.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/dtx_dec.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,899 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : dtx_dec.c
+*      Purpose          : Decode comfort noise when in DTX
+*
+*****************************************************************************
+*/
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "dtx_dec.h"
+const char dtx_dec_id[] = "@(#)$Id $" dtx_dec_h;
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "copy.h"
+#include "set_zero.h"
+#include "mode.h"
+#include "log2.h"
+#include "lsp_az.h"
+#include "pow2.h"
+#include "a_refl.h"
+#include "b_cn_cod.h"
+#include "syn_filt.h"
+#include "lsp_lsf.h"
+#include "reorder.h"
+#include "count.h"
+#include "q_plsf_5.tab"
+#include "lsp.tab"
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+#define PN_INITIAL_SEED 0x70816958L   /* Pseudo noise generator seed value  */
+
+/***************************************************
+ * Scaling factors for the lsp variability operation *
+ ***************************************************/
+static const Word16 lsf_hist_mean_scale[M] = {
+   20000,
+   20000,
+   20000,
+   20000,
+   20000,
+   18000,
+   16384,
+    8192,
+       0,
+       0
+};
+
+/*************************************************
+ * level adjustment for different modes Q11      *
+ *************************************************/
+static const Word16 dtx_log_en_adjust[9] =
+{
+  -1023, /* MR475 */
+   -878, /* MR515 */
+   -732, /* MR59  */
+   -586, /* MR67  */
+   -440, /* MR74  */
+   -294, /* MR795 */
+   -148, /* MR102 */
+      0, /* MR122 */
+      0, /* MRDTX */
+};
+
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : dtx_dec_init
+*
+**************************************************************************
+*/ 
+int dtx_dec_init (dtx_decState **st)
+{
+   dtx_decState* s;
+   
+   if (st == (dtx_decState **) NULL){
+      fprintf(stderr, "dtx_dec_init: invalid parameter\n");
+      return -1; 
+   }
+   
+   *st = NULL;
+   
+   /* allocate memory */
+   if ((s= (dtx_decState *) malloc(sizeof(dtx_decState))) == NULL){
+      fprintf(stderr, "dtx_dec_init: can not malloc state structure\n");
+      return -1;
+   }
+   
+   dtx_dec_reset(s);
+   *st = s;
+   
+   return 0;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : dtx_dec_reset
+*
+**************************************************************************
+*/
+int dtx_dec_reset (dtx_decState *st)
+{
+   int i;
+
+   if (st == (dtx_decState *) NULL){
+      fprintf(stderr, "dtx_dec_reset: invalid parameter\n");
+      return -1;
+   }
+   
+   st->since_last_sid = 0;
+   st->true_sid_period_inv = (1 << 13); 
+ 
+   st->log_en = 3500;  
+   st->old_log_en = 3500;
+   /* low level noise for better performance in  DTX handover cases*/
+   
+   st->L_pn_seed_rx = PN_INITIAL_SEED;
+
+   /* Initialize state->lsp [] and state->lsp_old [] */
+   Copy(lsp_init_data, &st->lsp[0], M);
+   Copy(lsp_init_data, &st->lsp_old[0], M);
+
+   st->lsf_hist_ptr = 0;
+   st->log_pg_mean = 0;
+   st->log_en_hist_ptr = 0;
+
+   /* initialize decoder lsf history */
+   Copy(mean_lsf, &st->lsf_hist[0], M);
+
+   for (i = 1; i < DTX_HIST_SIZE; i++)
+   {
+      Copy(&st->lsf_hist[0], &st->lsf_hist[M*i], M);
+   }
+   Set_zero(st->lsf_hist_mean, M*DTX_HIST_SIZE);
+
+   /* initialize decoder log frame energy */ 
+   for (i = 0; i < DTX_HIST_SIZE; i++)
+   {
+      st->log_en_hist[i] = st->log_en;
+   }
+
+   st->log_en_adjust = 0;
+
+   st->dtxHangoverCount = DTX_HANG_CONST;
+   st->decAnaElapsedCount = 32767;   
+
+   st->sid_frame = 0;       
+   st->valid_data = 0;             
+   st->dtxHangoverAdded = 0; 
+  
+   st->dtxGlobalState = DTX;    
+   st->data_updated = 0; 
+   return 0;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : dtx_dec_exit
+*
+**************************************************************************
+*/
+void dtx_dec_exit (dtx_decState **st)
+{
+   if (st == NULL || *st == NULL)
+      return;
+   
+   /* deallocate memory */
+   free(*st);
+   *st = NULL;
+   
+   return;
+}
+
+/*
+**************************************************************************
+*
+*  Function    : dtx_dec
+*                
+**************************************************************************
+*/
+int dtx_dec(
+   dtx_decState *st,                /* i/o : State struct                    */
+   Word16 mem_syn[],                /* i/o : AMR decoder state               */
+   D_plsfState* lsfState,           /* i/o : decoder lsf states              */
+   gc_predState* predState,         /* i/o : prediction states               */
+   Cb_gain_averageState* averState, /* i/o : CB gain average states          */
+   enum DTXStateType new_state,     /* i   : new DTX state                   */
+   enum Mode mode,                  /* i   : AMR mode                        */
+   Word16 parm[],                   /* i   : Vector of synthesis parameters  */
+   Word16 synth[],                  /* o   : synthesised speech              */
+   Word16 A_t[]                     /* o   : decoded LP filter in 4 subframes*/
+   )
+{
+   Word16 log_en_index;
+   Word16 i, j;
+   Word16 int_fac;
+   Word32 L_log_en_int;
+   Word16 lsp_int[M];
+   Word16 log_en_int_e;
+   Word16 log_en_int_m;
+   Word16 level;
+   Word16 acoeff[M + 1];
+   Word16 refl[M];
+   Word16 pred_err;
+   Word16 ex[L_SUBFR];
+   Word16 ma_pred_init;
+   Word16 log_pg_e, log_pg_m;
+   Word16 log_pg;
+   Flag negative;
+   Word16 lsf_mean;
+   Word32 L_lsf_mean;
+   Word16 lsf_variab_index;
+   Word16 lsf_variab_factor;
+   Word16 lsf_int[M];
+   Word16 lsf_int_variab[M];
+   Word16 lsp_int_variab[M];
+   Word16 acoeff_variab[M + 1];
+
+   Word16 lsf[M];
+   Word32 L_lsf[M];
+   Word16 ptr;
+   Word16 tmp_int_length;
+
+
+   /*  This function is called if synthesis state is not SPEECH 
+    *  the globally passed  inputs to this function are 
+    * st->sid_frame 
+    * st->valid_data 
+    * st->dtxHangoverAdded
+    * new_state  (SPEECH, DTX, DTX_MUTE)
+    */
+
+   test(); test();
+   if ((st->dtxHangoverAdded != 0) && 
+       (st->sid_frame != 0))
+   {
+      /* sid_first after dtx hangover period */
+      /* or sid_upd after dtxhangover        */
+
+      /* set log_en_adjust to correct value */
+      st->log_en_adjust = dtx_log_en_adjust[mode];
+          
+      ptr = add(st->lsf_hist_ptr, M);                               move16(); 
+      test();
+      if (sub(ptr, 80) == 0)
+      {
+         ptr = 0;                                                   move16();
+      }
+      Copy( &st->lsf_hist[st->lsf_hist_ptr],&st->lsf_hist[ptr],M); 
+      
+      ptr = add(st->log_en_hist_ptr,1);                             move16();
+      test();
+      if (sub(ptr, DTX_HIST_SIZE) == 0)
+      {
+         ptr = 0;                                                   move16();
+      }
+      move16();
+      st->log_en_hist[ptr] = st->log_en_hist[st->log_en_hist_ptr]; /* Q11 */
+      
+      /* compute mean log energy and lsp *
+       * from decoded signal (SID_FIRST) */         
+      st->log_en = 0;                                               move16();
+      for (i = 0; i < M; i++)
+      {
+         L_lsf[i] = 0;                                              move16();
+      }
+      
+      /* average energy and lsp */
+      for (i = 0; i < DTX_HIST_SIZE; i++)
+      {
+         st->log_en = add(st->log_en,
+                          shr(st->log_en_hist[i],3));
+         for (j = 0; j < M; j++)
+         {
+            L_lsf[j] = L_add(L_lsf[j],
+                             L_deposit_l(st->lsf_hist[i * M + j]));
+         }
+      }
+       
+      for (j = 0; j < M; j++)
+      {
+         lsf[j] = extract_l(L_shr(L_lsf[j],3)); /* divide by 8 */  move16();
+      }
+      
+      Lsf_lsp(lsf, st->lsp, M); 
+
+      /* make log_en speech coder mode independent */
+      /* added again later before synthesis        */
+      st->log_en = sub(st->log_en, st->log_en_adjust);
+
+      /* compute lsf variability vector */
+      Copy(st->lsf_hist, st->lsf_hist_mean, 80);
+
+      for (i = 0; i < M; i++)
+      {
+         L_lsf_mean = 0;                                           move32();
+         /* compute mean lsf */
+         for (j = 0; j < 8; j++)
+         {
+            L_lsf_mean = L_add(L_lsf_mean, 
+                               L_deposit_l(st->lsf_hist_mean[i+j*M]));
+         }
+         
+         lsf_mean = extract_l(L_shr(L_lsf_mean, 3));               move16();
+         /* subtract mean and limit to within reasonable limits  *
+          * moreover the upper lsf's are attenuated              */
+         for (j = 0; j < 8; j++)
+         {
+            /* subtract mean */ 
+            st->lsf_hist_mean[i+j*M] = 
+               sub(st->lsf_hist_mean[i+j*M], lsf_mean);
+
+            /* attenuate deviation from mean, especially for upper lsf's */
+            st->lsf_hist_mean[i+j*M] = 
+               mult(st->lsf_hist_mean[i+j*M], lsf_hist_mean_scale[i]);
+
+            /* limit the deviation */
+            test();
+            if (st->lsf_hist_mean[i+j*M] < 0)
+            {
+               negative = 1;                                        move16();
+            }
+            else
+            {
+               negative = 0;                                        move16();
+            }
+            st->lsf_hist_mean[i+j*M] = abs_s(st->lsf_hist_mean[i+j*M]);
+
+            /* apply soft limit */
+            test();
+            if (sub(st->lsf_hist_mean[i+j*M], 655) > 0)
+            {
+               st->lsf_hist_mean[i+j*M] = 
+                  add(655, shr(sub(st->lsf_hist_mean[i+j*M], 655), 2));
+            }
+            
+            /* apply hard limit */
+            test();
+            if (sub(st->lsf_hist_mean[i+j*M], 1310) > 0)
+            {
+               st->lsf_hist_mean[i+j*M] = 1310;                     move16();
+            }
+            test();
+            if (negative != 0) 
+            {
+               st->lsf_hist_mean[i+j*M] = -st->lsf_hist_mean[i+j*M];move16();
+            }
+            
+         }
+      }
+   }
+   
+   test();
+   if (st->sid_frame != 0 )
+   {
+      /* Set old SID parameters, always shift */
+      /* even if there is no new valid_data   */
+      Copy(st->lsp, st->lsp_old, M);
+      st->old_log_en = st->log_en;                                  move16();
+
+      test();
+      if (st->valid_data != 0 )  /* new data available (no CRC) */
+      {
+         /* Compute interpolation factor, since the division only works *
+          * for values of since_last_sid < 32 we have to limit the      *
+          * interpolation to 32 frames                                  */
+         tmp_int_length = st->since_last_sid;                       move16();
+         st->since_last_sid = 0;                                    move16();
+
+         test();
+         if (sub(tmp_int_length, 32) > 0)
+         {
+            tmp_int_length = 32;                                    move16();
+         }
+         test();
+         if (sub(tmp_int_length, 2) >= 0)
+         {
+            move16();
+            st->true_sid_period_inv = div_s(1 << 10, shl(tmp_int_length, 10)); 
+         }
+         else
+         {
+            st->true_sid_period_inv = 1 << 14; /* 0.5 it Q15 */     move16();
+         }
+         
+         Init_D_plsf_3(lsfState, parm[0]);  /* temporay initialization */ 
+         D_plsf_3(lsfState, MRDTX, 0, &parm[1], st->lsp);
+         Set_zero(lsfState->past_r_q, M);   /* reset for next speech frame */ 
+
+         log_en_index = parm[4];                                    move16();
+         /* Q11 and divide by 4 */
+         st->log_en = shl(log_en_index, (11 - 2));                  move16();
+         
+         /* Subtract 2.5 in Q11 */
+         st->log_en = sub(st->log_en, (2560 * 2));
+         
+         /* Index 0 is reserved for silence */
+         test();
+         if (log_en_index == 0)
+         {
+            st->log_en = MIN_16;                                    move16();
+         }
+         
+         /* no interpolation at startup after coder reset        */
+         /* or when SID_UPD has been received right after SPEECH */
+         test(); test();
+         if ((st->data_updated == 0) ||
+             (sub(st->dtxGlobalState, SPEECH) == 0)
+             ) 
+         {
+            Copy(st->lsp, st->lsp_old, M);
+            st->old_log_en = st->log_en;                            move16();
+         }         
+      } /* endif valid_data */
+
+      /* initialize gain predictor memory of other modes */       
+      ma_pred_init = sub(shr(st->log_en,1), 9000);                  move16();
+      test();
+      if (ma_pred_init > 0)
+      {                   
+         ma_pred_init = 0;                                          move16();  
+      }      
+      test();
+      if (sub(ma_pred_init, -14436) < 0)
+      {
+         ma_pred_init = -14436;                                     move16();
+      }
+      
+      predState->past_qua_en[0] = ma_pred_init;                     move16();
+      predState->past_qua_en[1] = ma_pred_init;                     move16();
+      predState->past_qua_en[2] = ma_pred_init;                     move16();
+      predState->past_qua_en[3] = ma_pred_init;                     move16();
+
+      /* past_qua_en for other modes than MR122 */      
+      ma_pred_init = mult(5443, ma_pred_init); 
+      /* scale down by factor 20*log10(2) in Q15 */
+      predState->past_qua_en_MR122[0] = ma_pred_init;               move16();
+      predState->past_qua_en_MR122[1] = ma_pred_init;               move16();
+      predState->past_qua_en_MR122[2] = ma_pred_init;               move16();
+      predState->past_qua_en_MR122[3] = ma_pred_init;               move16();
+   } /* endif sid_frame */
+   
+   /* CN generation */
+   /* recompute level adjustment factor Q11             *
+    * st->log_en_adjust = 0.9*st->log_en_adjust +       *
+    *                     0.1*dtx_log_en_adjust[mode]); */
+   move16();
+   st->log_en_adjust = add(mult(st->log_en_adjust, 29491),
+                           shr(mult(shl(dtx_log_en_adjust[mode],5),3277),5));
+
+   /* Interpolate SID info */
+   int_fac = shl(add(1,st->since_last_sid), 10); /* Q10 */                 move16();
+   int_fac = mult(int_fac, st->true_sid_period_inv); /* Q10 * Q15 -> Q10 */
+   
+   /* Maximize to 1.0 in Q10 */
+   test();
+   if (sub(int_fac, 1024) > 0)
+   {
+      int_fac = 1024;                                               move16();
+   }
+   int_fac = shl(int_fac, 4); /* Q10 -> Q14 */
+   
+   L_log_en_int = L_mult(int_fac, st->log_en); /* Q14 * Q11->Q26 */ move32();
+   for(i = 0; i < M; i++)
+   {
+      lsp_int[i] = mult(int_fac, st->lsp[i]);/* Q14 * Q15 -> Q14 */ move16();
+   }
+   
+   int_fac = sub(16384, int_fac); /* 1-k in Q14 */                  move16();
+
+   /* (Q14 * Q11 -> Q26) + Q26 -> Q26 */
+   L_log_en_int = L_mac(L_log_en_int, int_fac, st->old_log_en);
+   for(i = 0; i < M; i++)
+   {
+      /* Q14 + (Q14 * Q15 -> Q14) -> Q14 */
+      lsp_int[i] = add(lsp_int[i], mult(int_fac, st->lsp_old[i]));  move16();
+      lsp_int[i] = shl(lsp_int[i], 1); /* Q14 -> Q15 */             move16();
+   }
+   
+   /* compute the amount of lsf variability */
+   lsf_variab_factor = sub(st->log_pg_mean,2457); /* -0.6 in Q12 */ move16();
+   /* *0.3 Q12*Q15 -> Q12 */
+   lsf_variab_factor = sub(4096, mult(lsf_variab_factor, 9830)); 
+
+   /* limit to values between 0..1 in Q12 */ 
+   test();
+   if (sub(lsf_variab_factor, 4096) > 0)
+   {
+      lsf_variab_factor = 4096;                                     move16();
+   }
+   test();
+   if (lsf_variab_factor < 0)
+   {
+      lsf_variab_factor = 0;                                        move16(); 
+   }
+   lsf_variab_factor = shl(lsf_variab_factor, 3); /* -> Q15 */      move16();
+
+   /* get index of vector to do variability with */
+   lsf_variab_index = pseudonoise(&st->L_pn_seed_rx, 3);            move16();
+
+   /* convert to lsf */
+   Lsp_lsf(lsp_int, lsf_int, M);
+
+   /* apply lsf variability */
+   Copy(lsf_int, lsf_int_variab, M);
+   for(i = 0; i < M; i++)
+   {
+      move16();
+      lsf_int_variab[i] = add(lsf_int_variab[i], 
+                              mult(lsf_variab_factor,
+                                   st->lsf_hist_mean[i+lsf_variab_index*M]));
+   }
+
+   /* make sure that LSP's are ordered */
+   Reorder_lsf(lsf_int, LSF_GAP, M);
+   Reorder_lsf(lsf_int_variab, LSF_GAP, M);
+
+   /* copy lsf to speech decoders lsf state */
+   Copy(lsf_int, lsfState->past_lsf_q, M);
+
+   /* convert to lsp */
+   Lsf_lsp(lsf_int, lsp_int, M);
+   Lsf_lsp(lsf_int_variab, lsp_int_variab, M);
+
+   /* Compute acoeffs Q12 acoeff is used for level    * 
+    * normalization and postfilter, acoeff_variab is  *
+    * used for synthesis filter                       *
+    * by doing this we make sure that the level       *
+    * in high frequenncies does not jump up and down  */
+
+   Lsp_Az(lsp_int, acoeff);
+   Lsp_Az(lsp_int_variab, acoeff_variab);
+   
+   /* For use in postfilter */
+   Copy(acoeff, &A_t[0],           M + 1);
+   Copy(acoeff, &A_t[M + 1],       M + 1);
+   Copy(acoeff, &A_t[2 * (M + 1)], M + 1);
+   Copy(acoeff, &A_t[3 * (M + 1)], M + 1);
+   
+   /* Compute reflection coefficients Q15 */
+   A_Refl(&acoeff[1], refl);
+   
+   /* Compute prediction error in Q15 */
+   pred_err = MAX_16; /* 0.99997 in Q15 */                          move16();
+   for (i = 0; i < M; i++)
+   { 
+      pred_err = mult(pred_err, sub(MAX_16, mult(refl[i], refl[i])));
+   }
+
+   /* compute logarithm of prediction gain */   
+   Log2(L_deposit_l(pred_err), &log_pg_e, &log_pg_m);
+   
+   /* convert exponent and mantissa to Word16 Q12 */
+   log_pg = shl(sub(log_pg_e,15), 12);  /* Q12 */                   move16();
+   log_pg = shr(sub(0,add(log_pg, shr(log_pg_m, 15-12))), 1);       move16();
+   st->log_pg_mean = add(mult(29491,st->log_pg_mean),
+                         mult(3277, log_pg));                       move16();
+
+   /* Compute interpolated log energy */
+   L_log_en_int = L_shr(L_log_en_int, 10); /* Q26 -> Q16 */         move32();
+
+   /* Add 4 in Q16 */
+   L_log_en_int = L_add(L_log_en_int, 4 * 65536L);                  move32();
+
+   /* subtract prediction gain */
+   L_log_en_int = L_sub(L_log_en_int, L_shl(L_deposit_l(log_pg), 4));move32();
+
+   /* adjust level to speech coder mode */
+   L_log_en_int = L_add(L_log_en_int, 
+                        L_shl(L_deposit_l(st->log_en_adjust), 5));  move32();
+       
+   log_en_int_e = extract_h(L_log_en_int);                    move16();
+   move16();
+   log_en_int_m = extract_l(L_shr(L_sub(L_log_en_int, 
+                                        L_deposit_h(log_en_int_e)), 1));
+   level = extract_l(Pow2(log_en_int_e, log_en_int_m)); /* Q4 */ move16();
+   
+   for (i = 0; i < 4; i++)
+   {             
+      /* Compute innovation vector */
+      build_CN_code(&st->L_pn_seed_rx, ex);
+      for (j = 0; j < L_SUBFR; j++)
+      {
+         ex[j] = mult(level, ex[j]);                                move16();
+      }
+      /* Synthesize */
+      Syn_filt(acoeff_variab, ex, &synth[i * L_SUBFR], L_SUBFR, 
+               mem_syn, 1);
+      
+   } /* next i */
+   
+   /* reset codebook averaging variables */ 
+   averState->hangVar = 20;                                         move16();
+   averState->hangCount = 0;                                        move16();
+    
+   test();
+   if (sub(new_state, DTX_MUTE) == 0)
+   {
+      /* mute comfort noise as it has been quite a long time since  
+       * last SID update  was performed                            */
+      
+      tmp_int_length = st->since_last_sid;                          move16();
+      test();
+      if (sub(tmp_int_length, 32) > 0)
+      {
+         tmp_int_length = 32;                                       move16();
+      }
+      
+      /* safety guard against division by zero */
+      test();
+      if(tmp_int_length <= 0) {
+         tmp_int_length = 8;                                       move16();
+      }      
+      
+      move16();
+      st->true_sid_period_inv = div_s(1 << 10, shl(tmp_int_length, 10)); 
+
+      st->since_last_sid = 0;                                       move16();
+      Copy(st->lsp, st->lsp_old, M);
+      st->old_log_en = st->log_en;                                  move16();
+      /* subtract 1/8 in Q11 i.e -6/8 dB */
+      st->log_en = sub(st->log_en, 256);                            move16();  
+   }
+
+   /* reset interpolation length timer 
+    * if data has been updated.        */
+   test(); test(); test(); test();
+   if ((st->sid_frame != 0) && 
+       ((st->valid_data != 0) || 
+        ((st->valid_data == 0) &&  (st->dtxHangoverAdded) != 0))) 
+   {
+      st->since_last_sid =  0;                                      move16();
+      st->data_updated = 1;                                         move16();
+   }
+         
+   return 0;
+}
+
+void dtx_dec_activity_update(dtx_decState *st,
+                             Word16 lsf[],
+                             Word16 frame[])
+{
+   Word16 i;
+
+   Word32 L_frame_en;
+   Word16 log_en_e, log_en_m, log_en;
+
+   /* update lsp history */
+   st->lsf_hist_ptr = add(st->lsf_hist_ptr,M);                     move16();
+   test();
+   if (sub(st->lsf_hist_ptr, 80) == 0)
+   {
+      st->lsf_hist_ptr = 0;                                        move16();
+   }
+   Copy(lsf, &st->lsf_hist[st->lsf_hist_ptr], M); 
+
+   /* compute log energy based on frame energy */
+   L_frame_en = 0;     /* Q0 */                                    move32();
+   for (i=0; i < L_FRAME; i++)
+   {
+      L_frame_en = L_mac(L_frame_en, frame[i], frame[i]); 
+   }
+   Log2(L_frame_en, &log_en_e, &log_en_m);
+   
+   /* convert exponent and mantissa to Word16 Q10 */
+   log_en = shl(log_en_e, 10);  /* Q10 */                          
+   log_en = add(log_en, shr(log_en_m, 15-10));                      
+   
+   /* divide with L_FRAME i.e subtract with log2(L_FRAME) = 7.32193 */
+   log_en = sub(log_en, 7497+1024);                                
+   
+   /* insert into log energy buffer, no division by two as  *
+    * log_en in decoder is Q11                              */
+   st->log_en_hist_ptr = add(st->log_en_hist_ptr, 1);
+   test();
+   if (sub(st->log_en_hist_ptr, DTX_HIST_SIZE) == 0)
+   {
+      st->log_en_hist_ptr = 0;                                     move16();
+   }
+   st->log_en_hist[st->log_en_hist_ptr] = log_en; /* Q11 */        move16();
+}
+
+/*   
+     Table of new SPD synthesis states 
+     
+                           |     previous SPD_synthesis_state
+     Incoming              |  
+     frame_type            | SPEECH       | DTX           | DTX_MUTE   
+     ---------------------------------------------------------------
+     RX_SPEECH_GOOD ,      |              |               |
+     RX_SPEECH_PR_DEGRADED | SPEECH       | SPEECH        | SPEECH 
+     ----------------------------------------------------------------       
+     RX_SPEECH_BAD,        | SPEECH       | DTX           | DTX_MUTE
+     ----------------------------------------------------------------
+     RX_SID_FIRST,         | DTX          | DTX/(DTX_MUTE)| DTX_MUTE  
+     ----------------------------------------------------------------
+     RX_SID_UPDATE,        | DTX          | DTX           | DTX
+     ----------------------------------------------------------------
+     RX_SID_BAD,           | DTX          | DTX/(DTX_MUTE)| DTX_MUTE
+     ----------------------------------------------------------------
+     RX_NO_DATA            | SPEECH       | DTX/(DTX_MUTE)| DTX_MUTE
+                           |(class2 garb.)|               |
+     ----------------------------------------------------------------
+     RX_ONSET              | SPEECH       | DTX/(DTX_MUTE)| DTX_MUTE
+                           |(class2 garb.)|               |
+     ----------------------------------------------------------------
+*/
+
+enum DTXStateType rx_dtx_handler(
+                      dtx_decState *st,           /* i/o : State struct     */
+                      enum RXFrameType frame_type /* i   : Frame type       */ 
+                      )
+{
+   enum DTXStateType newState;
+   enum DTXStateType encState;
+
+   /* DTX if SID frame or previously in DTX{_MUTE} and (NO_RX OR BAD_SPEECH) */
+   test(); test(); test();
+   test(); test(); test();
+   test(); test();   
+   if ((sub(frame_type, RX_SID_FIRST) == 0)   ||
+       (sub(frame_type, RX_SID_UPDATE) == 0)  ||
+       (sub(frame_type, RX_SID_BAD) == 0)     ||
+       (((sub(st->dtxGlobalState, DTX) == 0) ||
+         (sub(st->dtxGlobalState, DTX_MUTE) == 0)) && 
+        ((sub(frame_type, RX_NO_DATA) == 0) ||
+         (sub(frame_type, RX_SPEECH_BAD) == 0) || 
+         (sub(frame_type, RX_ONSET) == 0))))
+   {
+      newState = DTX;                                              move16();
+
+      /* stay in mute for these input types */
+      test(); test(); test(); test(); test();
+      if ((sub(st->dtxGlobalState, DTX_MUTE) == 0) &&
+          ((sub(frame_type, RX_SID_BAD) == 0) ||
+           (sub(frame_type, RX_SID_FIRST) ==  0) ||
+           (sub(frame_type, RX_ONSET) ==  0) ||
+           (sub(frame_type, RX_NO_DATA) == 0)))
+      {
+         newState = DTX_MUTE;                                      move16();
+      }
+
+      /* evaluate if noise parameters are too old                     */
+      /* since_last_sid is reset when CN parameters have been updated */
+      st->since_last_sid = add(st->since_last_sid, 1);             move16();
+
+      /* no update of sid parameters in DTX for a long while */
+      /* Due to the delayed update of  st->since_last_sid counter
+         SID_UPDATE frames need to be handled separately to avoid
+         entering DTX_MUTE for late SID_UPDATE frames
+         */
+      test(); test(); logic16();
+      if((sub(frame_type, RX_SID_UPDATE) != 0) &&
+         (sub(st->since_last_sid, DTX_MAX_EMPTY_THRESH) > 0))
+      {
+         newState = DTX_MUTE;                                      move16();
+      }
+   }
+   else 
+   {
+      newState = SPEECH;                                           move16();
+      st->since_last_sid = 0;                                      move16();
+   }
+   
+   /* 
+      reset the decAnaElapsed Counter when receiving CNI data the first  
+      time, to robustify counter missmatch after handover
+      this might delay the bwd CNI analysis in the new decoder slightly.
+   */    
+   test(); test();
+   if ((st->data_updated == 0) &&
+       (sub(frame_type, RX_SID_UPDATE) == 0))
+   {
+      st->decAnaElapsedCount = 0;                                  move16();
+   }
+
+   /* update the SPE-SPD DTX hangover synchronization */
+   /* to know when SPE has added dtx hangover         */
+   st->decAnaElapsedCount = add(st->decAnaElapsedCount, 1);        move16();
+   st->dtxHangoverAdded = 0;                                       move16();
+   
+   test(); test(); test(); test(); test();
+   if ((sub(frame_type, RX_SID_FIRST) == 0)  ||
+       (sub(frame_type, RX_SID_UPDATE) == 0) ||
+       (sub(frame_type, RX_SID_BAD) == 0)    ||
+       (sub(frame_type, RX_ONSET) == 0)      ||
+       (sub(frame_type, RX_NO_DATA) == 0))
+   {
+      encState = DTX;                                              move16();
+      
+      /*         
+         In frame errors simulations RX_NO_DATA may occasionally mean that
+         a speech packet was probably sent by the encoder,
+         the assumed _encoder_ state should be SPEECH in such cases.
+      */
+      
+      test(); logic16(); 
+      if((sub(frame_type, RX_NO_DATA) == 0) &&
+         (sub(newState, SPEECH) == 0)) 
+      {
+         encState = SPEECH;                                       move16();
+      }
+      
+      
+      /* Note on RX_ONSET operation differing from RX_NO_DATA operation:
+         If a  RX_ONSET is received in the decoder (by "accident")
+         it is still most likely that the encoder  state
+         for the "ONSET frame" was DTX.
+      */      
+   }
+   else 
+   {
+      encState = SPEECH;                                           move16();
+   }
+ 
+   test();
+   if (sub(encState, SPEECH) == 0)
+   {
+      st->dtxHangoverCount = DTX_HANG_CONST;                       move16();
+   }
+   else
+   {
+      test();
+      if (sub(st->decAnaElapsedCount, DTX_ELAPSED_FRAMES_THRESH) > 0)
+      {
+         st->dtxHangoverAdded = 1;                                 move16();
+         st->decAnaElapsedCount = 0;                               move16();
+         st->dtxHangoverCount = 0;                                 move16();
+      }
+      else if (test(), st->dtxHangoverCount == 0)
+      {
+         st->decAnaElapsedCount = 0;                               move16();
+      }
+      else
+      {
+         st->dtxHangoverCount = sub(st->dtxHangoverCount, 1);      move16();
+      }
+   }
+   
+   if (sub(newState, SPEECH) != 0)
+   {
+      /* DTX or DTX_MUTE
+       * CN data is not in a first SID, first SIDs are marked as SID_BAD 
+       *  but will do backwards analysis if a hangover period has been added
+       *  according to the state machine above 
+       */
+      
+      st->sid_frame = 0;                                           move16();
+      st->valid_data = 0;                                          move16();
+            
+      test(); 
+      if (sub(frame_type, RX_SID_FIRST) == 0)
+      {
+         st->sid_frame = 1;                                        move16();
+      }
+      else if (test(), sub(frame_type, RX_SID_UPDATE) == 0)
+      {
+         st->sid_frame = 1;                                        move16();
+         st->valid_data = 1;                                       move16();
+      }
+      else if (test(), sub(frame_type, RX_SID_BAD) == 0)
+      {
+         st->sid_frame = 1;                                        move16();
+         st->dtxHangoverAdded = 0; /* use old data */              move16();
+      } 
+   }
+
+   return newState; 
+   /* newState is used by both SPEECH AND DTX synthesis routines */ 
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/dtx_dec.h FFMpeg-20050127-new/libavcodec/amr/dtx_dec.h
--- FFMpeg-20050127/libavcodec/amr/dtx_dec.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/dtx_dec.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,155 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : dtx_dec.h
+*      Purpose          : Decode comfort noice when in DTX
+*
+*****************************************************************************
+*/
+#ifndef dtx_dec_h
+#define dtx_dec_h "$Id $" 
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include "typedef.h"
+#include "dtx_enc.h"
+#include "d_plsf.h"
+#include "gc_pred.h"
+#include "c_g_aver.h"
+#include "frame.h"
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+enum DTXStateType {SPEECH = 0, DTX, DTX_MUTE};
+
+#define DTX_MAX_EMPTY_THRESH 50
+
+/*
+*****************************************************************************
+*                         DEFINITION OF DATA TYPES
+*****************************************************************************
+*/
+
+typedef struct {
+   Word16 since_last_sid;
+   Word16 true_sid_period_inv;
+   Word16 log_en;
+   Word16 old_log_en;
+   Word32 L_pn_seed_rx; 
+   Word16 lsp[M];
+   Word16 lsp_old[M]; 
+   
+   Word16 lsf_hist[M*DTX_HIST_SIZE];
+   Word16 lsf_hist_ptr;
+   Word16 lsf_hist_mean[M*DTX_HIST_SIZE]; 
+   Word16 log_pg_mean;
+   Word16 log_en_hist[DTX_HIST_SIZE];
+   Word16 log_en_hist_ptr;
+
+   Word16 log_en_adjust;
+
+   Word16 dtxHangoverCount;
+   Word16 decAnaElapsedCount;
+
+   Word16 sid_frame;       
+   Word16 valid_data;          
+   Word16 dtxHangoverAdded;
+ 
+   enum DTXStateType dtxGlobalState;     /* contains previous state */
+                                         /* updated in main decoder */ 
+
+   Word16 data_updated;      /* marker to know if CNI data is ever renewed */ 
+
+} dtx_decState;
+
+/*
+*****************************************************************************
+*                         DECLARATION OF PROTOTYPES
+*****************************************************************************
+*/
+/*
+**************************************************************************
+*  Function    : dtx_dec_init
+*  Purpose     : Allocates memory and initializes state variables
+*  Description : Stores pointer to filter status struct in *st. This
+*                pointer has to be passed to dtx_dec in each call.
+*  Returns     : 0 on success
+*
+**************************************************************************
+*/ 
+int dtx_dec_init (dtx_decState **st);
+ 
+/*
+**************************************************************************
+*
+*  Function    : dtx_dec_reset
+*  Purpose     : Resets state memory
+*  Returns     : 0 on success
+*
+**************************************************************************
+*/
+int dtx_dec_reset (dtx_decState *st);
+ 
+/*
+**************************************************************************
+*
+*  Function    : dtx_dec_exit
+*  Purpose     : The memory used for state memory is freed
+*  Description : Stores NULL in *st
+*
+**************************************************************************
+*/
+void dtx_dec_exit (dtx_decState **st);
+ 
+/*
+**************************************************************************
+*
+*  Function    : dtx_dec
+*  Purpose     :
+*  Description :
+*                
+**************************************************************************
+*/
+int dtx_dec(
+   dtx_decState *st,                /* i/o : State struct                    */
+   Word16 mem_syn[],                /* i/o : AMR decoder state               */
+   D_plsfState* lsfState,           /* i/o : decoder lsf states              */
+   gc_predState* predState,         /* i/o : prediction states               */
+   Cb_gain_averageState* averState, /* i/o : CB gain average states          */
+   enum DTXStateType new_state,     /* i   : new DTX state                   */    
+   enum Mode mode,                  /* i   : AMR mode                        */
+   Word16 parm[],                   /* i   : Vector of synthesis parameters  */
+   Word16 synth[],                  /* o   : synthesised speech              */
+   Word16 A_t[]                     /* o   : decoded LP filter in 4 subframes*/
+   );
+
+void dtx_dec_activity_update(dtx_decState *st,
+                             Word16 lsf[],
+                             Word16 frame[]);
+
+/*
+**************************************************************************
+*
+*  Function    : rx_dtx_handler 
+*  Purpose     : reads the frame type and checks history  
+*  Description : to decide what kind of DTX/CNI action to perform
+
+**************************************************************************
+*/
+enum DTXStateType rx_dtx_handler(dtx_decState *st,           /* i/o : State struct */
+                                 enum RXFrameType frame_type /* i   : Frame type   */
+                                 );
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/dtx_enc.c FFMpeg-20050127-new/libavcodec/amr/dtx_enc.c
--- FFMpeg-20050127/libavcodec/amr/dtx_enc.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/dtx_enc.c	2004-03-05 10:54:00.000000000 +0000
@@ -0,0 +1,372 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : dtx_enc.c
+*      Purpose          : DTX mode computation of SID parameters
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "dtx_enc.h"
+const char dtx_enc_id[] = "@(#)$Id $" dtx_enc_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "q_plsf.h"
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "copy.h"
+#include "set_zero.h"
+#include "mode.h"
+#include "log2.h"
+#include "lsp_lsf.h"
+#include "reorder.h"
+#include "count.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#include "lsp.tab"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : dtx_enc_init
+*
+**************************************************************************
+*/ 
+int dtx_enc_init (dtx_encState **st)
+{
+  dtx_encState* s;
+ 
+  if (st == (dtx_encState **) NULL){
+    fprintf(stderr, "dtx_enc_init: invalid parameter\n");
+    return -1;
+  }
+  
+  *st = NULL;
+ 
+  /* allocate memory */
+  if ((s= (dtx_encState *) malloc(sizeof(dtx_encState))) == NULL){
+    fprintf(stderr, "dtx_enc_init: can not malloc state structure\n");
+    return -1;
+  }
+  
+  dtx_enc_reset(s);
+  *st = s;
+  
+  return 0;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : dtx_enc_reset
+*
+**************************************************************************
+*/
+int dtx_enc_reset (dtx_encState *st)
+{
+  Word16 i;
+
+  if (st == (dtx_encState *) NULL){
+    fprintf(stderr, "dtx_enc_reset: invalid parameter\n");
+    return -1;
+  }
+
+  st->hist_ptr = 0;
+  st->log_en_index = 0;
+  st->init_lsf_vq_index = 0;
+  st->lsp_index[0] = 0;
+  st->lsp_index[1] = 0;
+  st->lsp_index[2] = 0;
+ 
+  /* Init lsp_hist[] */
+  for(i = 0; i < DTX_HIST_SIZE; i++)
+  {
+    Copy(lsp_init_data, &st->lsp_hist[i * M], M);
+  }
+
+  /* Reset energy history */
+  Set_zero(st->log_en_hist, M);
+
+  st->dtxHangoverCount = DTX_HANG_CONST;
+  st->decAnaElapsedCount = 32767; 
+
+  return 1;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : dtx_enc_exit
+*
+**************************************************************************
+*/
+void dtx_enc_exit (dtx_encState **st)
+{
+   if (st == NULL || *st == NULL)
+      return;
+   
+   /* deallocate memory */
+   free(*st);
+   *st = NULL;
+   
+   return;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : dtx_enc
+*                
+**************************************************************************
+*/
+int dtx_enc(dtx_encState *st,        /* i/o : State struct                    */
+            Word16 computeSidFlag,   /* i   : compute SID                     */
+            Q_plsfState *qSt,        /* i/o : Qunatizer state struct          */
+            gc_predState* predState, /* i/o : State struct                    */
+	    Word16 **anap            /* o   : analysis parameters             */
+	    )
+{
+   Word16 i,j;
+   Word16 log_en;
+   Word16 lsf[M];
+   Word16 lsp[M];
+   Word16 lsp_q[M];
+   Word32 L_lsp[M];
+
+   /* VOX mode computation of SID parameters */
+   test (); test ();
+   if ((computeSidFlag != 0))
+   {
+      /* compute new SID frame if safe i.e don't
+       * compute immediately after a talk spurt  */
+      log_en = 0;                                           move16 ();
+      for (i = 0; i < M; i++)
+      {
+         L_lsp[i] = 0;                                      move16 ();
+      }
+      
+      /* average energy and lsp */
+      for (i = 0; i < DTX_HIST_SIZE; i++)
+      {
+         log_en = add(log_en,
+                      shr(st->log_en_hist[i],2));
+
+         for (j = 0; j < M; j++)
+         {
+            L_lsp[j] = L_add(L_lsp[j],
+                             L_deposit_l(st->lsp_hist[i * M + j]));
+         }
+      }
+
+      log_en = shr(log_en, 1);
+      for (j = 0; j < M; j++)
+      {
+         lsp[j] = extract_l(L_shr(L_lsp[j], 3));   /* divide by 8 */
+      }
+
+      /*  quantize logarithmic energy to 6 bits */
+      st->log_en_index = add(log_en, 2560);          /* +2.5 in Q10      */
+      st->log_en_index = add(st->log_en_index, 128); /* add 0.5/4 in Q10 */
+      st->log_en_index = shr(st->log_en_index, 8);
+
+      test ();
+      if (sub(st->log_en_index, 63) > 0)
+      {
+         st->log_en_index = 63;                             move16 ();
+      }
+      test ();
+      if (st->log_en_index < 0)
+      {
+         st->log_en_index = 0;                              move16 ();
+      }
+         
+      /* update gain predictor memory */
+      log_en = shl(st->log_en_index, -2+10); /* Q11 and divide by 4 */
+      log_en = sub(log_en, 2560);            /* add 2.5 in Q11      */
+      
+      log_en = sub(log_en, 9000);
+      test ();
+      if (log_en > 0)
+      {
+         log_en = 0;                                        move16 ();
+      }
+      test ();
+      if (sub(log_en, -14436) < 0)
+      {
+         log_en = -14436;                                   move16 ();
+      }
+      
+      /* past_qua_en for other modes than MR122 */      
+      predState->past_qua_en[0] = log_en;                   move16 ();
+      predState->past_qua_en[1] = log_en;                   move16 ();
+      predState->past_qua_en[2] = log_en;                   move16 ();
+      predState->past_qua_en[3] = log_en;                   move16 ();
+
+      /* scale down by factor 20*log10(2) in Q15 */
+      log_en = mult(5443, log_en);
+      
+      /* past_qua_en for mode MR122 */      
+      predState->past_qua_en_MR122[0] = log_en;             move16 ();
+      predState->past_qua_en_MR122[1] = log_en;             move16 ();
+      predState->past_qua_en_MR122[2] = log_en;             move16 ();
+      predState->past_qua_en_MR122[3] = log_en;             move16 ();
+ 
+      /* make sure that LSP's are ordered */
+      Lsp_lsf(lsp, lsf, M);
+      Reorder_lsf(lsf, LSF_GAP, M);
+      Lsf_lsp(lsf, lsp, M);
+      
+      /* Quantize lsp and put on parameter list */
+      Q_plsf_3(qSt, MRDTX, lsp, lsp_q, st->lsp_index, 
+               &st->init_lsf_vq_index);
+   }
+   
+   *(*anap)++ = st->init_lsf_vq_index; /* 3 bits */         move16 ();
+   
+   *(*anap)++ = st->lsp_index[0];      /* 8 bits */         move16 ();
+   *(*anap)++ = st->lsp_index[1];      /* 9 bits */         move16 ();
+   *(*anap)++ = st->lsp_index[2];      /* 9 bits */         move16 ();
+   
+   
+   *(*anap)++ = st->log_en_index;      /* 6 bits    */      move16 ();
+                                       /* = 35 bits */
+   
+   return 0;
+}
+
+/*
+**************************************************************************
+*
+*  Function    : dtx_buffer
+*  Purpose     : handles the DTX buffer
+*                
+**************************************************************************
+*/
+int dtx_buffer(dtx_encState *st,   /* i/o : State struct                    */
+	       Word16 lsp_new[],   /* i   : LSP vector                      */
+	       Word16 speech[]     /* i   : speech samples                  */
+	       )
+{
+   Word16 i;
+   Word32 L_frame_en;
+   Word16 log_en_e;
+   Word16 log_en_m;
+   Word16 log_en;
+   
+   /* update pointer to circular buffer      */
+   st->hist_ptr = add(st->hist_ptr, 1);
+   test ();
+   if (sub(st->hist_ptr, DTX_HIST_SIZE) == 0)
+   {
+      st->hist_ptr = 0;                                     move16 ();
+   }
+   
+   /* copy lsp vector into buffer */
+   Copy(lsp_new, &st->lsp_hist[st->hist_ptr * M], M);
+   
+   /* compute log energy based on frame energy */
+   L_frame_en = 0;     /* Q0 */                             move32 ();
+   for (i=0; i < L_FRAME; i++)
+   {
+      L_frame_en = L_mac(L_frame_en, speech[i], speech[i]); 
+   }
+   Log2(L_frame_en, &log_en_e, &log_en_m);
+   
+   /* convert exponent and mantissa to Word16 Q10 */
+   log_en = shl(log_en_e, 10);  /* Q10 */
+   log_en = add(log_en, shr(log_en_m, 15-10));
+   
+   /* divide with L_FRAME i.e subtract with log2(L_FRAME) = 7.32193 */
+   log_en = sub(log_en, 8521);
+   
+   /* insert into log energy buffer with division by 2 */
+   log_en = shr(log_en, 1);
+   st->log_en_hist[st->hist_ptr] = log_en; /* Q10 */        move16 ();
+
+   return 0;
+}
+
+/*
+**************************************************************************
+*
+*  Function    : tx_dtx_handler
+*  Purpose     : adds extra speech hangover to analyze speech on the decoding side. 
+*                
+**************************************************************************
+*/
+Word16 tx_dtx_handler(dtx_encState *st,      /* i/o : State struct           */
+                      Word16 vad_flag,       /* i   : vad decision           */
+                      enum Mode *usedMode    /* i/o : mode changed or not    */
+                      )
+{
+   Word16 compute_new_sid_possible;
+   
+   /* this state machine is in synch with the GSMEFR txDtx machine      */ 
+   st->decAnaElapsedCount = add(st->decAnaElapsedCount, 1);  
+   
+   compute_new_sid_possible = 0;                       move16(); 
+
+   test();
+   if (vad_flag != 0)
+   {
+      st->dtxHangoverCount = DTX_HANG_CONST;           move16();
+   }
+   else 
+   {  /* non-speech */
+      test();
+      if (st->dtxHangoverCount == 0)
+      {  /* out of decoder analysis hangover  */
+         st->decAnaElapsedCount = 0;                   move16();        
+         *usedMode = MRDTX;                            move16(); 
+         compute_new_sid_possible = 1;                 move16(); 
+      }
+      else
+      { /* in possible analysis hangover */
+         st->dtxHangoverCount = sub(st->dtxHangoverCount, 1);
+         
+         /* decAnaElapsedCount + dtxHangoverCount < DTX_ELAPSED_FRAMES_THRESH */
+         test ();
+         if (sub(add(st->decAnaElapsedCount, st->dtxHangoverCount),
+                 DTX_ELAPSED_FRAMES_THRESH) < 0)
+         {
+            *usedMode = MRDTX;                         move16(); 
+            /* if short time since decoder update, do not add extra HO */            
+         }
+         /*
+          else 
+            override VAD and stay in 
+            speech mode *usedMode 
+            and add extra hangover
+         */
+      }
+   }
+   
+   return compute_new_sid_possible;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/dtx_enc.h FFMpeg-20050127-new/libavcodec/amr/dtx_enc.h
--- FFMpeg-20050127/libavcodec/amr/dtx_enc.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/dtx_enc.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,140 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : dtx_enc.h
+*      Purpose          : DTX mode computation of SID parameters
+*
+********************************************************************************
+*/
+#ifndef dtx_enc_h
+#define dtx_enc_h "$Id $" 
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "cnst.h"
+#include "q_plsf.h"
+#include "gc_pred.h"
+#include "mode.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#define DTX_HIST_SIZE 8
+#define DTX_ELAPSED_FRAMES_THRESH (24 + 7 -1)
+#define DTX_HANG_CONST 7             /* yields eight frames of SP HANGOVER  */
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+typedef struct {
+   Word16 lsp_hist[M * DTX_HIST_SIZE];
+   Word16 log_en_hist[DTX_HIST_SIZE];
+   Word16 hist_ptr;
+   Word16 log_en_index;
+   Word16 init_lsf_vq_index;
+   Word16 lsp_index[3];
+
+   /* DTX handler stuff */
+   Word16 dtxHangoverCount;
+   Word16 decAnaElapsedCount;
+
+} dtx_encState;
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*
+**************************************************************************
+*  Function    : dtx_enc_init
+*  Purpose     : Allocates memory and initializes state variables
+*  Description : Stores pointer to filter status struct in *st. This
+*                pointer has to be passed to dtx_enc in each call.
+*  Returns     : 0 on success
+*
+**************************************************************************
+*/ 
+int dtx_enc_init (dtx_encState **st);
+ 
+/*
+**************************************************************************
+*
+*  Function    : dtx_enc_reset
+*  Purpose     : Resets state memory
+*  Returns     : 0 on success
+*
+**************************************************************************
+*/
+int dtx_enc_reset (dtx_encState *st);
+ 
+/*
+**************************************************************************
+*
+*  Function    : dtx_enc_exit
+*  Purpose     : The memory used for state memory is freed
+*  Description : Stores NULL in *st
+*
+**************************************************************************
+*/
+void dtx_enc_exit (dtx_encState **st);
+ 
+/*
+**************************************************************************
+*
+*  Function    : dtx_enc
+*  Purpose     :
+*  Description :
+*                
+**************************************************************************
+*/
+int dtx_enc(dtx_encState *st,        /* i/o : State struct                    */
+            Word16 computeSidFlag,   /* i   : compute SID                     */
+	    Q_plsfState *qSt,        /* i/o : Qunatizer state struct          */
+            gc_predState* predState, /* i/o : State struct                    */
+	    Word16 **anap            /* o   : analysis parameters             */
+	    );
+
+/*
+**************************************************************************
+*
+*  Function    : dtx_buffer
+*  Purpose     : handles the DTX buffer
+*                
+**************************************************************************
+*/
+int dtx_buffer(dtx_encState *st,   /* i/o : State struct                    */
+	       Word16 lsp_new[],   /* i   : LSP vector                      */
+	       Word16 speech[]     /* i   : speech samples                  */
+	       );
+
+/*
+**************************************************************************
+*
+*  Function    : tx_dtx_handler
+*  Purpose     : adds extra speech hangover to analyze speech on the decoding side. 
+*  Description : returns 1 when a new SID analysis may be made
+*                otherwise it adds the appropriate hangover after a sequence
+*                with out updates of SID parameters . 
+*                
+**************************************************************************
+*/
+Word16 tx_dtx_handler(dtx_encState *st,       /* i/o : State struct          */
+                      Word16 vadFlag,         /* i   : vad control variable  */
+                      enum Mode *usedMode     /* o   : mode changed or not   */
+                      );
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/e_homing.c FFMpeg-20050127-new/libavcodec/amr/e_homing.c
--- FFMpeg-20050127/libavcodec/amr/e_homing.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/e_homing.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,73 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : e_homing.c
+*
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+
+#include "e_homing.h"
+const char e_homing_id[] = "@(#)$Id $" e_homing_h;
+
+
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+
+#include "typedef.h"
+#include "cnst.h"
+
+
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+
+
+/*
+********************************************************************************
+*
+*     Function        : encoder_homing_frame_test
+*     In              : input_frame[]  one frame of speech samples
+*     Out             : none
+*     Calls           : none
+*     Tables          : none
+*     Compile Defines : none
+*     Return          : 0  input frame does not match the encoder homing frame pattern
+*                       1  input frame matches the encoder homing frame pattern
+*     Information     : Checks if all samples of the input frame matches the encoder
+*                       homing frame pattern, which is 0x0008 for all samples.
+*
+********************************************************************************
+*/
+
+Word16 encoder_homing_frame_test (Word16 input_frame[])
+{
+    Word16 i, j;
+
+    /* check 160 input samples for matching EHF_MASK: defined in e_homing.h */
+    for (i = 0; i < L_FRAME; i++)
+    {
+        j = input_frame[i] ^ EHF_MASK;
+
+        if (j)
+            break;
+    }
+
+    return !j;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/e_homing.h FFMpeg-20050127-new/libavcodec/amr/e_homing.h
--- FFMpeg-20050127/libavcodec/amr/e_homing.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/e_homing.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,35 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*      File             : e_homing.h
+*      Purpose          : Definition of encoder homing frame pattern and
+*                         declaration of encoder homing function prototype.
+*
+********************************************************************************
+*/
+
+#ifndef e_homing_h
+#define e_homing_h "$Id $"
+
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+
+#include "typedef.h"
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+
+Word16 encoder_homing_frame_test (Word16 input_frame[]);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/ec_gains.c FFMpeg-20050127-new/libavcodec/amr/ec_gains.c
--- FFMpeg-20050127/libavcodec/amr/ec_gains.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/ec_gains.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,379 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : ec_gains.c
+*      Purpose:         : Error concealment for pitch and codebook gains
+*
+********************************************************************************
+*/
+ 
+ 
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "ec_gains.h"
+const char ec_gains_id[] = "@(#)$Id $" ec_gains_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "cnst.h"
+#include "gmed_n.h"
+#include "gc_pred.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#include "gains.tab"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : ec_gain_code_init
+*  Purpose     : Allocates memory and initializes state variables
+*
+**************************************************************************
+*/
+int ec_gain_code_init (ec_gain_codeState **state)
+{
+  ec_gain_codeState* s;
+ 
+  if (state == (ec_gain_codeState **) NULL){
+      fprintf(stderr, "ec_gain_code_init: invalid parameter\n");
+      return -1;
+  }
+  *state = NULL;
+ 
+  /* allocate memory */
+  if ((s= (ec_gain_codeState *) malloc(sizeof(ec_gain_codeState))) == NULL){
+      fprintf(stderr, "ec_gain_code_init: can not malloc state structure\n");
+      return -1;
+  }
+
+  ec_gain_code_reset(s);
+  *state = s;
+  
+  return 0;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : ec_gain_code_reset
+*  Purpose     : Resets state memory
+*
+**************************************************************************
+*/
+int ec_gain_code_reset (ec_gain_codeState *state)
+{
+  Word16 i;
+  
+  if (state == (ec_gain_codeState *) NULL){
+      fprintf(stderr, "ec_gain_code_reset: invalid parameter\n");
+      return -1;
+  }
+
+  for ( i = 0; i < 5; i++)
+      state->gbuf[i] = 1;
+  state->past_gain_code = 0;
+  state->prev_gc = 1;       
+
+  return 0;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : ec_gain_code_exit
+*  Purpose     : The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void ec_gain_code_exit (ec_gain_codeState **state)
+{
+  if (state == NULL || *state == NULL)
+      return;
+
+  /* deallocate memory */
+  free(*state);
+  *state = NULL;
+  
+  return;
+}
+
+/*
+**************************************************************************
+*
+*  Function    : ec_gain_code
+*  Purpose     : conceal the codebook gain
+*                Call this function only in BFI (instead of normal gain
+*                decoding function)
+*
+**************************************************************************
+*/
+void ec_gain_code (
+    ec_gain_codeState *st,    /* i/o : State struct                     */
+    gc_predState *pred_state, /* i/o : MA predictor state               */
+    Word16 state,             /* i   : state of the state machine       */
+    Word16 *gain_code         /* o   : decoded innovation gain          */
+)
+{
+    static const Word16 cdown[7] =
+    {
+        32767, 32112, 32112, 32112,
+        32112, 32112, 22937
+    };
+
+    Word16 tmp;
+    Word16 qua_ener_MR122;
+    Word16 qua_ener;
+    
+    /* calculate median of last five gain values */
+    tmp = gmed_n (st->gbuf,5);                                 move16 ();
+
+    /* new gain = minimum(median, past_gain) * cdown[state] */
+    test (); 
+    if (sub (tmp, st->past_gain_code) > 0)
+    {
+        tmp = st->past_gain_code;                              move16 (); 
+    }
+    tmp = mult (tmp, cdown[state]);
+    *gain_code = tmp;                                          move16 (); 
+
+    /* update table of past quantized energies with average of
+     * current values
+     */
+    gc_pred_average_limited(pred_state, &qua_ener_MR122, &qua_ener);
+    gc_pred_update(pred_state, qua_ener_MR122, qua_ener);
+}
+
+/*
+**************************************************************************
+*
+*  Function    : ec_gain_code_update
+*  Purpose     : update the codebook gain concealment state;
+*                limit gain_code if the previous frame was bad
+*                Call this function always after decoding (or concealing)
+*                the gain
+*
+**************************************************************************
+*/
+void ec_gain_code_update (
+    ec_gain_codeState *st,    /* i/o : State struct                     */
+    Word16 bfi,               /* i   : flag: frame is bad               */
+    Word16 prev_bf,           /* i   : flag: previous frame was bad     */
+    Word16 *gain_code         /* i/o : decoded innovation gain          */
+)
+{
+    Word16 i;
+    
+    /* limit gain_code by previous good gain if previous frame was bad */
+    test ();
+    if (bfi == 0)
+    {
+		test ();
+        if (prev_bf != 0)
+        {
+            test (); 
+            if (sub (*gain_code, st->prev_gc) > 0)
+            {
+                *gain_code = st->prev_gc;     move16 (); 
+            }
+        }
+        st->prev_gc = *gain_code;                          move16 (); 
+    }
+
+    /* update EC states: previous gain, gain buffer */
+    st->past_gain_code = *gain_code;                       move16 (); 
+    
+    for (i = 1; i < 5; i++)
+    {
+        st->gbuf[i - 1] = st->gbuf[i];                     move16 (); 
+    }
+    st->gbuf[4] = *gain_code;                              move16 (); 
+
+    return;
+}
+
+
+/*
+**************************************************************************
+*
+*  Function    : ec_gain_pitch_init
+*  Purpose     : Allocates memory and initializes state memory.
+*
+**************************************************************************
+*/
+int ec_gain_pitch_init (ec_gain_pitchState **state)
+{
+  ec_gain_pitchState* s;
+ 
+  if (state == (ec_gain_pitchState **) NULL){
+      fprintf(stderr, "ec_gain_pitch_init: invalid parameter\n");
+      return -1;
+  }
+  *state = NULL;
+ 
+  /* allocate memory */
+  if ((s= (ec_gain_pitchState *) malloc(sizeof(ec_gain_pitchState))) == NULL){
+      fprintf(stderr, "ec_gain_pitch_init: can not malloc state structure\n");
+      return -1;
+  }
+  
+  ec_gain_pitch_reset(s);
+  *state = s;
+  
+  return 0;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function:   ec_gain_pitch_reset
+*  Purpose:    Resets state memory
+*
+**************************************************************************
+*/
+int ec_gain_pitch_reset (ec_gain_pitchState *state)
+{
+  Word16 i;
+  
+  if (state == (ec_gain_pitchState *) NULL){
+      fprintf(stderr, "ec_gain_pitch_reset: invalid parameter\n");
+      return -1;
+  }
+  
+  for(i = 0; i < 5; i++)
+      state->pbuf[i] = 1640;
+  state->past_gain_pit = 0; 
+  state->prev_gp = 16384;   
+
+  return 0;
+}
+ 
+/*************************************************************************
+*
+*  Function    : ec_gain_pitch_exit
+*  Purpose     : The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void ec_gain_pitch_exit (ec_gain_pitchState **state)
+{
+  if (state == NULL || *state == NULL)
+      return;
+ 
+  /* deallocate memory */
+  free(*state);
+  *state = NULL;
+  
+  return;
+}
+
+/*
+**************************************************************************
+*
+*  Function    : ec_gain_pitch
+*  Purpose     : conceal the pitch gain
+*                Call this function only in BFI (instead of normal gain
+*                decoding function)
+*
+**************************************************************************
+*/
+void ec_gain_pitch (
+    ec_gain_pitchState *st, /* i/o : state variables                   */
+    Word16 state,           /* i   : state of the state machine        */
+    Word16 *gain_pitch      /* o   : pitch gain (Q14)                  */
+)
+{
+    static const Word16 pdown[7] =
+    {
+        32767, 32112, 32112, 26214,
+        9830, 6553, 6553
+    };
+
+    Word16 tmp;
+
+    /* calculate median of last five gains */
+    tmp = gmed_n (st->pbuf, 5);                        move16 (); 
+
+    /* new gain = minimum(median, past_gain) * pdown[state] */
+    test (); 
+    if (sub (tmp, st->past_gain_pit) > 0)
+    {
+        tmp = st->past_gain_pit;                       move16 (); 
+    }
+    *gain_pitch = mult (tmp, pdown[state]);
+}
+
+/*
+**************************************************************************
+*
+*  Function    : ec_gain_pitch_update
+*  Purpose     : update the pitch gain concealment state;
+*                limit gain_pitch if the previous frame was bad
+*                Call this function always after decoding (or concealing)
+*                the gain
+*
+**************************************************************************
+*/
+void ec_gain_pitch_update (
+    ec_gain_pitchState *st, /* i/o : state variables                   */
+    Word16 bfi,             /* i   : flag: frame is bad                */
+    Word16 prev_bf,         /* i   : flag: previous frame was bad      */
+    Word16 *gain_pitch      /* i/o : pitch gain                        */
+)
+{
+    Word16 i;
+
+    test (); 
+    if (bfi == 0)
+    {
+        test ();
+        if (prev_bf != 0)
+        {
+            test (); 
+            if (sub (*gain_pitch, st->prev_gp) > 0)
+            {
+                *gain_pitch = st->prev_gp;
+            }
+        }
+        st->prev_gp = *gain_pitch;                         move16 (); 
+    }
+    
+    st->past_gain_pit = *gain_pitch;                       move16 ();
+
+    test (); 
+    if (sub (st->past_gain_pit, 16384) > 0)  /* if (st->past_gain_pit > 1.0) */
+    {
+        st->past_gain_pit = 16384;                         move16 (); 
+    }
+    for (i = 1; i < 5; i++)
+    {
+        st->pbuf[i - 1] = st->pbuf[i];                     move16 (); 
+    }
+    st->pbuf[4] = st->past_gain_pit;                       move16 (); 
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/ec_gains.h FFMpeg-20050127-new/libavcodec/amr/ec_gains.h
--- FFMpeg-20050127/libavcodec/amr/ec_gains.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/ec_gains.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,196 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : ec_gains.h
+*      Purpose:         : Error concealment for pitch and codebook gains
+*
+********************************************************************************
+*/
+#ifndef ec_gains_h
+#define ec_gains_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "gc_pred.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+typedef struct {
+  Word16 pbuf[5];
+  Word16 past_gain_pit;
+  Word16 prev_gp;
+} ec_gain_pitchState;
+ 
+typedef struct {
+  Word16 gbuf[5];
+  Word16 past_gain_code;
+  Word16 prev_gc;
+} ec_gain_codeState;
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+
+/*
+**************************************************************************
+*
+*  Function    : ec_gain_code_init
+*  Purpose     : Allocates memory and initializes state variables
+*
+**************************************************************************
+*/
+int ec_gain_code_init (
+    ec_gain_codeState **state
+);
+ 
+/*
+**************************************************************************
+*
+*  Function    : ec_gain_code_reset
+*  Purpose     : Resets state memory
+*
+**************************************************************************
+*/
+int ec_gain_code_reset (
+    ec_gain_codeState *state
+);
+ 
+/*
+**************************************************************************
+*
+*  Function    : ec_gain_code_exit
+*  Purpose     : The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void ec_gain_code_exit (
+    ec_gain_codeState **state
+);
+
+/*
+**************************************************************************
+*
+*  Function    : ec_gain_code
+*  Purpose     : conceal the codebook gain
+*                Call this function only in BFI (instead of normal gain
+*                decoding function)
+*
+**************************************************************************
+*/
+void ec_gain_code (
+    ec_gain_codeState *st,    /* i/o : State struct                     */
+    gc_predState *pred_state, /* i/o : MA predictor state               */
+    Word16 state,             /* i   : state of the state machine       */
+    Word16 *gain_code         /* o   : decoded innovation gain          */
+);
+
+/*
+**************************************************************************
+*
+*  Function    : ec_gain_code_update
+*  Purpose     : update the codebook gain concealment state;
+*                limit gain_code if the previous frame was bad
+*                Call this function always after decoding (or concealing)
+*                the gain
+*
+**************************************************************************
+*/
+void ec_gain_code_update (
+    ec_gain_codeState *st,    /* i/o : State struct                     */
+    Word16 bfi,               /* i   : flag: frame is bad               */
+    Word16 prev_bf,           /* i   : flag: previous frame was bad     */
+    Word16 *gain_code         /* i/o : decoded innovation gain          */
+);
+
+
+/*
+**************************************************************************
+*
+*  Function    : ec_gain_pitch_init
+*  Purpose     : Allocates memory and initializes state memory.
+*
+**************************************************************************
+*/
+int ec_gain_pitch_init (
+    ec_gain_pitchState **state
+);
+ 
+/*
+**************************************************************************
+*
+*  Function:   ec_gain_pitch_reset
+*  Purpose:    Resets state memory
+*
+**************************************************************************
+*/
+int ec_gain_pitch_reset (
+    ec_gain_pitchState *state
+);
+ 
+/*************************************************************************
+*
+*  Function    : ec_gain_pitch_exit
+*  Purpose     : The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void ec_gain_pitch_exit (
+    ec_gain_pitchState **state
+);
+
+/*
+**************************************************************************
+*
+*  Function    : ec_gain_pitch
+*  Purpose     : conceal the pitch gain
+*                Call this function only in BFI (instead of normal gain
+*                decoding function)
+*
+**************************************************************************
+*/
+void ec_gain_pitch (
+    ec_gain_pitchState *st, /* i/o : state variables                   */
+    Word16 state,           /* i   : state of the state machine        */
+    Word16 *gain_pitch      /* o   : pitch gain (Q14)                  */
+);
+
+/*
+**************************************************************************
+*
+*  Function    : ec_gain_pitch_update
+*  Purpose     : update the pitch gain concealment state;
+*                limit gain_pitch if the previous frame was bad
+*                Call this function always after decoding (or concealing)
+*                the gain
+*
+**************************************************************************
+*/
+void ec_gain_pitch_update (
+    ec_gain_pitchState *st, /* i/o : state variables                   */
+    Word16 bfi,             /* i   : flag: frame is bad               */
+    Word16 prev_bf,         /* i   : flag: previous frame was bad     */
+    Word16 *gain_pitch      /* i/o : pitch gain                        */
+);
+
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/enc_lag3.c FFMpeg-20050127-new/libavcodec/amr/enc_lag3.c
--- FFMpeg-20050127/libavcodec/amr/enc_lag3.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/enc_lag3.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,157 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : enc_lag3.c
+*      Purpose          : Encoding of fractional pitch lag with 1/3 resolution.
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "enc_lag3.h"
+const char enc_lag3_id[] = "@(#)$Id $" enc_lag3_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *   FUNCTION:  Enc_lag3
+ *
+ *   PURPOSE:  Encoding of fractional pitch lag with 1/3 resolution.
+ *
+ *   DESCRIPTION:
+ *                    First and third subframes:
+ *                    --------------------------
+ *   The pitch range is divided as follows:
+ *           19 1/3  to   84 2/3   resolution 1/3
+ *           85      to   143      resolution 1
+ *
+ *   The period is encoded with 8 bits.
+ *   For the range with fractions:
+ *     index = (T-19)*3 + frac - 1;
+ *                         where T=[19..85] and frac=[-1,0,1]
+ *   and for the integer only range
+ *     index = (T - 85) + 197;        where T=[86..143]
+ *
+ *                    Second and fourth subframes:
+ *                    ----------------------------
+ *   For the 2nd and 4th subframes a resolution of 1/3 is always used,
+ *   and the search range is relative to the lag in previous subframe.
+ *   If t0 is the lag in the previous subframe then
+ *   t_min=t0-5   and  t_max=t0+4   and  the range is given by
+ *        t_min - 2/3   to  t_max + 2/3
+ *
+ *   The period in the 2nd (and 4th) subframe is encoded with 5 bits:
+ *     index = (T-(t_min-1))*3 + frac - 1;
+ *                 where T=[t_min-1..t_max+1]
+ *
+ *************************************************************************/
+Word16
+Enc_lag3(                /* o  : Return index of encoding             */
+    Word16 T0,           /* i  : Pitch delay                          */
+    Word16 T0_frac,      /* i  : Fractional pitch delay               */
+    Word16 T0_prev,      /* i  : Integer pitch delay of last subframe */
+    Word16 T0_min,       /* i  : minimum of search range              */
+    Word16 T0_max,       /* i  : maximum of search range              */
+    Word16 delta_flag,   /* i  : Flag for 1st (or 3rd) subframe       */
+    Word16 flag4         /* i  : Flag for encoding with 4 bits        */
+    )
+{
+   Word16 index, i, tmp_ind, uplag;
+   Word16 tmp_lag;
+   
+   test (); 
+   if (delta_flag == 0)
+   {  /* if 1st or 3rd subframe */
+
+      /* encode pitch delay (with fraction) */
+      
+      test (); 
+      if (sub (T0, 85) <= 0)
+      {
+         /* index = T0*3 - 58 + T0_frac   */
+         i = add (add (T0, T0), T0);
+         index = add (sub (i, 58), T0_frac);
+      }
+      else
+      {
+         index = add (T0, 112);
+      }
+   }
+   else
+   {   /* if second or fourth subframe */
+      test (); 
+      if (flag4 == 0) {
+         
+         /* 'normal' encoding: either with 5 or 6 bit resolution */
+		  
+         /* index = 3*(T0 - T0_min) + 2 + T0_frac */
+         i = sub (T0, T0_min);
+         i = add (add (i, i), i);
+         index = add (add (i, 2), T0_frac);
+      }
+      else {
+         
+         /* encoding with 4 bit resolution */
+         
+         tmp_lag = T0_prev;                                   move16 ();
+
+         test ();
+         if ( sub( sub(tmp_lag, T0_min), 5) > 0)
+            tmp_lag = add (T0_min, 5);
+         test ();
+         if ( sub( sub(T0_max, tmp_lag), 4) > 0)
+            tmp_lag = sub (T0_max, 4);
+         
+         uplag = add (add (add (T0, T0), T0), T0_frac);
+         
+         i = sub (tmp_lag, 2);
+         tmp_ind = add (add (i, i), i);
+         
+         test ();
+         if (sub (tmp_ind, uplag) >= 0) { 
+            index = add (sub (T0, tmp_lag), 5);
+         } 
+         else {
+            
+            i = add (tmp_lag, 1);
+            i = add (add (i, i), i);
+            
+            test ();
+            if (sub (i, uplag) > 0) {
+               
+                index = add ( sub (uplag, tmp_ind), 3);                
+            }
+            else {
+               
+               index = add (sub (T0, tmp_lag), 11);
+            }
+         }
+         
+      } /* end if (encoding with 4 bit resolution) */
+   }   /* end if (second of fourth subframe) */
+   
+   return index;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/enc_lag3.h FFMpeg-20050127-new/libavcodec/amr/enc_lag3.h
--- FFMpeg-20050127/libavcodec/amr/enc_lag3.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/enc_lag3.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,47 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : enc_lag3.h
+*      Purpose          : Encoding of fractional pitch lag with 1/3 resolution.
+*
+********************************************************************************
+*/
+#ifndef enc_lag3_h
+#define enc_lag3_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+Word16
+Enc_lag3(                /* o  : Return index of encoding     */
+    Word16 T0,           /* i  : Pitch delay                          */
+    Word16 T0_frac,      /* i  : Fractional pitch delay               */
+	 Word16 T0_prev,      /* i  : Integer pitch delay of last subframe */
+	 Word16 T0_min,       /* i  : minimum of search range              */
+	 Word16 T0_max,       /* i  : maximum of search range              */
+    Word16 delta_flag,   /* i  : Flag for 1st (or 3rd) subframe       */
+	 Word16 flag4         /* i  : Flag for encoding with 4 bits        */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/enc_lag6.c FFMpeg-20050127-new/libavcodec/amr/enc_lag6.c
--- FFMpeg-20050127/libavcodec/amr/enc_lag6.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/enc_lag6.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,116 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : enc_lag6.c
+*      Purpose          : Encoding of fractional pitch lag with 1/6 resolution.
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "enc_lag6.h"
+const char enc_lag6_id[] = "@(#)$Id $" enc_lag6_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+ 
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *   FUNCTION:  Enc_lag6
+ *
+ *   PURPOSE:  Encoding of fractional pitch lag with 1/6 resolution.
+ *
+ *   DESCRIPTION:
+ *                    First and third subframes:
+ *                    --------------------------
+ *   The pitch range is divided as follows:
+ *           17 3/6  to   94 3/6   resolution 1/6
+ *           95      to   143      resolution 1
+ *
+ *   The period is encoded with 9 bits.
+ *   For the range with fractions:
+ *     index = (T-17)*6 + frac - 3;
+ *                         where T=[17..94] and frac=[-2,-1,0,1,2,3]
+ *   and for the integer only range
+ *     index = (T - 95) + 463;        where T=[95..143]
+ *
+ *                    Second and fourth subframes:
+ *                    ----------------------------
+ *   For the 2nd and 4th subframes a resolution of 1/6 is always used,
+ *   and the search range is relative to the lag in previous subframe.
+ *   If t0 is the lag in the previous subframe then
+ *   t_min=t0-5   and  t_max=t0+4   and  the range is given by
+ *       (t_min-1) 3/6   to  (t_max) 3/6
+ *
+ *   The period in the 2nd (and 4th) subframe is encoded with 6 bits:
+ *     index = (T-(t_min-1))*6 + frac - 3;
+ *                 where T=[t_min-1..t_max] and frac=[-2,-1,0,1,2,3]
+ *
+ *   Note that only 61 values are used. If the decoder receives 61, 62,
+ *   or 63 as the relative pitch index, it means that a transmission
+ *   error occurred and the pitch from previous subframe should be used.
+ *
+ *************************************************************************/
+Word16 Enc_lag6 (        /* o : Return index of encoding             */
+    Word16 T0,           /* i : Pitch delay                          */
+    Word16 T0_frac,      /* i : Fractional pitch delay               */
+    Word16 T0_min,       /* i : minimum of search range              */
+    Word16 delta_flag    /* i : Flag for 1st (or 3rd) subframe       */
+)
+{
+    Word16 index, i;
+
+    test (); 
+    if (delta_flag == 0)          /* if 1st or 3rd subframe */
+    {
+       /* encode pitch delay (with fraction) */
+       test (); 
+       if (sub (T0, 94) <= 0)
+       {
+          /* index = T0*6 - 105 + T0_frac */
+          i = add (add (T0, T0), T0);
+          index = add (sub (add (i, i), 105), T0_frac);
+       }
+       else
+       {
+          index = add (T0, 368);
+       }
+       
+    }
+    else
+       /* if second or fourth subframe */
+    {
+       /* index = 6*(T0-T0_min) + 3 + T0_frac  */
+       i = sub (T0, T0_min);
+       i = add (add (i, i), i);
+       index = add (add (add (i, i), 3), T0_frac);
+    }
+    
+    return index;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/enc_lag6.h FFMpeg-20050127-new/libavcodec/amr/enc_lag6.h
--- FFMpeg-20050127/libavcodec/amr/enc_lag6.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/enc_lag6.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,43 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : enc_lag6.h
+*      Purpose          : Encoding of fractional pitch lag with 1/6 resolution.
+*
+********************************************************************************
+*/
+#ifndef enc_lag6_h
+#define enc_lag6_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+Word16 Enc_lag6 (        /* o  : Return index of encoding             */
+    Word16 T0,           /* i  : Pitch delay                          */
+    Word16 T0_frac,      /* i  : Fractional pitch delay               */
+	 Word16 T0_min,       /* i  : minimum of search range              */
+    Word16 delta_flag    /* i  : Flag for 1st (or 3rd) subframe       */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/ex_ctrl.c FFMpeg-20050127-new/libavcodec/amr/ex_ctrl.c
--- FFMpeg-20050127/libavcodec/amr/ex_ctrl.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/ex_ctrl.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,132 @@
+/*************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : ex_ctrl.c
+*      Purpose          : Excitation Control module in background noise
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "ex_ctrl.h"
+const char ex_ctrl_id[] = "@(#)$Id $" ex_ctrl_h;
+
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+#include "copy.h"
+#include "set_zero.h"
+#include "gmed_n.h"
+#include "sqrt_l.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+/*-----------------------------------------------------------------*
+ *   Decoder constant parameters (defined in "cnst.h")             *
+ *-----------------------------------------------------------------*
+ *   L_FRAME       : Frame size.                                   *
+ *   L_SUBFR       : Sub-frame size.                               *
+ *-----------------------------------------------------------------*/
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+
+/*
+**************************************************************************
+*
+*  Function    : Ex_ctrl
+*  Purpose     : Charaterice synthesis speech and detect background noise
+*  Returns     : background noise decision; 0 = no bgn, 1 = bgn
+*
+**************************************************************************
+*/
+Word16 Ex_ctrl (Word16 excitation[],   /*i/o: Current subframe excitation   */
+                Word16 excEnergy,      /* i : Exc. Energy, sqrt(totEx*totEx)*/
+                Word16 exEnergyHist[], /* i : History of subframe energies  */
+                Word16 voicedHangover, /* i : # of fr. after last voiced fr.*/
+                Word16 prevBFI,        /* i : Set i previous BFI            */
+                Word16 carefulFlag     /* i : Restrict dymamic in scaling   */
+                )
+{
+   Word16 i, exp;
+   Word16 testEnergy, scaleFactor, avgEnergy, prevEnergy;
+   Word32 t0;
+
+   /* get target level */
+   avgEnergy = gmed_n(exEnergyHist, 9);                    move16();
+
+   prevEnergy = shr( add (exEnergyHist[7], exEnergyHist[8]) ,1);
+
+   test ();
+   if ( sub (exEnergyHist[8], prevEnergy) < 0)
+   {
+      prevEnergy = exEnergyHist[8];         move16 ();
+   }
+
+   /* upscaling to avoid too rapid energy rises  for some cases */
+   test (); test ();
+   if ( sub (excEnergy, avgEnergy) < 0 && sub (excEnergy, 5) > 0)
+   {
+      testEnergy = shl(prevEnergy, 2);  /* testEnergy = 4*prevEnergy; */
+
+      test (); test ();
+      if ( sub (voicedHangover, 7) < 0 || prevBFI != 0 )
+      {
+         /* testEnergy = 3*prevEnergy */
+         testEnergy = sub (testEnergy, prevEnergy);  
+      }
+
+      test ();
+      if ( sub (avgEnergy, testEnergy) > 0)
+      {
+         avgEnergy = testEnergy;         move16 ();
+      }
+
+      /* scaleFactor=avgEnergy/excEnergy in Q0 (const 29 below)*/
+      exp = norm_s (excEnergy);
+      excEnergy = shl (excEnergy, exp);
+      excEnergy = div_s ((Word16) 16383, excEnergy);
+      t0 = L_mult (avgEnergy, excEnergy);
+      t0 = L_shr (t0, sub (20, exp));  /* const=30 for t0 in Q0, 20 for Q10 */
+      if ( L_sub(t0, 32767) > 0 )
+      {
+         t0 = 32767; move32 ();   /* saturate  */
+      }
+      scaleFactor = extract_l (t0); 
+
+      /* test if scaleFactor > 3.0 */
+      test (); test ();
+      if ( carefulFlag != 0 && sub(scaleFactor, 3072) > 0 ) 
+      {
+         scaleFactor = 3072;              move16 ();
+      }
+
+      /* scale the excitation by scaleFactor */
+      for (i = 0; i < L_SUBFR; i++)
+      {
+         t0 = L_mult (scaleFactor, excitation[i]);
+         t0 = L_shr (t0, 11);
+         excitation[i] = extract_l (t0);
+      } 
+   }
+
+   return 0;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/ex_ctrl.h FFMpeg-20050127-new/libavcodec/amr/ex_ctrl.h
--- FFMpeg-20050127/libavcodec/amr/ex_ctrl.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/ex_ctrl.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,65 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : ex_ctrl.h
+*      Purpose          : Excitation Control module in background noise
+*
+********************************************************************************
+*/
+#ifndef ex_ctrl_h
+#define ex_ctrl_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#define L_ENERGYHIST 60
+
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+ 
+/*
+**************************************************************************
+*
+*  Function    : Ex_ctrl
+*  Purpose     : Charaterice synthesis speech and detect background noise
+*  Returns     : background noise decision; 0 = bgn, 1 = no bgn
+*
+**************************************************************************
+*/
+Word16 Ex_ctrl (Word16 excitation[],   /*i/o: Current subframe excitation   */
+                Word16 excEnergy,      /* i : Exc. Energy, sqrt(totEx*totEx)*/
+                Word16 exEnergyHist[], /* i : History of subframe energies  */
+                Word16 voicedHangover, /* i : # of fr. after last voiced fr.*/
+                Word16 prevBFI,        /* i : Set i previous BFI            */
+                Word16 carefulFlag     /* i : Restrict dymamic in scaling   */
+);
+ 
+#endif
+
+
Binary files FFMpeg-20050127/libavcodec/amr/fipop.a and FFMpeg-20050127-new/libavcodec/amr/fipop.a differ
diff -Nur FFMpeg-20050127/libavcodec/amr/frame.h FFMpeg-20050127-new/libavcodec/amr/frame.h
--- FFMpeg-20050127/libavcodec/amr/frame.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/frame.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,73 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : frame.h
+*      Purpose          : Declaration of received and transmitted frame types
+*
+*****************************************************************************
+*/
+#ifndef frame_h
+#define frame_h "$Id $"
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+/*
+*****************************************************************************
+*                         DEFINITION OF DATA TYPES
+*****************************************************************************
+* Note: The order of the TX and RX_Type identifiers has been chosen in
+*       the way below to be compatible to an earlier version of the
+*       AMR-NB C reference program.                                   
+*****************************************************************************
+*/
+
+enum RXFrameType { RX_SPEECH_GOOD = 0,
+                   RX_SPEECH_DEGRADED,
+                   RX_ONSET,
+                   RX_SPEECH_BAD,
+                   RX_SID_FIRST,
+                   RX_SID_UPDATE,
+                   RX_SID_BAD,
+                   RX_NO_DATA,
+                   RX_N_FRAMETYPES     /* number of frame types */
+};
+
+enum TXFrameType { TX_SPEECH_GOOD = 0,
+                   TX_SID_FIRST,
+                   TX_SID_UPDATE,
+                   TX_NO_DATA,
+                   TX_SPEECH_DEGRADED,
+                   TX_SPEECH_BAD,
+                   TX_SID_BAD,
+                   TX_ONSET,
+                   TX_N_FRAMETYPES     /* number of frame types */
+};
+
+
+/* Channel decoded frame type */
+enum CHDECFrameType { CHDEC_SID_FIRST = 0,
+                      CHDEC_SID_FIRST_INCOMPLETE,
+                      CHDEC_SID_UPDATE_INCOMPLETE,
+                      CHDEC_SID_UPDATE,
+                      CHDEC_SPEECH,
+                      CHDEC_SPEECH_ONSET,
+                      CHDEC_ESCAPE_MARKER,
+                      CHDEC_ESCAPE_DATA,
+                      CHDEC_NO_DATA };
+
+/* Channel decoded frame quality */
+enum CHDECFrameQuality { CHDEC_GOOD = 0,
+                         CHDEC_PROBABLY_DEGRADED,
+                         CHDEC_PROBABLY_BAD,
+                         CHDEC_BAD };
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/g_adapt.c FFMpeg-20050127-new/libavcodec/amr/g_adapt.c
--- FFMpeg-20050127/libavcodec/amr/g_adapt.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/g_adapt.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,253 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : g_adapt.c
+*      Purpose          : gain adaptation for MR795 gain quantization
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "g_adapt.h"
+const char g_adapt_id[] = "@(#)$Id $" g_adapt_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "cnst.h"
+#include "gmed_n.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#define LTP_GAIN_THR1 2721 /* 2721 Q13 = 0.3322 ~= 1.0 / (10*log10(2)) */
+#define LTP_GAIN_THR2 5443 /* 5443 Q13 = 0.6644 ~= 2.0 / (10*log10(2)) */
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+*
+*  Function:   gain_adapt_init
+*  Purpose:    Allocates state memory and initializes state memory
+*
+**************************************************************************
+*/
+int gain_adapt_init (GainAdaptState **st)
+{
+    GainAdaptState* s;
+
+    if (st == (GainAdaptState **) NULL){
+        fprintf(stderr, "gain_adapt_init: invalid parameter\n");
+        return -1;
+    }
+    *st = NULL;
+
+    /* allocate memory */
+    if ((s= (GainAdaptState *) malloc(sizeof(GainAdaptState))) == NULL){
+        fprintf(stderr, "gain_adapt_init: can't malloc state structure\n");
+        return -1;
+    }
+    gain_adapt_reset(s);
+    *st = s;
+
+    return 0;
+}
+
+/*************************************************************************
+*
+*  Function:   gain_adapt_reset
+*  Purpose:    Initializes state memory to zero
+*
+**************************************************************************
+*/
+int gain_adapt_reset (GainAdaptState *st)
+{
+    Word16 i;
+
+    if (st == (GainAdaptState *) NULL){
+        fprintf(stderr, "gain_adapt_reset: invalid parameter\n");
+        return -1;
+    }
+
+    st->onset = 0;
+    st->prev_alpha = 0;
+    st->prev_gc = 0;
+
+    for (i = 0; i < LTPG_MEM_SIZE; i++)
+    {
+        st->ltpg_mem[i] = 0;
+    }
+
+    return 0;
+}
+
+/*************************************************************************
+*
+*  Function:   gain_adapt_exit
+*  Purpose:    The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void gain_adapt_exit (GainAdaptState **st)
+{
+    if (st == NULL || *st == NULL)
+        return;
+
+    /* deallocate memory */
+    free(*st);
+    *st = NULL;
+
+    return;
+}
+
+
+/*************************************************************************
+ *
+ *  Function:   gain_adapt()
+ *  Purpose:    calculate pitch/codebook gain adaptation factor alpha
+ *              (and update the adaptor state)
+ *
+ **************************************************************************
+ */
+void gain_adapt(
+    GainAdaptState *st,  /* i  : state struct                  */
+    Word16 ltpg,         /* i  : ltp coding gain (log2()), Q13 */
+    Word16 gain_cod,     /* i  : code gain,                Q1  */
+    Word16 *alpha        /* o  : gain adaptation factor,   Q15 */
+)
+{
+    Word16 adapt;      /* adaptdation status; 0, 1, or 2       */
+    Word16 result;     /* alpha factor, Q13                    */
+    Word16 filt;       /* median-filtered LTP coding gain, Q13 */
+    Word16 tmp, i;
+    
+    /* basic adaptation */
+    test ();
+    if (sub (ltpg, LTP_GAIN_THR1) <= 0)
+    {
+        adapt = 0;                            move16 ();
+    }
+    else
+    {
+        test ();
+        if (sub (ltpg, LTP_GAIN_THR2) <= 0)
+        {
+            adapt = 1;                        move16 ();
+        }
+        else
+        {
+            adapt = 2;                        move16 ();
+        }
+    }
+
+    /*
+     * // onset indicator
+     * if ((cbGain > onFact * cbGainMem[0]) && (cbGain > 100.0))
+     *     onset = 8;
+     * else
+     *     if (onset)
+     *         onset--;
+     */
+    /* tmp = cbGain / onFact; onFact = 2.0; 200 Q1 = 100.0 */
+    tmp = shr_r (gain_cod, 1);
+    test (); test ();
+    if ((sub (tmp, st->prev_gc) > 0) && sub(gain_cod, 200) > 0)
+    {
+        st->onset = 8;                            move16 ();
+    }
+    else
+    {
+        test ();
+        if (st->onset != 0)
+        {
+            st->onset = sub (st->onset, 1);       move16 ();
+        }
+    }
+
+    /*
+     *  // if onset, increase adaptor state
+     *  if (onset && (gainAdapt < 2)) gainAdapt++;
+     */
+    test(); test ();
+    if ((st->onset != 0) && (sub (adapt, 2) < 0))
+    {
+        adapt = add (adapt, 1);
+    }
+
+    st->ltpg_mem[0] = ltpg;                       move16 ();
+    filt = gmed_n (st->ltpg_mem, 5);   move16 (); /* function result */
+
+    test ();
+    if (adapt == 0)
+    {
+        test ();
+        if (sub (filt, 5443) > 0) /* 5443 Q13 = 0.66443... */
+        {
+            result = 0; move16 ();
+        }
+        else
+        {
+            test ();
+            if (filt < 0)
+            {
+                result = 16384; move16 ();  /* 16384 Q15 = 0.5 */
+            }
+            else
+            {   /* result       =   0.5 - 0.75257499*filt     */
+                /* result (Q15) = 16384 - 24660 * (filt << 2) */
+                filt = shl (filt, 2); /* Q15 */
+                result = sub (16384, mult (24660, filt));
+            }
+        }
+    }
+    else
+    {
+        result = 0; move16 ();
+    }
+    /*
+     *  if (prevAlpha == 0.0) result = 0.5 * (result + prevAlpha);
+     */
+    test ();
+    if (st->prev_alpha == 0)
+    {
+        result = shr (result, 1);
+    }
+
+    /* store the result */
+    *alpha = result;                           move16 ();
+    
+    /* update adapter state memory */
+    st->prev_alpha = result;                   move16 ();
+    st->prev_gc = gain_cod;                    move16 ();
+
+    for (i = LTPG_MEM_SIZE-1; i > 0; i--)
+    {
+        st->ltpg_mem[i] = st->ltpg_mem[i-1];   move16 ();
+    }
+    /* mem[0] is just present for convenience in calling the gmed_n[5]
+     * function above. The memory depth is really LTPG_MEM_SIZE-1.
+     */
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/g_adapt.h FFMpeg-20050127-new/libavcodec/amr/g_adapt.h
--- FFMpeg-20050127/libavcodec/amr/g_adapt.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/g_adapt.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,85 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : g_adapt.h
+*      Purpose          : gain adaptation for MR795 gain quantization
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#ifndef g_adapt_h
+#define g_adapt_h "$Id $"
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+
+#define LTPG_MEM_SIZE 5 /* number of stored past LTP coding gains + 1 */
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+typedef struct {
+    Word16 onset;                   /* onset state,                   Q0  */
+    Word16 prev_alpha;              /* previous adaptor output,       Q15 */
+    Word16 prev_gc;                 /* previous code gain,            Q1  */
+
+    Word16 ltpg_mem[LTPG_MEM_SIZE]; /* LTP coding gain history,       Q13 */
+                                    /* (ltpg_mem[0] not used for history) */
+} GainAdaptState;
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+int gain_adapt_init (GainAdaptState **st);
+/* initialize one instance of the gain adaptor
+   Stores pointer to state struct in *st. This pointer has to
+   be passed to gain_adapt and gain_adapt_update in each call.
+   returns 0 on success
+ */
+ 
+int gain_adapt_reset (GainAdaptState *st);
+/* reset of gain adaptor state (i.e. set state memory to zero)
+   returns 0 on success
+ */
+
+void gain_adapt_exit (GainAdaptState **st);
+/* de-initialize gain adaptor state (i.e. free state struct)
+   stores NULL in *st
+ */
+
+/*************************************************************************
+ *
+ *  Function:   gain_adapt()
+ *  Purpose:    calculate pitch/codebook gain adaptation factor alpha
+ *              (and update the adaptor state)
+ *
+ **************************************************************************
+ */
+void gain_adapt(
+    GainAdaptState *st,  /* i  : state struct                  */
+    Word16 ltpg,         /* i  : ltp coding gain (log2()), Q   */
+    Word16 gain_cod,     /* i  : code gain,                Q13 */
+    Word16 *alpha        /* o  : gain adaptation factor,   Q15 */
+);
+
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/g_code.c FFMpeg-20050127-new/libavcodec/amr/g_code.c
--- FFMpeg-20050127/libavcodec/amr/g_code.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/g_code.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,114 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : g_code.c
+*      Purpose          : Compute the innovative codebook gain.
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "g_code.h"
+const char g_code_id[] = "@(#)$Id $" g_code_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:   G_code
+ *
+ *  PURPOSE:  Compute the innovative codebook gain.
+ *
+ *  DESCRIPTION:
+ *      The innovative codebook gain is given by
+ *
+ *              g = <x[], y[]> / <y[], y[]>
+ *
+ *      where x[] is the target vector, y[] is the filtered innovative
+ *      codevector, and <> denotes dot product.
+ *
+ *************************************************************************/
+Word16 G_code (         /* out   : Gain of innovation code         */
+    Word16 xn2[],       /* in    : target vector                   */
+    Word16 y2[]         /* in    : filtered innovation vector      */
+)
+{
+    Word16 i;
+    Word16 xy, yy, exp_xy, exp_yy, gain;
+    Word16 scal_y2[L_SUBFR];
+    Word32 s;
+
+    /* Scale down Y[] by 2 to avoid overflow */
+
+    for (i = 0; i < L_SUBFR; i++)
+    {
+        scal_y2[i] = shr (y2[i], 1);  move16 (); 
+    }
+
+    /* Compute scalar product <X[],Y[]> */
+
+    s = 1L;                           move32 (); /* Avoid case of all zeros */
+    for (i = 0; i < L_SUBFR; i++)
+    {
+        s = L_mac (s, xn2[i], scal_y2[i]);
+    }
+    exp_xy = norm_l (s);
+    xy = extract_h (L_shl (s, exp_xy));
+
+    /* If (xy < 0) gain = 0  */
+
+    test (); 
+    if (xy <= 0)
+        return ((Word16) 0);
+
+    /* Compute scalar product <Y[],Y[]> */
+
+    s = 0L;                           move32 (); 
+    for (i = 0; i < L_SUBFR; i++)
+    {
+        s = L_mac (s, scal_y2[i], scal_y2[i]);
+    }
+    exp_yy = norm_l (s);
+    yy = extract_h (L_shl (s, exp_yy));
+
+    /* compute gain = xy/yy */
+
+    xy = shr (xy, 1);                 /* Be sure xy < yy */
+    gain = div_s (xy, yy);
+
+    /* Denormalization of division */
+    i = add (exp_xy, 5);              /* 15-1+9-18 = 5 */
+    i = sub (i, exp_yy);
+
+    gain = shl (shr (gain, i), 1);    /* Q0 -> Q1 */
+    
+    return (gain);
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/g_code.h FFMpeg-20050127-new/libavcodec/amr/g_code.h
--- FFMpeg-20050127/libavcodec/amr/g_code.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/g_code.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,41 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : g_code.h
+*      Purpose          : Compute the innovative codebook gain.
+*
+********************************************************************************
+*/
+#ifndef g_code_h
+#define g_code_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+Word16 G_code (        /* out      : Gain of innovation code.               */
+    Word16 xn[],       /* in       : target vector                          */
+    Word16 y2[]        /* in       : filtered inovation vector              */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/g_pitch.c FFMpeg-20050127-new/libavcodec/amr/g_pitch.c
--- FFMpeg-20050127/libavcodec/amr/g_pitch.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/g_pitch.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,171 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : g_pitch.c
+*      Purpose          : Compute the pitch (adaptive codebook) gain.
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "g_pitch.h"
+const char g_pitch_id[] = "@(#)$Id $" g_pitch_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "mode.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "cnst.h"
+ 
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  G_pitch
+ *
+ *  PURPOSE:  Compute the pitch (adaptive codebook) gain.
+ *            Result in Q14 (NOTE: 12.2 bit exact using Q12) 
+ *
+ *  DESCRIPTION:
+ *      The adaptive codebook gain is given by
+ *
+ *              g = <x[], y[]> / <y[], y[]>
+ *
+ *      where x[] is the target vector, y[] is the filtered adaptive
+ *      codevector, and <> denotes dot product.
+ *      The gain is limited to the range [0,1.2] (=0..19661 Q14)
+ *
+ *************************************************************************/
+Word16 G_pitch     (    /* o : Gain of pitch lag saturated to 1.2       */
+    enum Mode mode,     /* i : AMR mode                                 */
+    Word16 xn[],        /* i : Pitch target.                            */
+    Word16 y1[],        /* i : Filtered adaptive codebook.              */
+    Word16 g_coeff[],   /* i : Correlations need for gain quantization  */
+    Word16 L_subfr      /* i : Length of subframe.                      */
+)
+{
+    Word16 i;
+    Word16 xy, yy, exp_xy, exp_yy, gain;
+    Word32 s;
+
+    Word16 scaled_y1[L_SUBFR];   /* Usually dynamic allocation of (L_subfr) */
+
+    /* divide "y1[]" by 4 to avoid overflow */
+
+    for (i = 0; i < L_subfr; i++)
+    {
+        scaled_y1[i] = shr (y1[i], 2); move16 (); 
+    }
+
+    /* Compute scalar product <y1[],y1[]> */
+
+    /* Q12 scaling / MR122 */
+    Overflow = 0;                   move16 ();
+    s = 1L;                         move32 (); /* Avoid case of all zeros */
+    for (i = 0; i < L_subfr; i++)
+    {
+        s = L_mac (s, y1[i], y1[i]);
+    }
+    test (); 
+    if (Overflow == 0)       /* Test for overflow */
+    {
+        exp_yy = norm_l (s);
+        yy = round (L_shl (s, exp_yy));
+    }
+    else
+    {
+        s = 1L;                     move32 (); /* Avoid case of all zeros */
+        for (i = 0; i < L_subfr; i++)
+        {
+            s = L_mac (s, scaled_y1[i], scaled_y1[i]);
+        }
+        exp_yy = norm_l (s);
+        yy = round (L_shl (s, exp_yy));
+        exp_yy = sub (exp_yy, 4);
+    }
+        
+    /* Compute scalar product <xn[],y1[]> */
+        
+    Overflow = 0;                   move16 (); 
+    s = 1L;                         move32 (); /* Avoid case of all zeros */
+        
+    for (i = 0; i < L_subfr; i++)
+    {
+        s = L_mac(s, xn[i], y1[i]);
+    }
+    test (); 
+    if (Overflow == 0)
+    {
+        exp_xy = norm_l (s);
+        xy = round (L_shl (s, exp_xy));
+    }
+    else
+    {
+        s = 1L;                     move32 (); /* Avoid case of all zeros */
+        for (i = 0; i < L_subfr; i++)
+        {
+            s = L_mac (s, xn[i], scaled_y1[i]);
+        }
+        exp_xy = norm_l (s);
+        xy = round (L_shl (s, exp_xy));
+        exp_xy = sub (exp_xy, 2);
+    }
+
+    g_coeff[0] = yy;                 move16 ();
+    g_coeff[1] = sub (15, exp_yy);   move16 ();
+    g_coeff[2] = xy;                 move16 ();
+    g_coeff[3] = sub (15, exp_xy);   move16 ();
+    
+    /* If (xy < 4) gain = 0 */
+
+    i = sub (xy, 4);
+
+    test (); 
+    if (i < 0)
+        return ((Word16) 0);
+
+    /* compute gain = xy/yy */
+
+    xy = shr (xy, 1);                  /* Be sure xy < yy */
+    gain = div_s (xy, yy);
+
+    i = sub (exp_xy, exp_yy);      /* Denormalization of division */        
+    gain = shr (gain, i);
+    
+    /* if(gain >1.2) gain = 1.2 */
+    
+    test (); 
+    if (sub (gain, 19661) > 0)
+    {
+        gain = 19661;                   move16 (); 
+    }
+
+    test ();
+    if (sub(mode, MR122) == 0)
+    {
+       /* clear 2 LSBits */
+       gain = gain & 0xfffC;            logic16 ();
+    }
+    
+    return (gain);
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/g_pitch.h FFMpeg-20050127-new/libavcodec/amr/g_pitch.h
--- FFMpeg-20050127/libavcodec/amr/g_pitch.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/g_pitch.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,40 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : g_pitch.h
+*      Purpose          : Compute the pitch (adaptive codebook) gain.
+*
+********************************************************************************
+*/
+#ifndef g_pitch_h
+#define g_pitch_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+Word16 G_pitch     (    /* o : Gain of pitch lag saturated to 1.2       */
+    enum Mode mode,     /* i : AMR mode                                 */
+    Word16 xn[],        /* i : Pitch target.                            */
+    Word16 y1[],        /* i : Filtered adaptive codebook.              */
+    Word16 g_coeff[],   /* i : Correlations need for gain quantization.
+                               (7.4 only). Pass NULL if not needed      */
+    Word16 L_subfr      /* i : Length of subframe.                      */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/gain_q.c FFMpeg-20050127-new/libavcodec/amr/gain_q.c
--- FFMpeg-20050127/libavcodec/amr/gain_q.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/gain_q.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,315 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : gain_q.c
+*      Purpose          : Quantazation of gains
+*
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "gain_q.h"
+const char gain_q_id[] = "@(#)$Id $" gain_q_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "qua_gain.h"
+#include "cnst.h"
+#include "mode.h"
+#include "g_code.h"
+#include "q_gain_c.h"
+#include "gc_pred.h"
+#include "calc_en.h"
+#include "qgain795.h"
+#include "qgain475.h"
+#include "set_zero.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+*
+*  Function:   gainQuant_init
+*  Purpose:    Allocates state memory and initializes state memory
+*
+**************************************************************************
+*/
+int gainQuant_init (gainQuantState **state)
+{
+  gainQuantState* s;
+ 
+  if (state == (gainQuantState **) NULL){
+      fprintf(stderr, "gainQuant_init: invalid parameter\n");
+      return -1;
+  }
+  *state = NULL;
+ 
+  /* allocate memory */
+  if ((s= (gainQuantState *) malloc(sizeof(gainQuantState))) == NULL){
+      fprintf(stderr, "gainQuant_init: can not malloc state structure\n");
+      return -1;
+  }
+  
+  s->gain_idx_ptr = NULL;
+  
+  s->gc_predSt = NULL;
+  s->gc_predUnqSt = NULL;
+  s->adaptSt = NULL;
+
+  /* Init sub states */
+  if (   gc_pred_init(&s->gc_predSt)
+      || gc_pred_init(&s->gc_predUnqSt)
+      || gain_adapt_init(&s->adaptSt)) {
+     gainQuant_exit(&s);
+     return -1;
+  }
+ 
+  gainQuant_reset(s);
+  *state = s;
+  
+  return 0;
+}
+
+/*************************************************************************
+*
+*  Function:   gainQuant_reset
+*  Purpose:    Initializes state memory to zero
+*
+**************************************************************************
+*/
+int gainQuant_reset (gainQuantState *state)
+{
+  
+  if (state == (gainQuantState *) NULL){
+      fprintf(stderr, "gainQuant_reset: invalid parameter\n");
+      return -1;
+  }
+  
+  state->sf0_exp_gcode0 = 0;
+  state->sf0_frac_gcode0 = 0;
+  state->sf0_exp_target_en = 0;
+  state->sf0_frac_target_en = 0;
+  
+  Set_zero (state->sf0_exp_coeff, 5);
+  Set_zero (state->sf0_frac_coeff, 5);
+  state->gain_idx_ptr = NULL;
+  
+  gc_pred_reset(state->gc_predSt);
+  gc_pred_reset(state->gc_predUnqSt);
+  gain_adapt_reset(state->adaptSt);
+  
+  return 0;
+}
+ 
+/*************************************************************************
+*
+*  Function:   gainQuant_exit
+*  Purpose:    The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void gainQuant_exit (gainQuantState **state)
+{
+  if (state == NULL || *state == NULL)
+      return;
+ 
+  gc_pred_exit(&(*state)->gc_predSt);
+  gc_pred_exit(&(*state)->gc_predUnqSt);
+  gain_adapt_exit(&(*state)->adaptSt);
+
+  /* deallocate memory */
+  free(*state);
+  *state = NULL;
+  
+  return;
+}
+ 
+int gainQuant(
+    gainQuantState *st,   /* i/o : State struct                      */
+    enum Mode mode,       /* i   : coder mode                        */
+    Word16 res[],         /* i   : LP residual,                 Q0   */
+    Word16 exc[],         /* i   : LTP excitation (unfiltered), Q0   */
+    Word16 code[],        /* i   : CB innovation (unfiltered),  Q13  */
+                          /*       (unsharpened for MR475)           */
+    Word16 xn[],          /* i   : Target vector.                    */
+    Word16 xn2[],         /* i   : Target vector.                    */
+    Word16 y1[],          /* i   : Adaptive codebook.                */
+    Word16 Y2[],          /* i   : Filtered innovative vector.       */
+    Word16 g_coeff[],     /* i   : Correlations <xn y1> <y1 y1>      */
+                          /*       Compute in G_pitch().             */
+    Word16 even_subframe, /* i   : even subframe indicator flag      */
+    Word16 gp_limit,      /* i   : pitch gain limit                  */
+    Word16 *sf0_gain_pit, /* o   : Pitch gain sf 0.   MR475          */
+    Word16 *sf0_gain_cod, /* o   : Code gain sf 0.    MR475          */
+    Word16 *gain_pit,     /* i/o : Pitch gain.                       */
+    Word16 *gain_cod,     /* o   : Code gain.                        */
+                          /*       MR475: gain_* unquantized in even */
+                          /*       subframes, quantized otherwise    */
+    Word16 **anap         /* o   : Index of quantization             */
+)
+{
+    Word16 exp_gcode0;
+    Word16 frac_gcode0;
+    Word16 qua_ener_MR122;
+    Word16 qua_ener;
+    Word16 frac_coeff[5];
+    Word16 exp_coeff[5];
+    Word16 exp_en, frac_en;
+    Word16 cod_gain_exp, cod_gain_frac;
+            
+    test ();
+    if (sub (mode, MR475) == 0)
+    {
+        test ();
+        if (even_subframe != 0)
+        {
+            /* save position in output parameter stream and current
+               state of codebook gain predictor */
+            st->gain_idx_ptr = (*anap)++;
+            gc_pred_copy(st->gc_predSt, st->gc_predUnqSt);
+            
+            /* predict codebook gain (using "unquantized" predictor)*/
+            /* (note that code[] is unsharpened in MR475)           */
+            gc_pred(st->gc_predUnqSt, mode, code,
+                    &st->sf0_exp_gcode0, &st->sf0_frac_gcode0,
+                    &exp_en, &frac_en);
+            
+            /* calculate energy coefficients for quantization
+               and store them in state structure (will be used
+               in next subframe when real quantizer is run) */
+            calc_filt_energies(mode, xn, xn2, y1, Y2, g_coeff,
+                               st->sf0_frac_coeff, st->sf0_exp_coeff,
+                               &cod_gain_frac, &cod_gain_exp);
+
+            /* store optimum codebook gain (Q1) */
+            *gain_cod = shl (cod_gain_frac, add (cod_gain_exp, 1));
+                                                         move16 ();
+
+            calc_target_energy(xn,
+                               &st->sf0_exp_target_en, &st->sf0_frac_target_en);
+
+            /* calculate optimum codebook gain and update
+               "unquantized" predictor                    */
+            MR475_update_unq_pred(st->gc_predUnqSt,
+                                  st->sf0_exp_gcode0, st->sf0_frac_gcode0,
+                                  cod_gain_exp, cod_gain_frac);
+            
+            /* the real quantizer is not run here... */
+        }
+        else
+        {
+            /* predict codebook gain (using "unquantized" predictor) */
+            /* (note that code[] is unsharpened in MR475)            */
+            gc_pred(st->gc_predUnqSt, mode, code,
+                    &exp_gcode0, &frac_gcode0,
+                    &exp_en, &frac_en);
+            
+            /* calculate energy coefficients for quantization */
+            calc_filt_energies(mode, xn, xn2, y1, Y2, g_coeff,
+                               frac_coeff, exp_coeff,
+                               &cod_gain_frac, &cod_gain_exp);
+
+            calc_target_energy(xn, &exp_en, &frac_en);
+
+            /* run real (4-dim) quantizer and update real gain predictor */
+            *st->gain_idx_ptr = MR475_gain_quant(
+                st->gc_predSt,
+                st->sf0_exp_gcode0, st->sf0_frac_gcode0, 
+                st->sf0_exp_coeff,  st->sf0_frac_coeff,
+                st->sf0_exp_target_en, st->sf0_frac_target_en,
+                code,
+                exp_gcode0, frac_gcode0, 
+                exp_coeff, frac_coeff,
+                exp_en, frac_en,
+                gp_limit,
+                sf0_gain_pit, sf0_gain_cod,   
+                gain_pit, gain_cod);
+        }
+    }
+    else
+    {
+        /*-------------------------------------------------------------------*
+         *  predict codebook gain and quantize                               *
+         *  (also compute normalized CB innovation energy for MR795)         *
+         *-------------------------------------------------------------------*/
+        gc_pred(st->gc_predSt, mode, code, &exp_gcode0, &frac_gcode0,
+                &exp_en, &frac_en);
+        
+        test ();
+        if (sub(mode, MR122) == 0)
+        {
+            *gain_cod = G_code (xn2, Y2); move16 ();
+            *(*anap)++ = q_gain_code (mode, exp_gcode0, frac_gcode0,
+                                      gain_cod, &qua_ener_MR122, &qua_ener);
+            move16 ();
+        }
+        else
+        {
+            /* calculate energy coefficients for quantization */
+            calc_filt_energies(mode, xn, xn2, y1, Y2, g_coeff,
+                               frac_coeff, exp_coeff,
+                               &cod_gain_frac, &cod_gain_exp);
+            
+            test ();
+            if (sub (mode, MR795) == 0)
+            {
+                MR795_gain_quant(st->adaptSt, res, exc, code,
+                                 frac_coeff, exp_coeff,
+                                 exp_en, frac_en,
+                                 exp_gcode0, frac_gcode0, L_SUBFR,
+                                 cod_gain_frac, cod_gain_exp,
+                                 gp_limit, gain_pit, gain_cod,
+                                 &qua_ener_MR122, &qua_ener,
+                                 anap);
+            }
+            else
+            {
+                *(*anap)++ = Qua_gain(mode,
+                                      exp_gcode0, frac_gcode0,
+                                      frac_coeff, exp_coeff, gp_limit,
+                                      gain_pit, gain_cod,
+                                      &qua_ener_MR122, &qua_ener);
+                move16 ();
+            }
+        }
+        
+        /*------------------------------------------------------------------*
+         *  update table of past quantized energies                         *
+         *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                         *
+         *  st->past_qua_en(Q10) = 20 * Log10(qua_gain_code) / constant     *
+         *                       = Log2(qua_gain_code)                      *
+         *                       = qua_ener                                 *
+         *                                           constant = 20*Log10(2) *
+         *------------------------------------------------------------------*/
+        gc_pred_update(st->gc_predSt, qua_ener_MR122, qua_ener);
+    }
+        
+    return 0;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/gain_q.h FFMpeg-20050127-new/libavcodec/amr/gain_q.h
--- FFMpeg-20050127/libavcodec/amr/gain_q.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/gain_q.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,92 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : gainQuant.h
+*      Purpose          : Quantazation of gains
+*
+********************************************************************************
+*/
+#ifndef gain_q_h
+#define gain_q_h "$Id $"
+ 
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+#include "gc_pred.h"
+#include "g_adapt.h"
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+typedef struct {
+    Word16 sf0_exp_gcode0;
+    Word16 sf0_frac_gcode0;
+    Word16 sf0_exp_target_en;
+    Word16 sf0_frac_target_en;
+    Word16 sf0_exp_coeff[5];
+    Word16 sf0_frac_coeff[5];
+    Word16 *gain_idx_ptr;
+    
+    gc_predState     *gc_predSt;
+    gc_predState     *gc_predUnqSt;
+    GainAdaptState   *adaptSt;
+} gainQuantState;
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+int gainQuant_init (gainQuantState **st);
+/* initialize one instance of the pre processing state.
+   Stores pointer to filter status struct in *st. This pointer has to
+   be passed to gainQuant in each call.
+   returns 0 on success
+ */
+int gainQuant_reset (gainQuantState *st);
+/* reset of pre processing state (i.e. set state memory to zero)
+   returns 0 on success
+ */
+void gainQuant_exit (gainQuantState **st);
+/* de-initialize pre processing state (i.e. free status struct)
+   stores NULL in *st
+ */
+
+int gainQuant(
+    gainQuantState *st,   /* i/o : State struct                      */
+    enum Mode mode,       /* i   : coder mode                        */
+    Word16 res[],         /* i   : LP residual,                 Q0   */
+    Word16 exc[],         /* i   : LTP excitation (unfiltered), Q0   */
+    Word16 code[],        /* i   : CB innovation (unfiltered),  Q13  */
+                          /*       (unsharpened for MR475)           */
+    Word16 xn[],          /* i   : Target vector.                    */
+    Word16 xn2[],         /* i   : Target vector.                    */
+    Word16 y1[],          /* i   : Adaptive codebook.                */
+    Word16 Y2[],          /* i   : Filtered innovative vector.       */
+    Word16 g_coeff[],     /* i   : Correlations <xn y1> <y1 y1>      */
+                          /*       Compute in G_pitch().             */
+    Word16 even_subframe, /* i   : even subframe indicator flag      */
+    Word16 gp_limit,      /* i   : pitch gain limit                  */
+    Word16 *sf0_gain_pit, /* o   : Pitch gain sf 0.   MR475          */
+    Word16 *sf0_gain_cod, /* o   : Code gain sf 0.    MR475          */
+    Word16 *gain_pit,     /* i/o : Pitch gain.                       */
+    Word16 *gain_cod,     /* o   : Code gain.                        */
+                          /*       MR475: gain_* unquantized in even */
+                          /*       subframes, quantized otherwise    */
+    Word16 **anap         /* o   : Index of quantization             */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/gains.tab FFMpeg-20050127-new/libavcodec/amr/gains.tab
--- FFMpeg-20050127/libavcodec/amr/gains.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/gains.tab	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,72 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : gains.tab
+*      Purpose          : Scalar quantization tables of the pitch gain and
+*                       : the codebook gain.
+*      $Id $
+*
+********************************************************************************
+*/
+#define NB_QUA_PITCH 16
+
+static const Word16 qua_gain_pitch[NB_QUA_PITCH] =
+{
+    0, 3277, 6556, 8192, 9830, 11469, 12288, 13107,
+    13926, 14746, 15565, 16384, 17203, 18022, 18842, 19661
+};
+
+#define NB_QUA_CODE 32
+
+static const Word16 qua_gain_code[NB_QUA_CODE*3] =
+{
+/* gain factor (g_fac) and quantized energy error (qua_ener_MR122, qua_ener)
+ * are stored:
+ *
+ * qua_ener_MR122 = log2(g_fac)      (not the rounded floating point value, but
+ *                                    the value the original EFR algorithm
+ *                                    calculates from g_fac [using Log2])
+ * qua_ener       = 20*log10(g_fac); (rounded floating point value)
+ *
+ *
+ * g_fac (Q11), qua_ener_MR122 (Q10), qua_ener (Q10)
+ */
+          159,                -3776,          -22731,
+          206,                -3394,          -20428,
+          268,                -3005,          -18088,
+          349,                -2615,          -15739,
+          419,                -2345,          -14113,
+          482,                -2138,          -12867,
+          554,                -1932,          -11629,
+          637,                -1726,          -10387,
+          733,                -1518,           -9139,
+          842,                -1314,           -7906,
+          969,                -1106,           -6656,
+         1114,                 -900,           -5416,
+         1281,                 -694,           -4173,
+         1473,                 -487,           -2931,
+         1694,                 -281,           -1688,
+         1948,                  -75,            -445,
+         2241,                  133,             801,
+         2577,                  339,            2044,
+         2963,                  545,            3285,
+         3408,                  752,            4530,
+         3919,                  958,            5772,
+         4507,                 1165,            7016,
+         5183,                 1371,            8259,
+         5960,                 1577,            9501,
+         6855,                 1784,           10745,
+         7883,                 1991,           11988,
+         9065,                 2197,           13231,
+        10425,                 2404,           14474,
+        12510,                 2673,           16096,
+        16263,                 3060,           18429,
+        21142,                 3448,           20763,
+        27485,                 3836,           23097
+};
diff -Nur FFMpeg-20050127/libavcodec/amr/gc_pred.c FFMpeg-20050127-new/libavcodec/amr/gc_pred.c
--- FFMpeg-20050127/libavcodec/amr/gc_pred.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/gc_pred.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,430 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : gc_pred.c
+*      Purpose          : codebook gain MA prediction
+*
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "gc_pred.h"
+const char gc_pred_id[] = "@(#)$Id $" gc_pred_h;
+
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "cnst.h"
+#include "count.h"
+#include "log2.h"
+#include "copy.h"
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+
+#define NPRED 4  /* number of prediction taps */
+
+/* MA prediction coefficients (Q13) */
+static const Word16 pred[NPRED] = {5571, 4751, 2785, 1556};
+
+/* average innovation energy.                               */
+/* MEAN_ENER  = 36.0/constant, constant = 20*Log10(2)       */
+#define MEAN_ENER_MR122  783741L  /* 36/(20*log10(2)) (Q17) */
+
+/* MA prediction coefficients (Q6)  */
+static const Word16 pred_MR122[NPRED] = {44, 37, 22, 12};
+
+/* minimum quantized energy: -14 dB */
+#define MIN_ENERGY       -14336       /* 14                 Q10 */
+#define MIN_ENERGY_MR122  -2381       /* 14 / (20*log10(2)) Q10 */ 
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+/*************************************************************************
+*
+*  Function:   qua_gain_init
+*  Purpose:    Allocates state memory and initializes state memory
+*
+**************************************************************************
+*/
+int gc_pred_init (gc_predState **state)
+{
+  gc_predState* s;
+
+  if (state == (gc_predState **) NULL){
+      fprintf(stderr, "gc_pred_init: invalid parameter\n");
+      return -1;
+  }
+  *state = NULL;
+
+  /* allocate memory */
+  if ((s= (gc_predState *) malloc(sizeof(gc_predState))) == NULL){
+      fprintf(stderr, "gc_pred_init: can not malloc state structure\n");
+      return -1;
+  }
+  gc_pred_reset(s);
+  *state = s;
+
+  return 0;
+}
+/*************************************************************************
+*
+*  Function:   gc_pred_reset
+*  Purpose:    Initializes state memory to zero
+*
+**************************************************************************
+*/
+int gc_pred_reset (gc_predState *state)
+{
+   Word16 i;
+
+   if (state == (gc_predState *) NULL){
+      fprintf(stderr, "gc_pred_reset: invalid parameter\n");
+      return -1;
+   }
+
+   for(i = 0; i < NPRED; i++)
+   {
+      state->past_qua_en[i] = MIN_ENERGY;
+      state->past_qua_en_MR122[i] = MIN_ENERGY_MR122;
+   }
+  return 0;
+}
+
+/*************************************************************************
+*
+*  Function:   gc_pred_exit
+*  Purpose:    The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void gc_pred_exit (gc_predState **state)
+{
+  if (state == NULL || *state == NULL)
+      return;
+
+  /* deallocate memory */
+  free(*state);
+  *state = NULL;
+
+  return;
+}
+
+/*************************************************************************
+ *
+ * FUNCTION:  gc_pred_copy()
+ *
+ * PURPOSE: Copy MA predictor state variable
+ *
+ *************************************************************************/
+void
+gc_pred_copy(
+    gc_predState *st_src,  /* i : State struct                           */
+    gc_predState *st_dest  /* o : State struct                           */
+)
+{
+    Copy (st_src->past_qua_en, st_dest->past_qua_en, NPRED);
+    Copy (st_src->past_qua_en_MR122, st_dest->past_qua_en_MR122, NPRED);
+}
+
+/*************************************************************************
+ *
+ * FUNCTION:  gc_pred()
+ *
+ * PURPOSE: MA prediction of the innovation energy
+ *          (in dB/(20*log10(2))) with mean  removed).
+ *
+ *************************************************************************/
+void
+gc_pred(
+    gc_predState *st,   /* i/o: State struct                           */
+    enum Mode mode,     /* i  : AMR mode                               */
+    Word16 *code,       /* i  : innovative codebook vector (L_SUBFR)   */
+                        /*      MR122: Q12, other modes: Q13           */
+    Word16 *exp_gcode0, /* o  : exponent of predicted gain factor, Q0  */
+    Word16 *frac_gcode0,/* o  : fraction of predicted gain factor  Q15 */
+    Word16 *exp_en,     /* o  : exponent of innovation energy,     Q0  */
+                        /*      (only calculated for MR795)            */
+    Word16 *frac_en     /* o  : fraction of innovation energy,     Q15 */
+                        /*      (only calculated for MR795)            */
+)
+{
+    Word16 i;
+    Word32 ener_code;
+    Word16 exp, frac;
+
+    /*-------------------------------------------------------------------*
+     *  energy of code:                                                  *
+     *  ~~~~~~~~~~~~~~~                                                  *
+     *  ener_code = sum(code[i]^2)                                       *
+     *-------------------------------------------------------------------*/
+    ener_code = L_mac((Word32) 0, code[0], code[0]);
+                                                 /* MR122:  Q12*Q12 -> Q25 */
+                                                 /* others: Q13*Q13 -> Q27 */
+    for (i = 1; i < L_SUBFR; i++)
+        ener_code = L_mac(ener_code, code[i], code[i]);
+    
+    test ();
+    if (sub (mode, MR122) == 0)
+    {
+        Word32 ener;
+
+        /* ener_code = ener_code / lcode; lcode = 40; 1/40 = 26214 Q20       */
+        ener_code = L_mult (round (ener_code), 26214);   /* Q9  * Q20 -> Q30 */
+
+        /*-------------------------------------------------------------------*
+         *  energy of code:                                                  *
+         *  ~~~~~~~~~~~~~~~                                                  *
+         *  ener_code(Q17) = 10 * Log10(energy) / constant                   *
+         *                 = 1/2 * Log2(energy)                              *
+         *                                           constant = 20*Log10(2)  *
+         *-------------------------------------------------------------------*/
+        /* ener_code = 1/2 * Log2(ener_code); Note: Log2=log2+30 */
+        Log2(ener_code, &exp, &frac);
+        ener_code = L_Comp (sub (exp, 30), frac);     /* Q16 for log()    */
+                                                    /* ->Q17 for 1/2 log()*/
+
+        /*-------------------------------------------------------------------*
+         *  predicted energy:                                                *
+         *  ~~~~~~~~~~~~~~~~~                                                *
+         *  ener(Q24) = (Emean + sum{pred[i]*past_en[i]})/constant           *
+         *            = MEAN_ENER + sum(pred[i]*past_qua_en[i])              *
+         *                                           constant = 20*Log10(2)  *
+         *-------------------------------------------------------------------*/
+
+        ener = MEAN_ENER_MR122; move32 ();                  /* Q24 (Q17) */
+        for (i = 0; i < NPRED; i++)
+        {
+            ener = L_mac (ener, st->past_qua_en_MR122[i], pred_MR122[i]);
+                                                     /* Q10 * Q13 -> Q24 */
+                                                     /* Q10 * Q6  -> Q17 */
+        }
+
+        /*-------------------------------------------------------------------*
+         *  predicted codebook gain                                          *
+         *  ~~~~~~~~~~~~~~~~~~~~~~~                                          *
+         *  gc0     = Pow10( (ener*constant - ener_code*constant) / 20 )     *
+         *          = Pow2(ener-ener_code)                                   *
+         *          = Pow2(int(d)+frac(d))                                   *
+         *                                                                   *
+         *  (store exp and frac for pow2())                                  *
+         *-------------------------------------------------------------------*/
+
+        ener = L_shr (L_sub (ener, ener_code), 1);                /* Q16 */
+        L_Extract(ener, exp_gcode0, frac_gcode0);
+    }
+    else /* all modes except 12.2 */
+    {
+        Word32 L_tmp;
+        Word16 exp_code, gcode0;
+        
+        /*-----------------------------------------------------------------*
+         *  Compute: means_ener - 10log10(ener_code/ L_sufr)               *
+         *-----------------------------------------------------------------*/
+
+        exp_code = norm_l (ener_code);
+        ener_code = L_shl (ener_code, exp_code);
+        
+        /* Log2 = log2 + 27 */
+        Log2_norm (ener_code, exp_code, &exp, &frac);
+        
+        /* fact = 10/log2(10) = 3.01 = 24660 Q13 */
+        L_tmp = Mpy_32_16(exp, frac, -24660); /* Q0.Q15 * Q13 -> Q14 */
+
+        /*   L_tmp = means_ener - 10log10(ener_code/L_SUBFR)
+         *         = means_ener - 10log10(ener_code) + 10log10(L_SUBFR)
+         *         = K - fact * Log2(ener_code)
+         *         = K - fact * log2(ener_code) - fact*27
+         *
+         *   ==> K = means_ener + fact*27 + 10log10(L_SUBFR)
+         *
+         *   means_ener =       33    =  540672    Q14  (MR475, MR515, MR59)
+         *   means_ener =       28.75 =  471040    Q14  (MR67)
+         *   means_ener =       30    =  491520    Q14  (MR74)
+         *   means_ener =       36    =  589824    Q14  (MR795)
+         *   means_ener =       33    =  540672    Q14  (MR102)         
+         *   10log10(L_SUBFR) = 16.02 =  262481.51 Q14
+         *   fact * 27                = 1331640    Q14
+         *   -----------------------------------------
+         *   (MR475, MR515, MR59)   K = 2134793.51 Q14 ~= 16678 * 64 * 2
+         *   (MR67)                 K = 2065161.51 Q14 ~= 32268 * 32 * 2
+         *   (MR74)                 K = 2085641.51 Q14 ~= 32588 * 32 * 2
+         *   (MR795)                K = 2183945.51 Q14 ~= 17062 * 64 * 2
+         *   (MR102)                K = 2134793.51 Q14 ~= 16678 * 64 * 2         
+         */
+
+        if (test (), sub (mode, MR102) == 0)
+        {
+            /* mean = 33 dB */
+            L_tmp = L_mac(L_tmp, 16678, 64);     /* Q14 */
+        }
+        else if (test (), sub (mode, MR795) == 0)
+        {
+            /* ener_code  = <xn xn> * 2^27*2^exp_code
+               frac_en    = ener_code / 2^16
+                          = <xn xn> * 2^11*2^exp_code
+               <xn xn>    = <xn xn>*2^11*2^exp * 2^exp_en
+                         := frac_en            * 2^exp_en
+
+               ==> exp_en = -11-exp_code;
+             */
+            *frac_en = extract_h (ener_code); move16 ();
+            *exp_en = sub (-11, exp_code);    move16 ();
+
+            /* mean = 36 dB */
+            L_tmp = L_mac(L_tmp, 17062, 64);     /* Q14 */
+        }
+        else if (test (), sub (mode, MR74) == 0)
+        {
+            /* mean = 30 dB */
+            L_tmp = L_mac(L_tmp, 32588, 32);     /* Q14 */
+        }
+        else if (test (), sub (mode, MR67) == 0)
+        {
+            /* mean = 28.75 dB */
+            L_tmp = L_mac(L_tmp, 32268, 32);     /* Q14 */
+        }
+        else /* MR59, MR515, MR475 */
+        {
+            /* mean = 33 dB */
+            L_tmp = L_mac(L_tmp, 16678, 64);     /* Q14 */
+        }
+        
+        /*-----------------------------------------------------------------*
+         * Compute gcode0.                                                 *
+         *  = Sum(i=0,3) pred[i]*past_qua_en[i] - ener_code + mean_ener    *
+         *-----------------------------------------------------------------*/
+
+        L_tmp = L_shl(L_tmp, 10);                /* Q24 */
+        for (i = 0; i < 4; i++)
+            L_tmp = L_mac(L_tmp, pred[i], st->past_qua_en[i]);
+                                                 /* Q13 * Q10 -> Q24 */
+
+        gcode0 = extract_h(L_tmp);               /* Q8  */
+
+        /*-----------------------------------------------------------------*
+         * gcode0 = pow(10.0, gcode0/20)                                   *
+         *        = pow(2, 3.3219*gcode0/20)                               *
+         *        = pow(2, 0.166*gcode0)                                   *
+         *-----------------------------------------------------------------*/
+
+        /* 5439 Q15 = 0.165985                                        */
+        /* (correct: 1/(20*log10(2)) 0.166096 = 5443 Q15)             */
+        test ();
+        if (sub (mode, MR74) == 0) /* For IS641 bitexactness */
+            L_tmp = L_mult(gcode0, 5439);  /* Q8 * Q15 -> Q24 */
+        else
+            L_tmp = L_mult(gcode0, 5443);  /* Q8 * Q15 -> Q24 */
+
+        L_tmp = L_shr(L_tmp, 8);                   /*          -> Q16 */
+        L_Extract(L_tmp, exp_gcode0, frac_gcode0); /*       -> Q0.Q15 */
+    }
+}
+
+
+/*************************************************************************
+ *
+ * FUNCTION:  gc_pred_update()
+ *
+ * PURPOSE: update MA predictor with last quantized energy
+ *
+ *************************************************************************/
+void gc_pred_update(
+    gc_predState *st,      /* i/o: State struct                     */
+    Word16 qua_ener_MR122, /* i  : quantized energy for update, Q10 */
+                           /*      (log2(qua_err))                  */
+    Word16 qua_ener        /* i  : quantized energy for update, Q10 */
+                           /*      (20*log10(qua_err))              */
+)
+{
+    Word16 i;
+
+    for (i = 3; i > 0; i--)
+    {
+        st->past_qua_en[i] = st->past_qua_en[i - 1];             move16 ();
+        st->past_qua_en_MR122[i] = st->past_qua_en_MR122[i - 1]; move16 ();
+    }
+
+    st->past_qua_en_MR122[0] = qua_ener_MR122;  /*    log2 (qua_err), Q10 */
+	                                                             move16 ();
+    st->past_qua_en[0] = qua_ener;              /* 20*log10(qua_err), Q10 */
+	                                                             move16 ();
+}
+
+/*************************************************************************
+ *
+ * FUNCTION:  gc_pred_average_limited()
+ *
+ * PURPOSE: get average of MA predictor state values (with a lower limit)
+ *          [used in error concealment]
+ *
+ *************************************************************************/
+void gc_pred_average_limited(
+    gc_predState *st,       /* i: State struct                    */
+    Word16 *ener_avg_MR122, /* o: everaged quantized energy,  Q10 */
+                            /*    (log2(qua_err))                 */
+    Word16 *ener_avg        /* o: averaged quantized energy,  Q10 */
+                            /*    (20*log10(qua_err))             */
+)
+{
+    Word16 av_pred_en;
+    Word16 i;
+
+    /* do average in MR122 mode (log2() domain) */
+    av_pred_en = 0;                                        move16 ();
+    for (i = 0; i < NPRED; i++)
+    {
+        av_pred_en = add (av_pred_en, st->past_qua_en_MR122[i]);
+    }
+
+    /* av_pred_en = 0.25*av_pred_en */
+    av_pred_en = mult (av_pred_en, 8192);
+
+    /* if (av_pred_en < -14/(20Log10(2))) av_pred_en = .. */
+    test ();
+    if (sub (av_pred_en, MIN_ENERGY_MR122) < 0)
+    {
+        av_pred_en = MIN_ENERGY_MR122;                     move16 ();
+    }
+    *ener_avg_MR122 = av_pred_en;                          move16 ();
+
+    /* do average for other modes (20*log10() domain) */
+    av_pred_en = 0;                                        move16 ();
+    for (i = 0; i < NPRED; i++)
+    {
+        av_pred_en = add (av_pred_en, st->past_qua_en[i]);
+    }
+
+    /* av_pred_en = 0.25*av_pred_en */
+    av_pred_en = mult (av_pred_en, 8192);
+
+    /* if (av_pred_en < -14) av_pred_en = .. */
+    test ();
+    if (sub (av_pred_en, MIN_ENERGY) < 0)
+    {
+        av_pred_en = MIN_ENERGY;                           move16 ();
+    }
+    *ener_avg = av_pred_en;                                move16 ();
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/gc_pred.h FFMpeg-20050127-new/libavcodec/amr/gc_pred.h
--- FFMpeg-20050127/libavcodec/amr/gc_pred.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/gc_pred.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,124 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : gc_pred.h
+*      Purpose          : codebook gain MA prediction
+*
+********************************************************************************
+*/
+
+#ifndef gc_pred_h
+#define gc_pred_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+typedef struct {
+   Word16 past_qua_en[4];         /* normal MA predictor memory,         Q10 */
+                                  /* (contains 20*log10(qua_err))            */
+   Word16 past_qua_en_MR122[4];   /* MA predictor memory for MR122 mode, Q10 */
+                                  /* (contains log2(qua_err))                */
+} gc_predState;
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+int gc_pred_init (gc_predState **st);
+/* initialize one instance of codebook gain MA predictor
+   Stores pointer to state struct in *st. This pointer has to
+   be passed to gc_pred in each call.
+   returns 0 on success
+ */
+ 
+int gc_pred_reset (gc_predState *st);
+/* reset of codebook gain MA predictor state (i.e. set state memory to zero)
+   returns 0 on success
+ */
+void gc_pred_exit (gc_predState **st);
+/* de-initialize codebook gain MA predictor state (i.e. free state struct)
+   stores NULL in *st
+ */
+
+void
+gc_pred_copy(
+    gc_predState *st_src,  /* i : State struct                           */
+    gc_predState *st_dest  /* o : State struct                           */
+);
+
+/*************************************************************************
+ *
+ * FUNCTION:  gc_pred()
+ *
+ * PURPOSE: MA prediction of the innovation energy
+ *          (in dB/(20*log10(2))) with mean  removed).
+ *
+ *************************************************************************/
+void gc_pred(
+    gc_predState *st,   /* i/o: State struct                           */
+    enum Mode mode,     /* i  : AMR mode                               */
+    Word16 *code,       /* i  : innovative codebook vector (L_SUBFR)   */
+                        /*      MR122: Q12, other modes: Q13           */
+    Word16 *exp_gcode0, /* o  : exponent of predicted gain factor, Q0  */
+    Word16 *frac_gcode0,/* o  : fraction of predicted gain factor  Q15 */
+    Word16 *exp_en,     /* o  : exponent of innovation energy,     Q0  */
+                        /*      (only calculated for MR795)            */
+    Word16 *frac_en     /* o  : fraction of innovation energy,     Q15 */
+                        /*      (only calculated for MR795)            */
+);
+
+/*************************************************************************
+ *
+ * FUNCTION:  gc_pred_update()
+ *
+ * PURPOSE: update MA predictor with last quantized energy
+ *
+ *************************************************************************/
+void gc_pred_update(
+    gc_predState *st,      /* i/o: State struct                     */
+    Word16 qua_ener_MR122, /* i  : quantized energy for update, Q10 */
+                           /*      (log2(qua_err))                  */
+    Word16 qua_ener        /* i  : quantized energy for update, Q10 */
+                           /*      (20*log10(qua_err))              */
+);
+
+/*************************************************************************
+ *
+ * FUNCTION:  gc_pred_average_limited()
+ *
+ * PURPOSE: get average of MA predictor state values (with a lower limit)
+ *          [used in error concealment]
+ *
+ *************************************************************************/
+void gc_pred_average_limited(
+    gc_predState *st,       /* i: State struct                    */
+    Word16 *ener_avg_MR122, /* o: averaged quantized energy,  Q10 */
+                            /*    (log2(qua_err))                 */
+    Word16 *ener_avg        /* o: averaged quantized energy,  Q10 */
+                            /*    (20*log10(qua_err))             */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/gmed_n.c FFMpeg-20050127-new/libavcodec/amr/gmed_n.c
--- FFMpeg-20050127/libavcodec/amr/gmed_n.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/gmed_n.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,93 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : gmed_n.c
+*      Purpose          : calculates N-point median.
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "gmed_n.h"
+const char gmed_n_id[] = "@(#)$Id $" gmed_n_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+ 
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+#define NMAX 9  /* largest N used in median calculation */
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:   gmed_n
+ *
+ *  PURPOSE:    calculates N-point median.
+ *
+ *  DESCRIPTION:
+ *             
+ *************************************************************************/
+
+Word16 gmed_n (   /* o : index of the median value (0...N-1)      */
+    Word16 ind[], /* i : Past gain values                         */
+    Word16 n      /* i : The number of gains; this routine        */
+                  /*     is only valid for a odd number of gains  */
+                  /*     (n <= NMAX)                              */
+)
+{
+    Word16 i, j, ix = 0;
+    Word16 max;
+    Word16 medianIndex;
+    Word16 tmp[NMAX];
+    Word16 tmp2[NMAX];
+
+    for (i = 0; i < n; i++)
+    {
+        tmp2[i] = ind[i];                                      move16 (); 
+    }
+
+    for (i = 0; i < n; i++)
+    {
+        max = -32767;                                          move16 (); 
+        for (j = 0; j < n; j++)
+        {
+            test (); 
+            if (sub (tmp2[j], max) >= 0)
+            {
+                max = tmp2[j];                                 move16 (); 
+                ix = j;                                        move16 (); 
+            }
+        }
+        tmp2[ix] = -32768;                                     move16 (); 
+        tmp[i] = ix;                                           move16 (); 
+    }
+
+    medianIndex=tmp[ shr(n,1) ]; move16 (); /* account for complex addressing */
+    return (ind[medianIndex]);                                     
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/gmed_n.h FFMpeg-20050127-new/libavcodec/amr/gmed_n.h
--- FFMpeg-20050127/libavcodec/amr/gmed_n.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/gmed_n.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,43 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : gmed_n.h
+*      Purpose          : calculates N-point median.
+*
+********************************************************************************
+*/
+#ifndef gmed_n_h
+#define gmed_n_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+Word16 gmed_n (   /* o : index of the median value (0...N-1)      */
+    Word16 ind[], /* i : Past gain values                         */
+    Word16 n      /* i : The number of gains; this routine        */
+                  /*     is only valid for a odd number of gains  */ 
+);
+
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/gray.tab FFMpeg-20050127-new/libavcodec/amr/gray.tab
--- FFMpeg-20050127/libavcodec/amr/gray.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/gray.tab	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,19 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : gray.tab
+*      Purpose          : gray encoding and decoding tables
+*      $Id $
+*
+*
+********************************************************************************
+*/
+
+static const Word16 gray[8]  = {0, 1, 3, 2, 6, 4, 5, 7};
+static const Word16 dgray[8] = {0, 1, 3, 2, 5, 6, 4, 7};
diff -Nur FFMpeg-20050127/libavcodec/amr/grid.tab FFMpeg-20050127-new/libavcodec/amr/grid.tab
--- FFMpeg-20050127/libavcodec/amr/grid.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/grid.tab	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,41 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : pow2.c
+*      Purpose          : Table for az_lsf()
+*      $Id $
+*
+********************************************************************************
+*/
+/*-------------------------------------------------------------*
+ *  Table for az_lsf()                                         *
+ *                                                             *
+ * grid[0] = 1.0;                                              *
+ * grid[grid_points+1] = -1.0;                                 *
+ * for (i = 1; i < grid_points; i++)                           *
+ *   grid[i] = cos((6.283185307*i)/(2.0*grid_points));         *
+ *                                                             *
+ *-------------------------------------------------------------*/
+
+#define grid_points 60
+
+static const Word16 grid[grid_points + 1] =
+{
+    32760, 32723, 32588, 32364, 32051, 31651,
+    31164, 30591, 29935, 29196, 28377, 27481,
+    26509, 25465, 24351, 23170, 21926, 20621,
+    19260, 17846, 16384, 14876, 13327, 11743,
+    10125, 8480, 6812, 5126, 3425, 1714,
+    0, -1714, -3425, -5126, -6812, -8480,
+    -10125, -11743, -13327, -14876, -16384, -17846,
+    -19260, -20621, -21926, -23170, -24351, -25465,
+    -26509, -27481, -28377, -29196, -29935, -30591,
+    -31164, -31651, -32051, -32364, -32588, -32723,
+    -32760
+};
diff -Nur FFMpeg-20050127/libavcodec/amr/hp_max.c FFMpeg-20050127-new/libavcodec/amr/hp_max.c
--- FFMpeg-20050127/libavcodec/amr/hp_max.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/hp_max.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,123 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : hp_max.c
+*      Purpose          : Find the maximum correlation of scal_sig[] in a given
+*                         delay range.
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "hp_max.h"
+const char hp_max_id[] = "@(#)$Id $" hp_max_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+Word16 hp_max (  
+    Word32 corr[],      /* i   : correlation vector.                      */
+    Word16 scal_sig[],  /* i   : scaled signal.                           */
+    Word16 L_frame,     /* i   : length of frame to compute pitch         */
+    Word16 lag_max,     /* i   : maximum lag                              */
+    Word16 lag_min,     /* i   : minimum lag                              */
+    Word16 *cor_hp_max) /* o   : max high-pass filtered norm. correlation */
+{
+    Word16 i;
+    Word16 *p, *p1;
+    Word32 max, t0, t1;
+    Word16 max16, t016, cor_max;
+    Word16 shift, shift1, shift2;
+    
+    max = MIN_32;               move32 (); 
+    t0 = 0L;                    move32 ();    
+   
+    for (i = lag_max-1; i > lag_min; i--)
+    {
+       /* high-pass filtering */
+       t0 = L_sub (L_sub(L_shl(corr[-i], 1), corr[-i-1]), corr[-i+1]);   
+       t0 = L_abs (t0);
+       
+       test (); 
+       if (L_sub (t0, max) >= 0)
+       {
+          max = t0;             move32 (); 
+       }
+    }
+
+    /* compute energy */
+    p = scal_sig;               move16 (); 
+    p1 = &scal_sig[0];          move16 (); 
+    t0 = 0L;                    move32 (); 
+    for (i = 0; i < L_frame; i++, p++, p1++)
+    {
+       t0 = L_mac (t0, *p, *p1);
+    }
+
+    p = scal_sig;               move16 (); 
+    p1 = &scal_sig[-1];         move16 (); 
+    t1 = 0L;                    move32 (); 
+    for (i = 0; i < L_frame; i++, p++, p1++)
+    {
+       t1 = L_mac (t1, *p, *p1);
+    }
+    
+    /* high-pass filtering */
+    t0 = L_sub(L_shl(t0, 1), L_shl(t1, 1));
+    t0 = L_abs (t0);
+
+    /* max/t0 */
+    shift1 = sub(norm_l(max), 1);                 
+    max16  = extract_h(L_shl(max, shift1));       
+    shift2 = norm_l(t0);                          
+    t016 =  extract_h(L_shl(t0, shift2));         
+
+    test ();
+    if (t016 != 0)
+    {
+       cor_max = div_s(max16, t016);              
+    }
+    else
+    {
+       cor_max = 0;                                move16 ();
+    }
+    
+    shift = sub(shift1, shift2);       
+
+    test ();
+    if (shift >= 0)
+    {
+       *cor_hp_max = shr(cor_max, shift);          move16 (); /* Q15 */
+    }
+    else
+    {
+       *cor_hp_max = shl(cor_max, negate(shift));  move16 (); /* Q15 */
+    }
+
+    return 0;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/hp_max.h FFMpeg-20050127-new/libavcodec/amr/hp_max.h
--- FFMpeg-20050127/libavcodec/amr/hp_max.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/hp_max.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,53 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : hp_max.h
+*      Purpose          : Find the maximum correlation of scal_sig[] in a given
+*                         delay range.
+*
+********************************************************************************
+*/
+#ifndef hp_max_h
+#define hp_max_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  hp_max
+ *
+ *  PURPOSE: Find the maximum high-pass filtered correlation of
+ *           signal scal_sig[] in a given delay range.
+ *
+ *  DESCRIPTION:
+ *      The correlation is given by
+ *           corr[t] = <scal_sig[n],scal_sig[n-t]>,  t=lag_min,...,lag_max
+ *      The functions outputs the maximum high-pass filtered correlation
+ *      after normalization.
+ *
+ *************************************************************************/
+Word16 hp_max (   
+    Word32 corr[],      /* i   : correlation vector.                      */
+    Word16 scal_sig[],  /* i   : scaled signal.                           */
+    Word16 L_frame,     /* i   : length of frame to compute pitch         */
+    Word16 lag_max,     /* i   : maximum lag                              */
+    Word16 lag_min,     /* i   : minimum lag                              */
+    Word16 *cor_hp_max  /* o   : max high-pass filtered norm. correlation */
+    );
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/int_lpc.c FFMpeg-20050127-new/libavcodec/amr/int_lpc.c
--- FFMpeg-20050127/libavcodec/amr/int_lpc.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/int_lpc.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,256 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : int_lpc.c
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "int_lpc.h"
+const char int_lpc_id[] = "@(#)$Id $" int_lpc_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+#include "lsp_az.h" 
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+/*
+*--------------------------------------*
+* Constants (defined in cnst.h)        *
+*--------------------------------------*
+*  M         : LPC order               *
+*  MP1       : LPC order + 1           *
+*--------------------------------------*
+*/
+ 
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : Int_lpc_1and3
+*  Purpose     : Interpolates the LSPs and converts to LPC parameters 
+*                to get a different LP filter in each subframe.
+*  Description : The 20 ms speech frame is divided into 4 subframes.
+*                The LSPs are quantized and transmitted at the 2nd and 
+*                4th subframes (twice per frame) and interpolated at the
+*                1st and 3rd subframe.
+*
+*                      |------|------|------|------|
+*                         sf1    sf2    sf3    sf4
+*                   F0            Fm            F1
+*      
+*                 sf1:   1/2 Fm + 1/2 F0         sf3:   1/2 F1 + 1/2 Fm
+*                 sf2:       Fm                  sf4:       F1
+*  Returns     : void
+*
+**************************************************************************
+*/
+void Int_lpc_1and3 (
+    Word16 lsp_old[],  /* i : LSP vector at the 4th subfr. of past frame (M) */
+    Word16 lsp_mid[],  /* i : LSP vector at the 2nd subfr. of
+                              present frame (M)                              */
+    Word16 lsp_new[],  /* i : LSP vector at the 4th subfr. of
+                              present frame (M)                              */
+    Word16 Az[]        /* o : interpolated LP parameters in all subfr.
+                              (AZ_SIZE)                                      */
+)
+{
+    Word16 i;
+    Word16 lsp[M];
+
+    /*  lsp[i] = lsp_mid[i] * 0.5 + lsp_old[i] * 0.5 */
+
+    for (i = 0; i < M; i++)
+    {
+        lsp[i] = add (shr (lsp_mid[i], 1), shr (lsp_old[i], 1));
+                                move16 (); 
+    }
+
+    Lsp_Az (lsp, Az);           /* Subframe 1 */
+    Az += MP1;                  move16 (); 
+
+    Lsp_Az (lsp_mid, Az);       /* Subframe 2 */
+    Az += MP1;                  move16 (); 
+
+    for (i = 0; i < M; i++)
+    {
+        lsp[i] = add (shr (lsp_mid[i], 1), shr (lsp_new[i], 1));
+                                move16 (); 
+    }
+
+    Lsp_Az (lsp, Az);           /* Subframe 3 */
+    Az += MP1;                  move16 (); 
+
+    Lsp_Az (lsp_new, Az);       /* Subframe 4 */
+
+    return;
+}
+
+/*
+**************************************************************************
+*
+*  Function    : Int_lpc_1and3_2
+*  Purpose     : Interpolation of the LPC parameters. Same as the Int_lpc
+*                function but we do not recompute Az() for subframe 2 and
+*                4 because it is already available.
+*  Returns     : void
+*
+**************************************************************************
+*/
+void Int_lpc_1and3_2 (
+    Word16 lsp_old[],  /* i : LSP vector at the 4th subfr. of past frame (M) */
+    Word16 lsp_mid[],  /* i : LSP vector at the 2nd subframe of
+                             present frame (M)                                  */
+    Word16 lsp_new[],  /* i : LSP vector at the 4th subframe of
+                             present frame (M)                                  */
+    Word16 Az[]        /* o :interpolated LP parameters
+                             in subframes 1 and 3 (AZ_SIZE)                     */
+)
+{
+    Word16 i;
+    Word16 lsp[M];
+
+    /*  lsp[i] = lsp_mid[i] * 0.5 + lsp_old[i] * 0.5 */
+
+    for (i = 0; i < M; i++)
+    {
+        lsp[i] = add (shr (lsp_mid[i], 1), shr (lsp_old[i], 1));
+                                move16 (); 
+    }
+    Lsp_Az (lsp, Az);           /* Subframe 1 */
+    Az += MP1 * 2;              move16 (); 
+
+    for (i = 0; i < M; i++)
+    {
+        lsp[i] = add (shr (lsp_mid[i], 1), shr (lsp_new[i], 1));
+                                move16 (); 
+    }
+    Lsp_Az (lsp, Az);           /* Subframe 3 */
+
+    return;
+}
+/*************************************************************************
+ *
+ *  FUNCTION:  Int_lpc_1to3()
+ *
+ *  PURPOSE:  Interpolates the LSPs and convert to LP parameters to get
+ *            a different LP filter in each subframe.
+ *
+ *  DESCRIPTION:
+ *     The 20 ms speech frame is divided into 4 subframes.
+ *     The LSPs are quantized and transmitted at the 4th subframe
+ *     (once per frame) and interpolated at the 1st, 2nd and 3rd subframe.
+ *
+ *          |------|------|------|------|
+ *             sf1    sf2    sf3    sf4
+ *       F0                          F1
+ *
+ *     sf1:   3/4 F0 + 1/4 F1         sf3:   1/4 F0 + 3/4 F1
+ *     sf2:   1/2 F0 + 1/2 F1         sf4:       F1
+ *
+ *************************************************************************/
+void Int_lpc_1to3(
+    Word16 lsp_old[], /* input : LSP vector at the 4th SF of past frame    */
+    Word16 lsp_new[], /* input : LSP vector at the 4th SF of present frame */
+    Word16 Az[]       /* output: interpolated LP parameters in all SFs     */
+)
+{
+    Word16 i;
+    Word16 lsp[M];
+
+    for (i = 0; i < M; i++) {
+        lsp[i] = add(shr(lsp_new[i], 2), sub(lsp_old[i], shr(lsp_old[i], 2)));
+		                    move16 ();
+    }
+
+    Lsp_Az(lsp, Az);        /* Subframe 1 */
+    Az += MP1;              move16 (); 
+
+
+    for (i = 0; i < M; i++) {
+        lsp[i] = add(shr(lsp_old[i], 1), shr(lsp_new[i], 1));
+		                    move16 ();
+    }
+
+    Lsp_Az(lsp, Az);        /* Subframe 2 */
+    Az += MP1;              move16 ();
+
+    for (i = 0; i < M; i++) {
+        lsp[i] = add(shr(lsp_old[i], 2), sub(lsp_new[i], shr(lsp_new[i], 2)));
+		                    move16 ();
+    }
+
+    Lsp_Az(lsp, Az);       /* Subframe 3 */
+    Az += MP1;              move16 ();
+
+    Lsp_Az(lsp_new, Az);        /* Subframe 4 */
+
+    return;
+}
+
+/*************************************************************************
+ * Function Int_lpc_1to3_2()
+ * Interpolation of the LPC parameters.
+ * Same as the previous function but we do not recompute Az() for
+ * subframe 4 because it is already available.
+ *************************************************************************/
+
+void Int_lpc_1to3_2(
+     Word16 lsp_old[],  /* input : LSP vector at the 4th SF of past frame    */
+     Word16 lsp_new[],  /* input : LSP vector at the 4th SF of present frame */
+     Word16 Az[]        /* output: interpolated LP parameters in SFs 1,2,3   */
+)
+{
+    Word16 i;
+    Word16 lsp[M];
+
+    for (i = 0; i < M; i++) {
+        lsp[i] = add(shr(lsp_new[i], 2), sub(lsp_old[i], shr(lsp_old[i], 2)));
+		                    move16 ();
+    }
+
+    Lsp_Az(lsp, Az);        /* Subframe 1 */
+    Az += MP1;              move16 ();
+
+    for (i = 0; i < M; i++) {
+        lsp[i] = add(shr(lsp_old[i], 1), shr(lsp_new[i], 1));
+		                    move16 ();
+    }
+
+    Lsp_Az(lsp, Az);        /* Subframe 2 */
+    Az += MP1;              move16 ();
+
+    for (i = 0; i < M; i++) {
+        lsp[i] = add(shr(lsp_old[i], 2), sub(lsp_new[i], shr(lsp_new[i], 2)));
+		                    move16 ();
+    }
+
+    Lsp_Az(lsp, Az);        /* Subframe 3 */
+
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/int_lpc.h FFMpeg-20050127-new/libavcodec/amr/int_lpc.h
--- FFMpeg-20050127/libavcodec/amr/int_lpc.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/int_lpc.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,133 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : int_lpc.h
+*      Purpose          : Interpolates the LSPs and converts to LPC parameters 
+*
+********************************************************************************
+*/
+#ifndef int_lpc_h
+#define int_lpc_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : Int_lpc_1and3
+*  Purpose     : Interpolates the LSPs and converts to LPC parameters 
+*                to get a different LP filter in each subframe.
+*  Description : The 20 ms speech frame is divided into 4 subframes.
+*                The LSPs are quantized and transmitted at the 2nd and 
+*                4th subframes (twice per frame) and interpolated at the
+*                1st and 3rd subframe.
+*
+*                      |------|------|------|------|
+*                         sf1    sf2    sf3    sf4
+*                   F0            Fm            F1
+*      
+*                 sf1:   1/2 Fm + 1/2 F0         sf3:   1/2 F1 + 1/2 Fm
+*                 sf2:       Fm                  sf4:       F1
+*  Returns     : void
+*
+**************************************************************************
+*/
+void Int_lpc_1and3 (
+    Word16 lsp_old[],  /* i : LSP vector at the 4th subfr. of past frame (M) */
+    Word16 lsp_mid[],  /* i : LSP vector at the 2nd subfr. of
+                              present frame (M)                              */
+    Word16 lsp_new[],  /* i : LSP vector at the 4th subfr. of
+                              present frame (M)                              */
+    Word16 Az[]        /* o : interpolated LP parameters in all subfr.
+                              (AZ_SIZE)                                      */
+);
+
+/*
+**************************************************************************
+*
+*  Function    : Int_lpc_1and3_2
+*  Purpose     : Interpolation of the LPC parameters. Same as the Int_lpc
+*                function but we do not recompute Az() for subframe 2 and
+*                4 because it is already available.
+*  Returns     : void
+*
+**************************************************************************
+*/
+void Int_lpc_1and3_2 (
+    Word16 lsp_old[],  /* i : LSP vector at the 4th subfr. of past frame (M) */
+    Word16 lsp_mid[],  /* i : LSP vector at the 2nd subframe of
+                             present frame (M)                                  */
+    Word16 lsp_new[],  /* i : LSP vector at the 4th subframe of
+                             present frame (M)                                  */
+    Word16 Az[]        /* o :interpolated LP parameters
+                             in subframes 1 and 3 (AZ_SIZE)                     */
+);
+
+/*
+**************************************************************************
+*
+*  Function    : Int_lpc_1to3
+*  Purpose     : Interpolates the LSPs and converts to LPC parameters 
+*                to get a different LP filter in each subframe.
+*  Description : The 20 ms speech frame is divided into 4 subframes.
+*                The LSPs are quantized and transmitted at the 4th 
+*                subframes (once per frame) and interpolated at the
+*                1st, 2nd and 3rd subframe.
+*
+*                      |------|------|------|------|
+*                         sf1    sf2    sf3    sf4
+*                   F0                          F1
+*      
+*                 sf1:   3/4 F0 + 1/4 F1         sf3:   1/4 F0 + 3/4 F1
+*                 sf2:   1/2 F0 + 1/2 F1         sf4:       F1
+*  Returns     : void
+*
+**************************************************************************
+*/
+void Int_lpc_1to3 (
+    Word16 lsp_old[], /* i : LSP vector at the 4th SF of past frame (M)      */
+    Word16 lsp_new[], /* i : LSP vector at the 4th SF of present frame (M)   */
+    Word16 Az[]       /* o : interpolated LP parameters in all SFs (AZ_SIZE) */
+);
+ 
+/*
+**************************************************************************
+*
+*  Function    : Int_lpc_1to3_2
+*  Purpose     : Interpolation of the LPC parameters. Same as the Int_lpc
+*                function but we do not recompute Az() for subframe 4
+*                because it is already available.
+*  Returns     : void
+*
+**************************************************************************
+*/
+void Int_lpc_1to3_2 (
+    Word16 lsp_old[],  /* i : LSP vector at the 4th SF of past frame (M) */
+    Word16 lsp_new[],  /* i : LSP vector at the 4th SF present frame (M) */
+    Word16 Az[]        /* o :interpolated LP parameters in SFs 1, 2, 3 
+                             (AZ_SIZE)                                   */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/int_lsf.c FFMpeg-20050127-new/libavcodec/amr/int_lsf.c
--- FFMpeg-20050127/libavcodec/amr/int_lsf.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/int_lsf.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,112 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : int_lsf.c
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "int_lsf.h"
+const char int_lsf_id[] = "@(#)$Id $" int_lsf_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+/*
+*--------------------------------------*
+* Constants (defined in cnst.h)        *
+*--------------------------------------*
+*  M         : LSF order               *
+*--------------------------------------*
+*/
+ 
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+
+/*
+**************************************************************************
+*
+*  Function    : Int_lsf
+*  Purpose     : Interpolates the LSFs for selected subframe
+*  Description : The 20 ms speech frame is divided into 4 subframes.
+*                The LSFs are interpolated at the 1st, 2nd and 3rd
+*                subframe and only forwarded at the 4th subframe.
+*
+*                      |------|------|------|------|
+*                         sf1    sf2    sf3    sf4
+*                   F0                          F1
+*      
+*                 sf1:   3/4 F0 + 1/4 F1         sf3:   1/4 F0 + 3/4 F1
+*                 sf2:   1/2 F0 + 1/2 F1         sf4:       F1
+*  Returns     : void
+*
+**************************************************************************
+*/
+void Int_lsf(
+    Word16 lsf_old[], /* i : LSF vector at the 4th SF of past frame          */
+    Word16 lsf_new[], /* i : LSF vector at the 4th SF of present frame       */
+    Word16 i_subfr,   /* i : Pointer to current sf (equal to 0,40,80 or 120) */
+    Word16 lsf_out[]  /* o : interpolated LSF parameters for current sf      */
+)
+{
+    Word16 i;
+
+    if ( i_subfr == 0 )
+    {
+       test ();          
+       for (i = 0; i < M; i++) {
+          lsf_out[i] = add(sub(lsf_old[i], shr(lsf_old[i], 2)), shr(lsf_new[i], 2));
+          move16 ();
+       }
+    }
+    else if ( sub(i_subfr, 40) == 0 )
+    {
+       test (); test ();
+       for (i = 0; i < M; i++) {
+          lsf_out[i] = add(shr(lsf_old[i],1), shr(lsf_new[i], 1) );
+          move16 ();
+       }
+    }
+    else if ( sub(i_subfr, 80) == 0 )
+    {
+       test (); test (); test ();
+       for (i = 0; i < M; i++) {
+          lsf_out[i] = add(shr(lsf_old[i], 2), sub(lsf_new[i], shr(lsf_new[i], 2)));
+          move16 ();
+       }
+    }
+    else if ( sub(i_subfr, 120) == 0 )
+    {
+       test (); test (); test (); test ();                    
+       for (i = 0; i < M; i++) {
+          lsf_out[i] = lsf_new[i];                        move16 ();
+       }
+    }
+
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/int_lsf.h FFMpeg-20050127-new/libavcodec/amr/int_lsf.h
--- FFMpeg-20050127/libavcodec/amr/int_lsf.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/int_lsf.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,63 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : int_lsf.h
+*      Purpose          : Interpolates the LSFs
+*
+********************************************************************************
+*/
+#ifndef int_lsf_h
+#define int_lsf_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+
+/*
+**************************************************************************
+*
+*  Function    : Int_lsf
+*  Purpose     : Interpolates the LSFs for selected subframe
+*  Description : The 20 ms speech frame is divided into 4 subframes.
+*                The LSFs are interpolated at the 1st, 2nd and 3rd
+*                subframe and only forwarded at the 4th subframe.
+*
+*                      |------|------|------|------|
+*                         sf1    sf2    sf3    sf4
+*                   F0                          F1
+*      
+*                 sf1:   3/4 F0 + 1/4 F1         sf3:   1/4 F0 + 3/4 F1
+*                 sf2:   1/2 F0 + 1/2 F1         sf4:       F1
+*  Returns     : void
+*
+**************************************************************************
+*/
+void Int_lsf (
+    Word16 lsf_old[], /* i : LSF vector at the 4th SF of past frame          */
+    Word16 lsf_new[], /* i : LSF vector at the 4th SF of present frame       */
+    Word16 i_subfr,   /* i : Pointer to current sf (equal to 0,40,80 or 120) */
+    Word16 lsf_out[]  /* o : interpolated LSF parameters for current sf      */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/inter_36.c FFMpeg-20050127-new/libavcodec/amr/inter_36.c
--- FFMpeg-20050127/libavcodec/amr/inter_36.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/inter_36.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,93 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : inter_36.c
+*      Purpose          : Interpolating the normalized correlation
+*                       : with 1/3 or 1/6 resolution.
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "inter_36.h"
+const char inter_36_id[] = "@(#)$Id $" inter_36_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#define UP_SAMP_MAX  6
+
+#include "inter_36.tab"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  Interpol_3or6()
+ *
+ *  PURPOSE:  Interpolating the normalized correlation with 1/3 or 1/6
+ *            resolution.
+ *
+ *************************************************************************/
+Word16 Interpol_3or6 (  /* o : interpolated value                        */
+    Word16 *x,          /* i : input vector                              */
+    Word16 frac,        /* i : fraction  (-2..2 for 3*, -3..3 for 6*)    */
+    Word16 flag3        /* i : if set, upsampling rate = 3 (6 otherwise) */
+)
+{
+    Word16 i, k;
+    Word16 *x1, *x2;
+    const Word16 *c1, *c2;
+    Word32 s;
+
+    test();
+    if (flag3 != 0)
+    {
+      frac = shl (frac, 1);   /* inter_3[k] = inter_6[2*k] -> k' = 2*k */
+    }
+    
+    test (); 
+    if (frac < 0)
+    {
+        frac = add (frac, UP_SAMP_MAX);
+        x--;
+    }
+    
+    x1 = &x[0];                         move16 (); 
+    x2 = &x[1];                         move16 (); 
+    c1 = &inter_6[frac];                move16 (); 
+    c2 = &inter_6[sub (UP_SAMP_MAX, frac)]; move16 (); 
+
+    s = 0;                              move32 (); 
+    for (i = 0, k = 0; i < L_INTER_SRCH; i++, k += UP_SAMP_MAX)
+    {
+        s = L_mac (s, x1[-i], c1[k]);
+        s = L_mac (s, x2[i], c2[k]);
+    }
+
+    return round (s);
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/inter_36.h FFMpeg-20050127-new/libavcodec/amr/inter_36.h
--- FFMpeg-20050127/libavcodec/amr/inter_36.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/inter_36.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,43 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : inter_36.h
+*      Purpose          : Interpolating the normalized correlation
+*                       : with 1/3 or 1/6 resolution.
+*
+********************************************************************************
+*/
+#ifndef inter_36_h
+#define inter_36_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+Word16 Interpol_3or6 (  /* (o)  : interpolated value                        */
+    Word16 *x,          /* (i)  : input vector                              */
+    Word16 frac,        /* (i)  : fraction  (-2..2 for 3*, -3..3 for 6*)    */
+    Word16 flag3        /* (i)  : if set, upsampling rate = 3 (6 otherwise) */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/inter_36.tab FFMpeg-20050127-new/libavcodec/amr/inter_36.tab
--- FFMpeg-20050127/libavcodec/amr/inter_36.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/inter_36.tab	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,34 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : inter_36.tab
+*      Purpose          : Tables for interpolating the normalized correlation 
+*                         with 1/3 or 1/6 resolution.
+*      $Id $
+*
+********************************************************************************
+*/
+#define FIR_SIZE     (UP_SAMP_MAX*L_INTER_SRCH+1)
+
+/* 1/6 resolution interpolation filter  (-3 dB at 3600 Hz) */
+/* Note: The IS641 (7.4) 1/3 resolution filter is simply a subsampled
+         version of the 1/6 resolution filter, i.e. it uses
+         every second coefficient:
+         
+         inter_3[k] = inter_6[2*k], 0 <= k <= 3*L_INTER_SRCH
+ */
+
+static const Word16 inter_6[FIR_SIZE] =
+{
+    29519,
+    28316, 24906, 19838, 13896, 7945, 2755,
+    -1127, -3459, -4304, -3969, -2899, -1561,
+    -336, 534, 970, 1023, 823, 516,
+    220, 0, -131, -194, -215, 0
+};
diff -Nur FFMpeg-20050127/libavcodec/amr/inv_sqrt.c FFMpeg-20050127-new/libavcodec/amr/inv_sqrt.c
--- FFMpeg-20050127/libavcodec/amr/inv_sqrt.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/inv_sqrt.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,97 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : inv_sqrt.c
+*      Purpose          : Computes 1/sqrt(L_x),  where  L_x is positive.
+*                       : If L_x is negative or zero, 
+*                       : the result is 1 (3fff ffff).
+*      Description      :
+*            The function 1/sqrt(L_x) is approximated by a table and linear
+*            interpolation. The inverse square root is computed using the
+*            following steps:
+*                1- Normalization of L_x.
+*                2- If (30-exponent) is even then shift right once.
+*                3- exponent = (30-exponent)/2  +1
+*                4- i = bit25-b31 of L_x;  16<=i<=63  because of normalization.
+*                5- a = bit10-b24
+*                6- i -=16
+*                7- L_y = table[i]<<16 - (table[i] - table[i+1]) * a * 2
+*                8- L_y >>= exponent
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "inv_sqrt.h"
+const char inv_sqrt_id[] = "@(#)$Id $" inv_sqrt_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#include "inv_sqrt.tab" /* Table for inv_sqrt() */
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+
+Word32 Inv_sqrt (       /* (o) : output value   */
+    Word32 L_x          /* (i) : input value    */
+)
+{
+    Word16 exp, i, a, tmp;
+    Word32 L_y;
+
+    test (); 
+    if (L_x <= (Word32) 0)
+        return ((Word32) 0x3fffffffL);
+
+    exp = norm_l (L_x);
+    L_x = L_shl (L_x, exp);     /* L_x is normalize */
+
+    exp = sub (30, exp);
+    test (); logic16 (); 
+    if ((exp & 1) == 0)         /* If exponent even -> shift right */
+    {
+        L_x = L_shr (L_x, 1);
+    }
+    exp = shr (exp, 1);
+    exp = add (exp, 1);
+
+    L_x = L_shr (L_x, 9);
+    i = extract_h (L_x);        /* Extract b25-b31 */
+    L_x = L_shr (L_x, 1);
+    a = extract_l (L_x);        /* Extract b10-b24 */
+    a = a & (Word16) 0x7fff;    logic16 (); 
+
+    i = sub (i, 16);
+
+    L_y = L_deposit_h (table[i]);       /* table[i] << 16          */
+    tmp = sub (table[i], table[i + 1]); /* table[i] - table[i+1])  */
+    L_y = L_msu (L_y, tmp, a);  /* L_y -=  tmp*a*2         */
+
+    L_y = L_shr (L_y, exp);     /* denormalization */
+
+    return (L_y);
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/inv_sqrt.h FFMpeg-20050127-new/libavcodec/amr/inv_sqrt.h
--- FFMpeg-20050127/libavcodec/amr/inv_sqrt.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/inv_sqrt.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,54 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : inv_sqrt.h
+*      Purpose          : Computes 1/sqrt(L_x),  where  L_x is positive.
+*                       : If L_x is negative or zero, the result is
+*                       : 1 (3fff ffff).
+*      Description      : The function 1/sqrt(L_x) is approximated by a table 
+*                       : and linear interpolation. The inverse square root is 
+*                       : computed using the following steps:
+*               1- Normalization of L_x.
+*               2- If (30-exponent) is even then shift right once.
+*               3- exponent = (30-exponent)/2  +1
+*               4- i = bit25-b31 of L_x;  16<=i<=63  because of normalization.
+*               5- a = bit10-b24
+*               6- i -=16
+*               7- L_y = table[i]<<16 - (table[i] - table[i+1]) * a * 2
+*               8- L_y >>= exponent
+*
+********************************************************************************
+*/
+#ifndef inv_sqrt_h
+#define inv_sqrt_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+ 
+Word32 Inv_sqrt (      /* (o) : output value   (range: 0<=val<1)            */
+    Word32 L_x           /* (i) : input value    (range: 0<=val<=7fffffff)    */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/inv_sqrt.tab FFMpeg-20050127-new/libavcodec/amr/inv_sqrt.tab
--- FFMpeg-20050127/libavcodec/amr/inv_sqrt.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/inv_sqrt.tab	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,24 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : inv_sqrt.tab
+*      Purpose          : Table for routine Inv_sqrt()
+*      $Id $
+*
+********************************************************************************
+*/
+static const Word16 table[49] =
+{
+
+    32767, 31790, 30894, 30070, 29309, 28602, 27945, 27330, 26755, 26214,
+    25705, 25225, 24770, 24339, 23930, 23541, 23170, 22817, 22479, 22155,
+    21845, 21548, 21263, 20988, 20724, 20470, 20225, 19988, 19760, 19539,
+    19326, 19119, 18919, 18725, 18536, 18354, 18176, 18004, 17837, 17674,
+    17515, 17361, 17211, 17064, 16921, 16782, 16646, 16514, 16384
+};
diff -Nur FFMpeg-20050127/libavcodec/amr/lag_wind.c FFMpeg-20050127-new/libavcodec/amr/lag_wind.c
--- FFMpeg-20050127/libavcodec/amr/lag_wind.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/lag_wind.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,73 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : lag_wind.c
+*      Purpose          : Lag windowing of autocorrelations.
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "lag_wind.h"
+const char lag_wind_id[] = "@(#)$Id $" lag_wind_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+ 
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#include "lag_wind.tab"     /* Table for Lag_Window() */
+ 
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  Lag_window()
+ *
+ *  PURPOSE:  Lag windowing of autocorrelations.
+ *
+ *  DESCRIPTION:
+ *         r[i] = r[i]*lag_wind[i],   i=1,...,10
+ *
+ *     r[i] and lag_wind[i] are in special double precision format.
+ *     See "oper_32b.c" for the format.
+ *
+ *************************************************************************/
+void Lag_window (
+    Word16 m,           /* (i)     : LPC order                        */
+    Word16 r_h[],       /* (i/o)   : Autocorrelations  (msb)          */
+    Word16 r_l[]        /* (i/o)   : Autocorrelations  (lsb)          */
+)
+{
+    Word16 i;
+    Word32 x;
+
+    for (i = 1; i <= m; i++)
+    {
+        x = Mpy_32 (r_h[i], r_l[i], lag_h[i - 1], lag_l[i - 1]);
+        L_Extract (x, &r_h[i], &r_l[i]);
+    }
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/lag_wind.h FFMpeg-20050127-new/libavcodec/amr/lag_wind.h
--- FFMpeg-20050127/libavcodec/amr/lag_wind.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/lag_wind.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,42 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : lag_wind.h
+*      Purpose          : Lag windowing of autocorrelations.
+*
+********************************************************************************
+*/
+#ifndef lag_wind_h
+#define lag_wind_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+void Lag_window (
+    Word16 m,          /* (i)    : LPC order                                */
+    Word16 r_h[],      /* (i/o)  : Autocorrelations  (msb)                  */
+    Word16 r_l[]       /* (i/o)  : Autocorrelations  (lsb)                  */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/lag_wind.tab FFMpeg-20050127-new/libavcodec/amr/lag_wind.tab
--- FFMpeg-20050127/libavcodec/amr/lag_wind.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/lag_wind.tab	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,62 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : lag_wind.tab
+*      Purpose          : Table of lag_window for autocorrelation.
+*      $Id $
+*
+********************************************************************************
+*/
+/*-----------------------------------------------------*
+ | Table of lag_window for autocorrelation.            |
+ |                                                     |
+ | noise floor = 1.0001   = (0.9999  on r[1] ..r[10])  |
+ | Bandwitdh expansion = 60 Hz                         |
+ |                                                     |
+ |                                                     |
+ | lag_wind[0] =  1.00000000    (not stored)           |
+ | lag_wind[1] =  0.99879038                           |
+ | lag_wind[2] =  0.99546897                           |
+ | lag_wind[3] =  0.98995781                           |
+ | lag_wind[4] =  0.98229337                           |
+ | lag_wind[5] =  0.97252619                           |
+ | lag_wind[6] =  0.96072036                           |
+ | lag_wind[7] =  0.94695264                           |
+ | lag_wind[8] =  0.93131179                           |
+ | lag_wind[9] =  0.91389757                           |
+ | lag_wind[10]=  0.89481968                           |
+ -----------------------------------------------------*/
+
+static const Word16 lag_h[10] =
+{
+    32728,
+    32619,
+    32438,
+    32187,
+    31867,
+    31480,
+    31029,
+    30517,
+    29946,
+    29321
+};
+
+static const Word16 lag_l[10] =
+{
+    11904,
+    17280,
+    30720,
+    25856,
+    24192,
+    28992,
+    24384,
+    7360,
+    19520,
+    14784
+};
diff -Nur FFMpeg-20050127/libavcodec/amr/levinson.c FFMpeg-20050127-new/libavcodec/amr/levinson.c
--- FFMpeg-20050127/libavcodec/amr/levinson.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/levinson.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,305 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : levinson.c
+*      Purpose          : Levinson-Durbin algorithm in double precision.
+*                       : To compute the LP filter parameters from the
+*                       : speech autocorrelations.
+*
+*****************************************************************************
+*/
+ 
+ 
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "levinson.h"
+const char levinson_id[] = "@(#)$Id $" levinson_h;
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "cnst.h"
+ 
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+/*---------------------------------------------------------------*
+ *    Constants (defined in "cnst.h")                            *
+ *---------------------------------------------------------------*
+ * M           : LPC order
+ *---------------------------------------------------------------*/
+ 
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+/*************************************************************************
+*
+*  Function:   Levinson_init
+*  Purpose:    Allocates state memory and initializes state memory
+*
+**************************************************************************
+*/
+int Levinson_init (LevinsonState **state)
+{
+  LevinsonState* s;
+ 
+  if (state == (LevinsonState **) NULL){
+      fprintf(stderr, "Levinson_init: invalid parameter\n");
+      return -1;
+  }
+  *state = NULL;
+ 
+  /* allocate memory */
+  if ((s= (LevinsonState *) malloc(sizeof(LevinsonState))) == NULL){
+      fprintf(stderr, "Levinson_init: can not malloc state structure\n");
+      return -1;
+  }
+  
+  Levinson_reset(s);
+  *state = s;
+  
+  return 0;
+}
+ 
+/*************************************************************************
+*
+*  Function:   Levinson_reset
+*  Purpose:    Initializes state memory to zero
+*
+**************************************************************************
+*/
+int Levinson_reset (LevinsonState *state)
+{
+  Word16 i;
+  
+  if (state == (LevinsonState *) NULL){
+      fprintf(stderr, "Levinson_reset: invalid parameter\n");
+      return -1;
+  }
+  
+  state->old_A[0] = 4096;
+  for(i = 1; i < M + 1; i++)
+      state->old_A[i] = 0;
+ 
+  return 0;
+}
+ 
+/*************************************************************************
+*
+*  Function:   Levinson_exit
+*  Purpose:    The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void Levinson_exit (LevinsonState **state)
+{
+  if (state == NULL || *state == NULL)
+      return;
+ 
+  /* deallocate memory */
+  free(*state);
+  *state = NULL;
+  
+  return;
+}
+ 
+/*************************************************************************
+ *
+ *   FUNCTION:  Levinson()
+ *
+ *   PURPOSE:  Levinson-Durbin algorithm in double precision. To compute the
+ *             LP filter parameters from the speech autocorrelations.
+ *
+ *   DESCRIPTION:
+ *       R[i]    autocorrelations.
+ *       A[i]    filter coefficients.
+ *       K       reflection coefficients.
+ *       Alpha   prediction gain.
+ *
+ *       Initialisation:
+ *               A[0] = 1
+ *               K    = -R[1]/R[0]
+ *               A[1] = K
+ *               Alpha = R[0] * (1-K**2]
+ *
+ *       Do for  i = 2 to M
+ *
+ *            S =  SUM ( R[j]*A[i-j] ,j=1,i-1 ) +  R[i]
+ *
+ *            K = -S / Alpha
+ *
+ *            An[j] = A[j] + K*A[i-j]   for j=1 to i-1
+ *                                      where   An[i] = new A[i]
+ *            An[i]=K
+ *
+ *            Alpha=Alpha * (1-K**2)
+ *
+ *       END
+ *
+ *************************************************************************/
+int Levinson (
+    LevinsonState *st,
+    Word16 Rh[],       /* i : Rh[m+1] Vector of autocorrelations (msb) */
+    Word16 Rl[],       /* i : Rl[m+1] Vector of autocorrelations (lsb) */
+    Word16 A[],        /* o : A[m]    LPC coefficients  (m = 10)       */
+    Word16 rc[]        /* o : rc[4]   First 4 reflection coefficients  */
+)
+{
+    Word16 i, j;
+    Word16 hi, lo;
+    Word16 Kh, Kl;                /* reflexion coefficient; hi and lo      */
+    Word16 alp_h, alp_l, alp_exp; /* Prediction gain; hi lo and exponent   */
+    Word16 Ah[M + 1], Al[M + 1];  /* LPC coef. in double prec.             */
+    Word16 Anh[M + 1], Anl[M + 1];/* LPC coef.for next iteration in double
+                                     prec. */
+    Word32 t0, t1, t2;            /* temporary variable                    */
+
+    /* K = A[1] = -R[1] / R[0] */
+
+    t1 = L_Comp (Rh[1], Rl[1]);
+    t2 = L_abs (t1);                    /* abs R[1]         */
+    t0 = Div_32 (t2, Rh[0], Rl[0]);     /* R[1]/R[0]        */
+    test (); 
+    if (t1 > 0)
+       t0 = L_negate (t0);             /* -R[1]/R[0]       */
+    L_Extract (t0, &Kh, &Kl);           /* K in DPF         */
+    
+    rc[0] = round (t0);                 move16 (); 
+
+    t0 = L_shr (t0, 4);                 /* A[1] in          */
+    L_Extract (t0, &Ah[1], &Al[1]);     /* A[1] in DPF      */
+
+    /*  Alpha = R[0] * (1-K**2) */
+
+    t0 = Mpy_32 (Kh, Kl, Kh, Kl);       /* K*K             */
+    t0 = L_abs (t0);                    /* Some case <0 !! */
+    t0 = L_sub ((Word32) 0x7fffffffL, t0); /* 1 - K*K        */
+    L_Extract (t0, &hi, &lo);           /* DPF format      */
+    t0 = Mpy_32 (Rh[0], Rl[0], hi, lo); /* Alpha in        */
+
+    /* Normalize Alpha */
+
+    alp_exp = norm_l (t0);
+    t0 = L_shl (t0, alp_exp);
+    L_Extract (t0, &alp_h, &alp_l);     /* DPF format    */
+
+    /*--------------------------------------*
+     * ITERATIONS  I=2 to M                 *
+     *--------------------------------------*/
+
+    for (i = 2; i <= M; i++)
+    {
+       /* t0 = SUM ( R[j]*A[i-j] ,j=1,i-1 ) +  R[i] */
+       
+       t0 = 0;                         move32 (); 
+       for (j = 1; j < i; j++)
+       {
+          t0 = L_add (t0, Mpy_32 (Rh[j], Rl[j], Ah[i - j], Al[i - j]));
+       }
+       t0 = L_shl (t0, 4);
+       
+       t1 = L_Comp (Rh[i], Rl[i]);
+       t0 = L_add (t0, t1);            /* add R[i]        */
+       
+       /* K = -t0 / Alpha */
+       
+       t1 = L_abs (t0);
+       t2 = Div_32 (t1, alp_h, alp_l); /* abs(t0)/Alpha              */
+       test (); 
+       if (t0 > 0)
+          t2 = L_negate (t2);         /* K =-t0/Alpha                */
+       t2 = L_shl (t2, alp_exp);       /* denormalize; compare to Alpha */
+       L_Extract (t2, &Kh, &Kl);       /* K in DPF                      */
+       
+       test (); 
+       if (sub (i, 5) < 0)
+       {
+          rc[i - 1] = round (t2);     move16 (); 
+       }
+       /* Test for unstable filter. If unstable keep old A(z) */
+       
+       test (); 
+       if (sub (abs_s (Kh), 32750) > 0)
+       {
+          for (j = 0; j <= M; j++)
+          {
+             A[j] = st->old_A[j];        move16 (); 
+          }
+          
+          for (j = 0; j < 4; j++)
+          {
+             rc[j] = 0;              move16 (); 
+          }
+          
+          return 0;
+       }
+       /*------------------------------------------*
+        *  Compute new LPC coeff. -> An[i]         *
+        *  An[j]= A[j] + K*A[i-j]     , j=1 to i-1 *
+        *  An[i]= K                                *
+        *------------------------------------------*/
+       
+       for (j = 1; j < i; j++)
+       {
+          t0 = Mpy_32 (Kh, Kl, Ah[i - j], Al[i - j]);
+          t0 = L_add(t0, L_Comp(Ah[j], Al[j]));
+          L_Extract (t0, &Anh[j], &Anl[j]);
+       }
+       t2 = L_shr (t2, 4);
+       L_Extract (t2, &Anh[i], &Anl[i]);
+       
+       /*  Alpha = Alpha * (1-K**2) */
+       
+       t0 = Mpy_32 (Kh, Kl, Kh, Kl);           /* K*K             */
+       t0 = L_abs (t0);                        /* Some case <0 !! */
+       t0 = L_sub ((Word32) 0x7fffffffL, t0);  /* 1 - K*K        */
+       L_Extract (t0, &hi, &lo);               /* DPF format      */
+       t0 = Mpy_32 (alp_h, alp_l, hi, lo);
+       
+       /* Normalize Alpha */
+       
+       j = norm_l (t0);
+       t0 = L_shl (t0, j);
+       L_Extract (t0, &alp_h, &alp_l);         /* DPF format    */
+       alp_exp = add (alp_exp, j);             /* Add normalization to
+                                                  alp_exp */
+       
+       /* A[j] = An[j] */
+       
+       for (j = 1; j <= i; j++)
+       {
+          Ah[j] = Anh[j];                     move16 (); 
+          Al[j] = Anl[j];                     move16 (); 
+       }
+    }
+    
+    A[0] = 4096;                                move16 (); 
+    for (i = 1; i <= M; i++)
+    {
+       t0 = L_Comp (Ah[i], Al[i]);
+       st->old_A[i] = A[i] = round (L_shl (t0, 1));move16 (); move16 (); 
+    }
+    
+    return 0;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/levinson.h FFMpeg-20050127-new/libavcodec/amr/levinson.h
--- FFMpeg-20050127/libavcodec/amr/levinson.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/levinson.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,73 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : levinson.h
+*      Purpose          : Levinson-Durbin algorithm in double precision.
+*                       : To compute the LP filter parameters from the
+*                       : speech autocorrelations.
+*
+********************************************************************************
+*/
+#ifndef levinson_h
+#define levinson_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "cnst.h"
+ 
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+typedef struct {
+  Word16 old_A[M + 1];     /* Last A(z) for case of unstable filter */
+} LevinsonState;
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+ 
+int Levinson_init (LevinsonState **st);
+/* initialize one instance of the pre processing state.
+   Stores pointer to filter status struct in *st. This pointer has to
+   be passed to Levinson in each call.
+   returns 0 on success
+ */
+ 
+int Levinson_reset (LevinsonState *st);
+/* reset of pre processing state (i.e. set state memory to zero)
+   returns 0 on success
+ */
+void Levinson_exit (LevinsonState **st);
+/* de-initialize pre processing state (i.e. free status struct)
+   stores NULL in *st
+ */
+
+int Levinson (
+    LevinsonState *st,
+    Word16 Rh[],       /* i : Rh[m+1] Vector of autocorrelations (msb) */
+    Word16 Rl[],       /* i : Rl[m+1] Vector of autocorrelations (lsb) */
+    Word16 A[],        /* o : A[m]    LPC coefficients  (m = 10)       */
+    Word16 rc[]        /* o : rc[4]   First 4 reflection coefficients  */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/lflg_upd.c FFMpeg-20050127-new/libavcodec/amr/lflg_upd.c
--- FFMpeg-20050127/libavcodec/amr/lflg_upd.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/lflg_upd.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,88 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : lflg_upd.c
+*      Purpose          : LTP_flag update for AMR VAD option 2
+*
+*****************************************************************************
+*/
+
+const char lflg_upd_id[] = "@(#)$Id $";
+
+
+#include "typedef.h"
+#include "cnst.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+
+#include "vad2.h"
+#include "mode.h"
+
+/***************************************************************************
+ *
+ *   FUNCTION NAME: LTP_flag_update
+ *
+ *   PURPOSE:
+ *     Set LTP_flag if the LTP gain > LTP_THRESHOLD, where the value of
+ *     LTP_THRESHOLD depends on the LTP analysis window length.
+ *
+ *   INPUTS:
+ *
+ *     mode
+ *                     AMR mode
+ *     vadState->L_R0
+ *                     LTP energy
+ *     vadState->L_Rmax
+ *                     LTP maximum autocorrelation
+ *   OUTPUTS:
+ *
+ *     vadState->LTP_flag
+ *                     Set if LTP gain > LTP_THRESHOLD
+ *
+ *   RETURN VALUE:
+ *
+ *     none
+ *
+ *************************************************************************/
+
+void LTP_flag_update (vadState2 * st, Word16 mode)
+{
+	Word16 thresh;
+	Word16 hi1;
+	Word16 lo1;
+	Word32 Ltmp;
+
+									test(); test();
+	if ((sub(mode, MR475) == 0) || (sub(mode, MR515) == 0))
+	{
+		thresh = (Word16)(32768.0*0.55);			move16();
+	}
+	else if (sub(mode, MR102) == 0)
+	{
+		thresh = (Word16)(32768.0*0.60);			move16();
+	}
+	else
+	{
+		thresh = (Word16)(32768.0*0.65);			move16();
+	}
+
+	L_Extract (st->L_R0, &hi1, &lo1);
+	Ltmp = Mpy_32_16(hi1, lo1, thresh);				test();
+	if (L_sub(st->L_Rmax, Ltmp) > 0)
+	{
+		st->LTP_flag = TRUE;					move16();
+	}
+	else
+	{
+		st->LTP_flag = FALSE;					move16();
+	}
+
+	return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/log2.c FFMpeg-20050127-new/libavcodec/amr/log2.c
--- FFMpeg-20050127/libavcodec/amr/log2.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/log2.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,122 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : log2.c
+*      Purpose          : Computes log2(L_x)
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "log2.h"
+const char log2_id[] = "@(#)$Id $" log2_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+ 
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#include "log2.tab"     /* Table for Log2() */
+ 
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ *   FUNCTION:   Log2_norm()
+ *
+ *   PURPOSE:   Computes log2(L_x, exp),  where   L_x is positive and
+ *              normalized, and exp is the normalisation exponent
+ *              If L_x is negative or zero, the result is 0.
+ *
+ *   DESCRIPTION:
+ *        The function Log2(L_x) is approximated by a table and linear
+ *        interpolation. The following steps are used to compute Log2(L_x)
+ *
+ *           1- exponent = 30-norm_exponent
+ *           2- i = bit25-b31 of L_x;  32<=i<=63  (because of normalization).
+ *           3- a = bit10-b24
+ *           4- i -=32
+ *           5- fraction = table[i]<<16 - (table[i] - table[i+1]) * a * 2
+ *
+ *************************************************************************/
+void Log2_norm (
+    Word32 L_x,         /* (i) : input value (normalized)                    */
+    Word16 exp,         /* (i) : norm_l (L_x)                                */
+    Word16 *exponent,   /* (o) : Integer part of Log2.   (range: 0<=val<=30) */
+    Word16 *fraction    /* (o) : Fractional part of Log2. (range: 0<=val<1)  */
+)
+{
+    Word16 i, a, tmp;
+    Word32 L_y;
+
+    test (); 
+    if (L_x <= (Word32) 0)
+    {
+        *exponent = 0;          move16 (); 
+        *fraction = 0;          move16 (); 
+        return;
+    }
+
+    *exponent = sub (30, exp);  move16 (); 
+
+    L_x = L_shr (L_x, 9);
+    i = extract_h (L_x);                /* Extract b25-b31 */
+    L_x = L_shr (L_x, 1);
+    a = extract_l (L_x);                /* Extract b10-b24 of fraction */
+    a = a & (Word16) 0x7fff;    logic16 (); 
+
+    i = sub (i, 32);
+
+    L_y = L_deposit_h (table[i]);       /* table[i] << 16        */
+    tmp = sub (table[i], table[i + 1]); /* table[i] - table[i+1] */
+    L_y = L_msu (L_y, tmp, a);          /* L_y -= tmp*a*2        */
+
+    *fraction = extract_h (L_y);move16 (); 
+
+    return;
+}
+
+/*************************************************************************
+ *
+ *   FUNCTION:   Log2()
+ *
+ *   PURPOSE:   Computes log2(L_x),  where   L_x is positive.
+ *              If L_x is negative or zero, the result is 0.
+ *
+ *   DESCRIPTION:
+ *        normalizes L_x and then calls Log2_norm().
+ *
+ *************************************************************************/
+void Log2 (
+    Word32 L_x,         /* (i) : input value                                 */
+    Word16 *exponent,   /* (o) : Integer part of Log2.   (range: 0<=val<=30) */
+    Word16 *fraction    /* (o) : Fractional part of Log2. (range: 0<=val<1) */
+)
+{
+    Word16 exp;
+
+    exp = norm_l (L_x);
+    Log2_norm (L_shl (L_x, exp), exp, exponent, fraction);
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/log2.h FFMpeg-20050127-new/libavcodec/amr/log2.h
--- FFMpeg-20050127/libavcodec/amr/log2.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/log2.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,49 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : log2.h
+*      Purpose          : Computes log2(L_x)
+*
+********************************************************************************
+*/
+#ifndef log2_h
+#define log2_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+void Log2 (
+    Word32 L_x,        /* (i) : input value                                 */
+    Word16 *exponent,  /* (o) : Integer part of Log2.   (range: 0<=val<=30) */
+    Word16 *fraction   /* (o) : Fractional part of Log2. (range: 0<=val<1)*/
+);
+
+void Log2_norm (
+    Word32 L_x,         /* (i) : input value (normalized)                    */
+    Word16 exp,         /* (i) : norm_l (L_x)                                */
+    Word16 *exponent,   /* (o) : Integer part of Log2.   (range: 0<=val<=30) */
+    Word16 *fraction    /* (o) : Fractional part of Log2. (range: 0<=val<1)  */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/log2.tab FFMpeg-20050127-new/libavcodec/amr/log2.tab
--- FFMpeg-20050127/libavcodec/amr/log2.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/log2.tab	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,22 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : log2.tab
+*      Purpose          : Table for routine Log2().
+*      $Id $
+*
+********************************************************************************
+*/
+static const Word16 table[33] =
+{
+    0, 1455, 2866, 4236, 5568, 6863, 8124, 9352, 10549, 11716,
+    12855, 13967, 15054, 16117, 17156, 18172, 19167, 20142, 21097, 22033,
+    22951, 23852, 24735, 25603, 26455, 27291, 28113, 28922, 29716, 30497,
+    31266, 32023, 32767
+};
diff -Nur FFMpeg-20050127/libavcodec/amr/lpc.c FFMpeg-20050127-new/libavcodec/amr/lpc.c
--- FFMpeg-20050127/libavcodec/amr/lpc.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/lpc.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,169 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : lpc.c
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "lpc.h"
+const char lpc_id[] = "@(#)$Id $" lpc_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "autocorr.h"
+#include "lag_wind.h"
+#include "levinson.h"
+#include "cnst.h"
+#include "mode.h"
+#include "count.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#include "window.tab"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+*
+*  Function:   lpc_init
+*
+**************************************************************************
+*/
+int lpc_init (lpcState **state)
+{
+  lpcState* s;
+ 
+  if (state == (lpcState **) NULL){
+      fprintf(stderr, "lpc_init: invalid parameter\n");
+      return -1;
+  }
+  *state = NULL;
+ 
+  /* allocate memory */
+  if ((s= (lpcState *) malloc(sizeof(lpcState))) == NULL){
+      fprintf(stderr, "lpc_init: can not malloc state structure\n");
+      return -1;
+  }
+  
+  s->levinsonSt = NULL;
+  
+  /* Init sub states */
+  if (Levinson_init(&s->levinsonSt)) {
+     lpc_exit(&s);
+     return -1;
+  }
+
+
+  lpc_reset(s);
+  *state = s;
+  
+  return 0;
+}
+ 
+/*************************************************************************
+*
+*  Function:   lpc_reset
+*
+**************************************************************************
+*/
+int lpc_reset (lpcState *state)
+{
+  
+  if (state == (lpcState *) NULL){
+      fprintf(stderr, "lpc_reset: invalid parameter\n");
+      return -1;
+  }
+  
+  Levinson_reset(state->levinsonSt);
+
+  return 0;
+}
+
+/*************************************************************************
+*
+*  Function:   lpc_exit
+*
+**************************************************************************
+*/
+void lpc_exit (lpcState **state)
+{
+  if (state == NULL || *state == NULL)
+      return;
+
+  Levinson_exit(&(*state)->levinsonSt);
+
+  /* deallocate memory */
+  free(*state);
+  *state = NULL;
+  
+  return;
+}
+
+int lpc(
+    lpcState *st,     /* i/o: State struct                */
+    enum Mode mode,   /* i  : coder mode                  */
+    Word16 x[],       /* i  : Input signal           Q15  */
+    Word16 x_12k2[],  /* i  : Input signal (EFR)     Q15  */
+    Word16 a[]        /* o  : predictor coefficients Q12  */
+)
+{
+   Word16 rc[4];                  /* First 4 reflection coefficients Q15 */
+   Word16 rLow[MP1], rHigh[MP1];  /* Autocorrelations low and hi      */
+                                  /* No fixed Q value but normalized  */
+                                  /* so that overflow is avoided      */
+   
+   test ();
+   if ( sub (mode, MR122) == 0)
+   {
+       /* Autocorrelations */
+       Autocorr(x_12k2, M, rHigh, rLow, window_160_80);              
+       /* Lag windowing    */
+       Lag_window(M, rHigh, rLow);                                   
+       /* Levinson Durbin  */
+       Levinson(st->levinsonSt, rHigh, rLow, &a[MP1], rc);     
+
+       /* Autocorrelations */
+       Autocorr(x_12k2, M, rHigh, rLow, window_232_8);                  
+       /* Lag windowing    */
+       Lag_window(M, rHigh, rLow);                                  
+       /* Levinson Durbin  */
+       Levinson(st->levinsonSt, rHigh, rLow, &a[MP1 * 3], rc); 
+   }
+   else
+   {
+       /* Autocorrelations */
+       Autocorr(x, M, rHigh, rLow, window_200_40);                 
+       /* Lag windowing    */
+       Lag_window(M, rHigh, rLow);                                   
+       /* Levinson Durbin  */
+       Levinson(st->levinsonSt, rHigh, rLow, &a[MP1 * 3], rc); 
+   }
+   
+   return 0;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/lpc.h FFMpeg-20050127-new/libavcodec/amr/lpc.h
--- FFMpeg-20050127/libavcodec/amr/lpc.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/lpc.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,73 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : lpc.h
+*      Purpose          : 2 LP analyses centered at 2nd and 4th subframe
+*                         for mode 12.2. For all other modes a
+*                         LP analysis centered at 4th subframe is 
+*                         performed.
+*
+********************************************************************************
+*/
+#ifndef lpc_h
+#define lpc_h "$Id $"
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "levinson.h"
+#include "mode.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+typedef struct {
+   LevinsonState *levinsonSt;
+} lpcState;
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+int lpc_init (lpcState **st);
+/* initialize one instance of the pre processing state.
+   Stores pointer to filter status struct in *st. This pointer has to
+   be passed to lpc in each call.
+   returns 0 on success
+ */
+ 
+int lpc_reset (lpcState *st);
+/* reset of pre processing state (i.e. set state memory to zero)
+   returns 0 on success
+ */
+void lpc_exit (lpcState **st);
+/* de-initialize pre processing state (i.e. free status struct)
+   stores NULL in *st
+ */
+
+int lpc(
+    lpcState *st,     /* i/o: State struct                */
+    enum Mode mode,   /* i  : coder mode                  */
+    Word16 x[],       /* i  : Input signal           Q15  */
+    Word16 x_12k2[],  /* i  : Input signal (EFR)     Q15  */
+    Word16 a[]        /* o  : predictor coefficients Q12  */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/lsfwt.c FFMpeg-20050127-new/libavcodec/amr/lsfwt.c
--- FFMpeg-20050127/libavcodec/amr/lsfwt.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/lsfwt.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,107 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : lsfwt.c
+*      Purpose          : Compute LSF weighting factors
+*
+********************************************************************************
+*/
+ 
+ 
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "lsfwt.h"
+const char lsfwt_id[] = "@(#)$Id $" lsfwt_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/****************************************************
+ *
+ * FUNCTION  Lsf_wt                                                         *
+ *                                                                          *
+ ****************************************************
+ * Compute LSF weighting factors                                            *
+ *                                                                          *
+ *  d[i] = lsf[i+1] - lsf[i-1]                                              *
+ *                                                                          *
+ *  The weighting factors are approximated by two line segment.             *
+ *                                                                          *
+ *  First segment passes by the following 2 points:                         *
+ *                                                                          *
+ *     d[i] = 0Hz     wf[i] = 3.347                                         *
+ *     d[i] = 450Hz   wf[i] = 1.8                                           *
+ *                                                                          *
+ *  Second segment passes by the following 2 points:                        *
+ *                                                                          *
+ *     d[i] = 450Hz   wf[i] = 1.8                                           *
+ *     d[i] = 1500Hz  wf[i] = 1.0                                           *
+ *                                                                          *
+ *  if( d[i] < 450Hz )                                                      *
+ *    wf[i] = 3.347 - ( (3.347-1.8) / (450-0)) *  d[i]                      *
+ *  else                                                                    *
+ *    wf[i] = 1.8 - ( (1.8-1.0) / (1500-450)) *  (d[i] - 450)               *
+ *                                                                          *
+ *                                                                          *
+ *  if( d[i] < 1843)                                                        *
+ *    wf[i] = 3427 - (28160*d[i])>>15                                       *
+ *  else                                                                    *
+ *    wf[i] = 1843 - (6242*(d[i]-1843))>>15                                 *
+ *                                                                          *
+ *--------------------------------------------------------------------------*/
+
+void Lsf_wt (
+    Word16 *lsf,         /* input : LSF vector                  */
+    Word16 *wf)          /* output: square of weighting factors */
+{
+    Word16 temp;
+    Word16 i;
+    /* wf[0] = lsf[1] - 0  */
+    wf[0] = lsf[1];                                     move16 (); 
+    for (i = 1; i < 9; i++)
+    {
+        wf[i] = sub (lsf[i + 1], lsf[i - 1]);           move16 (); 
+    }
+    /* wf[9] = 0.5 - lsf[8] */    
+    wf[9] = sub (16384, lsf[8]);move16 ();      
+
+    for (i = 0; i < 10; i++)
+    {
+        temp = sub (wf[i], 1843);
+        test (); 
+        if (temp < 0)
+        {
+            wf[i] = sub (3427, mult (wf[i], 28160));    move16 (); 
+        }
+        else
+        {
+            wf[i] = sub (1843, mult (temp, 6242));      move16 (); 
+        }
+
+        wf[i] = shl (wf[i], 3); move16 (); 
+    }
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/lsfwt.h FFMpeg-20050127-new/libavcodec/amr/lsfwt.h
--- FFMpeg-20050127/libavcodec/amr/lsfwt.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/lsfwt.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,36 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : lsfwt.h
+*      Purpose          : Compute LSF weighting factors
+*
+********************************************************************************
+*/
+#ifndef lsfwt_h
+#define lsfwt_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "cnst.h"
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+ 
+void Lsf_wt (
+    Word16 *lsf,         /* input : LSF vector                  */
+    Word16 *wf);         /* output: square of weighting factors */
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/lsp.c FFMpeg-20050127-new/libavcodec/amr/lsp.c
--- FFMpeg-20050127/libavcodec/amr/lsp.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/lsp.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,205 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : lsp.c
+*      Purpose          : From A(z) to lsp. LSP quantization and interpolation
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "lsp.h"
+const char lsp_id[] = "@(#)$Id $" lsp_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "q_plsf.h"
+#include "copy.h"
+#include "az_lsp.h"
+#include "int_lpc.h"
+#include "count.h"
+
+#include "lsp.tab"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : lsp_init
+*
+**************************************************************************
+*/
+int lsp_init (lspState **st)
+{
+  lspState* s;
+
+  if (st == (lspState **) NULL){
+      fprintf(stderr, "lsp_init: invalid parameter\n");
+      return -1;
+  }
+  
+  *st = NULL;
+ 
+  /* allocate memory */
+  if ((s= (lspState *) malloc(sizeof(lspState))) == NULL){
+      fprintf(stderr, "lsp_init: can not malloc state structure\n");
+      return -1;
+  }
+
+  /* Initialize quantization state */
+   Q_plsf_init(&s->qSt);
+
+  lsp_reset(s);
+  *st = s;
+  
+  return 0;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : lsp_reset
+*
+**************************************************************************
+*/
+int lsp_reset (lspState *st)
+{
+  
+  if (st == (lspState *) NULL){
+      fprintf(stderr, "lsp_reset: invalid parameter\n");
+      return -1;
+  }
+  
+  /* Init lsp_old[] */
+  Copy(lsp_init_data, &st->lsp_old[0], M);
+
+  /* Initialize lsp_old_q[] */
+  Copy(st->lsp_old, st->lsp_old_q, M);
+  
+  /* Reset quantization state */
+   Q_plsf_reset(st->qSt);
+
+  return 0;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : lsp_exit
+*
+**************************************************************************
+*/
+void lsp_exit (lspState **st)
+{
+  if (st == NULL || *st == NULL)
+      return;
+
+  /* Deallocate members */
+  Q_plsf_exit(&(*st)->qSt);
+
+  /* deallocate memory */
+  free(*st);
+  *st = NULL;
+  
+  return;
+}
+
+/*************************************************************************
+ *
+ *   FUNCTION:  lsp()
+ *
+ ************************************************************************/
+int lsp(lspState *st,        /* i/o : State struct                            */
+        enum Mode req_mode,  /* i   : requested coder mode                    */
+        enum Mode used_mode, /* i   : used coder mode                         */        
+        Word16 az[],         /* i/o : interpolated LP parameters Q12          */
+        Word16 azQ[],        /* o   : quantization interpol. LP parameters Q12*/
+        Word16 lsp_new[],    /* o   : new lsp vector                          */ 
+        Word16 **anap        /* o   : analysis parameters                     */)
+{
+   Word16 lsp_new_q[M];    /* LSPs at 4th subframe           */
+   Word16 lsp_mid[M], lsp_mid_q[M];    /* LSPs at 2nd subframe           */
+  
+   Word16 pred_init_i; /* init index for MA prediction in DTX mode */
+
+   test ();
+   if ( sub (req_mode, MR122) == 0)
+   {
+       Az_lsp (&az[MP1], lsp_mid, st->lsp_old);
+       Az_lsp (&az[MP1 * 3], lsp_new, lsp_mid);
+
+       /*--------------------------------------------------------------------*
+        * Find interpolated LPC parameters in all subframes (both quantized  *
+        * and unquantized).                                                  *
+        * The interpolated parameters are in array A_t[] of size (M+1)*4     *
+        * and the quantized interpolated parameters are in array Aq_t[]      *
+        *--------------------------------------------------------------------*/
+       Int_lpc_1and3_2 (st->lsp_old, lsp_mid, lsp_new, az);
+
+       test ();
+       if ( sub (used_mode, MRDTX) != 0)
+       {
+          /* LSP quantization (lsp_mid[] and lsp_new[] jointly quantized) */
+          Q_plsf_5 (st->qSt, lsp_mid, lsp_new, lsp_mid_q, lsp_new_q, *anap);
+       
+          Int_lpc_1and3 (st->lsp_old_q, lsp_mid_q, lsp_new_q, azQ);
+          
+          /* Advance analysis parameters pointer */
+          (*anap) += add(0,5); move16 ();
+       }	 
+   }
+   else
+   {
+       Az_lsp(&az[MP1 * 3], lsp_new, st->lsp_old);  /* From A(z) to lsp  */
+       
+       /*--------------------------------------------------------------------*
+        * Find interpolated LPC parameters in all subframes (both quantized  *
+        * and unquantized).                                                  *
+        * The interpolated parameters are in array A_t[] of size (M+1)*4     *
+        * and the quantized interpolated parameters are in array Aq_t[]      *
+        *--------------------------------------------------------------------*/
+       
+       Int_lpc_1to3_2(st->lsp_old, lsp_new, az);
+       
+       test ();
+       if ( sub (used_mode, MRDTX) != 0)
+       {
+          /* LSP quantization */
+          Q_plsf_3(st->qSt, req_mode, lsp_new, lsp_new_q, *anap, &pred_init_i);
+          
+          Int_lpc_1to3(st->lsp_old_q, lsp_new_q, azQ);
+          
+          /* Advance analysis parameters pointer */
+          (*anap) += add (0, 3); move16 ();
+       }
+   }
+       
+   /* update the LSPs for the next frame */   
+   Copy (lsp_new, st->lsp_old, M);
+   Copy (lsp_new_q, st->lsp_old_q, M);
+
+   return 0;
+}
+
diff -Nur FFMpeg-20050127/libavcodec/amr/lsp.h FFMpeg-20050127-new/libavcodec/amr/lsp.h
--- FFMpeg-20050127/libavcodec/amr/lsp.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/lsp.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,117 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : lsp.h
+*      Purpose          : Conversion from A(z) to LSP. Quantization and
+*                         interpolation of LSPs.
+*
+********************************************************************************
+*/
+#ifndef lsp_h
+#define lsp_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "q_plsf.h"
+#include "mode.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+typedef struct {
+
+   /* Past LSPs */
+   Word16 lsp_old[M];
+   Word16 lsp_old_q[M];
+
+   /* Quantization state */
+   Q_plsfState *qSt;
+
+} lspState;
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : lsp_init
+*  Purpose     : Allocates memory and initializes state variables
+*  Description : Stores pointer to filter status struct in *st. This
+*                pointer has to be passed to lsp in each call.
+*  Returns     : 0 on success
+*
+**************************************************************************
+*/ 
+int lsp_init (lspState **st);
+ 
+/*
+**************************************************************************
+*
+*  Function    : lsp_reset
+*  Purpose     : Resets state memory
+*  Returns     : 0 on success
+*
+**************************************************************************
+*/
+int lsp_reset (lspState *st);
+
+/*
+**************************************************************************
+*
+*  Function    : lsp_exit
+*  Purpose     : The memory used for state memory is freed
+*  Description : Stores NULL in *st
+*
+**************************************************************************
+*/
+void lsp_exit (lspState **st);
+
+/*
+**************************************************************************
+*
+*  Function    : lsp
+*  Purpose     : Conversion from LP coefficients to LSPs.
+*                Quantization of LSPs.
+*  Description : Generates 2 sets of LSPs from 2 sets of
+*                LP coefficients for mode 12.2. For the other
+*                modes 1 set of LSPs is generated from 1 set of
+*                LP coefficients. These LSPs are quantized with
+*                Matrix/Vector quantization (depending on the mode)
+*                and interpolated for the subframes not yet having
+*                their own LSPs.
+*                
+**************************************************************************
+*/
+int lsp(lspState *st,        /* i/o : State struct                            */
+        enum Mode req_mode,  /* i   : requested coder mode                    */
+        enum Mode used_mode, /* i   : used coder mode                         */        
+        Word16 az[],         /* i/o : interpolated LP parameters Q12          */
+        Word16 azQ[],        /* o   : quantization interpol. LP parameters Q12*/
+        Word16 lsp_new[],    /* o   : new lsp vector                          */ 
+        Word16 **anap        /* o   : analysis parameters                     */
+        );
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/lsp.tab FFMpeg-20050127-new/libavcodec/amr/lsp.tab
--- FFMpeg-20050127/libavcodec/amr/lsp.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/lsp.tab	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,17 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : lsp.tab
+*      Purpose          : Table for lsp init
+*      $Id $
+*
+********************************************************************************
+*/
+static const Word16 lsp_init_data[M] = {30000, 26000, 21000, 15000, 8000,
+					0, -8000, -15000, -21000, -26000};
diff -Nur FFMpeg-20050127/libavcodec/amr/lsp_avg.c FFMpeg-20050127-new/libavcodec/amr/lsp_avg.c
--- FFMpeg-20050127/libavcodec/amr/lsp_avg.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/lsp_avg.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,149 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : lsp_avg.c
+*      Purpose:         : LSP averaging and history
+*
+*****************************************************************************
+*/
+ 
+ 
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "lsp_avg.h"
+const char lsp_avg_id[] = "@(#)$Id $" lsp_avg_h;
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "q_plsf_5.tab"
+#include "copy.h"
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+/*
+**************************************************************************
+*
+*  Function    : lsp_avg_init
+*  Purpose     : Allocates memory and initializes state variables
+*
+**************************************************************************
+*/
+int lsp_avg_init (lsp_avgState **state)
+{
+  lsp_avgState* s;
+ 
+  if (state == (lsp_avgState **) NULL){
+      fprintf(stderr, "lsp_avg_init: invalid parameter\n");
+      return -1;
+  }
+  *state = NULL;
+ 
+  /* allocate memory */
+  if ((s = (lsp_avgState *) malloc(sizeof(lsp_avgState))) == NULL){
+      fprintf(stderr, "lsp_avg_init: can not malloc state structure\n");
+      return -1;
+  }
+
+  lsp_avg_reset(s);
+  *state = s;
+  
+  return 0;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : lsp_avg_reset
+*  Purpose     : Resets state memory
+*
+**************************************************************************
+*/
+int lsp_avg_reset (lsp_avgState *st)
+{ 
+  if (st == (lsp_avgState *) NULL){
+      fprintf(stderr, "lsp_avg_reset: invalid parameter\n");
+      return -1;
+  }
+
+  Copy(mean_lsf, &st->lsp_meanSave[0], M);
+  
+  return 0;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : lsp_avg_exit
+*  Purpose     : The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void lsp_avg_exit (lsp_avgState **state)
+{
+  if (state == NULL || *state == NULL)
+      return;
+
+  /* deallocate memory */
+  free(*state);
+  *state = NULL;
+  
+  return;
+}
+
+/*
+**************************************************************************
+*
+*  Function    : lsp_avg
+*  Purpose     : Calculate the LSP averages
+*
+**************************************************************************
+*/
+
+void lsp_avg (
+    lsp_avgState *st,         /* i/o : State struct                 Q15 */
+    Word16 *lsp               /* i   : state of the state machine   Q15 */
+)
+{
+    Word16 i;
+    Word32 L_tmp;            /* Q31 */
+
+    for (i = 0; i < M; i++) {
+
+       /* mean = 0.84*mean */
+       L_tmp = L_deposit_h(st->lsp_meanSave[i]);
+       L_tmp = L_msu(L_tmp, EXPCONST, st->lsp_meanSave[i]);
+
+       /* Add 0.16 of newest LSPs to mean */
+       L_tmp = L_mac(L_tmp, EXPCONST, lsp[i]);
+
+       /* Save means */
+       st->lsp_meanSave[i] = round(L_tmp);          move16();   /* Q15 */
+    }
+
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/lsp_avg.h FFMpeg-20050127-new/libavcodec/amr/lsp_avg.h
--- FFMpeg-20050127/libavcodec/amr/lsp_avg.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/lsp_avg.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,98 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : lsp_avg.h
+*      Purpose:         : LSP averaging and history
+*                         The LSPs are averaged over 8 frames
+*
+********************************************************************************
+*/
+#ifndef lsp_avg_h
+#define lsp_avg_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+#define EXPCONST          5243               /* 0.16 in Q15 */
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+typedef struct {
+  Word16 lsp_meanSave[M];          /* Averaged LSPs saved for efficiency  */
+} lsp_avgState;
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+
+/*
+**************************************************************************
+*
+*  Function    : lsp_avg_init
+*  Purpose     : Allocates memory and initializes state variables
+*
+**************************************************************************
+*/
+int lsp_avg_init (
+    lsp_avgState **state
+);
+ 
+/*
+**************************************************************************
+*
+*  Function    : lsp_history_reset
+*  Purpose     : Resets state memory
+*
+**************************************************************************
+*/
+int lsp_avg_reset (
+    lsp_avgState *state
+);
+ 
+/*
+**************************************************************************
+*
+*  Function    : lsp_avg_exit
+*  Purpose     : The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void lsp_avg_exit (
+    lsp_avgState **state
+);
+
+/*
+**************************************************************************
+*
+*  Function    : lsp_avg
+*  Purpose     : Calculate the LSP averages
+*
+**************************************************************************
+*/
+void lsp_avg (
+    lsp_avgState *st,     /* i/o : State struct                 Q15 */
+    Word16 *lsp           /* i   : LSP vector                   Q15 */
+);
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/lsp_az.c FFMpeg-20050127-new/libavcodec/amr/lsp_az.c
--- FFMpeg-20050127/libavcodec/amr/lsp_az.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/lsp_az.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,160 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : lsp_az.c
+*      Purpose          : Converts from the line spectral pairs (LSP) to
+*                       : LP coefficients, for a 10th order filter.
+*      Description      : 
+*                 - Find the coefficients of F1(z) and F2(z) (see Get_lsp_pol)
+*                 - Multiply F1(z) by 1+z^{-1} and F2(z) by 1-z^{-1}
+*                 - A(z) = ( F1(z) + F2(z) ) / 2
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "lsp_az.h"
+const char lsp_az_id[] = "@(#)$Id $" 
+lsp_az_h;
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         LOCAL PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  Get_lsp_pol
+ *
+ *  PURPOSE:  Find the polynomial F1(z) or F2(z) from the LSPs.
+ *            If the LSP vector is passed at address 0  F1(z) is computed
+ *            and if it is passed at address 1  F2(z) is computed.
+ *
+ *  DESCRIPTION:
+ *       This is performed by expanding the product polynomials:
+ *
+ *           F1(z) =   product   ( 1 - 2 lsp[i] z^-1 + z^-2 )
+ *                   i=0,2,4,6,8
+ *           F2(z) =   product   ( 1 - 2 lsp[i] z^-1 + z^-2 )
+ *                   i=1,3,5,7,9
+ *
+ *       where lsp[] is the LSP vector in the cosine domain.
+ *
+ *       The expansion is performed using the following recursion:
+ *
+ *            f[0] = 1
+ *            b = -2.0 * lsp[0]
+ *            f[1] = b
+ *            for i=2 to 5 do
+ *               b = -2.0 * lsp[2*i-2];
+ *               f[i] = b*f[i-1] + 2.0*f[i-2];
+ *               for j=i-1 down to 2 do
+ *                   f[j] = f[j] + b*f[j-1] + f[j-2];
+ *               f[1] = f[1] + b;
+ *
+ *************************************************************************/
+
+static void Get_lsp_pol (Word16 *lsp, Word32 *f)
+{
+    Word16 i, j, hi, lo;
+    Word32 t0;
+    
+    /* f[0] = 1.0;             */
+    *f = L_mult (4096, 2048);              move32 (); 
+    f++;                                   move32 (); 
+    *f = L_msu ((Word32) 0, *lsp, 512);    /* f[1] =  -2.0 * lsp[0];  */
+    f++;                                   move32 (); 
+    lsp += 2;                              /* Advance lsp pointer     */
+
+    for (i = 2; i <= 5; i++)
+    {
+        *f = f[-2];                        move32 (); 
+
+        for (j = 1; j < i; j++, f--)
+        {
+            L_Extract (f[-1], &hi, &lo);
+            t0 = Mpy_32_16 (hi, lo, *lsp); /* t0 = f[-1] * lsp    */
+            t0 = L_shl (t0, 1);
+            *f = L_add (*f, f[-2]);        move32 (); /* *f += f[-2]      */
+            *f = L_sub (*f, t0);move32 (); /* *f -= t0            */
+        }
+        *f = L_msu (*f, *lsp, 512);        move32 (); /* *f -= lsp<<9     */
+        f += i;                            /* Advance f pointer   */
+        lsp += 2;                          /* Advance lsp pointer */
+    }
+
+    return;
+}
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:   Lsp_Az
+ *
+ *  PURPOSE:  Converts from the line spectral pairs (LSP) to
+ *            LP coefficients, for a 10th order filter.
+ *
+ *  DESCRIPTION:
+ *     - Find the coefficients of F1(z) and F2(z) (see Get_lsp_pol)
+ *     - Multiply F1(z) by 1+z^{-1} and F2(z) by 1-z^{-1}
+ *     - A(z) = ( F1(z) + F2(z) ) / 2
+ *
+ *************************************************************************/
+void Lsp_Az (
+    Word16 lsp[],        /* (i)  : line spectral frequencies            */
+    Word16 a[]           /* (o)  : predictor coefficients (order = 10)  */
+)
+{
+    Word16 i, j;
+    Word32 f1[6], f2[6];
+    Word32 t0;
+
+    Get_lsp_pol (&lsp[0], f1);
+    Get_lsp_pol (&lsp[1], f2);
+
+    for (i = 5; i > 0; i--)
+    {
+        f1[i] = L_add (f1[i], f1[i - 1]);    move32 (); /* f1[i] += f1[i-1]; */
+        f2[i] = L_sub (f2[i], f2[i - 1]);    move32 (); /* f2[i] -= f2[i-1]; */
+    }
+
+    a[0] = 4096;                             move16 (); 
+    for (i = 1, j = 10; i <= 5; i++, j--)
+    {
+        t0 = L_add (f1[i], f2[i]);           /* f1[i] + f2[i] */
+        a[i] = extract_l (L_shr_r (t0, 13)); move16 (); 
+        t0 = L_sub (f1[i], f2[i]);           /* f1[i] - f2[i] */
+        a[j] = extract_l (L_shr_r (t0, 13)); move16 (); 
+    }
+
+    return;
+}
+
diff -Nur FFMpeg-20050127/libavcodec/amr/lsp_az.h FFMpeg-20050127-new/libavcodec/amr/lsp_az.h
--- FFMpeg-20050127/libavcodec/amr/lsp_az.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/lsp_az.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,43 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : lsp_az.h
+*      Purpose          : Converts from the line spectral pairs (LSP) to
+*                       : LP coefficients, for a 10th order filter.
+*
+********************************************************************************
+*/
+#ifndef lsp_az_h
+#define lsp_az_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+void Lsp_Az (
+    Word16 lsp[],      /* (i)    : line spectral frequencies                */
+    Word16 a[]         /* (o)    : predictor coefficients (order = 10)      */
+);
+
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/lsp_lsf.c FFMpeg-20050127-new/libavcodec/amr/lsp_lsf.c
--- FFMpeg-20050127/libavcodec/amr/lsp_lsf.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/lsp_lsf.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,113 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : lsp_lsf.c
+*      Purpose          : Lsp_lsf:   Transformation lsp to lsf
+*                       : Lsf_lsp:   Transformation lsf to lsp
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "lsp_lsf.h"
+const char lsp_lsf_id[] = "@(#)$Id $" lsp_lsf_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+ 
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#include "lsp_lsf.tab"          /* Look-up table for transformations */
+ 
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *   FUNCTIONS:  Lsp_lsf and Lsf_lsp
+ *
+ *   PURPOSE:
+ *      Lsp_lsf:   Transformation lsp to lsf
+ *      Lsf_lsp:   Transformation lsf to lsp
+ *
+ *   DESCRIPTION:
+ *         lsp[i] = cos(2*pi*lsf[i]) and lsf[i] = arccos(lsp[i])/(2*pi)
+ *
+ *   The transformation from lsp[i] to lsf[i] and lsf[i] to lsp[i] are
+ *   approximated by a look-up table and interpolation.
+ *
+ *************************************************************************/
+void Lsf_lsp (
+    Word16 lsf[],       /* (i) : lsf[m] normalized (range: 0.0<=val<=0.5) */
+    Word16 lsp[],       /* (o) : lsp[m] (range: -1<=val<1)                */
+    Word16 m            /* (i) : LPC order                                */
+)
+{
+    Word16 i, ind, offset;
+    Word32 L_tmp;
+
+    for (i = 0; i < m; i++)
+    {
+        ind = shr (lsf[i], 8);      /* ind    = b8-b15 of lsf[i] */
+        offset = lsf[i] & 0x00ff;   logic16 (); /* offset = b0-b7  of lsf[i] */
+
+        /* lsp[i] = table[ind]+ ((table[ind+1]-table[ind])*offset) / 256 */
+
+        L_tmp = L_mult (sub (table[ind + 1], table[ind]), offset);
+        lsp[i] = add (table[ind], extract_l (L_shr (L_tmp, 9)));
+                                    move16 (); 
+    }
+    return;
+}
+
+void Lsp_lsf (
+    Word16 lsp[],       /* (i)  : lsp[m] (range: -1<=val<1)                */
+    Word16 lsf[],       /* (o)  : lsf[m] normalized (range: 0.0<=val<=0.5) */
+    Word16 m            /* (i)  : LPC order                                */
+)
+{
+    Word16 i, ind;
+    Word32 L_tmp;
+
+    ind = 63;  move16 ();                      /* begin at end of table -1 */
+
+    for (i = m - 1; i >= 0; i--)
+    {
+        /* find value in table that is just greater than lsp[i] */
+        test (); 
+        while (sub (table[ind], lsp[i]) < 0)
+        {
+            ind--;
+            test (); 
+        }
+
+        /* acos(lsp[i])= ind*256 + ( ( lsp[i]-table[ind] ) *
+           slope[ind] )/4096 */
+
+        L_tmp = L_mult (sub (lsp[i], table[ind]), slope[ind]);
+        /*(lsp[i]-table[ind])*slope[ind])>>12*/
+        lsf[i] = round (L_shl (L_tmp, 3));      move16 (); 
+        lsf[i] = add (lsf[i], shl (ind, 8));    move16 (); 
+    }
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/lsp_lsf.h FFMpeg-20050127-new/libavcodec/amr/lsp_lsf.h
--- FFMpeg-20050127/libavcodec/amr/lsp_lsf.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/lsp_lsf.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,48 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : lsp_lsf.h
+*      Purpose          : Lsp_lsf:   Transformation lsp to lsf
+*                       : Lsf_lsp:   Transformation lsf to lsp
+*
+********************************************************************************
+*/
+#ifndef lsp_lsf_h
+#define lsp_lsf_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+void Lsf_lsp (
+    Word16 lsf[],      /* (i)    : lsf[m] normalized (range: 0.0<=val<=0.5) */
+    Word16 lsp[],      /* (o)    : lsp[m] (range: -1<=val<1)                */
+    Word16 m           /* (i)    : LPC order                                */
+);
+void Lsp_lsf (
+    Word16 lsp[],      /* (i)    : lsp[m] (range: -1<=val<1)                */
+    Word16 lsf[],      /* (o)    : lsf[m] normalized (range: 0.0<=val<=0.5) */
+    Word16 m           /* (i)    : LPC order                                */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/lsp_lsf.tab FFMpeg-20050127-new/libavcodec/amr/lsp_lsf.tab
--- FFMpeg-20050127/libavcodec/amr/lsp_lsf.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/lsp_lsf.tab	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,45 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : lsp_lsf.tab
+*      Purpose          : Tables for function Lsf_lsp() and Lsp_lsf()
+*      $Id $
+*
+********************************************************************************
+*/
+/* table of cos(x) */
+
+static const Word16 table[65] =
+{
+    32767, 32729, 32610, 32413, 32138, 31786, 31357, 30853,
+    30274, 29622, 28899, 28106, 27246, 26320, 25330, 24279,
+    23170, 22006, 20788, 19520, 18205, 16846, 15447, 14010,
+    12540, 11039, 9512, 7962, 6393, 4808, 3212, 1608,
+    0, -1608, -3212, -4808, -6393, -7962, -9512, -11039,
+    -12540, -14010, -15447, -16846, -18205, -19520, -20788, -22006,
+    -23170, -24279, -25330, -26320, -27246, -28106, -28899, -29622,
+    -30274, -30853, -31357, -31786, -32138, -32413, -32610, -32729,
+    (Word16) 0x8000
+};
+
+/* 0x8000 = -32768 (used to silence the compiler) */
+
+/* slope used to compute y = acos(x) */
+
+static const Word16 slope[64] =
+{
+    -26887, -8812, -5323, -3813, -2979, -2444, -2081, -1811,
+    -1608, -1450, -1322, -1219, -1132, -1059, -998, -946,
+    -901, -861, -827, -797, -772, -750, -730, -713,
+    -699, -687, -677, -668, -662, -657, -654, -652,
+    -652, -654, -657, -662, -668, -677, -687, -699,
+    -713, -730, -750, -772, -797, -827, -861, -901,
+    -946, -998, -1059, -1132, -1219, -1322, -1450, -1608,
+    -1811, -2081, -2444, -2979, -3813, -5323, -8812, -26887
+};
diff -Nur FFMpeg-20050127/libavcodec/amr/mac_32.c FFMpeg-20050127-new/libavcodec/amr/mac_32.c
--- FFMpeg-20050127/libavcodec/amr/mac_32.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/mac_32.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,95 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : mac_32.c
+*      Purpose          : 32 x 32 and 32 x 16 bit DPF multiy & accumulate
+*                         (similar as Mpy_32 and Mpy_32_16 in oper_32b.c)
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "mac_32.h"
+const char mac_32_id[] = "@(#)$Id $" mac_32_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+
+/*****************************************************************************
+ * Function Mac_32()                                                         *
+ *                                                                           *
+ *   Multiply two 32 bit integers (DPF) and accumulate with (normal) 32 bit  *
+ *   integer. The multiplication result is divided by 2**31                  *
+ *                                                                           *
+ *   L_32 = L_32 + (hi1*hi2)<<1 + ( (hi1*lo2)>>15 + (lo1*hi2)>>15 )<<1       *
+ *                                                                           *
+ *   This operation can also be viewed as the multiplication of two Q31      *
+ *   number and the result is also in Q31.                                   *
+ *                                                                           *
+ * Arguments:                                                                *
+ *                                                                           *
+ *  hi1         hi part of first number                                      *
+ *  lo1         lo part of first number                                      *
+ *  hi2         hi part of second number                                     *
+ *  lo2         lo part of second number                                     *
+ *                                                                           *
+ *****************************************************************************
+*/
+
+Word32 Mac_32 (Word32 L_32, Word16 hi1, Word16 lo1, Word16 hi2, Word16 lo2)
+{
+    L_32 = L_mac (L_32, hi1, hi2);
+    L_32 = L_mac (L_32, mult (hi1, lo2), 1);
+    L_32 = L_mac (L_32, mult (lo1, hi2), 1);
+
+    return (L_32);
+}
+
+/*****************************************************************************
+ * Function Mac_32_16()                                                      *
+ *                                                                           *
+ *   Multiply a 16 bit integer by a 32 bit (DPF) and accumulate with (normal)*
+ *   32 bit integer. The multiplication result is divided by 2**15           *
+ *                                                                           *
+ *                                                                           *
+ *   L_32 = L_32 + (hi1*lo2)<<1 + ((lo1*lo2)>>15)<<1                         *
+ *                                                                           *
+ * Arguments:                                                                *
+ *                                                                           *
+ *  hi          hi part of 32 bit number.                                    *
+ *  lo          lo part of 32 bit number.                                    *
+ *  n           16 bit number.                                               *
+ *                                                                           *
+ *****************************************************************************
+*/
+
+Word32 Mac_32_16 (Word32 L_32, Word16 hi, Word16 lo, Word16 n)
+{
+    L_32 = L_mac (L_32, hi, n);
+    L_32 = L_mac (L_32, mult (lo, n), 1);
+
+    return (L_32);
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/mac_32.h FFMpeg-20050127-new/libavcodec/amr/mac_32.h
--- FFMpeg-20050127/libavcodec/amr/mac_32.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/mac_32.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,84 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : mac_32.h
+*      Purpose          : 32 x 32 and 32 x 16 bit DPF multiy & accumulate
+*                         (similar as Mpy_32 and Mpy_32_16 in oper_32b.c)
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#ifndef mac_32_h
+#define mac_32_h "$Id $"
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+
+/*****************************************************************************
+ * Function Mac_32()                                                         *
+ *                                                                           *
+ *   Multiply two 32 bit integers (DPF) and accumulate with (normal) 32 bit  *
+ *   integer. The multiplication result is divided by 2**31                  *
+ *                                                                           *
+ *   L_32 = L_32 + (hi1*hi2)<<1 + ( (hi1*lo2)>>15 + (lo1*hi2)>>15 )<<1       *
+ *                                                                           *
+ *   This operation can also be viewed as the multiplication of two Q31      *
+ *   number and the result is also in Q31.                                   *
+ *                                                                           *
+ * Arguments:                                                                *
+ *                                                                           *
+ *  hi1         hi part of first number                                      *
+ *  lo1         lo part of first number                                      *
+ *  hi2         hi part of second number                                     *
+ *  lo2         lo part of second number                                     *
+ *                                                                           *
+ *****************************************************************************
+*/
+
+Word32 Mac_32 (Word32 L_32, Word16 hi1, Word16 lo1, Word16 hi2, Word16 lo2);
+
+/*****************************************************************************
+ * Function Mac_32_16()                                                      *
+ *                                                                           *
+ *   Multiply a 16 bit integer by a 32 bit (DPF) and accumulate with (normal)*
+ *   32 bit integer. The multiplication result is divided by 2**15           *
+ *                                                                           *
+ *                                                                           *
+ *   L_32 = L_32 + (hi1*lo2)<<1 + ((lo1*lo2)>>15)<<1                         *
+ *                                                                           *
+ * Arguments:                                                                *
+ *                                                                           *
+ *  hi          hi part of 32 bit number.                                    *
+ *  lo          lo part of 32 bit number.                                    *
+ *  n           16 bit number.                                               *
+ *                                                                           *
+ *****************************************************************************
+*/
+
+Word32 Mac_32_16 (Word32 L_32, Word16 hi, Word16 lo, Word16 n);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/makefile FFMpeg-20050127-new/libavcodec/amr/makefile
--- FFMpeg-20050127/libavcodec/amr/makefile	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/makefile	2005-01-27 23:07:31.000000000 +0000
@@ -0,0 +1,453 @@
+#****************************************************************
+#
+#      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+#                                R99   Version 3.3.0                
+#                                REL-4 Version 4.1.0                
+#
+#****************************************************************
+#
+#      File             : makefile
+#      Purpose          : gcc makefile for AMR SPC fixed point library
+#                       : and standalone encoder/decoder program
+#
+#                             make [MODE=DEBUG] [VAD=VAD#] [target [target...]]
+#
+#                         Important targets are:
+#                             default           (same as not specifying a
+#                                                target at all)
+#                                               remove all objects and libs;
+#                                               build libraries; then build
+#                                               encoder & decoder programs
+#                             depend            make new dependency list
+#                             clean             Remove all object/executable/
+#                                               verification output files
+#                             clean_depend      Clean dependency list
+#                             clean_all         clean & clean_depend & rm *.a
+#
+#
+#                         Specifying MODE=DEBUG compiles in debug mode
+#                         (libaries compiled in DEBUG mode will be linked)
+#                         Specifying MODE=WMOPS enables WMOPS counting
+#                         (FIP operation library compiled in WMOPS mode will
+#                          be linked)
+#
+#                         Specifying VAD=VAD1 compiles VAD option 1
+#                         Specifying VAD=VAD2 compiles VAD option 2
+#
+#                         The makefile uses the GNU C compiler (gcc); change
+#                         the line CC=gcc below if another compiler is desired
+#                         (CFLAGSxxx probably must be changed then as well)
+#                         
+#
+# $Id $
+#
+#****************************************************************
+
+CC := gcc
+MAKEFILENAME = makefile
+
+# Use MODE=DEBUG for debuggable library (default target builds both)
+#
+# default mode = NORM ==> no debug, no wmops
+#
+MODE=NORM
+
+# Use VAD=VAD1 for VAD option 1, or VAD=VAD2 for VAD option 2
+#
+# default mode = VAD1
+#
+VAD=VAD1
+
+#
+# compiler flags (for normal, DEBUG, and WMOPS compilation)
+#
+CFLAGS_NORM  := -O3 -DWMOPS=0
+CFLAGS_DEBUG := -g -DDEBUG -DWMOPS=0
+CFLAGS_WMOPS := -O3 -DWMOPS=1
+
+CFLAGS = -Wall -I. $(CFLAGS_$(MODE)) -D$(VAD) -DMMS_IO
+CFLAGSDEPEND = -MM $(CFLAGS)                    # for make depend
+
+
+TMP=$(MODE:NORM=)
+TMP2=$(TMP:DEBUG=_debug)
+#
+# construct SPC library name:
+#   spc.a        in normal or wmops mode
+#   spc_debug.a  in debug mode (MODE=DEBUG)
+#
+SPCLIB=spc$(TMP2:WMOPS=).a
+
+#
+# construct FIP operation library name:
+#   fipop.a        in normal mode
+#   fipop_debug.a  in debug mode (MODE=DEBUG)
+#   fipop_wmops.a  in wmops mode (MODE=WMOPS)
+#
+FIPOPLIB=fipop$(TMP2:WMOPS=_wmops).a
+
+
+#
+# source/object files
+#
+SPC_OBJS=  agc.o autocorr.o az_lsp.o bits2prm.o \
+       cl_ltp.o convolve.o c1035pf.o d_plsf.o d_plsf_5.o \
+       d_gain_c.o d_gain_p.o dec_lag6.o d1035pf.o cor_h.o \
+       enc_lag3.o enc_lag6.o g_code.o g_pitch.o int_lpc.o \
+       inter_36.o inv_sqrt.o \
+       lag_wind.o levinson.o lsp_az.o lsp_lsf.o ol_ltp.o \
+       pitch_fr.o pitch_ol.o pow2.o pre_big.o pre_proc.o pred_lt.o preemph.o \
+       prm2bits.o \
+       pstfilt.o q_gain_c.o q_gain_p.o q_plsf.o q_plsf_5.o lsfwt.o reorder.o \
+       residu.o lsp.o lpc.o ec_gains.o spreproc.o syn_filt.o \
+       weight_a.o qua_gain.o gc_pred.o q_plsf_3.o post_pro.o \
+       dec_lag3.o dec_gain.o d_plsf_3.o d4_17pf.o c4_17pf.o d3_14pf.o \
+       c3_14pf.o \
+       d2_11pf.o c2_11pf.o d2_9pf.o c2_9pf.o cbsearch.o spstproc.o gain_q.o \
+       cod_amr.o dec_amr.o sp_enc.o sp_dec.o ph_disp.o \
+       g_adapt.o calc_en.o qgain795.o qgain475.o sqrt_l.o set_sign.o s10_8pf.o \
+       bgnscd.o gmed_n.o \
+       mac_32.o ex_ctrl.o c_g_aver.o lsp_avg.o int_lsf.o c8_31pf.o d8_31pf.o \
+       p_ol_wgh.o ton_stab.o vad1.o dtx_enc.o dtx_dec.o a_refl.o \
+       b_cn_cod.o calc_cor.o hp_max.o vadname.o \
+       vad2.o r_fft.o lflg_upd.o \
+       e_homing.o d_homing.o
+
+
+ENCODER_SRCS=coder.c 
+DECODER_SRCS=decoder.c
+FIPOP_SRCS=basicop2.c count.c oper_32b.c copy.c log2.c set_zero.c \
+           strfunc.c n_proc.c sid_sync.c
+
+ENCODER_OBJS=$(ENCODER_SRCS:.c=.o) 
+DECODER_OBJS=$(DECODER_SRCS:.c=.o)
+FIPOP_OBJS=$(FIPOP_SRCS:.c=.o)
+
+ALL_SRCS=$(ENCODER_SRCS) $(DECODER_SRCS) $(FIPOP_SRCS) $(SPC_OBJS:.o=.c)
+
+#
+# default target: build standalone speech encoder and decoder
+#
+default: clean_all spclib fipoplib encoder decoder
+
+
+encoder: $(ENCODER_OBJS) $(SPCLIB) $(FIPOPLIB)
+	$(CC) -o encoder $(CFLAGS) $(ENCODER_OBJS) $(SPCLIB) $(FIPOPLIB) $(LDFLAGS)
+
+decoder: $(DECODER_OBJS) $(SPCLIB) $(FIPOPLIB)
+	$(CC) -o decoder $(CFLAGS) $(DECODER_OBJS) $(SPCLIB) $(FIPOPLIB) $(LDFLAGS)
+
+
+
+
+#
+# how to compile a .c file into a .o
+#
+.SUFFIXES: .c .h .o
+.c.o:
+	$(CC) -c $(CFLAGS) $<
+
+
+#
+# build normal and DEBUG version of SPC library from scratch
+#
+spclib_allmodes:
+	rm -f spc.a spc_debug.a
+	$(MAKE) -f $(MAKEFILENAME) $(MFLAGS) $(MAKEDEFS) MODE=      clean spclib
+	$(MAKE) -f $(MAKEFILENAME) $(MFLAGS) $(MAKEDEFS) MODE=DEBUG clean spclib
+
+#
+# build the speech coder library
+#
+spclib: $(SPC_OBJS)
+	$(AR) rc $(SPCLIB) $(SPC_OBJS)
+	ranlib $(SPCLIB)
+
+
+#
+# build normal, DEBUG, and WMOPS version of FIP operation library from scratch
+#
+fipoplib_allmodes:
+	rm -f fipop.a fipop_debug.a fipop_wmops.a
+	$(MAKE) -f $(MAKEFILENAME) $(MFLAGS) $(MAKEDEFS)            clean fipoplib
+	$(MAKE) -f $(MAKEFILENAME) $(MFLAGS) $(MAKEDEFS) MODE=DEBUG clean fipoplib
+	$(MAKE) -f $(MAKEFILENAME) $(MFLAGS) $(MAKEDEFS) MODE=WMOPS clean fipoplib
+
+#
+# build the FIP operation library
+#
+fipoplib:	$(FIPOP_OBJS)
+	$(AR) rc $(FIPOPLIB) $(FIPOP_OBJS)
+	ranlib $(FIPOPLIB)
+
+
+#
+# make / clean dependency list
+#
+depend:
+	$(MAKE) -f $(MAKEFILENAME) $(MFLAGS) $(MAKEDEFS) clean_depend
+	$(CC) $(CFLAGSDEPEND) $(ALL_SRCS) >> $(MAKEFILENAME)
+
+clean_depend:
+	chmod u+w $(MAKEFILENAME)
+	(awk 'BEGIN{f=1}{if (f) print $0}/^\# DO NOT DELETE THIS LINE -- make depend depends on it./{f=0}'\
+	    < $(MAKEFILENAME) > .depend && \
+	mv .depend $(MAKEFILENAME)) || exit 1;
+
+#
+# remove object/executable files
+#
+clean:
+	rm -f *.o core
+
+clean_all: clean
+	rm -f *.a encoder decoder
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+coder.o: coder.c typedef.h typedefs.h cnst.h n_proc.h mode.h frame.h \
+ strfunc.h sp_enc.h pre_proc.h cod_amr.h lpc.h levinson.h lsp.h \
+ q_plsf.h cl_ltp.h pitch_fr.h ton_stab.h gain_q.h gc_pred.h g_adapt.h \
+ p_ol_wgh.h vad.h vad1.h cnst_vad.h vad2.h dtx_enc.h sid_sync.h \
+ vadname.h e_homing.h
+decoder.o: decoder.c typedef.h typedefs.h n_proc.h cnst.h mode.h \
+ frame.h strfunc.h sp_dec.h dec_amr.h dtx_dec.h dtx_enc.h q_plsf.h \
+ gc_pred.h d_plsf.h c_g_aver.h ec_gains.h ph_disp.h bgnscd.h lsp_avg.h \
+ pstfilt.h preemph.h agc.h post_pro.h d_homing.h
+basicop2.o: basicop2.c typedef.h typedefs.h basic_op.h
+count.o: count.c typedef.h typedefs.h count.h
+oper_32b.o: oper_32b.c typedef.h typedefs.h basic_op.h oper_32b.h \
+ count.h
+copy.o: copy.c copy.h typedef.h typedefs.h basic_op.h count.h
+log2.o: log2.c log2.h typedef.h typedefs.h basic_op.h count.h log2.tab
+set_zero.o: set_zero.c set_zero.h typedef.h typedefs.h basic_op.h \
+ count.h
+strfunc.o: strfunc.c strfunc.h mode.h frame.h
+n_proc.o: n_proc.c
+sid_sync.o: sid_sync.c sid_sync.h typedef.h typedefs.h mode.h frame.h \
+ basic_op.h count.h
+agc.o: agc.c agc.h typedef.h typedefs.h basic_op.h count.h cnst.h \
+ inv_sqrt.h
+autocorr.o: autocorr.c autocorr.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h cnst.h
+az_lsp.o: az_lsp.c az_lsp.h typedef.h typedefs.h basic_op.h oper_32b.h \
+ count.h cnst.h grid.tab
+bits2prm.o: bits2prm.c bits2prm.h typedef.h typedefs.h mode.h \
+ basic_op.h count.h bitno.tab cnst.h
+cl_ltp.o: cl_ltp.c cl_ltp.h typedef.h typedefs.h mode.h pitch_fr.h \
+ ton_stab.h cnst.h basic_op.h count.h oper_32b.h convolve.h g_pitch.h \
+ pred_lt.h enc_lag3.h enc_lag6.h q_gain_p.h
+convolve.o: convolve.c convolve.h typedef.h typedefs.h basic_op.h \
+ count.h
+c1035pf.o: c1035pf.c c1035pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h inv_sqrt.h set_sign.h cor_h.h s10_8pf.h gray.tab
+d_plsf.o: d_plsf.c d_plsf.h typedef.h typedefs.h cnst.h mode.h \
+ basic_op.h count.h copy.h q_plsf_5.tab
+d_plsf_5.o: d_plsf_5.c d_plsf.h typedef.h typedefs.h cnst.h mode.h \
+ basic_op.h count.h lsp_lsf.h reorder.h copy.h q_plsf_5.tab
+d_gain_c.o: d_gain_c.c d_gain_c.h typedef.h typedefs.h mode.h \
+ gc_pred.h basic_op.h oper_32b.h count.h cnst.h log2.h pow2.h \
+ gains.tab
+d_gain_p.o: d_gain_p.c d_gain_p.h typedef.h typedefs.h mode.h \
+ basic_op.h oper_32b.h count.h cnst.h gains.tab
+dec_lag6.o: dec_lag6.c dec_lag6.h typedef.h typedefs.h basic_op.h \
+ count.h
+d1035pf.o: d1035pf.c d1035pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h gray.tab
+cor_h.o: cor_h.c cor_h.h typedef.h typedefs.h cnst.h basic_op.h \
+ count.h inv_sqrt.h
+enc_lag3.o: enc_lag3.c enc_lag3.h typedef.h typedefs.h basic_op.h \
+ count.h cnst.h
+enc_lag6.o: enc_lag6.c enc_lag6.h typedef.h typedefs.h basic_op.h \
+ count.h
+g_code.o: g_code.c g_code.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+g_pitch.o: g_pitch.c g_pitch.h typedef.h typedefs.h mode.h basic_op.h \
+ oper_32b.h count.h cnst.h
+int_lpc.o: int_lpc.c int_lpc.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h lsp_az.h
+inter_36.o: inter_36.c inter_36.h typedef.h typedefs.h basic_op.h \
+ count.h cnst.h inter_36.tab
+inv_sqrt.o: inv_sqrt.c inv_sqrt.h typedef.h typedefs.h basic_op.h \
+ count.h inv_sqrt.tab
+lag_wind.o: lag_wind.c lag_wind.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h lag_wind.tab
+levinson.o: levinson.c levinson.h typedef.h typedefs.h cnst.h \
+ basic_op.h oper_32b.h count.h
+lsp_az.o: lsp_az.c lsp_az.h typedef.h typedefs.h basic_op.h oper_32b.h \
+ count.h
+lsp_lsf.o: lsp_lsf.c lsp_lsf.h typedef.h typedefs.h basic_op.h count.h \
+ lsp_lsf.tab
+ol_ltp.o: ol_ltp.c ol_ltp.h typedef.h typedefs.h mode.h p_ol_wgh.h \
+ vad.h vad1.h cnst_vad.h vad2.h cnst.h pitch_ol.h count.h basic_op.h
+pitch_fr.o: pitch_fr.c pitch_fr.h typedef.h typedefs.h mode.h \
+ basic_op.h oper_32b.h count.h cnst.h enc_lag3.h enc_lag6.h inter_36.h \
+ inv_sqrt.h convolve.h
+pitch_ol.o: pitch_ol.c pitch_ol.h typedef.h typedefs.h mode.h vad.h \
+ vad1.h cnst_vad.h vad2.h basic_op.h oper_32b.h count.h cnst.h \
+ inv_sqrt.h calc_cor.h hp_max.h
+pow2.o: pow2.c pow2.h typedef.h typedefs.h basic_op.h count.h pow2.tab
+pre_big.o: pre_big.c pre_big.h typedef.h typedefs.h mode.h cnst.h \
+ basic_op.h oper_32b.h syn_filt.h weight_a.h residu.h count.h
+pre_proc.o: pre_proc.c pre_proc.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h
+pred_lt.o: pred_lt.c pred_lt.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+preemph.o: preemph.c preemph.h typedef.h typedefs.h basic_op.h count.h
+prm2bits.o: prm2bits.c prm2bits.h typedef.h typedefs.h mode.h \
+ basic_op.h count.h bitno.tab cnst.h
+pstfilt.o: pstfilt.c pstfilt.h typedef.h typedefs.h mode.h cnst.h \
+ preemph.h agc.h basic_op.h set_zero.h weight_a.h residu.h copy.h \
+ syn_filt.h count.h
+q_gain_c.o: q_gain_c.c q_gain_c.h typedef.h typedefs.h mode.h \
+ gc_pred.h basic_op.h oper_32b.h count.h log2.h pow2.h gains.tab
+q_gain_p.o: q_gain_p.c q_gain_p.h typedef.h typedefs.h mode.h \
+ basic_op.h oper_32b.h count.h cnst.h gains.tab
+q_plsf.o: q_plsf.c q_plsf.h typedef.h typedefs.h cnst.h mode.h \
+ basic_op.h
+q_plsf_5.o: q_plsf_5.c q_plsf.h typedef.h typedefs.h cnst.h mode.h \
+ basic_op.h count.h lsp_lsf.h reorder.h lsfwt.h q_plsf_5.tab
+lsfwt.o: lsfwt.c lsfwt.h typedef.h typedefs.h cnst.h basic_op.h \
+ count.h
+reorder.o: reorder.c reorder.h typedef.h typedefs.h basic_op.h count.h
+residu.o: residu.c residu.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+lsp.o: lsp.c lsp.h typedef.h typedefs.h q_plsf.h cnst.h mode.h \
+ basic_op.h oper_32b.h copy.h az_lsp.h int_lpc.h count.h lsp.tab
+lpc.o: lpc.c lpc.h typedef.h typedefs.h levinson.h cnst.h mode.h \
+ basic_op.h oper_32b.h autocorr.h lag_wind.h count.h window.tab
+ec_gains.o: ec_gains.c ec_gains.h typedef.h typedefs.h gc_pred.h \
+ mode.h basic_op.h oper_32b.h count.h cnst.h gmed_n.h gains.tab
+spreproc.o: spreproc.c spreproc.h cnst.h mode.h typedef.h typedefs.h \
+ basic_op.h oper_32b.h weight_a.h syn_filt.h residu.h copy.h count.h
+syn_filt.o: syn_filt.c syn_filt.h typedef.h typedefs.h basic_op.h \
+ count.h cnst.h
+weight_a.o: weight_a.c weight_a.h typedef.h typedefs.h basic_op.h \
+ count.h cnst.h
+qua_gain.o: qua_gain.c qua_gain.h typedef.h typedefs.h gc_pred.h \
+ mode.h basic_op.h oper_32b.h count.h cnst.h pow2.h qua_gain.tab
+gc_pred.o: gc_pred.c gc_pred.h typedef.h typedefs.h mode.h basic_op.h \
+ oper_32b.h cnst.h count.h log2.h copy.h
+q_plsf_3.o: q_plsf_3.c q_plsf.h typedef.h typedefs.h cnst.h mode.h \
+ basic_op.h count.h lsp_lsf.h reorder.h lsfwt.h copy.h q_plsf_3.tab
+post_pro.o: post_pro.c post_pro.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h
+dec_lag3.o: dec_lag3.c dec_lag3.h typedef.h typedefs.h basic_op.h \
+ count.h
+dec_gain.o: dec_gain.c dec_gain.h typedef.h typedefs.h gc_pred.h \
+ mode.h basic_op.h oper_32b.h count.h cnst.h pow2.h log2.h \
+ qua_gain.tab qgain475.tab
+d_plsf_3.o: d_plsf_3.c d_plsf.h typedef.h typedefs.h cnst.h mode.h \
+ basic_op.h count.h lsp_lsf.h reorder.h copy.h q_plsf_3.tab
+d4_17pf.o: d4_17pf.c d4_17pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h gray.tab
+c4_17pf.o: c4_17pf.c c4_17pf.h typedef.h typedefs.h basic_op.h count.h \
+ inv_sqrt.h cnst.h cor_h.h set_sign.h gray.tab
+d3_14pf.o: d3_14pf.c d3_14pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+c3_14pf.o: c3_14pf.c c3_14pf.h typedef.h typedefs.h basic_op.h count.h \
+ inv_sqrt.h cnst.h cor_h.h set_sign.h
+d2_11pf.o: d2_11pf.c d2_11pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+c2_11pf.o: c2_11pf.c c2_11pf.h typedef.h typedefs.h basic_op.h count.h \
+ inv_sqrt.h cnst.h cor_h.h set_sign.h c2_11pf.tab
+d2_9pf.o: d2_9pf.c d2_9pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h c2_9pf.tab
+c2_9pf.o: c2_9pf.c c2_9pf.h typedef.h typedefs.h basic_op.h count.h \
+ inv_sqrt.h cnst.h cor_h.h set_sign.h c2_9pf.tab
+cbsearch.o: cbsearch.c cbsearch.h typedef.h typedefs.h mode.h c2_9pf.h \
+ c2_11pf.h c3_14pf.h c4_17pf.h c8_31pf.h c1035pf.h basic_op.h count.h \
+ cnst.h
+spstproc.o: spstproc.c spstproc.h typedef.h typedefs.h mode.h \
+ basic_op.h oper_32b.h count.h syn_filt.h cnst.h
+gain_q.o: gain_q.c gain_q.h typedef.h typedefs.h mode.h gc_pred.h \
+ g_adapt.h basic_op.h count.h qua_gain.h cnst.h g_code.h q_gain_c.h \
+ calc_en.h qgain795.h qgain475.h set_zero.h
+cod_amr.o: cod_amr.c cod_amr.h typedef.h typedefs.h cnst.h mode.h \
+ lpc.h levinson.h lsp.h q_plsf.h cl_ltp.h pitch_fr.h ton_stab.h \
+ gain_q.h gc_pred.h g_adapt.h p_ol_wgh.h vad.h vad1.h cnst_vad.h \
+ vad2.h dtx_enc.h basic_op.h count.h copy.h set_zero.h qua_gain.h \
+ pre_big.h ol_ltp.h spreproc.h pred_lt.h spstproc.h cbsearch.h \
+ convolve.h
+dec_amr.o: dec_amr.c dec_amr.h typedef.h typedefs.h cnst.h mode.h \
+ dtx_dec.h dtx_enc.h q_plsf.h gc_pred.h d_plsf.h c_g_aver.h frame.h \
+ ec_gains.h ph_disp.h bgnscd.h lsp_avg.h basic_op.h count.h copy.h \
+ set_zero.h syn_filt.h agc.h int_lpc.h dec_gain.h dec_lag3.h \
+ dec_lag6.h d2_9pf.h d2_11pf.h d3_14pf.h d4_17pf.h d8_31pf.h d1035pf.h \
+ pred_lt.h d_gain_p.h d_gain_c.h int_lsf.h lsp_lsf.h ex_ctrl.h \
+ sqrt_l.h lsp.tab bitno.tab b_cn_cod.h
+sp_enc.o: sp_enc.c sp_enc.h typedef.h typedefs.h cnst.h pre_proc.h \
+ mode.h cod_amr.h lpc.h levinson.h lsp.h q_plsf.h cl_ltp.h pitch_fr.h \
+ ton_stab.h gain_q.h gc_pred.h g_adapt.h p_ol_wgh.h vad.h vad1.h \
+ cnst_vad.h vad2.h dtx_enc.h basic_op.h count.h set_zero.h prm2bits.h
+sp_dec.o: sp_dec.c sp_dec.h typedef.h typedefs.h cnst.h dec_amr.h \
+ mode.h dtx_dec.h dtx_enc.h q_plsf.h gc_pred.h d_plsf.h c_g_aver.h \
+ frame.h ec_gains.h ph_disp.h bgnscd.h lsp_avg.h pstfilt.h preemph.h \
+ agc.h post_pro.h basic_op.h count.h set_zero.h bits2prm.h
+ph_disp.o: ph_disp.c ph_disp.h typedef.h typedefs.h mode.h basic_op.h \
+ count.h cnst.h copy.h ph_disp.tab
+g_adapt.o: g_adapt.c g_adapt.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h cnst.h gmed_n.h
+calc_en.o: calc_en.c calc_en.h typedef.h typedefs.h mode.h basic_op.h \
+ oper_32b.h count.h cnst.h log2.h
+qgain795.o: qgain795.c qgain795.h typedef.h typedefs.h g_adapt.h \
+ basic_op.h oper_32b.h count.h cnst.h log2.h pow2.h sqrt_l.h calc_en.h \
+ mode.h q_gain_p.h mac_32.h gains.tab
+qgain475.o: qgain475.c qgain475.h typedef.h typedefs.h gc_pred.h \
+ mode.h basic_op.h mac_32.h oper_32b.h count.h cnst.h pow2.h log2.h \
+ qgain475.tab
+sqrt_l.o: sqrt_l.c sqrt_l.h typedef.h typedefs.h basic_op.h count.h \
+ sqrt_l.tab
+set_sign.o: set_sign.c set_sign.h typedef.h typedefs.h basic_op.h \
+ count.h inv_sqrt.h cnst.h
+s10_8pf.o: s10_8pf.c s10_8pf.h typedef.h typedefs.h cnst.h basic_op.h \
+ count.h
+bgnscd.o: bgnscd.c bgnscd.h typedef.h typedefs.h cnst.h basic_op.h \
+ count.h copy.h set_zero.h gmed_n.h sqrt_l.h
+gmed_n.o: gmed_n.c gmed_n.h typedef.h typedefs.h basic_op.h count.h
+mac_32.o: mac_32.c mac_32.h typedef.h typedefs.h basic_op.h oper_32b.h \
+ count.h
+ex_ctrl.o: ex_ctrl.c ex_ctrl.h typedef.h typedefs.h cnst.h basic_op.h \
+ count.h copy.h set_zero.h gmed_n.h sqrt_l.h
+c_g_aver.o: c_g_aver.c c_g_aver.h typedef.h typedefs.h mode.h cnst.h \
+ basic_op.h count.h set_zero.h
+lsp_avg.o: lsp_avg.c lsp_avg.h typedef.h typedefs.h cnst.h basic_op.h \
+ oper_32b.h count.h q_plsf_5.tab copy.h
+int_lsf.o: int_lsf.c int_lsf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+c8_31pf.o: c8_31pf.c c8_31pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h inv_sqrt.h cor_h.h set_sign.h s10_8pf.h
+d8_31pf.o: d8_31pf.c d8_31pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+p_ol_wgh.o: p_ol_wgh.c p_ol_wgh.h typedef.h typedefs.h mode.h vad.h \
+ vad1.h cnst_vad.h vad2.h basic_op.h oper_32b.h count.h cnst.h \
+ corrwght.tab gmed_n.h inv_sqrt.h calc_cor.h hp_max.h
+ton_stab.o: ton_stab.c ton_stab.h typedef.h typedefs.h mode.h cnst.h \
+ basic_op.h count.h oper_32b.h set_zero.h copy.h
+vad1.o: vad1.c vad.h vad1.h typedef.h typedefs.h cnst_vad.h vad2.h \
+ basic_op.h count.h oper_32b.h
+dtx_enc.o: dtx_enc.c dtx_enc.h typedef.h typedefs.h cnst.h q_plsf.h \
+ mode.h gc_pred.h basic_op.h oper_32b.h copy.h set_zero.h log2.h \
+ lsp_lsf.h reorder.h count.h lsp.tab
+dtx_dec.o: dtx_dec.c dtx_dec.h typedef.h typedefs.h dtx_enc.h cnst.h \
+ q_plsf.h mode.h gc_pred.h d_plsf.h c_g_aver.h frame.h basic_op.h \
+ oper_32b.h copy.h set_zero.h log2.h lsp_az.h pow2.h a_refl.h \
+ b_cn_cod.h syn_filt.h lsp_lsf.h reorder.h count.h q_plsf_5.tab \
+ lsp.tab
+a_refl.o: a_refl.c a_refl.h typedef.h typedefs.h basic_op.h oper_32b.h \
+ count.h cnst.h
+b_cn_cod.o: b_cn_cod.c b_cn_cod.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h cnst.h window.tab
+calc_cor.o: calc_cor.c calc_cor.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h cnst.h
+hp_max.o: hp_max.c hp_max.h typedef.h typedefs.h basic_op.h oper_32b.h \
+ count.h cnst.h
+vadname.o: vadname.c vadname.h
+vad2.o: vad2.c typedef.h typedefs.h cnst.h basic_op.h oper_32b.h \
+ count.h log2.h pow2.h vad2.h
+r_fft.o: r_fft.c typedef.h typedefs.h cnst.h basic_op.h oper_32b.h \
+ count.h vad2.h
+lflg_upd.o: lflg_upd.c typedef.h typedefs.h cnst.h basic_op.h \
+ oper_32b.h count.h vad2.h mode.h
+e_homing.o: e_homing.c e_homing.h typedef.h typedefs.h cnst.h
+d_homing.o: d_homing.c d_homing.h typedef.h typedefs.h mode.h \
+ bits2prm.h d_homing.tab bitno.tab cnst.h
diff -Nur FFMpeg-20050127/libavcodec/amr/makefile.cc FFMpeg-20050127-new/libavcodec/amr/makefile.cc
--- FFMpeg-20050127/libavcodec/amr/makefile.cc	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/makefile.cc	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,453 @@
+#****************************************************************
+#
+#      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+#                                R99   Version 3.3.0                
+#                                REL-4 Version 4.1.0                
+#
+#****************************************************************
+#
+#      File             : makefile
+#      Purpose          : cc makefile for AMR SPC fixed point library
+#                       : and standalone encoder/decoder program
+#
+#                             make [MODE=DEBUG] [VAD=VAD#] [target [target...]]
+#
+#                         Important targets are:
+#                             default           (same as not specifying a
+#                                                target at all)
+#                                               remove all objects and libs;
+#                                               build libraries; then build
+#                                               encoder & decoder programs
+#                             depend            make new dependency list
+#                             clean             Remove all object/executable/
+#                                               verification output files
+#                             clean_depend      Clean dependency list
+#                             clean_all         clean & clean_depend & rm *.a
+#
+#
+#                         Specifying MODE=DEBUG compiles in debug mode
+#                         (libaries compiled in DEBUG mode will be linked)
+#                         Specifying MODE=WMOPS enables WMOPS counting
+#                         (FIP operation library compiled in WMOPS mode will
+#                          be linked)
+#
+#                         Specifying VAD=VAD1 compiles VAD option 1
+#                         Specifying VAD=VAD2 compiles VAD option 2
+#
+#                         The makefile uses the GNU C compiler (gcc); change
+#                         the line CC=gcc below if another compiler is desired
+#                         (CFLAGSxxx probably must be changed then as well)
+#                         
+#
+# $Id $
+#
+#****************************************************************
+
+CC = CC
+MAKEFILENAME = makefile.cc
+
+# Use MODE=DEBUG for debuggable library (default target builds both)
+#
+# default mode = NORM ==> no debug, no wmops
+#
+MODE=NORM
+
+# Use VAD=VAD1 for VAD option 1, or VAD=VAD2 for VAD option 2
+#
+# default mode = VAD1
+#
+VAD=VAD1
+
+#
+# compiler flags (for normal, DEBUG, and WMOPS compilation)
+#
+CFLAGS_NORM  = -O4 -DWMOPS=0
+CFLAGS_DEBUG = -g -DDEBUG -DWMOPS=0
+CFLAGS_WMOPS = -O4 -DWMOPS=1
+
+CFLAGS = -I. $(CFLAGS_$(MODE)) -D$(VAD)
+CFLAGSDEPEND = -MM $(CFLAGS)                    # for make depend
+
+
+TMP=$(MODE:NORM=)
+TMP2=$(TMP:DEBUG=_debug)
+#
+# construct SPC library name:
+#   spc.a        in normal or wmops mode
+#   spc_debug.a  in debug mode (MODE=DEBUG)
+#
+SPCLIB=spc$(TMP2:WMOPS=).a
+
+#
+# construct FIP operation library name:
+#   fipop.a        in normal mode
+#   fipop_debug.a  in debug mode (MODE=DEBUG)
+#   fipop_wmops.a  in wmops mode (MODE=WMOPS)
+#
+FIPOPLIB=fipop$(TMP2:WMOPS=_wmops).a
+
+
+#
+# source/object files
+#
+SPC_OBJS=  agc.o autocorr.o az_lsp.o bits2prm.o \
+       cl_ltp.o convolve.o c1035pf.o d_plsf.o d_plsf_5.o \
+       d_gain_c.o d_gain_p.o dec_lag6.o d1035pf.o cor_h.o \
+       enc_lag3.o enc_lag6.o g_code.o g_pitch.o int_lpc.o \
+       inter_36.o inv_sqrt.o \
+       lag_wind.o levinson.o lsp_az.o lsp_lsf.o ol_ltp.o \
+       pitch_fr.o pitch_ol.o pow2.o pre_big.o pre_proc.o pred_lt.o preemph.o \
+       prm2bits.o \
+       pstfilt.o q_gain_c.o q_gain_p.o q_plsf.o q_plsf_5.o lsfwt.o reorder.o \
+       residu.o lsp.o lpc.o ec_gains.o spreproc.o syn_filt.o \
+       weight_a.o qua_gain.o gc_pred.o q_plsf_3.o post_pro.o \
+       dec_lag3.o dec_gain.o d_plsf_3.o d4_17pf.o c4_17pf.o d3_14pf.o \
+       c3_14pf.o \
+       d2_11pf.o c2_11pf.o d2_9pf.o c2_9pf.o cbsearch.o spstproc.o gain_q.o \
+       cod_amr.o dec_amr.o sp_enc.o sp_dec.o ph_disp.o \
+       g_adapt.o calc_en.o qgain795.o qgain475.o sqrt_l.o set_sign.o s10_8pf.o \
+       bgnscd.o gmed_n.o \
+       mac_32.o ex_ctrl.o c_g_aver.o lsp_avg.o int_lsf.o c8_31pf.o d8_31pf.o \
+       p_ol_wgh.o ton_stab.o vad1.o dtx_enc.o dtx_dec.o a_refl.o \
+       b_cn_cod.o calc_cor.o hp_max.o vadname.o \
+       vad2.o r_fft.o lflg_upd.o \
+       e_homing.o d_homing.o
+
+
+ENCODER_SRCS=coder.c 
+DECODER_SRCS=decoder.c
+FIPOP_SRCS=basicop2.c count.c oper_32b.c copy.c log2.c set_zero.c \
+           strfunc.c n_proc.c sid_sync.c
+
+ENCODER_OBJS=$(ENCODER_SRCS:.c=.o) 
+DECODER_OBJS=$(DECODER_SRCS:.c=.o)
+FIPOP_OBJS=$(FIPOP_SRCS:.c=.o)
+
+ALL_SRCS=$(ENCODER_SRCS) $(DECODER_SRCS) $(FIPOP_SRCS) $(SPC_OBJS:.o=.c)
+
+#
+# default target: build standalone speech encoder and decoder
+#
+default: clean_all spclib fipoplib encoder decoder
+
+
+encoder: $(ENCODER_OBJS) $(SPCLIB) $(FIPOPLIB)
+	$(CC) -o encoder $(CFLAGS) $(ENCODER_OBJS) $(SPCLIB) $(FIPOPLIB) $(LDFLAGS)
+
+decoder: $(DECODER_OBJS) $(SPCLIB) $(FIPOPLIB)
+	$(CC) -o decoder $(CFLAGS) $(DECODER_OBJS) $(SPCLIB) $(FIPOPLIB) $(LDFLAGS)
+
+
+
+
+#
+# how to compile a .c file into a .o
+#
+.SUFFIXES: .c .h .o
+.c.o:
+	$(CC) -c $(CFLAGS) $<
+
+
+#
+# build normal and DEBUG version of SPC library from scratch
+#
+spclib_allmodes:
+	rm -f spc.a spc_debug.a
+	$(MAKE) -f $(MAKEFILENAME) $(MFLAGS) $(MAKEDEFS) MODE=      clean spclib
+	$(MAKE) -f $(MAKEFILENAME) $(MFLAGS) $(MAKEDEFS) MODE=DEBUG clean spclib
+
+#
+# build the speech coder library
+#
+spclib: $(SPC_OBJS)
+	$(AR) rc $(SPCLIB) $(SPC_OBJS)
+	ranlib $(SPCLIB)
+
+
+#
+# build normal, DEBUG, and WMOPS version of FIP operation library from scratch
+#
+fipoplib_allmodes:
+	rm -f fipop.a fipop_debug.a fipop_wmops.a
+	$(MAKE) -f $(MAKEFILENAME) $(MFLAGS) $(MAKEDEFS)            clean fipoplib
+	$(MAKE) -f $(MAKEFILENAME) $(MFLAGS) $(MAKEDEFS) MODE=DEBUG clean fipoplib
+	$(MAKE) -f $(MAKEFILENAME) $(MFLAGS) $(MAKEDEFS) MODE=WMOPS clean fipoplib
+
+#
+# build the FIP operation library
+#
+fipoplib:	$(FIPOP_OBJS)
+	$(AR) rc $(FIPOPLIB) $(FIPOP_OBJS)
+	ranlib $(FIPOPLIB)
+
+
+#
+# make / clean dependency list
+#
+depend:
+	$(MAKE) -f $(MAKEFILENAME) $(MFLAGS) $(MAKEDEFS) clean_depend
+	$(CC) $(CFLAGSDEPEND) $(ALL_SRCS) >> $(MAKEFILENAME)
+
+clean_depend:
+	chmod u+w $(MAKEFILENAME)
+	(awk 'BEGIN{f=1}{if (f) print $0}/^\# DO NOT DELETE THIS LINE -- make depend depends on it./{f=0}'\
+	    < $(MAKEFILENAME) > .depend && \
+	mv .depend $(MAKEFILENAME)) || exit 1;
+
+#
+# remove object/executable files
+#
+clean:
+	rm -f *.o core
+
+clean_all: clean
+	rm -f *.a encoder decoder
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+coder.o: coder.c typedef.h typedefs.h cnst.h n_proc.h mode.h frame.h \
+ strfunc.h sp_enc.h pre_proc.h cod_amr.h lpc.h levinson.h lsp.h \
+ q_plsf.h cl_ltp.h pitch_fr.h ton_stab.h gain_q.h gc_pred.h g_adapt.h \
+ p_ol_wgh.h vad.h vad1.h cnst_vad.h vad2.h dtx_enc.h sid_sync.h \
+ vadname.h e_homing.h
+decoder.o: decoder.c typedef.h typedefs.h n_proc.h cnst.h mode.h \
+ frame.h strfunc.h sp_dec.h dec_amr.h dtx_dec.h dtx_enc.h q_plsf.h \
+ gc_pred.h d_plsf.h c_g_aver.h ec_gains.h ph_disp.h bgnscd.h lsp_avg.h \
+ pstfilt.h preemph.h agc.h post_pro.h d_homing.h
+basicop2.o: basicop2.c typedef.h typedefs.h basic_op.h
+count.o: count.c typedef.h typedefs.h count.h
+oper_32b.o: oper_32b.c typedef.h typedefs.h basic_op.h oper_32b.h \
+ count.h
+copy.o: copy.c copy.h typedef.h typedefs.h basic_op.h count.h
+log2.o: log2.c log2.h typedef.h typedefs.h basic_op.h count.h log2.tab
+set_zero.o: set_zero.c set_zero.h typedef.h typedefs.h basic_op.h \
+ count.h
+strfunc.o: strfunc.c strfunc.h mode.h frame.h
+n_proc.o: n_proc.c
+sid_sync.o: sid_sync.c sid_sync.h typedef.h typedefs.h mode.h frame.h \
+ basic_op.h count.h
+agc.o: agc.c agc.h typedef.h typedefs.h basic_op.h count.h cnst.h \
+ inv_sqrt.h
+autocorr.o: autocorr.c autocorr.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h cnst.h
+az_lsp.o: az_lsp.c az_lsp.h typedef.h typedefs.h basic_op.h oper_32b.h \
+ count.h cnst.h grid.tab
+bits2prm.o: bits2prm.c bits2prm.h typedef.h typedefs.h mode.h \
+ basic_op.h count.h bitno.tab cnst.h
+cl_ltp.o: cl_ltp.c cl_ltp.h typedef.h typedefs.h mode.h pitch_fr.h \
+ ton_stab.h cnst.h basic_op.h count.h oper_32b.h convolve.h g_pitch.h \
+ pred_lt.h enc_lag3.h enc_lag6.h q_gain_p.h
+convolve.o: convolve.c convolve.h typedef.h typedefs.h basic_op.h \
+ count.h
+c1035pf.o: c1035pf.c c1035pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h inv_sqrt.h set_sign.h cor_h.h s10_8pf.h gray.tab
+d_plsf.o: d_plsf.c d_plsf.h typedef.h typedefs.h cnst.h mode.h \
+ basic_op.h count.h copy.h q_plsf_5.tab
+d_plsf_5.o: d_plsf_5.c d_plsf.h typedef.h typedefs.h cnst.h mode.h \
+ basic_op.h count.h lsp_lsf.h reorder.h copy.h q_plsf_5.tab
+d_gain_c.o: d_gain_c.c d_gain_c.h typedef.h typedefs.h mode.h \
+ gc_pred.h basic_op.h oper_32b.h count.h cnst.h log2.h pow2.h \
+ gains.tab
+d_gain_p.o: d_gain_p.c d_gain_p.h typedef.h typedefs.h mode.h \
+ basic_op.h oper_32b.h count.h cnst.h gains.tab
+dec_lag6.o: dec_lag6.c dec_lag6.h typedef.h typedefs.h basic_op.h \
+ count.h
+d1035pf.o: d1035pf.c d1035pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h gray.tab
+cor_h.o: cor_h.c cor_h.h typedef.h typedefs.h cnst.h basic_op.h \
+ count.h inv_sqrt.h
+enc_lag3.o: enc_lag3.c enc_lag3.h typedef.h typedefs.h basic_op.h \
+ count.h cnst.h
+enc_lag6.o: enc_lag6.c enc_lag6.h typedef.h typedefs.h basic_op.h \
+ count.h
+g_code.o: g_code.c g_code.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+g_pitch.o: g_pitch.c g_pitch.h typedef.h typedefs.h mode.h basic_op.h \
+ oper_32b.h count.h cnst.h
+int_lpc.o: int_lpc.c int_lpc.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h lsp_az.h
+inter_36.o: inter_36.c inter_36.h typedef.h typedefs.h basic_op.h \
+ count.h cnst.h inter_36.tab
+inv_sqrt.o: inv_sqrt.c inv_sqrt.h typedef.h typedefs.h basic_op.h \
+ count.h inv_sqrt.tab
+lag_wind.o: lag_wind.c lag_wind.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h lag_wind.tab
+levinson.o: levinson.c levinson.h typedef.h typedefs.h cnst.h \
+ basic_op.h oper_32b.h count.h
+lsp_az.o: lsp_az.c lsp_az.h typedef.h typedefs.h basic_op.h oper_32b.h \
+ count.h
+lsp_lsf.o: lsp_lsf.c lsp_lsf.h typedef.h typedefs.h basic_op.h count.h \
+ lsp_lsf.tab
+ol_ltp.o: ol_ltp.c ol_ltp.h typedef.h typedefs.h mode.h p_ol_wgh.h \
+ vad.h vad1.h cnst_vad.h vad2.h cnst.h pitch_ol.h count.h basic_op.h
+pitch_fr.o: pitch_fr.c pitch_fr.h typedef.h typedefs.h mode.h \
+ basic_op.h oper_32b.h count.h cnst.h enc_lag3.h enc_lag6.h inter_36.h \
+ inv_sqrt.h convolve.h
+pitch_ol.o: pitch_ol.c pitch_ol.h typedef.h typedefs.h mode.h vad.h \
+ vad1.h cnst_vad.h vad2.h basic_op.h oper_32b.h count.h cnst.h \
+ inv_sqrt.h calc_cor.h hp_max.h
+pow2.o: pow2.c pow2.h typedef.h typedefs.h basic_op.h count.h pow2.tab
+pre_big.o: pre_big.c pre_big.h typedef.h typedefs.h mode.h cnst.h \
+ basic_op.h oper_32b.h syn_filt.h weight_a.h residu.h count.h
+pre_proc.o: pre_proc.c pre_proc.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h
+pred_lt.o: pred_lt.c pred_lt.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+preemph.o: preemph.c preemph.h typedef.h typedefs.h basic_op.h count.h
+prm2bits.o: prm2bits.c prm2bits.h typedef.h typedefs.h mode.h \
+ basic_op.h count.h bitno.tab cnst.h
+pstfilt.o: pstfilt.c pstfilt.h typedef.h typedefs.h mode.h cnst.h \
+ preemph.h agc.h basic_op.h set_zero.h weight_a.h residu.h copy.h \
+ syn_filt.h count.h
+q_gain_c.o: q_gain_c.c q_gain_c.h typedef.h typedefs.h mode.h \
+ gc_pred.h basic_op.h oper_32b.h count.h log2.h pow2.h gains.tab
+q_gain_p.o: q_gain_p.c q_gain_p.h typedef.h typedefs.h mode.h \
+ basic_op.h oper_32b.h count.h cnst.h gains.tab
+q_plsf.o: q_plsf.c q_plsf.h typedef.h typedefs.h cnst.h mode.h \
+ basic_op.h
+q_plsf_5.o: q_plsf_5.c q_plsf.h typedef.h typedefs.h cnst.h mode.h \
+ basic_op.h count.h lsp_lsf.h reorder.h lsfwt.h q_plsf_5.tab
+lsfwt.o: lsfwt.c lsfwt.h typedef.h typedefs.h cnst.h basic_op.h \
+ count.h
+reorder.o: reorder.c reorder.h typedef.h typedefs.h basic_op.h count.h
+residu.o: residu.c residu.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+lsp.o: lsp.c lsp.h typedef.h typedefs.h q_plsf.h cnst.h mode.h \
+ basic_op.h oper_32b.h copy.h az_lsp.h int_lpc.h count.h lsp.tab
+lpc.o: lpc.c lpc.h typedef.h typedefs.h levinson.h cnst.h mode.h \
+ basic_op.h oper_32b.h autocorr.h lag_wind.h count.h window.tab
+ec_gains.o: ec_gains.c ec_gains.h typedef.h typedefs.h gc_pred.h \
+ mode.h basic_op.h oper_32b.h count.h cnst.h gmed_n.h gains.tab
+spreproc.o: spreproc.c spreproc.h cnst.h mode.h typedef.h typedefs.h \
+ basic_op.h oper_32b.h weight_a.h syn_filt.h residu.h copy.h count.h
+syn_filt.o: syn_filt.c syn_filt.h typedef.h typedefs.h basic_op.h \
+ count.h cnst.h
+weight_a.o: weight_a.c weight_a.h typedef.h typedefs.h basic_op.h \
+ count.h cnst.h
+qua_gain.o: qua_gain.c qua_gain.h typedef.h typedefs.h gc_pred.h \
+ mode.h basic_op.h oper_32b.h count.h cnst.h pow2.h qua_gain.tab
+gc_pred.o: gc_pred.c gc_pred.h typedef.h typedefs.h mode.h basic_op.h \
+ oper_32b.h cnst.h count.h log2.h copy.h
+q_plsf_3.o: q_plsf_3.c q_plsf.h typedef.h typedefs.h cnst.h mode.h \
+ basic_op.h count.h lsp_lsf.h reorder.h lsfwt.h copy.h q_plsf_3.tab
+post_pro.o: post_pro.c post_pro.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h
+dec_lag3.o: dec_lag3.c dec_lag3.h typedef.h typedefs.h basic_op.h \
+ count.h
+dec_gain.o: dec_gain.c dec_gain.h typedef.h typedefs.h gc_pred.h \
+ mode.h basic_op.h oper_32b.h count.h cnst.h pow2.h log2.h \
+ qua_gain.tab qgain475.tab
+d_plsf_3.o: d_plsf_3.c d_plsf.h typedef.h typedefs.h cnst.h mode.h \
+ basic_op.h count.h lsp_lsf.h reorder.h copy.h q_plsf_3.tab
+d4_17pf.o: d4_17pf.c d4_17pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h gray.tab
+c4_17pf.o: c4_17pf.c c4_17pf.h typedef.h typedefs.h basic_op.h count.h \
+ inv_sqrt.h cnst.h cor_h.h set_sign.h gray.tab
+d3_14pf.o: d3_14pf.c d3_14pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+c3_14pf.o: c3_14pf.c c3_14pf.h typedef.h typedefs.h basic_op.h count.h \
+ inv_sqrt.h cnst.h cor_h.h set_sign.h
+d2_11pf.o: d2_11pf.c d2_11pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+c2_11pf.o: c2_11pf.c c2_11pf.h typedef.h typedefs.h basic_op.h count.h \
+ inv_sqrt.h cnst.h cor_h.h set_sign.h c2_11pf.tab
+d2_9pf.o: d2_9pf.c d2_9pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h c2_9pf.tab
+c2_9pf.o: c2_9pf.c c2_9pf.h typedef.h typedefs.h basic_op.h count.h \
+ inv_sqrt.h cnst.h cor_h.h set_sign.h c2_9pf.tab
+cbsearch.o: cbsearch.c cbsearch.h typedef.h typedefs.h mode.h c2_9pf.h \
+ c2_11pf.h c3_14pf.h c4_17pf.h c8_31pf.h c1035pf.h basic_op.h count.h \
+ cnst.h
+spstproc.o: spstproc.c spstproc.h typedef.h typedefs.h mode.h \
+ basic_op.h oper_32b.h count.h syn_filt.h cnst.h
+gain_q.o: gain_q.c gain_q.h typedef.h typedefs.h mode.h gc_pred.h \
+ g_adapt.h basic_op.h count.h qua_gain.h cnst.h g_code.h q_gain_c.h \
+ calc_en.h qgain795.h qgain475.h set_zero.h
+cod_amr.o: cod_amr.c cod_amr.h typedef.h typedefs.h cnst.h mode.h \
+ lpc.h levinson.h lsp.h q_plsf.h cl_ltp.h pitch_fr.h ton_stab.h \
+ gain_q.h gc_pred.h g_adapt.h p_ol_wgh.h vad.h vad1.h cnst_vad.h \
+ vad2.h dtx_enc.h basic_op.h count.h copy.h set_zero.h qua_gain.h \
+ pre_big.h ol_ltp.h spreproc.h pred_lt.h spstproc.h cbsearch.h \
+ convolve.h
+dec_amr.o: dec_amr.c dec_amr.h typedef.h typedefs.h cnst.h mode.h \
+ dtx_dec.h dtx_enc.h q_plsf.h gc_pred.h d_plsf.h c_g_aver.h frame.h \
+ ec_gains.h ph_disp.h bgnscd.h lsp_avg.h basic_op.h count.h copy.h \
+ set_zero.h syn_filt.h agc.h int_lpc.h dec_gain.h dec_lag3.h \
+ dec_lag6.h d2_9pf.h d2_11pf.h d3_14pf.h d4_17pf.h d8_31pf.h d1035pf.h \
+ pred_lt.h d_gain_p.h d_gain_c.h int_lsf.h lsp_lsf.h ex_ctrl.h \
+ sqrt_l.h lsp.tab bitno.tab b_cn_cod.h
+sp_enc.o: sp_enc.c sp_enc.h typedef.h typedefs.h cnst.h pre_proc.h \
+ mode.h cod_amr.h lpc.h levinson.h lsp.h q_plsf.h cl_ltp.h pitch_fr.h \
+ ton_stab.h gain_q.h gc_pred.h g_adapt.h p_ol_wgh.h vad.h vad1.h \
+ cnst_vad.h vad2.h dtx_enc.h basic_op.h count.h set_zero.h prm2bits.h
+sp_dec.o: sp_dec.c sp_dec.h typedef.h typedefs.h cnst.h dec_amr.h \
+ mode.h dtx_dec.h dtx_enc.h q_plsf.h gc_pred.h d_plsf.h c_g_aver.h \
+ frame.h ec_gains.h ph_disp.h bgnscd.h lsp_avg.h pstfilt.h preemph.h \
+ agc.h post_pro.h basic_op.h count.h set_zero.h bits2prm.h
+ph_disp.o: ph_disp.c ph_disp.h typedef.h typedefs.h mode.h basic_op.h \
+ count.h cnst.h copy.h ph_disp.tab
+g_adapt.o: g_adapt.c g_adapt.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h cnst.h gmed_n.h
+calc_en.o: calc_en.c calc_en.h typedef.h typedefs.h mode.h basic_op.h \
+ oper_32b.h count.h cnst.h log2.h
+qgain795.o: qgain795.c qgain795.h typedef.h typedefs.h g_adapt.h \
+ basic_op.h oper_32b.h count.h cnst.h log2.h pow2.h sqrt_l.h calc_en.h \
+ mode.h q_gain_p.h mac_32.h gains.tab
+qgain475.o: qgain475.c qgain475.h typedef.h typedefs.h gc_pred.h \
+ mode.h basic_op.h mac_32.h oper_32b.h count.h cnst.h pow2.h log2.h \
+ qgain475.tab
+sqrt_l.o: sqrt_l.c sqrt_l.h typedef.h typedefs.h basic_op.h count.h \
+ sqrt_l.tab
+set_sign.o: set_sign.c set_sign.h typedef.h typedefs.h basic_op.h \
+ count.h inv_sqrt.h cnst.h
+s10_8pf.o: s10_8pf.c s10_8pf.h typedef.h typedefs.h cnst.h basic_op.h \
+ count.h
+bgnscd.o: bgnscd.c bgnscd.h typedef.h typedefs.h cnst.h basic_op.h \
+ count.h copy.h set_zero.h gmed_n.h sqrt_l.h
+gmed_n.o: gmed_n.c gmed_n.h typedef.h typedefs.h basic_op.h count.h
+mac_32.o: mac_32.c mac_32.h typedef.h typedefs.h basic_op.h oper_32b.h \
+ count.h
+ex_ctrl.o: ex_ctrl.c ex_ctrl.h typedef.h typedefs.h cnst.h basic_op.h \
+ count.h copy.h set_zero.h gmed_n.h sqrt_l.h
+c_g_aver.o: c_g_aver.c c_g_aver.h typedef.h typedefs.h mode.h cnst.h \
+ basic_op.h count.h set_zero.h
+lsp_avg.o: lsp_avg.c lsp_avg.h typedef.h typedefs.h cnst.h basic_op.h \
+ oper_32b.h count.h q_plsf_5.tab copy.h
+int_lsf.o: int_lsf.c int_lsf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+c8_31pf.o: c8_31pf.c c8_31pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h inv_sqrt.h cor_h.h set_sign.h s10_8pf.h
+d8_31pf.o: d8_31pf.c d8_31pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+p_ol_wgh.o: p_ol_wgh.c p_ol_wgh.h typedef.h typedefs.h mode.h vad.h \
+ vad1.h cnst_vad.h vad2.h basic_op.h oper_32b.h count.h cnst.h \
+ corrwght.tab gmed_n.h inv_sqrt.h calc_cor.h hp_max.h
+ton_stab.o: ton_stab.c ton_stab.h typedef.h typedefs.h mode.h cnst.h \
+ basic_op.h count.h oper_32b.h set_zero.h copy.h
+vad1.o: vad1.c vad.h vad1.h typedef.h typedefs.h cnst_vad.h vad2.h \
+ basic_op.h count.h oper_32b.h
+dtx_enc.o: dtx_enc.c dtx_enc.h typedef.h typedefs.h cnst.h q_plsf.h \
+ mode.h gc_pred.h basic_op.h oper_32b.h copy.h set_zero.h log2.h \
+ lsp_lsf.h reorder.h count.h lsp.tab
+dtx_dec.o: dtx_dec.c dtx_dec.h typedef.h typedefs.h dtx_enc.h cnst.h \
+ q_plsf.h mode.h gc_pred.h d_plsf.h c_g_aver.h frame.h basic_op.h \
+ oper_32b.h copy.h set_zero.h log2.h lsp_az.h pow2.h a_refl.h \
+ b_cn_cod.h syn_filt.h lsp_lsf.h reorder.h count.h q_plsf_5.tab \
+ lsp.tab
+a_refl.o: a_refl.c a_refl.h typedef.h typedefs.h basic_op.h oper_32b.h \
+ count.h cnst.h
+b_cn_cod.o: b_cn_cod.c b_cn_cod.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h cnst.h window.tab
+calc_cor.o: calc_cor.c calc_cor.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h cnst.h
+hp_max.o: hp_max.c hp_max.h typedef.h typedefs.h basic_op.h oper_32b.h \
+ count.h cnst.h
+vadname.o: vadname.c vadname.h
+vad2.o: vad2.c typedef.h typedefs.h cnst.h basic_op.h oper_32b.h \
+ count.h log2.h pow2.h vad2.h
+r_fft.o: r_fft.c typedef.h typedefs.h cnst.h basic_op.h oper_32b.h \
+ count.h vad2.h
+lflg_upd.o: lflg_upd.c typedef.h typedefs.h cnst.h basic_op.h \
+ oper_32b.h count.h vad2.h mode.h
+e_homing.o: e_homing.c e_homing.h typedef.h typedefs.h cnst.h
+d_homing.o: d_homing.c d_homing.h typedef.h typedefs.h mode.h \
+ bits2prm.h d_homing.tab bitno.tab cnst.h
diff -Nur FFMpeg-20050127/libavcodec/amr/makefile.sun FFMpeg-20050127-new/libavcodec/amr/makefile.sun
--- FFMpeg-20050127/libavcodec/amr/makefile.sun	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/makefile.sun	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,453 @@
+#****************************************************************
+#
+#      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+#                                R99   Version 3.3.0                
+#                                REL-4 Version 4.1.0                
+#
+#****************************************************************
+#
+#      File             : makefile
+#      Purpose          : cc makefile for AMR SPC fixed point library
+#                       : and standalone encoder/decoder program
+#
+#                             make [MODE=DEBUG] [VAD=VAD#] [target [target...]]
+#
+#                         Important targets are:
+#                             default           (same as not specifying a
+#                                                target at all)
+#                                               remove all objects and libs;
+#                                               build libraries; then build
+#                                               encoder & decoder programs
+#                             depend            make new dependency list
+#                             clean             Remove all object/executable/
+#                                               verification output files
+#                             clean_depend      Clean dependency list
+#                             clean_all         clean & clean_depend & rm *.a
+#
+#
+#                         Specifying MODE=DEBUG compiles in debug mode
+#                         (libaries compiled in DEBUG mode will be linked)
+#                         Specifying MODE=WMOPS enables WMOPS counting
+#                         (FIP operation library compiled in WMOPS mode will
+#                          be linked)
+#
+#                         Specifying VAD=VAD1 compiles VAD option 1
+#                         Specifying VAD=VAD2 compiles VAD option 2
+#
+#                         The makefile uses the GNU C compiler (gcc); change
+#                         the line CC=gcc below if another compiler is desired
+#                         (CFLAGSxxx probably must be changed then as well)
+#                         
+#
+# $Id $
+#
+#****************************************************************
+
+CC = cc
+MAKEFILENAME = makefile.sun
+
+# Use MODE=DEBUG for debuggable library (default target builds both)
+#
+# default mode = NORM ==> no debug, no wmops
+#
+MODE=NORM
+
+# Use VAD=VAD1 for VAD option 1, or VAD=VAD2 for VAD option 2
+#
+# default mode = VAD1
+#
+VAD=VAD1
+
+#
+# compiler flags (for normal, DEBUG, and WMOPS compilation)
+#
+CFLAGS_NORM  = -O4 -DWMOPS=0
+CFLAGS_DEBUG = -g -DDEBUG -DWMOPS=0
+CFLAGS_WMOPS = -O4 -DWMOPS=1
+
+CFLAGS = -Xc -I. $(CFLAGS_$(MODE)) -D$(VAD)
+CFLAGSDEPEND = -MM $(CFLAGS)                    # for make depend
+
+
+TMP=$(MODE:NORM=)
+TMP2=$(TMP:DEBUG=_debug)
+#
+# construct SPC library name:
+#   spc.a        in normal or wmops mode
+#   spc_debug.a  in debug mode (MODE=DEBUG)
+#
+SPCLIB=spc$(TMP2:WMOPS=).a
+
+#
+# construct FIP operation library name:
+#   fipop.a        in normal mode
+#   fipop_debug.a  in debug mode (MODE=DEBUG)
+#   fipop_wmops.a  in wmops mode (MODE=WMOPS)
+#
+FIPOPLIB=fipop$(TMP2:WMOPS=_wmops).a
+
+
+#
+# source/object files
+#
+SPC_OBJS=  agc.o autocorr.o az_lsp.o bits2prm.o \
+       cl_ltp.o convolve.o c1035pf.o d_plsf.o d_plsf_5.o \
+       d_gain_c.o d_gain_p.o dec_lag6.o d1035pf.o cor_h.o \
+       enc_lag3.o enc_lag6.o g_code.o g_pitch.o int_lpc.o \
+       inter_36.o inv_sqrt.o \
+       lag_wind.o levinson.o lsp_az.o lsp_lsf.o ol_ltp.o \
+       pitch_fr.o pitch_ol.o pow2.o pre_big.o pre_proc.o pred_lt.o preemph.o \
+       prm2bits.o \
+       pstfilt.o q_gain_c.o q_gain_p.o q_plsf.o q_plsf_5.o lsfwt.o reorder.o \
+       residu.o lsp.o lpc.o ec_gains.o spreproc.o syn_filt.o \
+       weight_a.o qua_gain.o gc_pred.o q_plsf_3.o post_pro.o \
+       dec_lag3.o dec_gain.o d_plsf_3.o d4_17pf.o c4_17pf.o d3_14pf.o \
+       c3_14pf.o \
+       d2_11pf.o c2_11pf.o d2_9pf.o c2_9pf.o cbsearch.o spstproc.o gain_q.o \
+       cod_amr.o dec_amr.o sp_enc.o sp_dec.o ph_disp.o \
+       g_adapt.o calc_en.o qgain795.o qgain475.o sqrt_l.o set_sign.o s10_8pf.o \
+       bgnscd.o gmed_n.o \
+       mac_32.o ex_ctrl.o c_g_aver.o lsp_avg.o int_lsf.o c8_31pf.o d8_31pf.o \
+       p_ol_wgh.o ton_stab.o vad1.o dtx_enc.o dtx_dec.o a_refl.o \
+       b_cn_cod.o calc_cor.o hp_max.o vadname.o \
+       vad2.o r_fft.o lflg_upd.o \
+       e_homing.o d_homing.o
+
+
+ENCODER_SRCS=coder.c 
+DECODER_SRCS=decoder.c
+FIPOP_SRCS=basicop2.c count.c oper_32b.c copy.c log2.c set_zero.c \
+           strfunc.c n_proc.c sid_sync.c
+
+ENCODER_OBJS=$(ENCODER_SRCS:.c=.o) 
+DECODER_OBJS=$(DECODER_SRCS:.c=.o)
+FIPOP_OBJS=$(FIPOP_SRCS:.c=.o)
+
+ALL_SRCS=$(ENCODER_SRCS) $(DECODER_SRCS) $(FIPOP_SRCS) $(SPC_OBJS:.o=.c)
+
+#
+# default target: build standalone speech encoder and decoder
+#
+default: clean_all spclib fipoplib encoder decoder
+
+
+encoder: $(ENCODER_OBJS) $(SPCLIB) $(FIPOPLIB)
+	$(CC) -o encoder $(CFLAGS) $(ENCODER_OBJS) $(SPCLIB) $(FIPOPLIB) $(LDFLAGS)
+
+decoder: $(DECODER_OBJS) $(SPCLIB) $(FIPOPLIB)
+	$(CC) -o decoder $(CFLAGS) $(DECODER_OBJS) $(SPCLIB) $(FIPOPLIB) $(LDFLAGS)
+
+
+
+
+#
+# how to compile a .c file into a .o
+#
+.SUFFIXES: .c .h .o
+.c.o:
+	$(CC) -c $(CFLAGS) $<
+
+
+#
+# build normal and DEBUG version of SPC library from scratch
+#
+spclib_allmodes:
+	rm -f spc.a spc_debug.a
+	$(MAKE) -f $(MAKEFILENAME) $(MFLAGS) $(MAKEDEFS) MODE=      clean spclib
+	$(MAKE) -f $(MAKEFILENAME) $(MFLAGS) $(MAKEDEFS) MODE=DEBUG clean spclib
+
+#
+# build the speech coder library
+#
+spclib: $(SPC_OBJS)
+	$(AR) rc $(SPCLIB) $(SPC_OBJS)
+	ranlib $(SPCLIB)
+
+
+#
+# build normal, DEBUG, and WMOPS version of FIP operation library from scratch
+#
+fipoplib_allmodes:
+	rm -f fipop.a fipop_debug.a fipop_wmops.a
+	$(MAKE) -f $(MAKEFILENAME) $(MFLAGS) $(MAKEDEFS)            clean fipoplib
+	$(MAKE) -f $(MAKEFILENAME) $(MFLAGS) $(MAKEDEFS) MODE=DEBUG clean fipoplib
+	$(MAKE) -f $(MAKEFILENAME) $(MFLAGS) $(MAKEDEFS) MODE=WMOPS clean fipoplib
+
+#
+# build the FIP operation library
+#
+fipoplib:	$(FIPOP_OBJS)
+	$(AR) rc $(FIPOPLIB) $(FIPOP_OBJS)
+	ranlib $(FIPOPLIB)
+
+
+#
+# make / clean dependency list
+#
+depend:
+	$(MAKE) -f $(MAKEFILENAME) $(MFLAGS) $(MAKEDEFS) clean_depend
+	$(CC) $(CFLAGSDEPEND) $(ALL_SRCS) >> $(MAKEFILENAME)
+
+clean_depend:
+	chmod u+w $(MAKEFILENAME)
+	(awk 'BEGIN{f=1}{if (f) print $0}/^\# DO NOT DELETE THIS LINE -- make depend depends on it./{f=0}'\
+	    < $(MAKEFILENAME) > .depend && \
+	mv .depend $(MAKEFILENAME)) || exit 1;
+
+#
+# remove object/executable files
+#
+clean:
+	rm -f *.o core
+
+clean_all: clean
+	rm -f *.a encoder decoder
+
+# DO NOT DELETE THIS LINE -- make depend depends on it.
+coder.o: coder.c typedef.h typedefs.h cnst.h n_proc.h mode.h frame.h \
+ strfunc.h sp_enc.h pre_proc.h cod_amr.h lpc.h levinson.h lsp.h \
+ q_plsf.h cl_ltp.h pitch_fr.h ton_stab.h gain_q.h gc_pred.h g_adapt.h \
+ p_ol_wgh.h vad.h vad1.h cnst_vad.h vad2.h dtx_enc.h sid_sync.h \
+ vadname.h e_homing.h
+decoder.o: decoder.c typedef.h typedefs.h n_proc.h cnst.h mode.h \
+ frame.h strfunc.h sp_dec.h dec_amr.h dtx_dec.h dtx_enc.h q_plsf.h \
+ gc_pred.h d_plsf.h c_g_aver.h ec_gains.h ph_disp.h bgnscd.h lsp_avg.h \
+ pstfilt.h preemph.h agc.h post_pro.h d_homing.h
+basicop2.o: basicop2.c typedef.h typedefs.h basic_op.h
+count.o: count.c typedef.h typedefs.h count.h
+oper_32b.o: oper_32b.c typedef.h typedefs.h basic_op.h oper_32b.h \
+ count.h
+copy.o: copy.c copy.h typedef.h typedefs.h basic_op.h count.h
+log2.o: log2.c log2.h typedef.h typedefs.h basic_op.h count.h log2.tab
+set_zero.o: set_zero.c set_zero.h typedef.h typedefs.h basic_op.h \
+ count.h
+strfunc.o: strfunc.c strfunc.h mode.h frame.h
+n_proc.o: n_proc.c
+sid_sync.o: sid_sync.c sid_sync.h typedef.h typedefs.h mode.h frame.h \
+ basic_op.h count.h
+agc.o: agc.c agc.h typedef.h typedefs.h basic_op.h count.h cnst.h \
+ inv_sqrt.h
+autocorr.o: autocorr.c autocorr.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h cnst.h
+az_lsp.o: az_lsp.c az_lsp.h typedef.h typedefs.h basic_op.h oper_32b.h \
+ count.h cnst.h grid.tab
+bits2prm.o: bits2prm.c bits2prm.h typedef.h typedefs.h mode.h \
+ basic_op.h count.h bitno.tab cnst.h
+cl_ltp.o: cl_ltp.c cl_ltp.h typedef.h typedefs.h mode.h pitch_fr.h \
+ ton_stab.h cnst.h basic_op.h count.h oper_32b.h convolve.h g_pitch.h \
+ pred_lt.h enc_lag3.h enc_lag6.h q_gain_p.h
+convolve.o: convolve.c convolve.h typedef.h typedefs.h basic_op.h \
+ count.h
+c1035pf.o: c1035pf.c c1035pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h inv_sqrt.h set_sign.h cor_h.h s10_8pf.h gray.tab
+d_plsf.o: d_plsf.c d_plsf.h typedef.h typedefs.h cnst.h mode.h \
+ basic_op.h count.h copy.h q_plsf_5.tab
+d_plsf_5.o: d_plsf_5.c d_plsf.h typedef.h typedefs.h cnst.h mode.h \
+ basic_op.h count.h lsp_lsf.h reorder.h copy.h q_plsf_5.tab
+d_gain_c.o: d_gain_c.c d_gain_c.h typedef.h typedefs.h mode.h \
+ gc_pred.h basic_op.h oper_32b.h count.h cnst.h log2.h pow2.h \
+ gains.tab
+d_gain_p.o: d_gain_p.c d_gain_p.h typedef.h typedefs.h mode.h \
+ basic_op.h oper_32b.h count.h cnst.h gains.tab
+dec_lag6.o: dec_lag6.c dec_lag6.h typedef.h typedefs.h basic_op.h \
+ count.h
+d1035pf.o: d1035pf.c d1035pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h gray.tab
+cor_h.o: cor_h.c cor_h.h typedef.h typedefs.h cnst.h basic_op.h \
+ count.h inv_sqrt.h
+enc_lag3.o: enc_lag3.c enc_lag3.h typedef.h typedefs.h basic_op.h \
+ count.h cnst.h
+enc_lag6.o: enc_lag6.c enc_lag6.h typedef.h typedefs.h basic_op.h \
+ count.h
+g_code.o: g_code.c g_code.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+g_pitch.o: g_pitch.c g_pitch.h typedef.h typedefs.h mode.h basic_op.h \
+ oper_32b.h count.h cnst.h
+int_lpc.o: int_lpc.c int_lpc.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h lsp_az.h
+inter_36.o: inter_36.c inter_36.h typedef.h typedefs.h basic_op.h \
+ count.h cnst.h inter_36.tab
+inv_sqrt.o: inv_sqrt.c inv_sqrt.h typedef.h typedefs.h basic_op.h \
+ count.h inv_sqrt.tab
+lag_wind.o: lag_wind.c lag_wind.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h lag_wind.tab
+levinson.o: levinson.c levinson.h typedef.h typedefs.h cnst.h \
+ basic_op.h oper_32b.h count.h
+lsp_az.o: lsp_az.c lsp_az.h typedef.h typedefs.h basic_op.h oper_32b.h \
+ count.h
+lsp_lsf.o: lsp_lsf.c lsp_lsf.h typedef.h typedefs.h basic_op.h count.h \
+ lsp_lsf.tab
+ol_ltp.o: ol_ltp.c ol_ltp.h typedef.h typedefs.h mode.h p_ol_wgh.h \
+ vad.h vad1.h cnst_vad.h vad2.h cnst.h pitch_ol.h count.h basic_op.h
+pitch_fr.o: pitch_fr.c pitch_fr.h typedef.h typedefs.h mode.h \
+ basic_op.h oper_32b.h count.h cnst.h enc_lag3.h enc_lag6.h inter_36.h \
+ inv_sqrt.h convolve.h
+pitch_ol.o: pitch_ol.c pitch_ol.h typedef.h typedefs.h mode.h vad.h \
+ vad1.h cnst_vad.h vad2.h basic_op.h oper_32b.h count.h cnst.h \
+ inv_sqrt.h calc_cor.h hp_max.h
+pow2.o: pow2.c pow2.h typedef.h typedefs.h basic_op.h count.h pow2.tab
+pre_big.o: pre_big.c pre_big.h typedef.h typedefs.h mode.h cnst.h \
+ basic_op.h oper_32b.h syn_filt.h weight_a.h residu.h count.h
+pre_proc.o: pre_proc.c pre_proc.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h
+pred_lt.o: pred_lt.c pred_lt.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+preemph.o: preemph.c preemph.h typedef.h typedefs.h basic_op.h count.h
+prm2bits.o: prm2bits.c prm2bits.h typedef.h typedefs.h mode.h \
+ basic_op.h count.h bitno.tab cnst.h
+pstfilt.o: pstfilt.c pstfilt.h typedef.h typedefs.h mode.h cnst.h \
+ preemph.h agc.h basic_op.h set_zero.h weight_a.h residu.h copy.h \
+ syn_filt.h count.h
+q_gain_c.o: q_gain_c.c q_gain_c.h typedef.h typedefs.h mode.h \
+ gc_pred.h basic_op.h oper_32b.h count.h log2.h pow2.h gains.tab
+q_gain_p.o: q_gain_p.c q_gain_p.h typedef.h typedefs.h mode.h \
+ basic_op.h oper_32b.h count.h cnst.h gains.tab
+q_plsf.o: q_plsf.c q_plsf.h typedef.h typedefs.h cnst.h mode.h \
+ basic_op.h
+q_plsf_5.o: q_plsf_5.c q_plsf.h typedef.h typedefs.h cnst.h mode.h \
+ basic_op.h count.h lsp_lsf.h reorder.h lsfwt.h q_plsf_5.tab
+lsfwt.o: lsfwt.c lsfwt.h typedef.h typedefs.h cnst.h basic_op.h \
+ count.h
+reorder.o: reorder.c reorder.h typedef.h typedefs.h basic_op.h count.h
+residu.o: residu.c residu.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+lsp.o: lsp.c lsp.h typedef.h typedefs.h q_plsf.h cnst.h mode.h \
+ basic_op.h oper_32b.h copy.h az_lsp.h int_lpc.h count.h lsp.tab
+lpc.o: lpc.c lpc.h typedef.h typedefs.h levinson.h cnst.h mode.h \
+ basic_op.h oper_32b.h autocorr.h lag_wind.h count.h window.tab
+ec_gains.o: ec_gains.c ec_gains.h typedef.h typedefs.h gc_pred.h \
+ mode.h basic_op.h oper_32b.h count.h cnst.h gmed_n.h gains.tab
+spreproc.o: spreproc.c spreproc.h cnst.h mode.h typedef.h typedefs.h \
+ basic_op.h oper_32b.h weight_a.h syn_filt.h residu.h copy.h count.h
+syn_filt.o: syn_filt.c syn_filt.h typedef.h typedefs.h basic_op.h \
+ count.h cnst.h
+weight_a.o: weight_a.c weight_a.h typedef.h typedefs.h basic_op.h \
+ count.h cnst.h
+qua_gain.o: qua_gain.c qua_gain.h typedef.h typedefs.h gc_pred.h \
+ mode.h basic_op.h oper_32b.h count.h cnst.h pow2.h qua_gain.tab
+gc_pred.o: gc_pred.c gc_pred.h typedef.h typedefs.h mode.h basic_op.h \
+ oper_32b.h cnst.h count.h log2.h copy.h
+q_plsf_3.o: q_plsf_3.c q_plsf.h typedef.h typedefs.h cnst.h mode.h \
+ basic_op.h count.h lsp_lsf.h reorder.h lsfwt.h copy.h q_plsf_3.tab
+post_pro.o: post_pro.c post_pro.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h
+dec_lag3.o: dec_lag3.c dec_lag3.h typedef.h typedefs.h basic_op.h \
+ count.h
+dec_gain.o: dec_gain.c dec_gain.h typedef.h typedefs.h gc_pred.h \
+ mode.h basic_op.h oper_32b.h count.h cnst.h pow2.h log2.h \
+ qua_gain.tab qgain475.tab
+d_plsf_3.o: d_plsf_3.c d_plsf.h typedef.h typedefs.h cnst.h mode.h \
+ basic_op.h count.h lsp_lsf.h reorder.h copy.h q_plsf_3.tab
+d4_17pf.o: d4_17pf.c d4_17pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h gray.tab
+c4_17pf.o: c4_17pf.c c4_17pf.h typedef.h typedefs.h basic_op.h count.h \
+ inv_sqrt.h cnst.h cor_h.h set_sign.h gray.tab
+d3_14pf.o: d3_14pf.c d3_14pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+c3_14pf.o: c3_14pf.c c3_14pf.h typedef.h typedefs.h basic_op.h count.h \
+ inv_sqrt.h cnst.h cor_h.h set_sign.h
+d2_11pf.o: d2_11pf.c d2_11pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+c2_11pf.o: c2_11pf.c c2_11pf.h typedef.h typedefs.h basic_op.h count.h \
+ inv_sqrt.h cnst.h cor_h.h set_sign.h c2_11pf.tab
+d2_9pf.o: d2_9pf.c d2_9pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h c2_9pf.tab
+c2_9pf.o: c2_9pf.c c2_9pf.h typedef.h typedefs.h basic_op.h count.h \
+ inv_sqrt.h cnst.h cor_h.h set_sign.h c2_9pf.tab
+cbsearch.o: cbsearch.c cbsearch.h typedef.h typedefs.h mode.h c2_9pf.h \
+ c2_11pf.h c3_14pf.h c4_17pf.h c8_31pf.h c1035pf.h basic_op.h count.h \
+ cnst.h
+spstproc.o: spstproc.c spstproc.h typedef.h typedefs.h mode.h \
+ basic_op.h oper_32b.h count.h syn_filt.h cnst.h
+gain_q.o: gain_q.c gain_q.h typedef.h typedefs.h mode.h gc_pred.h \
+ g_adapt.h basic_op.h count.h qua_gain.h cnst.h g_code.h q_gain_c.h \
+ calc_en.h qgain795.h qgain475.h set_zero.h
+cod_amr.o: cod_amr.c cod_amr.h typedef.h typedefs.h cnst.h mode.h \
+ lpc.h levinson.h lsp.h q_plsf.h cl_ltp.h pitch_fr.h ton_stab.h \
+ gain_q.h gc_pred.h g_adapt.h p_ol_wgh.h vad.h vad1.h cnst_vad.h \
+ vad2.h dtx_enc.h basic_op.h count.h copy.h set_zero.h qua_gain.h \
+ pre_big.h ol_ltp.h spreproc.h pred_lt.h spstproc.h cbsearch.h \
+ convolve.h
+dec_amr.o: dec_amr.c dec_amr.h typedef.h typedefs.h cnst.h mode.h \
+ dtx_dec.h dtx_enc.h q_plsf.h gc_pred.h d_plsf.h c_g_aver.h frame.h \
+ ec_gains.h ph_disp.h bgnscd.h lsp_avg.h basic_op.h count.h copy.h \
+ set_zero.h syn_filt.h agc.h int_lpc.h dec_gain.h dec_lag3.h \
+ dec_lag6.h d2_9pf.h d2_11pf.h d3_14pf.h d4_17pf.h d8_31pf.h d1035pf.h \
+ pred_lt.h d_gain_p.h d_gain_c.h int_lsf.h lsp_lsf.h ex_ctrl.h \
+ sqrt_l.h lsp.tab bitno.tab b_cn_cod.h
+sp_enc.o: sp_enc.c sp_enc.h typedef.h typedefs.h cnst.h pre_proc.h \
+ mode.h cod_amr.h lpc.h levinson.h lsp.h q_plsf.h cl_ltp.h pitch_fr.h \
+ ton_stab.h gain_q.h gc_pred.h g_adapt.h p_ol_wgh.h vad.h vad1.h \
+ cnst_vad.h vad2.h dtx_enc.h basic_op.h count.h set_zero.h prm2bits.h
+sp_dec.o: sp_dec.c sp_dec.h typedef.h typedefs.h cnst.h dec_amr.h \
+ mode.h dtx_dec.h dtx_enc.h q_plsf.h gc_pred.h d_plsf.h c_g_aver.h \
+ frame.h ec_gains.h ph_disp.h bgnscd.h lsp_avg.h pstfilt.h preemph.h \
+ agc.h post_pro.h basic_op.h count.h set_zero.h bits2prm.h
+ph_disp.o: ph_disp.c ph_disp.h typedef.h typedefs.h mode.h basic_op.h \
+ count.h cnst.h copy.h ph_disp.tab
+g_adapt.o: g_adapt.c g_adapt.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h cnst.h gmed_n.h
+calc_en.o: calc_en.c calc_en.h typedef.h typedefs.h mode.h basic_op.h \
+ oper_32b.h count.h cnst.h log2.h
+qgain795.o: qgain795.c qgain795.h typedef.h typedefs.h g_adapt.h \
+ basic_op.h oper_32b.h count.h cnst.h log2.h pow2.h sqrt_l.h calc_en.h \
+ mode.h q_gain_p.h mac_32.h gains.tab
+qgain475.o: qgain475.c qgain475.h typedef.h typedefs.h gc_pred.h \
+ mode.h basic_op.h mac_32.h oper_32b.h count.h cnst.h pow2.h log2.h \
+ qgain475.tab
+sqrt_l.o: sqrt_l.c sqrt_l.h typedef.h typedefs.h basic_op.h count.h \
+ sqrt_l.tab
+set_sign.o: set_sign.c set_sign.h typedef.h typedefs.h basic_op.h \
+ count.h inv_sqrt.h cnst.h
+s10_8pf.o: s10_8pf.c s10_8pf.h typedef.h typedefs.h cnst.h basic_op.h \
+ count.h
+bgnscd.o: bgnscd.c bgnscd.h typedef.h typedefs.h cnst.h basic_op.h \
+ count.h copy.h set_zero.h gmed_n.h sqrt_l.h
+gmed_n.o: gmed_n.c gmed_n.h typedef.h typedefs.h basic_op.h count.h
+mac_32.o: mac_32.c mac_32.h typedef.h typedefs.h basic_op.h oper_32b.h \
+ count.h
+ex_ctrl.o: ex_ctrl.c ex_ctrl.h typedef.h typedefs.h cnst.h basic_op.h \
+ count.h copy.h set_zero.h gmed_n.h sqrt_l.h
+c_g_aver.o: c_g_aver.c c_g_aver.h typedef.h typedefs.h mode.h cnst.h \
+ basic_op.h count.h set_zero.h
+lsp_avg.o: lsp_avg.c lsp_avg.h typedef.h typedefs.h cnst.h basic_op.h \
+ oper_32b.h count.h q_plsf_5.tab copy.h
+int_lsf.o: int_lsf.c int_lsf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+c8_31pf.o: c8_31pf.c c8_31pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h inv_sqrt.h cor_h.h set_sign.h s10_8pf.h
+d8_31pf.o: d8_31pf.c d8_31pf.h typedef.h typedefs.h basic_op.h count.h \
+ cnst.h
+p_ol_wgh.o: p_ol_wgh.c p_ol_wgh.h typedef.h typedefs.h mode.h vad.h \
+ vad1.h cnst_vad.h vad2.h basic_op.h oper_32b.h count.h cnst.h \
+ corrwght.tab gmed_n.h inv_sqrt.h calc_cor.h hp_max.h
+ton_stab.o: ton_stab.c ton_stab.h typedef.h typedefs.h mode.h cnst.h \
+ basic_op.h count.h oper_32b.h set_zero.h copy.h
+vad1.o: vad1.c vad.h vad1.h typedef.h typedefs.h cnst_vad.h vad2.h \
+ basic_op.h count.h oper_32b.h
+dtx_enc.o: dtx_enc.c dtx_enc.h typedef.h typedefs.h cnst.h q_plsf.h \
+ mode.h gc_pred.h basic_op.h oper_32b.h copy.h set_zero.h log2.h \
+ lsp_lsf.h reorder.h count.h lsp.tab
+dtx_dec.o: dtx_dec.c dtx_dec.h typedef.h typedefs.h dtx_enc.h cnst.h \
+ q_plsf.h mode.h gc_pred.h d_plsf.h c_g_aver.h frame.h basic_op.h \
+ oper_32b.h copy.h set_zero.h log2.h lsp_az.h pow2.h a_refl.h \
+ b_cn_cod.h syn_filt.h lsp_lsf.h reorder.h count.h q_plsf_5.tab \
+ lsp.tab
+a_refl.o: a_refl.c a_refl.h typedef.h typedefs.h basic_op.h oper_32b.h \
+ count.h cnst.h
+b_cn_cod.o: b_cn_cod.c b_cn_cod.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h cnst.h window.tab
+calc_cor.o: calc_cor.c calc_cor.h typedef.h typedefs.h basic_op.h \
+ oper_32b.h count.h cnst.h
+hp_max.o: hp_max.c hp_max.h typedef.h typedefs.h basic_op.h oper_32b.h \
+ count.h cnst.h
+vadname.o: vadname.c vadname.h
+vad2.o: vad2.c typedef.h typedefs.h cnst.h basic_op.h oper_32b.h \
+ count.h log2.h pow2.h vad2.h
+r_fft.o: r_fft.c typedef.h typedefs.h cnst.h basic_op.h oper_32b.h \
+ count.h vad2.h
+lflg_upd.o: lflg_upd.c typedef.h typedefs.h cnst.h basic_op.h \
+ oper_32b.h count.h vad2.h mode.h
+e_homing.o: e_homing.c e_homing.h typedef.h typedefs.h cnst.h
+d_homing.o: d_homing.c d_homing.h typedef.h typedefs.h mode.h \
+ bits2prm.h d_homing.tab bitno.tab cnst.h
diff -Nur FFMpeg-20050127/libavcodec/amr/mode.h FFMpeg-20050127-new/libavcodec/amr/mode.h
--- FFMpeg-20050127/libavcodec/amr/mode.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/mode.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,43 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : mode.h
+*      Purpose          : Declaration of mode type
+*
+********************************************************************************
+*/
+#ifndef mode_h
+#define mode_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+enum Mode { MR475 = 0,
+            MR515,            
+            MR59,
+            MR67,
+            MR74,
+            MR795,
+            MR102,
+            MR122,            
+
+	    MRDTX,
+	    
+            N_MODES     /* number of (SPC) modes */
+
+          };
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/n_proc.c FFMpeg-20050127-new/libavcodec/amr/n_proc.c
--- FFMpeg-20050127/libavcodec/amr/n_proc.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/n_proc.c	2003-03-26 13:23:00.000000000 +0000
@@ -0,0 +1,23 @@
+#include <stdio.h>
+#include <stdlib.h>
+/* $Id $ */
+
+void proc_head (char *mes)
+{
+    fprintf(stderr,"\n\
+**************************************************************\n\
+\n\
+     European digital cellular telecommunications system\n\
+           4750 ... 12200 bits/s speech codec for\n\
+         Adaptive Multi-Rate speech traffic channels\n\
+\n\
+     Bit-Exact C Simulation Code - %s\n\
+\n\
+     R98:   Version 7.6.0  \n\
+     R99:   Version 3.3.0  \n\
+     REL-4: Version 4.1.0   December 12, 2001\n\
+     REL-5: Version 5.1.0   March 26, 2003\n\
+**************************************************************\n\n",
+            mes);
+
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/n_proc.h FFMpeg-20050127-new/libavcodec/amr/n_proc.h
--- FFMpeg-20050127/libavcodec/amr/n_proc.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/n_proc.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,8 @@
+/* $Id $ */
+#if defined(__BORLANDC__)
+#include <dos.h>
+extern unsigned _stklen = 32000U;
+
+#endif
+
+void proc_head (char *mes);
diff -Nur FFMpeg-20050127/libavcodec/amr/ol_ltp.c FFMpeg-20050127-new/libavcodec/amr/ol_ltp.c
--- FFMpeg-20050127/libavcodec/amr/ol_ltp.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/ol_ltp.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,99 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : ol_ltp.c
+*      Purpose          : Compute the open loop pitch lag.
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "ol_ltp.h"
+const char ol_ltp_id[] = "@(#)$Id $" ol_ltp_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdio.h>
+#include "typedef.h"
+#include "cnst.h"
+#include "pitch_ol.h"
+#include "p_ol_wgh.h"
+#include "count.h"
+#include "basic_op.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+int ol_ltp(
+    pitchOLWghtState *st, /* i/o : State struct                            */
+    vadState *vadSt,      /* i/o : VAD state struct                        */
+    enum Mode mode,       /* i   : coder mode                              */
+    Word16 wsp[],         /* i   : signal used to compute the OL pitch, Q0 */
+                          /*       uses signal[-pit_max] to signal[-1]     */
+    Word16 *T_op,         /* o   : open loop pitch lag,                 Q0 */
+    Word16 old_lags[],    /* i   : history with old stored Cl lags         */
+    Word16 ol_gain_flg[], /* i   : OL gain flag                            */
+    Word16 idx,           /* i   : index                                   */
+    Flag dtx              /* i   : dtx flag; use dtx=1, do not use dtx=0   */
+    )
+{
+   test ();   
+   if (sub (mode, MR102) != 0 )
+   {
+      ol_gain_flg[0] = 0;                                       move16 ();
+      ol_gain_flg[1] = 0;                                       move16 ();
+   }
+   
+   test (); test ();
+   if (sub (mode, MR475) == 0 || sub (mode, MR515) == 0 )
+   {
+      *T_op = Pitch_ol(vadSt, mode, wsp, PIT_MIN, PIT_MAX, L_FRAME, idx, dtx);
+                                                                move16 ();
+   }
+   else
+   {
+      if ( sub (mode, MR795) <= 0 )
+      {
+         test();
+         *T_op = Pitch_ol(vadSt, mode, wsp, PIT_MIN, PIT_MAX, L_FRAME_BY2,
+                          idx, dtx);
+                                                                move16 ();
+      }
+      else if ( sub (mode, MR102) == 0 )
+      {
+         test(); test();
+         *T_op = Pitch_ol_wgh(st, vadSt, wsp, PIT_MIN, PIT_MAX, L_FRAME_BY2,
+                              old_lags, ol_gain_flg, idx, dtx);
+                                                                move16 ();
+      }
+      else
+      {
+         test(); test();          
+         *T_op = Pitch_ol(vadSt, mode, wsp, PIT_MIN_MR122, PIT_MAX,
+                          L_FRAME_BY2, idx, dtx);
+                                                                move16 ();
+      }
+   }
+   return 0;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/ol_ltp.h FFMpeg-20050127-new/libavcodec/amr/ol_ltp.h
--- FFMpeg-20050127/libavcodec/amr/ol_ltp.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/ol_ltp.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,44 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : ol_ltp.h
+*      Purpose          : Compute the open loop pitch lag.
+*
+********************************************************************************
+*/
+#ifndef ol_ltp_h
+#define ol_ltp_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+#include "p_ol_wgh.h"
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+int ol_ltp(
+    pitchOLWghtState *st, /* i/o : State struct                            */
+    vadState *vadSt,      /* i/o : VAD state struct                        */
+    enum Mode mode,       /* i   : coder mode                              */
+    Word16 wsp[],         /* i   : signal used to compute the OL pitch, Q0 */
+                          /*       uses signal[-pit_max] to signal[-1]     */
+    Word16 *T_op,         /* o   : open loop pitch lag,                 Q0 */
+    Word16 old_lags[],    /* i   : history with old stored Cl lags         */
+    Word16 ol_gain_flg[], /* i   : OL gain flag                            */
+    Word16 idx,           /* i   : index                                   */
+    Flag dtx              /* i   : dtx flag; use dtx=1, do not use dtx=0   */
+);
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/oper_32b.c FFMpeg-20050127-new/libavcodec/amr/oper_32b.c
--- FFMpeg-20050127/libavcodec/amr/oper_32b.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/oper_32b.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,209 @@
+/*****************************************************************************
+ *  $Id $
+ *
+ *  This file contains operations in double precision.                       *
+ *  These operations are not standard double precision operations.           *
+ *  They are used where single precision is not enough but the full 32 bits  *
+ *  precision is not necessary. For example, the function Div_32() has a     *
+ *  24 bits precision which is enough for our purposes.                      *
+ *                                                                           *
+ *  The double precision numbers use a special representation:               *
+ *                                                                           *
+ *     L_32 = hi<<16 + lo<<1                                                 *
+ *                                                                           *
+ *  L_32 is a 32 bit integer.                                                *
+ *  hi and lo are 16 bit signed integers.                                    *
+ *  As the low part also contains the sign, this allows fast multiplication. *
+ *                                                                           *
+ *      0x8000 0000 <= L_32 <= 0x7fff fffe.                                  *
+ *                                                                           *
+ *  We will use DPF (Double Precision Format )in this file to specify        *
+ *  this special format.                                                     *
+ *****************************************************************************
+*/
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+
+/*****************************************************************************
+ *                                                                           *
+ *  Function L_Extract()                                                     *
+ *                                                                           *
+ *  Extract from a 32 bit integer two 16 bit DPF.                            *
+ *                                                                           *
+ *  Arguments:                                                               *
+ *                                                                           *
+ *   L_32      : 32 bit integer.                                             *
+ *               0x8000 0000 <= L_32 <= 0x7fff ffff.                         *
+ *   hi        : b16 to b31 of L_32                                          *
+ *   lo        : (L_32 - hi<<16)>>1                                          *
+ *****************************************************************************
+*/
+
+void L_Extract (Word32 L_32, Word16 *hi, Word16 *lo)
+{
+    *hi = extract_h (L_32);
+    *lo = extract_l (L_msu (L_shr (L_32, 1), *hi, 16384));
+    return;
+}
+
+/*****************************************************************************
+ *                                                                           *
+ *  Function L_Comp()                                                        *
+ *                                                                           *
+ *  Compose from two 16 bit DPF a 32 bit integer.                            *
+ *                                                                           *
+ *     L_32 = hi<<16 + lo<<1                                                 *
+ *                                                                           *
+ *  Arguments:                                                               *
+ *                                                                           *
+ *   hi        msb                                                           *
+ *   lo        lsf (with sign)                                               *
+ *                                                                           *
+ *   Return Value :                                                          *
+ *                                                                           *
+ *             32 bit long signed integer (Word32) whose value falls in the  *
+ *             range : 0x8000 0000 <= L_32 <= 0x7fff fff0.                   *
+ *                                                                           *
+ *****************************************************************************
+*/
+
+Word32 L_Comp (Word16 hi, Word16 lo)
+{
+    Word32 L_32;
+
+    L_32 = L_deposit_h (hi);
+    return (L_mac (L_32, lo, 1));       /* = hi<<16 + lo<<1 */
+}
+
+/*****************************************************************************
+ * Function Mpy_32()                                                         *
+ *                                                                           *
+ *   Multiply two 32 bit integers (DPF). The result is divided by 2**31      *
+ *                                                                           *
+ *   L_32 = (hi1*hi2)<<1 + ( (hi1*lo2)>>15 + (lo1*hi2)>>15 )<<1              *
+ *                                                                           *
+ *   This operation can also be viewed as the multiplication of two Q31      *
+ *   number and the result is also in Q31.                                   *
+ *                                                                           *
+ * Arguments:                                                                *
+ *                                                                           *
+ *  hi1         hi part of first number                                      *
+ *  lo1         lo part of first number                                      *
+ *  hi2         hi part of second number                                     *
+ *  lo2         lo part of second number                                     *
+ *                                                                           *
+ *****************************************************************************
+*/
+
+Word32 Mpy_32 (Word16 hi1, Word16 lo1, Word16 hi2, Word16 lo2)
+{
+    Word32 L_32;
+
+    L_32 = L_mult (hi1, hi2);
+    L_32 = L_mac (L_32, mult (hi1, lo2), 1);
+    L_32 = L_mac (L_32, mult (lo1, hi2), 1);
+
+    return (L_32);
+}
+
+/*****************************************************************************
+ * Function Mpy_32_16()                                                      *
+ *                                                                           *
+ *   Multiply a 16 bit integer by a 32 bit (DPF). The result is divided      *
+ *   by 2**15                                                                *
+ *                                                                           *
+ *                                                                           *
+ *   L_32 = (hi1*lo2)<<1 + ((lo1*lo2)>>15)<<1                                *
+ *                                                                           *
+ * Arguments:                                                                *
+ *                                                                           *
+ *  hi          hi part of 32 bit number.                                    *
+ *  lo          lo part of 32 bit number.                                    *
+ *  n           16 bit number.                                               *
+ *                                                                           *
+ *****************************************************************************
+*/
+
+Word32 Mpy_32_16 (Word16 hi, Word16 lo, Word16 n)
+{
+    Word32 L_32;
+
+    L_32 = L_mult (hi, n);
+    L_32 = L_mac (L_32, mult (lo, n), 1);
+
+    return (L_32);
+}
+
+/*****************************************************************************
+ *                                                                           *
+ *   Function Name : Div_32                                                  *
+ *                                                                           *
+ *   Purpose :                                                               *
+ *             Fractional integer division of two 32 bit numbers.            *
+ *             L_num / L_denom.                                              *
+ *             L_num and L_denom must be positive and L_num < L_denom.       *
+ *             L_denom = denom_hi<<16 + denom_lo<<1                          *
+ *             denom_hi is a normalize number.                               *
+ *                                                                           *
+ *   Inputs :                                                                *
+ *                                                                           *
+ *    L_num                                                                  *
+ *             32 bit long signed integer (Word32) whose value falls in the  *
+ *             range : 0x0000 0000 < L_num < L_denom                         *
+ *                                                                           *
+ *    L_denom = denom_hi<<16 + denom_lo<<1      (DPF)                        *
+ *                                                                           *
+ *       denom_hi                                                            *
+ *             16 bit positive normalized integer whose value falls in the   *
+ *             range : 0x4000 < hi < 0x7fff                                  *
+ *       denom_lo                                                            *
+ *             16 bit positive integer whose value falls in the              *
+ *             range : 0 < lo < 0x7fff                                       *
+ *                                                                           *
+ *   Return Value :                                                          *
+ *                                                                           *
+ *    L_div                                                                  *
+ *             32 bit long signed integer (Word32) whose value falls in the  *
+ *             range : 0x0000 0000 <= L_div <= 0x7fff ffff.                  *
+ *                                                                           *
+ *  Algorithm:                                                               *
+ *                                                                           *
+ *  - find = 1/L_denom.                                                      *
+ *      First approximation: approx = 1 / denom_hi                           *
+ *      1/L_denom = approx * (2.0 - L_denom * approx )                       *
+ *                                                                           *
+ *  -  result = L_num * (1/L_denom)                                          *
+ *****************************************************************************
+*/
+
+Word32 Div_32 (Word32 L_num, Word16 denom_hi, Word16 denom_lo)
+{
+    Word16 approx, hi, lo, n_hi, n_lo;
+    Word32 L_32;
+
+    /* First approximation: 1 / L_denom = 1/denom_hi */
+
+    approx = div_s ((Word16) 0x3fff, denom_hi);
+
+    /* 1/L_denom = approx * (2.0 - L_denom * approx) */
+
+    L_32 = Mpy_32_16 (denom_hi, denom_lo, approx);
+
+    L_32 = L_sub ((Word32) 0x7fffffffL, L_32);
+
+    L_Extract (L_32, &hi, &lo);
+
+    L_32 = Mpy_32_16 (hi, lo, approx);
+
+    /* L_num * (1/L_denom) */
+
+    L_Extract (L_32, &hi, &lo);
+    L_Extract (L_num, &n_hi, &n_lo);
+    L_32 = Mpy_32 (n_hi, n_lo, hi, lo);
+    L_32 = L_shl (L_32, 2);
+
+    return (L_32);
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/oper_32b.h FFMpeg-20050127-new/libavcodec/amr/oper_32b.h
--- FFMpeg-20050127/libavcodec/amr/oper_32b.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/oper_32b.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,8 @@
+/* Double precision operations */
+/* $Id $ */
+
+void L_Extract (Word32 L_32, Word16 *hi, Word16 *lo);
+Word32 L_Comp (Word16 hi, Word16 lo);
+Word32 Mpy_32 (Word16 hi1, Word16 lo1, Word16 hi2, Word16 lo2);
+Word32 Mpy_32_16 (Word16 hi, Word16 lo, Word16 n);
+Word32 Div_32 (Word32 L_num, Word16 denom_hi, Word16 denom_lo);
diff -Nur FFMpeg-20050127/libavcodec/amr/p_ol_wgh.c FFMpeg-20050127-new/libavcodec/amr/p_ol_wgh.c
--- FFMpeg-20050127/libavcodec/amr/p_ol_wgh.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/p_ol_wgh.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,350 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : p_ol_wgh.c
+*      Purpose          : Compute the open loop pitch lag with weighting      
+*
+*************************************************************************/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "p_ol_wgh.h"
+const char p_ol_wgh_id[] = "@(#)$Id $" p_ol_wgh_h;
+
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "cnst.h"
+#include "corrwght.tab"
+#include "gmed_n.h"
+#include "inv_sqrt.h"
+#include "vad.h"
+#include "calc_cor.h"
+#include "hp_max.h"
+                      
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  Lag_max
+ *
+ *  PURPOSE: Find the lag that has maximum correlation of scal_sig[] in a
+ *           given delay range.
+ *
+ *  DESCRIPTION:
+ *      The correlation is given by
+ *           cor[t] = <scal_sig[n],scal_sig[n-t]>,  t=lag_min,...,lag_max
+ *      The functions outputs the maximum correlation after normalization
+ *      and the corresponding lag.
+ *
+ *************************************************************************/
+static Word16 Lag_max ( /* o : lag found                               */
+    vadState *vadSt,    /* i/o : VAD state struct                      */
+    Word32 corr[],      /* i   : correlation vector.                   */
+    Word16 scal_sig[],  /* i : scaled signal.                          */
+    Word16 L_frame,     /* i : length of frame to compute pitch        */
+    Word16 lag_max,     /* i : maximum lag                             */
+    Word16 lag_min,     /* i : minimum lag                             */
+    Word16 old_lag,     /* i : old open-loop lag                       */
+    Word16 *cor_max,    /* o : normalized correlation of selected lag  */
+    Word16 wght_flg,    /* i : is weighting function used              */ 
+    Word16 *gain_flg,   /* o : open-loop flag                          */
+    Flag dtx            /* i   : dtx flag; use dtx=1, do not use dtx=0 */
+    )
+{
+    Word16 i, j;
+    Word16 *p, *p1;
+    Word32 max, t0;
+    Word16 t0_h, t0_l;
+    Word16 p_max;
+    const Word16 *ww, *we;
+    Word32 t1;
+    
+    ww = &corrweight[250];                                 move16 ();
+    we = &corrweight[123 + lag_max - old_lag];             move16 ();
+
+    max = MIN_32;                                          move32 ();
+    p_max = lag_max;                                       move16 ();
+
+    for (i = lag_max; i >= lag_min; i--)
+    {
+       t0 = corr[-i];                                      move32 ();   
+       
+       /* Weighting of the correlation function.   */
+       L_Extract (corr[-i], &t0_h, &t0_l);
+       t0 = Mpy_32_16 (t0_h, t0_l, *ww);
+       ww--;                                               move16();
+       test ();
+       if (wght_flg > 0) {
+          /* Weight the neighbourhood of the old lag. */
+          L_Extract (t0, &t0_h, &t0_l);
+          t0 = Mpy_32_16 (t0_h, t0_l, *we);
+          we--;                                            move16();
+       }
+       
+       test (); 
+       if (L_sub (t0, max) >= 0)
+       {
+          max = t0;                                        move32 (); 
+          p_max = i;                                       move16 (); 
+       }
+    }
+    
+    p  = &scal_sig[0];                                     move16 (); 
+    p1 = &scal_sig[-p_max];                                move16 (); 
+    t0 = 0;                                                move32 (); 
+    t1 = 0;                                                move32 (); 
+    
+    for (j = 0; j < L_frame; j++, p++, p1++)
+    {
+       t0 = L_mac (t0, *p, *p1);               
+       t1 = L_mac (t1, *p1, *p1);
+    }
+
+    if (dtx)
+    {  /* no test() call since this if is only in simulation env */
+#ifdef VAD2
+       vadSt->L_Rmax = L_add(vadSt->L_Rmax, t0);   /* Save max correlation */
+       vadSt->L_R0 =   L_add(vadSt->L_R0, t1);        /* Save max energy */
+#else
+       /* update and detect tone */
+       vad_tone_detection_update (vadSt, 0);
+       vad_tone_detection (vadSt, t0, t1);
+#endif
+    }
+    
+    /* gain flag is set according to the open_loop gain */
+    /* is t2/t1 > 0.4 ? */    
+    *gain_flg = round(L_msu(t0, round(t1), 13107));        move16(); 
+    
+    *cor_max = 0;                                          move16 ();
+
+    return (p_max);
+}
+
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+/*************************************************************************
+*
+*  Function:   p_ol_wgh_init
+*  Purpose:    Allocates state memory and initializes state memory
+*
+**************************************************************************
+*/
+int p_ol_wgh_init (pitchOLWghtState **state)
+{
+    pitchOLWghtState* s;
+    
+    if (state == (pitchOLWghtState **) NULL){
+        fprintf(stderr, "p_ol_wgh_init: invalid parameter\n");
+        return -1;
+    }
+    *state = NULL;
+    
+    /* allocate memory */
+    if ((s= (pitchOLWghtState *) malloc(sizeof(pitchOLWghtState))) == NULL){
+        fprintf(stderr, "p_ol_wgh_init: can not malloc state structure\n");
+        return -1;
+    }
+
+    p_ol_wgh_reset(s);
+    
+    *state = s;
+    
+    return 0;
+}
+ 
+/*************************************************************************
+*
+*  Function:   p_ol_wgh_reset
+*  Purpose:    Initializes state memory to zero
+*
+**************************************************************************
+*/
+int p_ol_wgh_reset (pitchOLWghtState *st)
+{
+   if (st == (pitchOLWghtState *) NULL){
+      fprintf(stderr, "p_ol_wgh_reset: invalid parameter\n");
+      return -1;
+   }
+   
+   /* Reset pitch search states */
+   st->old_T0_med = 40;
+   st->ada_w = 0;
+   st->wght_flg = 0; 
+   
+   return 0;
+}
+ 
+/*************************************************************************
+*
+*  Function:   p_ol_wgh_exit
+*  Purpose:    The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void p_ol_wgh_exit (pitchOLWghtState **state)
+{
+    if (state == NULL || *state == NULL)
+        return;
+     
+    /* deallocate memory */
+    free(*state);
+    *state = NULL;
+    
+    return;
+}
+ 
+/*************************************************************************
+*
+*  Function:   p_ol_wgh
+*  Purpose:    open-loop pitch search with weighting
+*
+**************************************************************************
+*/
+Word16 Pitch_ol_wgh (     /* o   : open loop pitch lag                            */
+    pitchOLWghtState *st, /* i/o : State struct                                   */
+    vadState *vadSt,      /* i/o : VAD state struct                               */
+    Word16 signal[],      /* i   : signal used to compute the open loop pitch     */
+                          /*       signal[-pit_max] to signal[-1] should be known */
+    Word16 pit_min,       /* i   : minimum pitch lag                              */
+    Word16 pit_max,       /* i   : maximum pitch lag                              */
+    Word16 L_frame,       /* i   : length of frame to compute pitch               */
+    Word16 old_lags[],    /* i   : history with old stored Cl lags                */
+    Word16 ol_gain_flg[], /* i   : OL gain flag                                   */
+    Word16 idx,           /* i   : index                                          */
+    Flag dtx              /* i   : dtx flag; use dtx=1, do not use dtx=0          */
+    )
+{
+    Word16 i;
+    Word16 max1;
+    Word16 p_max1;
+    Word32 t0;
+#ifndef VAD2
+    Word16 corr_hp_max;
+#endif
+    Word32 corr[PIT_MAX+1], *corr_ptr;    
+
+    /* Scaled signal */
+    Word16 scaled_signal[PIT_MAX + L_FRAME];
+    Word16 *scal_sig;
+
+    scal_sig = &scaled_signal[pit_max];                          move16 (); 
+
+    t0 = 0L;                                                     move32 (); 
+    for (i = -pit_max; i < L_frame; i++)
+    {
+        t0 = L_mac (t0, signal[i], signal[i]);
+    }
+    /*--------------------------------------------------------*
+     * Scaling of input signal.                               *
+     *                                                        *
+     *   if Overflow        -> scal_sig[i] = signal[i]>>2     *
+     *   else if t0 < 1^22  -> scal_sig[i] = signal[i]<<2     *
+     *   else               -> scal_sig[i] = signal[i]        *
+     *--------------------------------------------------------*/
+
+    /*--------------------------------------------------------*
+     *  Verification for risk of overflow.                    *
+     *--------------------------------------------------------*/
+
+    test (); test (); 
+    if (L_sub (t0, MAX_32) == 0L)               /* Test for overflow */
+    {
+        for (i = -pit_max; i < L_frame; i++)
+        {
+            scal_sig[i] = shr (signal[i], 3);   move16 (); 
+        }
+    }
+    else if (L_sub (t0, (Word32) 1048576L) < (Word32) 0)
+    {
+        for (i = -pit_max; i < L_frame; i++)
+        {
+            scal_sig[i] = shl (signal[i], 3);   move16 (); 
+        }
+    }
+    else
+    {
+        for (i = -pit_max; i < L_frame; i++)
+        {
+            scal_sig[i] = signal[i];            move16 (); 
+        }
+    }
+
+    /* calculate all coreelations of scal_sig, from pit_min to pit_max */
+    corr_ptr = &corr[pit_max];                  move32 ();
+    comp_corr (scal_sig, L_frame, pit_max, pit_min, corr_ptr); 
+
+    p_max1 = Lag_max (vadSt, corr_ptr, scal_sig, L_frame, pit_max, pit_min,
+                      st->old_T0_med, &max1, st->wght_flg, &ol_gain_flg[idx],
+                      dtx);
+    move16 ();
+
+    test (); move16 ();
+    if (ol_gain_flg[idx] > 0)
+    {
+       /* Calculate 5-point median of previous lags */
+       for (i = 4; i > 0; i--) /* Shift buffer */
+       {
+          old_lags[i] = old_lags[i-1];              move16 ();
+       }
+       old_lags[0] = p_max1;                        move16 (); 
+       st->old_T0_med = gmed_n (old_lags, 5);       move16 ();
+       st->ada_w = 32767;                           move16 (); /* Q15 = 1.0 */
+    }	
+    else
+    {        
+       st->old_T0_med = p_max1;                     move16 ();
+       st->ada_w = mult(st->ada_w, 29491);      /* = ada_w = ada_w * 0.9 */
+    }
+    
+    test ();
+    if (sub(st->ada_w, 9830) < 0)  /* ada_w - 0.3 */
+    { 
+       st->wght_flg = 0;                            move16 ();
+    } 
+    else
+    {
+       st->wght_flg = 1;                            move16 ();
+    }
+
+#ifndef VAD2
+    if (dtx)
+    {  /* no test() call since this if is only in simulation env */
+       test ();
+       if (sub(idx, 1) == 0)
+       {
+          /* calculate max high-passed filtered correlation of all lags */
+          hp_max (corr_ptr, scal_sig, L_frame, pit_max, pit_min, &corr_hp_max); 
+          
+          /* update complex background detector */
+          vad_complex_detection_update(vadSt, corr_hp_max); 
+       }
+    }
+#endif
+    
+    return (p_max1);
+}
+
diff -Nur FFMpeg-20050127/libavcodec/amr/p_ol_wgh.h FFMpeg-20050127-new/libavcodec/amr/p_ol_wgh.h
--- FFMpeg-20050127/libavcodec/amr/p_ol_wgh.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/p_ol_wgh.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,75 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : p_ol_wgh.h
+*      Purpose          : Compute the open loop pitch lag with weighting.
+*
+********************************************************************************
+*/
+#ifndef p_ol_wgh_h
+#define p_ol_wgh_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+#include "vad.h"
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+/* state variable */
+typedef struct {
+   Word16 old_T0_med;
+   Word16 ada_w;
+   Word16 wght_flg; 
+} pitchOLWghtState;
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+int p_ol_wgh_init (pitchOLWghtState **st);
+/* initialize one instance of the pre processing state.
+   Stores pointer to filter status struct in *st. This pointer has to
+   be passed to p_ol_wgh in each call.
+   returns 0 on success
+ */
+ 
+int p_ol_wgh_reset (pitchOLWghtState *st);
+/* reset of pre processing state (i.e. set state memory to zero)
+   returns 0 on success
+ */
+
+void p_ol_wgh_exit (pitchOLWghtState **st);
+/* de-initialize pre processing state (i.e. free status struct)
+   stores NULL in *st
+ */
+
+Word16 Pitch_ol_wgh (     /* o   : open loop pitch lag                            */
+    pitchOLWghtState *st, /* i/o : State struct                                   */
+    vadState *vadSt,      /* i/o : VAD state struct                               */
+    Word16 signal[],      /* i   : signal used to compute the open loop pitch     */
+                          /*       signal[-pit_max] to signal[-1] should be known */
+    Word16 pit_min,       /* i   : minimum pitch lag                              */
+    Word16 pit_max,       /* i   : maximum pitch lag                              */
+    Word16 L_frame,       /* i   : length of frame to compute pitch               */
+    Word16 old_lags[],    /* i   : history with old stored Cl lags                */
+    Word16 ol_gain_flg[], /* i   : OL gain flag                                   */
+    Word16 idx,           /* i   : index                                          */
+    Flag dtx              /* i   : dtx flag; use dtx=1, do not use dtx=0          */
+    );
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/ph_disp.c FFMpeg-20050127-new/libavcodec/amr/ph_disp.c
--- FFMpeg-20050127/libavcodec/amr/ph_disp.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/ph_disp.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,363 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : ph_disp.c
+*      Purpose          : Perform adaptive phase dispersion of the excitation
+*                         signal.
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "ph_disp.h"
+const char ph_disp_id[] = "@(#)$Id $" ph_disp_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+#include "copy.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+#include "ph_disp.tab"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+*
+*  Function:   ph_disp_init
+*
+**************************************************************************
+*/
+int ph_disp_init (ph_dispState **state)
+{
+  ph_dispState *s;
+
+  if (state == (ph_dispState **) NULL){
+      fprintf(stderr, "ph_disp_init: invalid parameter\n");
+      return -1;
+  }
+  *state = NULL;
+
+  /* allocate memory */
+  if ((s= (ph_dispState *) malloc(sizeof(ph_dispState))) == NULL){
+      fprintf(stderr, "ph_disp_init: can not malloc state structure\n");
+      return -1;
+  }
+  ph_disp_reset(s);
+  *state = s;
+
+  return 0;
+  
+}
+
+/*************************************************************************
+*
+*  Function:   ph_disp_reset
+*
+**************************************************************************
+*/
+int ph_disp_reset (ph_dispState *state)
+{
+  Word16 i;
+
+   if (state == (ph_dispState *) NULL){
+      fprintf(stderr, "ph_disp_reset: invalid parameter\n");
+      return -1;
+   }
+   for (i=0; i<PHDGAINMEMSIZE; i++)
+   {
+       state->gainMem[i] = 0;
+   }
+   state->prevState = 0;
+   state->prevCbGain = 0;
+   state->lockFull = 0;
+   state->onset = 0;          /* assume no onset in start */ 
+
+   return 0;
+}
+
+/*************************************************************************
+*
+*  Function:   ph_disp_exit
+*
+**************************************************************************
+*/
+void ph_disp_exit (ph_dispState **state)
+{
+  if ((state == NULL) || (*state == NULL))
+      return;
+  
+  /* deallocate memory */
+  free(*state);
+  *state = NULL;
+  
+  return;
+}
+/*************************************************************************
+*
+*  Function:   ph_disp_lock
+*
+**************************************************************************
+*/
+void ph_disp_lock (ph_dispState *state)
+{
+  state->lockFull = 1;
+  return;
+}
+
+/*************************************************************************
+*
+*  Function:   ph_disp_release
+*
+**************************************************************************
+*/
+void ph_disp_release (ph_dispState *state)
+{
+  state->lockFull = 0;
+  return;
+}
+
+
+/*************************************************************************
+*
+*  Function:   ph_disp
+*
+*              Adaptive phase dispersion; forming of total excitation
+*              (for synthesis part of decoder)
+*
+**************************************************************************
+*/
+void ph_disp (
+      ph_dispState *state, /* i/o     : State struct                     */
+      enum Mode mode,      /* i       : codec mode                       */
+      Word16 x[],          /* i/o Q0  : in:  LTP excitation signal       */
+                           /*           out: total excitation signal     */
+      Word16 cbGain,       /* i   Q1  : Codebook gain                    */
+      Word16 ltpGain,      /* i   Q14 : LTP gain                         */
+      Word16 inno[],       /* i/o Q13 : Innovation vector (Q12 for 12.2) */
+      Word16 pitch_fac,    /* i   Q14 : pitch factor used to scale the
+                                        LTP excitation (Q13 for 12.2)    */
+      Word16 tmp_shift     /* i   Q0  : shift factor applied to sum of   
+                                        scaled LTP ex & innov. before
+                                        rounding                         */
+)
+{
+   Word16 i, i1;
+   Word16 tmp1;
+   Word32 L_temp;
+   Word16 impNr;           /* indicator for amount of disp./filter used */
+
+   Word16 inno_sav[L_SUBFR];
+   Word16 ps_poss[L_SUBFR];
+   Word16 j, nze, nPulse, ppos;
+   const Word16 *ph_imp;   /* Pointer to phase dispersion filter */
+
+   /* Update LTP gain memory */
+   for (i = PHDGAINMEMSIZE-1; i > 0; i--)
+   {
+       state->gainMem[i] = state->gainMem[i-1];                    move16 ();
+   }
+   state->gainMem[0] = ltpGain;                                    move16 ();
+   
+   /* basic adaption of phase dispersion */
+   test ();
+   if (sub(ltpGain, PHDTHR2LTP) < 0) {    /* if (ltpGain < 0.9) */
+       test ();
+       if (sub(ltpGain, PHDTHR1LTP) > 0)
+       {  /* if (ltpGain > 0.6 */
+          impNr = 1; /* medium dispersion */                      move16 ();
+       }
+       else
+       {
+          impNr = 0; /* maximum dispersion */                     move16 ();
+       }
+   }
+   else
+   {
+      impNr = 2; /* no dispersion */                              move16 ();
+   }
+   
+   /* onset indicator */
+   /* onset = (cbGain  > onFact * cbGainMem[0]) */
+                                                                   move32 ();
+   tmp1 = round(L_shl(L_mult(state->prevCbGain, ONFACTPLUS1), 2));
+   test ();
+   if (sub(cbGain, tmp1) > 0)
+   {
+       state->onset = ONLENGTH;                                    move16 ();
+   }
+   else
+   {
+       test (); 
+       if (state->onset > 0)
+       {
+           state->onset = sub (state->onset, 1);                   move16 ();
+       }
+   }
+   
+   /* if not onset, check ltpGain buffer and use max phase dispersion if
+      half or more of the ltpGain-parameters say so */
+   test ();
+   if (state->onset == 0)
+   {
+       /* Check LTP gain memory and set filter accordingly */
+       i1 = 0;                                                     move16 ();
+       for (i = 0; i < PHDGAINMEMSIZE; i++)
+       {
+           test ();
+           if (sub(state->gainMem[i], PHDTHR1LTP) < 0)
+           {
+               i1 = add (i1, 1);
+           }
+       }
+       test ();
+       if (sub(i1, 2) > 0)
+       {
+           impNr = 0;                                              move16 ();
+       }
+       
+   }
+   /* Restrict decrease in phase dispersion to one step if not onset */
+   test (); test ();
+   if ((sub(impNr, add(state->prevState, 1)) > 0) && (state->onset == 0))
+   {
+       impNr = sub (impNr, 1);
+   }
+   /* if onset, use one step less phase dispersion */
+   test (); test ();
+   if((sub(impNr, 2) < 0) && (state->onset > 0))
+   {
+       impNr = add (impNr, 1);
+   }
+   
+   /* disable for very low levels */
+   test ();
+   if(sub(cbGain, 10) < 0)
+   {
+       impNr = 2;                                                  move16 ();
+   }
+   
+   test ();
+   if(sub(state->lockFull, 1) == 0)
+   {
+       impNr = 0;                                                  move16 ();
+   }
+
+   /* update static memory */
+   state->prevState = impNr;                                       move16 ();
+   state->prevCbGain = cbGain;                                     move16 ();
+  
+   /* do phase dispersion for all modes but 12.2 and 7.4;
+      don't modify the innovation if impNr >=2 (= no phase disp) */
+   test (); test (); test(); test();
+   if (sub(mode, MR122) != 0 && 
+       sub(mode, MR102) != 0 &&
+       sub(mode, MR74) != 0 &&
+       sub(impNr, 2) < 0)
+   {
+       /* track pulse positions, save innovation,
+          and initialize new innovation          */
+       nze = 0;                                                    move16 ();
+       for (i = 0; i < L_SUBFR; i++)
+       {
+           move16 (); test();
+           if (inno[i] != 0)
+           {
+               ps_poss[nze] = i;                                   move16 ();
+               nze = add (nze, 1);
+           }
+           inno_sav[i] = inno[i];                                  move16 ();
+           inno[i] = 0;                                            move16 ();
+       }
+       /* Choose filter corresponding to codec mode and dispersion criterium */
+       test ();
+       if (sub (mode, MR795) == 0)
+       {
+           test ();
+           if (impNr == 0)
+           {
+               ph_imp = ph_imp_low_MR795;                            move16 ();
+           }
+           else
+           {
+               ph_imp = ph_imp_mid_MR795;                            move16 ();
+           }
+       }
+       else
+       {
+           test ();
+           if (impNr == 0)
+           {
+               ph_imp = ph_imp_low;                                  move16 ();
+           }
+           else
+           {
+               ph_imp = ph_imp_mid;                                  move16 ();
+           }
+       }
+       
+       /* Do phase dispersion of innovation */
+       for (nPulse = 0; nPulse < nze; nPulse++)
+       {
+           ppos = ps_poss[nPulse];                                   move16 ();
+           
+           /* circular convolution with impulse response */
+           j = 0;                                                    move16 ();
+           for (i = ppos; i < L_SUBFR; i++)
+           {
+               /* inno[i1] += inno_sav[ppos] * ph_imp[i1-ppos] */
+               tmp1 = mult(inno_sav[ppos], ph_imp[j++]);
+               inno[i] = add(inno[i], tmp1);                         move16 ();
+           }    
+           
+           for (i = 0; i < ppos; i++)
+           {
+               /* inno[i] += inno_sav[ppos] * ph_imp[L_SUBFR-ppos+i] */
+               tmp1 = mult(inno_sav[ppos], ph_imp[j++]);
+               inno[i] = add(inno[i], tmp1);                         move16 ();
+           }
+       }
+   }
+       
+   /* compute total excitation for synthesis part of decoder
+      (using modified innovation if phase dispersion is active) */
+   for (i = 0; i < L_SUBFR; i++)
+   {
+       /* x[i] = gain_pit*x[i] + cbGain*code[i]; */
+       L_temp = L_mult (        x[i],    pitch_fac);
+                                                /* 12.2: Q0 * Q13 */
+                                                /*  7.4: Q0 * Q14 */
+       L_temp = L_mac  (L_temp, inno[i], cbGain);
+                                                /* 12.2: Q12 * Q1 */
+                                                /*  7.4: Q13 * Q1 */
+       L_temp = L_shl (L_temp, tmp_shift);                 /* Q16 */           
+       x[i] = round (L_temp);                                        move16 (); 
+   }
+
+   return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/ph_disp.h FFMpeg-20050127-new/libavcodec/amr/ph_disp.h
--- FFMpeg-20050127/libavcodec/amr/ph_disp.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/ph_disp.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,126 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : ph_disp.h
+*      Purpose          : Phase dispersion of excitation signal
+*
+********************************************************************************
+*/
+
+#ifndef ph_disp_h
+#define ph_disp_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#define PHDGAINMEMSIZE 5
+#define PHDTHR1LTP     9830  /* 0.6 in Q14 */
+#define PHDTHR2LTP     14746 /* 0.9 in Q14 */
+#define ONFACTPLUS1    16384 /* 2.0 in Q13   */
+#define ONLENGTH 2
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+typedef struct {
+  Word16 gainMem[PHDGAINMEMSIZE];
+  Word16 prevState;
+  Word16 prevCbGain;
+  Word16 lockFull;
+  Word16 onset;
+} ph_dispState;
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*************************************************************************
+*
+*  Function:   ph_disp_init
+*  Purpose:    Allocates state memory and initializes state memory
+*
+**************************************************************************
+*/
+int ph_disp_init (ph_dispState **state);
+
+/*************************************************************************
+*
+*  Function:   ph_disp_reset
+*  Purpose:    Initializes state memory
+*
+**************************************************************************
+*/
+int ph_disp_reset (ph_dispState *state);
+
+/*************************************************************************
+*
+*  Function:   ph_disp_exit
+*  Purpose:    The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void ph_disp_exit (ph_dispState **state);
+
+/*************************************************************************
+*
+*  Function:   ph_disp_lock
+*  Purpose:    mark phase dispersion as locked in state struct
+*
+**************************************************************************
+*/
+void ph_disp_lock (ph_dispState *state);
+
+/*************************************************************************
+*
+*  Function:   ph_disp_release
+*  Purpose:    mark phase dispersion as unlocked in state struct
+*
+**************************************************************************
+*/
+void ph_disp_release (ph_dispState *state);
+
+/*************************************************************************
+*
+*  Function:   ph_disp
+*  Purpose:    perform phase dispersion according to the specified codec
+*              mode and computes total excitation for synthesis part
+*              if decoder
+*
+**************************************************************************
+*/
+void ph_disp (
+      ph_dispState *state, /* i/o     : State struct                     */
+      enum Mode mode,      /* i       : codec mode                       */
+      Word16 x[],          /* i/o Q0  : in:  LTP excitation signal       */
+                           /*           out: total excitation signal     */
+      Word16 cbGain,       /* i   Q1  : Codebook gain                    */
+      Word16 ltpGain,      /* i   Q14 : LTP gain                         */
+      Word16 inno[],       /* i   Q13 : Innovation vector (Q12 for 12.2) */
+      Word16 pitch_fac,    /* i   Q14 : pitch factor used to scale the
+                                        LTP excitation (Q13 for 12.2)    */
+      Word16 tmp_shift     /* i   Q0  : shift factor applied to sum of   
+                                        scaled LTP ex & innov. before
+                                        rounding                         */
+);
+
+
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/ph_disp.tab FFMpeg-20050127-new/libavcodec/amr/ph_disp.tab
--- FFMpeg-20050127/libavcodec/amr/ph_disp.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/ph_disp.tab	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,51 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : ph_disp.tab
+*      Purpose          : Table of impulse responses of phase dispersion filters
+*      $Id $
+*
+********************************************************************************
+*/
+
+/* The following tables are constant, but not declared constant due to
+   compiler warnings in conjunction with the program code              */
+
+/* All impulse responses are in Q15 */
+
+static const Word16 ph_imp_low_MR795[] = 
+{
+  26777,    801,   2505,   -683,  -1382,    582,    604,  -1274,   3511,  -5894,
+   4534,   -499,  -1940,   3011,  -5058,   5614,  -1990,  -1061,  -1459,   4442,
+   -700,  -5335,   4609,    452,   -589,  -3352,   2953,   1267,  -1212,  -2590,
+   1731,   3670,  -4475,   -975,   4391,  -2537,    949,  -1363,   -979,   5734
+};
+static const Word16 ph_imp_mid_MR795[] = 
+{
+  30274,   3831,  -4036,   2972,  -1048,  -1002,   2477,  -3043,   2815,  -2231,
+   1753,  -1611,   1714,  -1775,   1543,  -1008,    429,   -169,    472,  -1264,
+   2176,  -2706,   2523,  -1621,    344,    826,  -1529,   1724,  -1657,   1701,
+  -2063,   2644,  -3060,   2897,  -1978,    557,    780,  -1369,    842,    655
+};
+
+static const Word16 ph_imp_low[] =
+{
+  14690,  11518,   1268,  -2761,  -5671,   7514,    -35,  -2807,  -3040,   4823,
+   2952,  -8424,   3785,   1455,   2179,  -8637,   8051,  -2103,  -1454,    777,
+   1108,  -2385,   2254,   -363,   -674,  -2103,   6046,  -5681,   1072,   3123,
+  -5058,   5312,  -2329,  -3728,   6924,  -3889,    675,  -1775,     29,  10145
+};
+static const Word16 ph_imp_mid[] =
+{
+  30274,   3831,  -4036,   2972,  -1048,  -1002,   2477,  -3043,   2815,  -2231,
+   1753,  -1611,   1714,  -1775,   1543,  -1008,    429,   -169,    472,  -1264,
+   2176,  -2706,   2523,  -1621,    344,    826,  -1529,   1724,  -1657,   1701,
+  -2063,   2644,  -3060,   2897,  -1978,    557,    780,  -1369,    842,    655
+};
+
diff -Nur FFMpeg-20050127/libavcodec/amr/pitch_fr.c FFMpeg-20050127-new/libavcodec/amr/pitch_fr.c
--- FFMpeg-20050127/libavcodec/amr/pitch_fr.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/pitch_fr.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,612 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : pitch_fr.c
+*      Purpose          : Find the pitch period with 1/3 or 1/6 subsample
+*                       : resolution (closed loop).
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "pitch_fr.h"
+const char pitch_fr_id[] = "@(#)$Id $" pitch_fr_h;
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "cnst.h"
+#include "enc_lag3.h"
+#include "enc_lag6.h"
+#include "inter_36.h"
+#include "inv_sqrt.h"
+#include "convolve.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+/*
+ * mode dependent parameters used in Pitch_fr()
+ * Note: order of MRxx in 'enum Mode' is important!
+ */
+static const struct {
+    Word16 max_frac_lag;     /* lag up to which fractional lags are used    */
+    Word16 flag3;            /* enable 1/3 instead of 1/6 fract. resolution */
+    Word16 first_frac;       /* first fractional to check                   */
+    Word16 last_frac;        /* last fractional to check                    */
+    Word16 delta_int_low;    /* integer lag below TO to start search from   */
+    Word16 delta_int_range;  /* integer range around T0                     */
+    Word16 delta_frc_low;    /* fractional below T0                         */
+    Word16 delta_frc_range;  /* fractional range around T0                  */
+    Word16 pit_min;          /* minimum pitch                               */
+} mode_dep_parm[N_MODES] = {
+    /* MR475 */  { 84,  1, -2,  2,  5, 10,  5,  9, PIT_MIN },
+    /* MR515 */  { 84,  1, -2,  2,  5, 10,  5,  9, PIT_MIN },                 
+    /* MR59  */  { 84,  1, -2,  2,  3,  6,  5,  9, PIT_MIN },
+    /* MR67  */  { 84,  1, -2,  2,  3,  6,  5,  9, PIT_MIN },
+    /* MR74  */  { 84,  1, -2,  2,  3,  6,  5,  9, PIT_MIN },
+    /* MR795 */  { 84,  1, -2,  2,  3,  6, 10, 19, PIT_MIN },
+    /* MR102 */  { 84,  1, -2,  2,  3,  6,  5,  9, PIT_MIN },                 
+    /* MR122 */  { 94,  0, -3,  3,  3,  6,  5,  9, PIT_MIN_MR122 }
+};
+
+/*
+********************************************************************************
+*                         LOCAL PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:   Norm_Corr()
+ *
+ *  PURPOSE: Find the normalized correlation between the target vector
+ *           and the filtered past excitation.
+ *
+ *  DESCRIPTION:
+ *     The normalized correlation is given by the correlation between the
+ *     target and filtered past excitation divided by the square root of
+ *     the energy of filtered excitation.
+ *                   corr[k] = <x[], y_k[]>/sqrt(y_k[],y_k[])
+ *     where x[] is the target vector and y_k[] is the filtered past
+ *     excitation at delay k.
+ *
+ *************************************************************************/
+static void Norm_Corr (Word16 exc[], Word16 xn[], Word16 h[], Word16 L_subfr,
+                       Word16 t_min, Word16 t_max, Word16 corr_norm[])
+{
+    Word16 i, j, k;
+    Word16 corr_h, corr_l, norm_h, norm_l;
+    Word32 s;
+
+    /* Usally dynamic allocation of (L_subfr) */
+    Word16 excf[L_SUBFR];
+    Word16 scaling, h_fac, *s_excf, scaled_excf[L_SUBFR];
+
+    k = -t_min;                                move16 ();
+
+    /* compute the filtered excitation for the first delay t_min */
+
+    Convolve (&exc[k], h, excf, L_subfr);
+
+    /* scale "excf[]" to avoid overflow */
+
+    for (j = 0; j < L_subfr; j++) {
+        scaled_excf[j] = shr (excf[j], 2);     move16 ();
+    }
+
+    /* Compute 1/sqrt(energy of excf[]) */
+
+    s = 0;                                     move32 ();
+    for (j = 0; j < L_subfr; j++) {
+        s = L_mac (s, excf[j], excf[j]);
+    }
+    test ();
+    if (L_sub (s, 67108864L) <= 0) {            /* if (s <= 2^26) */
+        s_excf = excf;                         move16 ();
+        h_fac = 15 - 12;                       move16 ();
+        scaling = 0;                           move16 ();
+    }
+    else {
+        /* "excf[]" is divided by 2 */
+        s_excf = scaled_excf;                  move16 ();
+        h_fac = 15 - 12 - 2;                   move16 ();
+        scaling = 2;                           move16 ();
+    }
+
+    /* loop for every possible period */
+
+    for (i = t_min; i <= t_max; i++) {
+        /* Compute 1/sqrt(energy of excf[]) */
+        
+        s = 0;                                 move32 ();
+        for (j = 0; j < L_subfr; j++) {
+            s = L_mac (s, s_excf[j], s_excf[j]);
+        }
+        
+        s = Inv_sqrt (s);
+        L_Extract (s, &norm_h, &norm_l);
+        
+        /* Compute correlation between xn[] and excf[] */
+        
+        s = 0;                                  move32 ();
+        for (j = 0; j < L_subfr; j++) {
+            s = L_mac (s, xn[j], s_excf[j]);
+        }
+        L_Extract (s, &corr_h, &corr_l);
+
+        /* Normalize correlation = correlation * (1/sqrt(energy)) */
+        
+        s = Mpy_32 (corr_h, corr_l, norm_h, norm_l);
+        
+        corr_norm[i] = extract_h (L_shl (s, 16));
+        move16 ();
+
+            /* modify the filtered excitation excf[] for the next iteration */
+        
+        test ();
+        if (sub (i, t_max) != 0) {
+            k--;
+            for (j = L_subfr - 1; j > 0; j--) {
+                s = L_mult (exc[k], h[j]);
+                s = L_shl (s, h_fac);
+                s_excf[j] = add (extract_h (s), s_excf[j - 1]); move16 ();
+            }
+            s_excf[0] = shr (exc[k], scaling);  move16 ();
+        }
+    }
+    return;
+}
+
+/*************************************************************************
+ *
+ *  FUNCTION:   searchFrac()
+ *
+ *  PURPOSE: Find fractional pitch
+ *
+ *  DESCRIPTION:
+ *     The function interpolates the normalized correlation at the
+ *     fractional positions around lag T0. The position at which the
+ *     interpolation function reaches its maximum is the fractional pitch.
+ *     Starting point of the search is frac, end point is last_frac.
+ *     frac is overwritten with the fractional pitch.
+ *
+ *************************************************************************/
+static void searchFrac (
+    Word16 *lag,       /* i/o : integer pitch           */
+    Word16 *frac,      /* i/o : start point of search -
+                                fractional pitch        */
+    Word16 last_frac,  /* i   : endpoint of search      */
+    Word16 corr[],     /* i   : normalized correlation  */
+    Word16 flag3       /* i   : subsample resolution
+                                (3: =1 / 6: =0)         */
+)
+{
+    Word16 i;
+    Word16 max;
+    Word16 corr_int;
+
+    /* Test the fractions around T0 and choose the one which maximizes   */
+    /* the interpolated normalized correlation.                          */
+
+    max = Interpol_3or6 (&corr[*lag], *frac, flag3); move16 (); /* function result */
+
+    for (i = add (*frac, 1); i <= last_frac; i++) {
+        corr_int = Interpol_3or6 (&corr[*lag], i, flag3);
+        move16 ();
+        test ();
+        if (sub (corr_int, max) > 0) {
+            max = corr_int;                       move16 ();
+            *frac = i;                            move16 ();
+        }
+    }
+
+    test();
+    if (flag3 == 0) {
+        /* Limit the fraction value in the interval [-2,-1,0,1,2,3] */
+
+        test ();
+        if (sub (*frac, -3) == 0) {
+            *frac = 3;                            move16 ();
+            *lag = sub (*lag, 1);
+        }
+    }
+    else {
+        /* limit the fraction value between -1 and 1 */
+
+        test ();
+        if (sub (*frac, -2) == 0) {
+            *frac = 1;                            move16 ();
+            *lag = sub (*lag, 1);
+        }
+        test ();
+        if (sub (*frac, 2) == 0) {
+            *frac = -1;                           move16 ();
+            *lag = add (*lag, 1);
+        }
+    }
+}
+
+/*************************************************************************
+ *
+ *  FUNCTION:   getRange()
+ *
+ *  PURPOSE: Sets range around open-loop pitch or integer pitch of last subframe
+ *
+ *  DESCRIPTION:
+ *     Takes integer pitch T0 and calculates a range around it with
+ *       t0_min = T0-delta_low  and t0_max = (T0-delta_low) + delta_range
+ *     t0_min and t0_max are bounded by pitmin and pitmax
+ *
+ *************************************************************************/
+static void getRange (
+    Word16 T0,           /* i : integer pitch          */
+    Word16 delta_low,    /* i : search start offset    */
+    Word16 delta_range,  /* i : search range           */
+    Word16 pitmin,       /* i : minimum pitch          */
+    Word16 pitmax,       /* i : maximum pitch          */
+    Word16 *t0_min,      /* o : search range minimum   */
+    Word16 *t0_max)      /* o : search range maximum   */
+{
+    *t0_min = sub(T0, delta_low);
+    test ();
+    if (sub(*t0_min, pitmin) < 0) {
+        *t0_min = pitmin;                                  move16();
+    }
+    *t0_max = add(*t0_min, delta_range);
+    test ();
+    if (sub(*t0_max, pitmax) > 0) {
+        *t0_max = pitmax;                                  move16();
+        *t0_min = sub(*t0_max, delta_range);
+    }
+}
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+
+/*************************************************************************
+*
+*  Function:   Pitch_fr_init
+*  Purpose:    Allocates state memory and initializes state memory
+*
+**************************************************************************
+*/
+int Pitch_fr_init (Pitch_frState **state)
+{
+    Pitch_frState* s;
+
+    if (state == (Pitch_frState **) NULL){
+        fprintf(stderr, "Pitch_fr_init: invalid parameter\n");
+        return -1;
+    }
+    *state = NULL;
+
+    /* allocate memory */
+    if ((s= (Pitch_frState *) malloc(sizeof(Pitch_frState))) == NULL){
+        fprintf(stderr, "Pitch_fr_init: can not malloc state structure\n");
+        return -1;
+    }
+
+    Pitch_fr_reset(s);
+    *state = s;
+
+    return 0;
+}
+
+/*************************************************************************
+*
+*  Function:   Pitch_fr_reset
+*  Purpose:    Initializes state memory to zero
+*
+**************************************************************************
+*/
+int Pitch_fr_reset (Pitch_frState *state)
+{
+
+    if (state == (Pitch_frState *) NULL){
+        fprintf(stderr, "Pitch_fr_reset: invalid parameter\n");
+        return -1;
+    }
+
+    state->T0_prev_subframe = 0;
+
+    return 0;
+}
+
+/*************************************************************************
+*
+*  Function:   Pitch_fr_exit
+*  Purpose:    The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void Pitch_fr_exit (Pitch_frState **state)
+{
+    if (state == NULL || *state == NULL)
+        return;
+
+    /* deallocate memory */
+    free(*state);
+    *state = NULL;
+
+    return;
+}
+
+/*************************************************************************
+ *
+ *  FUNCTION:   Pitch_fr()
+ *
+ *  PURPOSE: Find the pitch period with 1/3 or 1/6 subsample resolution
+ *           (closed loop).
+ *
+ *  DESCRIPTION:
+ *        - find the normalized correlation between the target and filtered
+ *          past excitation in the search range.
+ *        - select the delay with maximum normalized correlation.
+ *        - interpolate the normalized correlation at fractions -3/6 to 3/6
+ *          with step 1/6 around the chosen delay.
+ *        - The fraction which gives the maximum interpolated value is chosen.
+ *
+ *************************************************************************/
+Word16 Pitch_fr (        /* o   : pitch period (integer)                    */
+    Pitch_frState *st,   /* i/o : State struct                              */
+    enum Mode mode,      /* i   : codec mode                                */
+    Word16 T_op[],       /* i   : open loop pitch lags                      */
+    Word16 exc[],        /* i   : excitation buffer                      Q0 */
+    Word16 xn[],         /* i   : target vector                          Q0 */
+    Word16 h[],          /* i   : impulse response of synthesis and
+                                  weighting filters                     Q12 */
+    Word16 L_subfr,      /* i   : Length of subframe                        */
+    Word16 i_subfr,      /* i   : subframe offset                           */
+    Word16 *pit_frac,    /* o   : pitch period (fractional)                 */
+    Word16 *resu3,       /* o   : subsample resolution 1/3 (=1) or 1/6 (=0) */
+    Word16 *ana_index    /* o   : index of encoding                         */
+)
+{
+    Word16 i;
+    Word16 t_min, t_max;
+    Word16 t0_min, t0_max;
+    Word16 max, lag, frac;
+    Word16 tmp_lag;
+    Word16 *corr;
+    Word16 corr_v[40];    /* Total length = t0_max-t0_min+1+2*L_INTER_SRCH */
+
+    Word16 max_frac_lag;
+    Word16 flag3, flag4;
+    Word16 last_frac;
+    Word16 delta_int_low, delta_int_range;
+    Word16 delta_frc_low, delta_frc_range;
+    Word16 pit_min;
+    Word16 frame_offset;
+    Word16 delta_search;
+
+    /*-----------------------------------------------------------------------*
+     *                      set mode specific variables                      *
+     *-----------------------------------------------------------------------*/
+
+    max_frac_lag    = mode_dep_parm[mode].max_frac_lag;           move16 ();
+    flag3           = mode_dep_parm[mode].flag3;                  move16 ();
+    frac            = mode_dep_parm[mode].first_frac;             move16 ();
+    last_frac       = mode_dep_parm[mode].last_frac;              move16 ();
+    delta_int_low   = mode_dep_parm[mode].delta_int_low;          move16 ();
+    delta_int_range = mode_dep_parm[mode].delta_int_range;        move16 ();
+    
+    delta_frc_low   = mode_dep_parm[mode].delta_frc_low;          move16 ();
+    delta_frc_range = mode_dep_parm[mode].delta_frc_range;        move16 ();
+    pit_min         = mode_dep_parm[mode].pit_min;                move16 ();
+    
+    /*-----------------------------------------------------------------------*
+     *                 decide upon full or differential search               *
+     *-----------------------------------------------------------------------*/
+    
+    delta_search = 1;                                             move16 ();
+    
+    test (); test ();
+    if ((i_subfr == 0) || (sub(i_subfr,L_FRAME_BY2) == 0)) {
+      
+        /* Subframe 1 and 3 */
+      
+        test (); test (); test ();
+        if (((sub(mode, MR475) != 0) && (sub(mode, MR515) != 0)) ||
+            (sub(i_subfr,L_FRAME_BY2) != 0)) {
+        
+            /* set t0_min, t0_max for full search */
+            /* this is *not* done for mode MR475, MR515 in subframe 3 */
+        
+            delta_search = 0; /* no differential search */         move16 ();
+            
+            /* calculate index into T_op which contains the open-loop */
+            /* pitch estimations for the 2 big subframes */
+            
+            frame_offset = 1;                                      move16 ();
+            test ();
+            if (i_subfr == 0)
+                frame_offset = 0;                                  move16 ();
+            
+            /* get T_op from the corresponding half frame and */
+            /* set t0_min, t0_max */
+            
+            getRange (T_op[frame_offset], delta_int_low, delta_int_range,
+                      pit_min, PIT_MAX, &t0_min, &t0_max);
+        }
+        else {
+            
+            /* mode MR475, MR515 and 3. Subframe: delta search as well */
+            getRange (st->T0_prev_subframe, delta_frc_low, delta_frc_range,
+                      pit_min, PIT_MAX, &t0_min, &t0_max);
+        }
+    }
+    else {
+        
+        /* for Subframe 2 and 4 */
+        /* get range around T0 of previous subframe for delta search */
+        
+        getRange (st->T0_prev_subframe, delta_frc_low, delta_frc_range,
+                  pit_min, PIT_MAX, &t0_min, &t0_max);
+    }
+
+    /*-----------------------------------------------------------------------*
+     *           Find interval to compute normalized correlation             *
+     *-----------------------------------------------------------------------*/
+
+    t_min = sub (t0_min, L_INTER_SRCH);
+    t_max = add (t0_max, L_INTER_SRCH);
+
+    corr = &corr_v[-t_min];                                        move16 ();
+
+    /*-----------------------------------------------------------------------*
+     * Compute normalized correlation between target and filtered excitation *
+     *-----------------------------------------------------------------------*/
+
+    Norm_Corr (exc, xn, h, L_subfr, t_min, t_max, corr);
+
+    /*-----------------------------------------------------------------------*
+     *                           Find integer pitch                          *
+     *-----------------------------------------------------------------------*/
+
+    max = corr[t0_min];                                            move16 ();
+    lag = t0_min;                                                  move16 ();
+
+    for (i = t0_min + 1; i <= t0_max; i++) {
+        test ();
+        if (sub (corr[i], max) >= 0) {
+            max = corr[i];                                         move16 ();
+            lag = i;                                               move16 ();
+        }
+    }
+
+    /*-----------------------------------------------------------------------*
+     *                        Find fractional pitch                          *
+     *-----------------------------------------------------------------------*/
+    test (); test ();
+    if ((delta_search == 0) && (sub (lag, max_frac_lag) > 0)) {
+
+        /* full search and integer pitch greater than max_frac_lag */
+        /* fractional search is not needed, set fractional to zero */
+
+        frac = 0;                                                  move16 ();
+    }
+    else {
+
+        /* if differential search AND mode MR475 OR MR515 OR MR59 OR MR67   */
+        /* then search fractional with 4 bits resolution           */
+       
+       test (); test (); test (); test (); test (); 
+       if ((delta_search != 0) &&
+           ((sub (mode, MR475) == 0) ||
+            (sub (mode, MR515) == 0) ||
+            (sub (mode, MR59) == 0) ||
+            (sub (mode, MR67) == 0))) {
+
+          /* modify frac or last_frac according to position of last */
+          /* integer pitch: either search around integer pitch, */
+          /* or only on left or right side */
+          
+          tmp_lag = st->T0_prev_subframe;                          move16 ();
+          test ();
+          if ( sub( sub(tmp_lag, t0_min), 5) > 0)
+             tmp_lag = add (t0_min, 5);
+          test ();
+          if ( sub( sub(t0_max, tmp_lag), 4) > 0)
+               tmp_lag = sub (t0_max, 4);
+          
+          test (); test ();
+          if ((sub (lag, tmp_lag) == 0) ||
+              (sub (lag, sub(tmp_lag, 1)) == 0)) {
+             
+             /* normal search in fractions around T0 */
+             
+             searchFrac (&lag, &frac, last_frac, corr, flag3);
+             
+          }
+          else if (sub (lag, sub (tmp_lag, 2)) == 0) {
+             test ();
+             /* limit search around T0 to the right side */
+             frac = 0;                                            move16 ();
+             searchFrac (&lag, &frac, last_frac, corr, flag3);
+          }
+          else if (sub (lag, add(tmp_lag, 1)) == 0) {
+             test (); test ();
+             /* limit search around T0 to the left side */
+             last_frac = 0;                                       move16 ();
+             searchFrac (&lag, &frac, last_frac, corr, flag3);
+          }
+          else {
+             test (); test ();
+             /* no fractional search */
+             frac = 0;                                            move16 ();
+            }
+       }
+       else
+          /* test the fractions around T0 */
+          searchFrac (&lag, &frac, last_frac, corr, flag3);
+    }
+    
+    /*-----------------------------------------------------------------------*
+     *                           encode pitch                                *
+     *-----------------------------------------------------------------------*/
+    
+    test ();
+    if (flag3 != 0) {       
+       /* flag4 indicates encoding with 4 bit resolution;         */
+       /* this is needed for mode MR475, MR515 and MR59           */
+       
+       flag4 = 0;                                                 move16 ();
+       test (); test (); test (); test (); 
+       if ( (sub (mode, MR475) == 0) ||
+            (sub (mode, MR515) == 0) ||
+            (sub (mode, MR59) == 0) ||
+            (sub (mode, MR67) == 0) ) {
+          flag4 = 1;                                              move16 ();
+       }
+       
+       /* encode with 1/3 subsample resolution */
+       
+       *ana_index = Enc_lag3(lag, frac, st->T0_prev_subframe,
+                             t0_min, t0_max, delta_search, flag4); move16 (); /* function result */
+
+    }  
+    else
+    {
+       /* encode with 1/6 subsample resolution */
+       
+       *ana_index = Enc_lag6(lag, frac, t0_min, delta_search); move16 (); /* function result */
+    }
+    
+    /*-----------------------------------------------------------------------*
+     *                          update state variables                       *
+     *-----------------------------------------------------------------------*/
+    
+    st->T0_prev_subframe = lag;                                    move16 ();
+    
+    /*-----------------------------------------------------------------------*
+     *                      update output variables                          *
+     *-----------------------------------------------------------------------*/
+    
+    *resu3    = flag3;                                             move16 ();
+
+    *pit_frac = frac;                                              move16 ();
+
+    return (lag);
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/pitch_fr.h FFMpeg-20050127-new/libavcodec/amr/pitch_fr.h
--- FFMpeg-20050127/libavcodec/amr/pitch_fr.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/pitch_fr.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,73 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : pitch_fr.h
+*      Purpose          : Find the pitch period with 1/3 or 1/6 subsample
+*                       : resolution (closed loop).
+*
+********************************************************************************
+*/
+#ifndef pitch_fr_h
+#define pitch_fr_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+typedef struct {
+   Word16 T0_prev_subframe;   /* integer pitch lag of previous sub-frame */
+} Pitch_frState;
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+int Pitch_fr_init (Pitch_frState **st);
+/* initialize one instance of the pre processing state.
+   Stores pointer to filter status struct in *st. This pointer has to
+   be passed to Pitch_fr in each call.
+   returns 0 on success
+ */
+ 
+int Pitch_fr_reset (Pitch_frState *st);
+/* reset of pre processing state (i.e. set state memory to zero)
+   returns 0 on success
+ */
+
+void Pitch_fr_exit (Pitch_frState **st);
+/* de-initialize pre processing state (i.e. free status struct)
+   stores NULL in *st
+ */
+
+Word16 Pitch_fr (        /* o   : pitch period (integer)                    */
+    Pitch_frState *st,   /* i/o : State struct                              */
+    enum Mode mode,      /* i   : codec mode                                */
+    Word16 T_op[],       /* i   : open loop pitch lags                      */
+    Word16 exc[],        /* i   : excitation buffer                         */
+    Word16 xn[],         /* i   : target vector                             */
+    Word16 h[],          /* i   : impulse response of synthesis and   
+                                  weighting filters                         */
+    Word16 L_subfr,      /* i   : Length of subframe                        */
+    Word16 i_subfr,      /* i   : subframe offset                           */
+    Word16 *pit_frac,    /* o   : pitch period (fractional)                 */
+    Word16 *resu3,       /* o   : subsample resolution 1/3 (=1) or 1/6 (=0) */
+    Word16 *ana_index    /* o   : index of encoding                         */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/pitch_ol.c FFMpeg-20050127-new/libavcodec/amr/pitch_ol.c
--- FFMpeg-20050127/libavcodec/amr/pitch_ol.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/pitch_ol.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,394 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : pitch_ol.c
+*      Purpose          : Compute the open loop pitch lag.
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "pitch_ol.h"
+const char pitch_ol_id[] = "@(#)$Id $" pitch_ol_h;
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "cnst.h"
+#include "inv_sqrt.h"
+#include "vad.h"
+#include "calc_cor.h"
+#include "hp_max.h"
+ 
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#define THRESHOLD 27853
+
+/*
+********************************************************************************
+*                         LOCAL PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  Lag_max
+ *
+ *  PURPOSE: Find the lag that has maximum correlation of scal_sig[] in a
+ *           given delay range.
+ *
+ *  DESCRIPTION:
+ *      The correlation is given by
+ *           cor[t] = <scal_sig[n],scal_sig[n-t]>,  t=lag_min,...,lag_max
+ *      The functions outputs the maximum correlation after normalization
+ *      and the corresponding lag.
+ *
+ *************************************************************************/
+#ifdef VAD2
+static Word16 Lag_max ( /* o   : lag found                               */
+    Word32 corr[],      /* i   : correlation vector.                     */
+    Word16 scal_sig[],  /* i   : scaled signal.                          */    
+    Word16 scal_fac,    /* i   : scaled signal factor.                   */
+    Word16 scal_flag,   /* i   : if 1 use EFR compatible scaling         */
+    Word16 L_frame,     /* i   : length of frame to compute pitch        */
+    Word16 lag_max,     /* i   : maximum lag                             */
+    Word16 lag_min,     /* i   : minimum lag                             */
+    Word16 *cor_max,    /* o   : normalized correlation of selected lag  */
+    Word32 *rmax,       /* o   : max(<s[i]*s[j]>)                        */
+    Word32 *r0,         /* o   : residual energy                         */
+    Flag dtx            /* i   : dtx flag; use dtx=1, do not use dtx=0   */
+    )
+#else
+static Word16 Lag_max ( /* o   : lag found                               */
+    vadState *vadSt,    /* i/o : VAD state struct                        */
+    Word32 corr[],      /* i   : correlation vector.                     */
+    Word16 scal_sig[],  /* i   : scaled signal.                          */    
+    Word16 scal_fac,    /* i   : scaled signal factor.                   */
+    Word16 scal_flag,   /* i   : if 1 use EFR compatible scaling         */
+    Word16 L_frame,     /* i   : length of frame to compute pitch        */
+    Word16 lag_max,     /* i   : maximum lag                             */
+    Word16 lag_min,     /* i   : minimum lag                             */
+    Word16 *cor_max,    /* o   : normalized correlation of selected lag  */
+    Flag dtx            /* i   : dtx flag; use dtx=1, do not use dtx=0   */
+    )
+#endif
+{
+    Word16 i, j;
+    Word16 *p;
+    Word32 max, t0;
+    Word16 max_h, max_l, ener_h, ener_l;
+    Word16 p_max = 0; /* initialization only needed to keep gcc silent */
+    
+    max = MIN_32;               move32 (); 
+    p_max = lag_max;            move16 ();
+   
+    for (i = lag_max, j = (PIT_MAX-lag_max-1); i >= lag_min; i--, j--)  
+    {
+       test ();  
+       if (L_sub (corr[-i], max) >= 0) 
+       { 
+          max = corr[-i];       move32 ();  
+          p_max = i;            move16 ();  
+       } 
+    }
+    
+    /* compute energy */
+
+    t0 = 0;                     move32 ();     
+    p = &scal_sig[-p_max];      move16 (); 
+    for (i = 0; i < L_frame; i++, p++)
+    {
+        t0 = L_mac (t0, *p, *p);
+    }
+    /* 1/sqrt(energy) */
+
+    if (dtx)
+    {  /* no test() call since this if is only in simulation env */
+#ifdef VAD2
+       *rmax = max;		move32();
+       *r0 = t0;		move32();
+#else
+       /* check tone */
+       vad_tone_detection (vadSt, max, t0);
+#endif
+    }
+    
+    t0 = Inv_sqrt (t0); move32 (); /* function result */
+
+    test();
+    if (scal_flag)
+    {
+       t0 = L_shl (t0, 1);
+    }
+    
+    /* max = max/sqrt(energy)  */
+
+    L_Extract (max, &max_h, &max_l);
+    L_Extract (t0, &ener_h, &ener_l);
+
+    t0 = Mpy_32 (max_h, max_l, ener_h, ener_l);
+    
+    test();
+    if (scal_flag)
+    {
+      t0 = L_shr (t0, scal_fac);
+      *cor_max = extract_h (L_shl (t0, 15)); /* divide by 2 */
+    }
+    else
+    {
+      *cor_max = extract_l(t0);
+    }
+
+    return (p_max);
+}
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  Pitch_ol
+ *
+ *  PURPOSE: Compute the open loop pitch lag.
+ *
+ *  DESCRIPTION:
+ *      The open-loop pitch lag is determined based on the perceptually
+ *      weighted speech signal. This is done in the following steps:
+ *        - find three maxima of the correlation <sw[n],sw[n-T]>,
+ *          dividing the search range into three parts:
+ *               pit_min ... 2*pit_min-1
+ *             2*pit_min ... 4*pit_min-1
+ *             4*pit_min ...   pit_max
+ *        - divide each maximum by <sw[n-t], sw[n-t]> where t is the delay at
+ *          that maximum correlation.
+ *        - select the delay of maximum normalized correlation (among the
+ *          three candidates) while favoring the lower delay ranges.
+ *
+ *************************************************************************/
+Word16 Pitch_ol (      /* o   : open loop pitch lag                         */
+    vadState *vadSt,   /* i/o : VAD state struct                            */
+    enum Mode mode,    /* i   : coder mode                                  */
+    Word16 signal[],   /* i   : signal used to compute the open loop pitch  */
+                       /*    signal[-pit_max] to signal[-1] should be known */
+    Word16 pit_min,    /* i   : minimum pitch lag                           */
+    Word16 pit_max,    /* i   : maximum pitch lag                           */
+    Word16 L_frame,    /* i   : length of frame to compute pitch            */
+    Word16 idx,        /* i   : frame index                                 */
+    Flag dtx           /* i   : dtx flag; use dtx=1, do not use dtx=0       */
+    )
+{
+    Word16 i, j;
+    Word16 max1, max2, max3;
+    Word16 p_max1, p_max2, p_max3;
+    Word16 scal_flag = 0;
+    Word32 t0;
+#ifdef VAD2
+    Word32  r01, r02, r03;
+    Word32  rmax1, rmax2, rmax3;
+#else
+    Word16 corr_hp_max;
+#endif
+    Word32 corr[PIT_MAX+1], *corr_ptr;
+    
+    /* Scaled signal */
+
+    Word16 scaled_signal[L_FRAME + PIT_MAX];
+    Word16 *scal_sig, scal_fac;
+
+#ifndef VAD2
+    if (dtx)
+    {  /* no test() call since this if is only in simulation env */
+       /* update tone detection */
+       test(); test();
+       if ((sub(mode, MR475) == 0) || (sub(mode, MR515) == 0))
+       {
+          vad_tone_detection_update (vadSt, 1);
+       }
+       else
+       {
+          vad_tone_detection_update (vadSt, 0);
+       }
+    }
+#endif
+    
+    scal_sig = &scaled_signal[pit_max]; move16 (); 
+
+    t0 = 0L;                            move32 (); 
+    for (i = -pit_max; i < L_frame; i++)
+    {
+        t0 = L_mac (t0, signal[i], signal[i]);
+    }
+   
+    /*--------------------------------------------------------*
+     * Scaling of input signal.                               *
+     *                                                        *
+     *   if Overflow        -> scal_sig[i] = signal[i]>>3     *
+     *   else if t0 < 1^20  -> scal_sig[i] = signal[i]<<3     *
+     *   else               -> scal_sig[i] = signal[i]        *
+     *--------------------------------------------------------*/
+
+    /*--------------------------------------------------------*
+     *  Verification for risk of overflow.                    *
+     *--------------------------------------------------------*/
+
+    test ();
+    if (L_sub (t0, MAX_32) == 0L)               /* Test for overflow */
+    {
+        for (i = -pit_max; i < L_frame; i++)
+        {
+            scal_sig[i] = shr (signal[i], 3);   move16 (); 
+        }
+        scal_fac = 3;                           move16 (); 
+    }
+    else if (L_sub (t0, (Word32) 1048576L) < (Word32) 0)
+        /* if (t0 < 2^20) */
+    {
+		test (); 
+        for (i = -pit_max; i < L_frame; i++)
+        {
+            scal_sig[i] = shl (signal[i], 3);   move16 (); 
+        }
+        scal_fac = -3;                          move16 (); 
+    }
+    else
+    {
+		test (); 
+        for (i = -pit_max; i < L_frame; i++)
+        {
+            scal_sig[i] = signal[i];            move16 (); 
+        }
+        scal_fac = 0;                           move16 (); 
+    }
+
+    /* calculate all coreelations of scal_sig, from pit_min to pit_max */
+    corr_ptr = &corr[pit_max];                  move32 ();
+    comp_corr (scal_sig, L_frame, pit_max, pit_min, corr_ptr); 
+    
+    /*--------------------------------------------------------------------*
+     *  The pitch lag search is divided in three sections.                *
+     *  Each section cannot have a pitch multiple.                        *
+     *  We find a maximum for each section.                               *
+     *  We compare the maximum of each section by favoring small lags.    *
+     *                                                                    *
+     *  First section:  lag delay = pit_max     downto 4*pit_min          *
+     *  Second section: lag delay = 4*pit_min-1 downto 2*pit_min          *
+     *  Third section:  lag delay = 2*pit_min-1 downto pit_min            *
+     *--------------------------------------------------------------------*/
+
+    /* mode dependent scaling in Lag_max */
+    test (); 
+    if (sub(mode, MR122) == 0)
+    {
+       scal_flag = 1;                           move16 (); 
+    }
+    else
+    {
+       scal_flag = 0;                           move16 ();    
+    } 
+    
+#ifdef VAD2
+    j = shl (pit_min, 2);
+    p_max1 = Lag_max (corr_ptr, scal_sig, scal_fac, scal_flag, L_frame,
+                      pit_max, j, &max1, &rmax1, &r01, dtx);
+                      move16 (); /* function result */
+
+    i = sub (j, 1);
+    j = shl (pit_min, 1);
+    p_max2 = Lag_max (corr_ptr, scal_sig, scal_fac, scal_flag, L_frame,
+                      i, j, &max2, &rmax2, &r02, dtx);
+                      move16 (); /* function result */
+
+    i = sub (j, 1);
+    p_max3 = Lag_max (corr_ptr, scal_sig, scal_fac, scal_flag, L_frame,
+                      i, pit_min, &max3, &rmax3, &r03, dtx);
+                      move16 (); /* function result */
+#else
+    j = shl (pit_min, 2);
+    p_max1 = Lag_max (vadSt, corr_ptr, scal_sig, scal_fac, scal_flag, L_frame,
+                      pit_max, j, &max1, dtx);  move16 (); /* function result */
+
+    i = sub (j, 1);
+    j = shl (pit_min, 1);
+    p_max2 = Lag_max (vadSt, corr_ptr, scal_sig, scal_fac, scal_flag, L_frame,
+                      i, j, &max2, dtx);        move16 (); /* function result */
+
+    i = sub (j, 1);
+    p_max3 = Lag_max (vadSt, corr_ptr, scal_sig, scal_fac, scal_flag, L_frame,
+                      i, pit_min, &max3, dtx);  move16 (); /* function result */
+
+    if (dtx)
+    {  /* no test() call since this if is only in simulation env */
+       test ();
+       if (sub(idx, 1) == 0)
+       {
+          /* calculate max high-passed filtered correlation of all lags */
+          hp_max (corr_ptr, scal_sig, L_frame, pit_max, pit_min, &corr_hp_max); 
+          
+          /* update complex background detector */
+          vad_complex_detection_update(vadSt, corr_hp_max); 
+       }
+    }
+#endif
+    
+    /*--------------------------------------------------------------------*
+     * Compare the 3 sections maximum, and favor small lag.               *
+     *--------------------------------------------------------------------*/
+    
+    test (); 
+    if (sub (mult (max1, THRESHOLD), max2) < 0)
+    {
+        max1 = max2;                       move16 (); 
+        p_max1 = p_max2;                   move16 (); 
+#ifdef VAD2
+        if (dtx)
+        {
+            rmax1 = rmax2;                 move32 ();
+            r01 = r02;                     move32 ();
+        }
+#endif
+    }
+    test (); 
+    if (sub (mult (max1, THRESHOLD), max3) < 0)
+    {
+        p_max1 = p_max3;                   move16 (); 
+#ifdef VAD2
+        if (dtx)
+        {
+            rmax1 = rmax3;                 move32 ();
+            r01 = r03;                     move32 ();
+        }
+#endif
+    }
+
+#ifdef VAD2
+    if (dtx)
+    {
+        vadSt->L_Rmax = L_add(vadSt->L_Rmax, rmax1);   /* Save max correlation */
+        vadSt->L_R0 =   L_add(vadSt->L_R0, r01);        /* Save max energy */
+    }
+#endif
+
+    return (p_max1);
+}
+
+
diff -Nur FFMpeg-20050127/libavcodec/amr/pitch_ol.h FFMpeg-20050127-new/libavcodec/amr/pitch_ol.h
--- FFMpeg-20050127/libavcodec/amr/pitch_ol.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/pitch_ol.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,50 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : pitch_ol.h
+*      Purpose          : Compute the open loop pitch lag.
+*
+********************************************************************************
+*/
+#ifndef pitch_ol_h
+#define pitch_ol_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+#include "vad.h"
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+Word16 Pitch_ol (      /* o   : open loop pitch lag                         */
+    vadState *vadSt,   /* i/o : VAD state struct                            */
+    enum Mode mode,    /* i   : coder mode                                  */
+    Word16 signal[],   /* i   : signal used to compute the open loop pitch  */
+                       /*    signal[-pit_max] to signal[-1] should be known */
+    Word16 pit_min,    /* i   : minimum pitch lag                           */
+    Word16 pit_max,    /* i   : maximum pitch lag                           */
+    Word16 L_frame,    /* i   : length of frame to compute pitch            */
+    Word16 idx,        /* i   : frame index                                 */
+    Flag dtx           /* i   : dtx flag; use dtx=1, do not use dtx=0       */
+    );
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/post_pro.c FFMpeg-20050127-new/libavcodec/amr/post_pro.c
--- FFMpeg-20050127/libavcodec/amr/post_pro.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/post_pro.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,179 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : post_pro.c
+*      Purpose          : Postprocessing of output speech.
+*
+*                         - 2nd order high pass filtering with cut
+*                           off frequency at 60 Hz.
+*                         - Multiplication of output by two.
+*
+********************************************************************************
+*/
+ 
+ 
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "post_pro.h"
+const char post_pro_id[] = "@(#)$Id $" post_pro_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+ 
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+/* filter coefficients (fc = 60 Hz) */
+static const Word16 b[3] = {7699, -15398, 7699};
+static const Word16 a[3] = {8192, 15836, -7667};
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+*
+*  Function:   Post_Process_init
+*  Purpose:    Allocates state memory and initializes state memory
+*
+**************************************************************************
+*/
+int Post_Process_init (Post_ProcessState **state)
+{
+  Post_ProcessState* s;
+ 
+  if (state == (Post_ProcessState **) NULL){
+      fprintf(stderr, "Post_Process_init: invalid parameter\n");
+      return -1;
+  }
+  *state = NULL;
+ 
+  /* allocate memory */
+  if ((s= (Post_ProcessState *) malloc(sizeof(Post_ProcessState))) == NULL){
+      fprintf(stderr, "Post_Process_init: can not malloc state structure\n");
+      return -1;
+  }
+  
+  Post_Process_reset(s);
+  *state = s;
+  
+  return 0;
+}
+ 
+/*************************************************************************
+*
+*  Function:   Post_Process_reset
+*  Purpose:    Initializes state memory to zero
+*
+**************************************************************************
+*/
+int Post_Process_reset (Post_ProcessState *state)
+{
+  if (state == (Post_ProcessState *) NULL){
+      fprintf(stderr, "Post_Process_reset: invalid parameter\n");
+      return -1;
+  }
+  
+  state->y2_hi = 0;
+  state->y2_lo = 0;
+  state->y1_hi = 0;
+  state->y1_lo = 0;
+  state->x0 = 0;
+  state->x1 = 0;
+
+  return 0;
+}
+ 
+/*************************************************************************
+*
+*  Function:   Post_Process_exit
+*  Purpose:    The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void Post_Process_exit (Post_ProcessState **state)
+{
+  if (state == NULL || *state == NULL)
+      return;
+ 
+  /* deallocate memory */
+  free(*state);
+  *state = NULL;
+  
+  return;
+}
+ 
+/*************************************************************************
+ *
+ *  FUNCTION:  Post_Process()
+ *
+ *  PURPOSE: Postprocessing of input speech.
+ *
+ *  DESCRIPTION:
+ *     - 2nd order high pass filtering with cut off frequency at 60 Hz.
+ *     - Multiplication of output by two.
+ *                                                                        
+ * Algorithm:                                                             
+ *                                                                        
+ *  y[i] = b[0]*x[i]*2 + b[1]*x[i-1]*2 + b[2]*x[i-2]*2
+ *                     + a[1]*y[i-1]   + a[2]*y[i-2];                     
+ *                                                                        
+ *                                                                        
+ *************************************************************************/
+int Post_Process (
+    Post_ProcessState *st,  /* i/o : post process state                   */
+    Word16 signal[],        /* i/o : signal                               */
+    Word16 lg               /* i   : length of signal                     */
+    )
+{
+    Word16 i, x2;
+    Word32 L_tmp;
+
+    test (); test ();
+    for (i = 0; i < lg; i++)
+    {
+        x2 = st->x1;                             move16 (); 
+        st->x1 = st->x0;                         move16 (); 
+        st->x0 = signal[i];                      move16 (); 
+        
+        /*  y[i] = b[0]*x[i]*2 + b[1]*x[i-1]*2 + b140[2]*x[i-2]/2  */
+        /*                     + a[1]*y[i-1] + a[2] * y[i-2];      */
+        
+        L_tmp = Mpy_32_16 (st->y1_hi, st->y1_lo, a[1]);
+        L_tmp = L_add (L_tmp, Mpy_32_16 (st->y2_hi, st->y2_lo, a[2]));
+        L_tmp = L_mac (L_tmp, st->x0, b[0]);
+        L_tmp = L_mac (L_tmp, st->x1, b[1]);
+        L_tmp = L_mac (L_tmp, x2, b[2]);
+        L_tmp = L_shl (L_tmp, 2);
+        
+        /* Multiplication by two of output speech with saturation. */
+        signal[i] = round(L_shl(L_tmp, 1));   move16 (); 
+        
+        st->y2_hi = st->y1_hi;                   move16 (); 
+        st->y2_lo = st->y1_lo;                   move16 (); 
+        L_Extract (L_tmp, &st->y1_hi, &st->y1_lo);
+    }
+
+    return 0;    
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/post_pro.h FFMpeg-20050127-new/libavcodec/amr/post_pro.h
--- FFMpeg-20050127/libavcodec/amr/post_pro.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/post_pro.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,77 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : post_pro.h
+*      Purpose          : Postprocessing of output speech.
+*
+*                         - 2nd order high pass filtering with cut
+*                           off frequency at 60 Hz.
+*                         - Multiplication of output by two.
+*
+********************************************************************************
+*/
+#ifndef post_pro_h
+#define post_pro_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+typedef struct {
+   Word16 y2_hi;
+   Word16 y2_lo;
+   Word16 y1_hi;
+   Word16 y1_lo;
+   Word16 x0;
+   Word16 x1;
+} Post_ProcessState;
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+ 
+int Post_Process_init (Post_ProcessState **st);
+/* initialize one instance of the Post processing state.
+   Stores pointer to filter status struct in *st. This pointer has to
+   be passed to Post_Process in each call.
+   returns 0 on success
+ */
+ 
+int Post_Process_reset (Post_ProcessState *st);
+/* reset of Post processing state (i.e. set state memory to zero)
+   returns 0 on success
+ */
+void Post_Process_exit (Post_ProcessState **st);
+/* de-initialize Post processing state (i.e. free status struct)
+   stores NULL in *st
+ */
+ 
+int Post_Process (
+    Post_ProcessState *st,  /* i/o : post process state                   */
+    Word16 signal[],        /* i/o : signal                               */
+    Word16 lg               /* i   : lenght of signal                     */
+    );
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/pow2.c FFMpeg-20050127-new/libavcodec/amr/pow2.c
--- FFMpeg-20050127/libavcodec/amr/pow2.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/pow2.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,81 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : pow2.c
+*      Purpose          : computes  L_x = pow(2.0, exponent.fraction)
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "pow2.h"
+const char pow2_id[] = "@(#)$Id $" pow2_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+ 
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#include "pow2.tab"     /* Table for Pow2() */
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *   FUNCTION:  Pow2()
+ *
+ *   PURPOSE: computes  L_x = pow(2.0, exponent.fraction)
+ *
+ *   DESCRIPTION:
+ *       The function Pow2(L_x) is approximated by a table and linear
+ *       interpolation.
+ *          1- i = bit10-b15 of fraction,   0 <= i <= 31
+ *          2- a = bit0-b9   of fraction   
+ *          3- L_x = table[i]<<16 - (table[i] - table[i+1]) * a * 2
+ *          4- L_x = L_x >> (30-exponent)     (with rounding)
+ *
+ *************************************************************************/
+Word32 Pow2 (           /* (o)  : result       (range: 0<=val<=0x7fffffff) */
+    Word16 exponent,    /* (i)  : Integer part.      (range: 0<=val<=30)   */
+    Word16 fraction     /* (i)  : Fractional part.  (range: 0.0<=val<1.0) */
+)
+{
+    Word16 exp, i, a, tmp;
+    Word32 L_x;
+
+    L_x = L_mult (fraction, 32);/* L_x = fraction<<6           */
+    i = extract_h (L_x);        /* Extract b10-b16 of fraction */
+    L_x = L_shr (L_x, 1);
+    a = extract_l (L_x);        /* Extract b0-b9   of fraction */
+    a = a & (Word16) 0x7fff;    logic16 (); 
+
+    L_x = L_deposit_h (table[i]);       /* table[i] << 16        */
+    tmp = sub (table[i], table[i + 1]); /* table[i] - table[i+1] */
+    L_x = L_msu (L_x, tmp, a);  /* L_x -= tmp*a*2        */
+
+    exp = sub (30, exponent);
+    L_x = L_shr_r (L_x, exp);
+
+    return (L_x);
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/pow2.h FFMpeg-20050127-new/libavcodec/amr/pow2.h
--- FFMpeg-20050127/libavcodec/amr/pow2.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/pow2.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,41 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : pow2.h
+*      Purpose          : computes  L_x = pow(2.0, exponent.fraction)
+*
+********************************************************************************
+*/
+#ifndef pow2_h
+#define pow2_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+Word32 Pow2 (          /* (o) : result       (range: 0<=val<=0x7fffffff)    */
+    Word16 exponent,   /* (i) : Integer part.      (range: 0<=val<=30)      */
+    Word16 fraction    /* (i) : Fractional part.  (range: 0.0<=val<1.0)     */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/pow2.tab FFMpeg-20050127-new/libavcodec/amr/pow2.tab
--- FFMpeg-20050127/libavcodec/amr/pow2.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/pow2.tab	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,22 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : pow2.tab
+*      Purpose          : Table for routine Pow2().
+*      $Id $
+*
+********************************************************************************
+*/
+static const Word16 table[33] =
+{
+    16384, 16743, 17109, 17484, 17867, 18258, 18658, 19066, 19484, 19911,
+    20347, 20792, 21247, 21713, 22188, 22674, 23170, 23678, 24196, 24726,
+    25268, 25821, 26386, 26964, 27554, 28158, 28774, 29405, 30048, 30706,
+    31379, 32066, 32767
+};
diff -Nur FFMpeg-20050127/libavcodec/amr/pre_big.c FFMpeg-20050127-new/libavcodec/amr/pre_big.c
--- FFMpeg-20050127/libavcodec/amr/pre_big.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/pre_big.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,95 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : pre_big.c
+*      Purpose          : Big subframe (2 subframes) preprocessing
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "pre_big.h"
+const char pre_big_id[] = "@(#)$Id $" pre_big_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "syn_filt.h"
+#include "weight_a.h"
+#include "residu.h"
+#include "count.h"
+#include "cnst.h"
+
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+int pre_big(
+    enum Mode mode,            /* i  : coder mode                             */
+    const Word16 gamma1[],     /* i  : spectral exp. factor 1                 */
+    const Word16 gamma1_12k2[],/* i  : spectral exp. factor 1 for EFR         */
+    const Word16 gamma2[],     /* i  : spectral exp. factor 2                 */
+    Word16 A_t[],              /* i  : A(z) unquantized, for 4 subframes, Q12 */
+    Word16 frameOffset,        /* i  : Start position in speech vector,   Q0  */
+    Word16 speech[],           /* i  : speech,                            Q0  */
+    Word16 mem_w[],            /* i/o: synthesis filter memory state,     Q0  */
+    Word16 wsp[]               /* o  : weighted speech                    Q0  */
+)
+{
+   Word16 Ap1[MP1];            /* A(z) with spectral expansion         */
+   Word16 Ap2[MP1];            /* A(z) with spectral expansion         */
+   const Word16 *g1;           /* Pointer to correct gammma1 vector    */
+   Word16 aOffset;
+   Word16 i;
+   
+   test ();
+   if (sub (mode, MR795) <= 0 )
+   {
+       g1 = gamma1;                          move16 ();
+   }
+   else
+   {
+       g1 = gamma1_12k2;                     move16 ();
+   }
+
+   test ();
+   if (frameOffset > 0) {
+      aOffset = 2*MP1;                       move16 ();
+   }
+   else {
+      aOffset = 0;                           move16 ();
+   }
+
+   /* process two subframes (which form the "big" subframe) */
+   for (i = 0; i < 2; i++)
+   {
+       Weight_Ai(&A_t[aOffset], g1, Ap1);
+       Weight_Ai(&A_t[aOffset], gamma2, Ap2);
+       Residu(Ap1, &speech[frameOffset], &wsp[frameOffset], L_SUBFR);
+       
+       Syn_filt(Ap2, &wsp[frameOffset], &wsp[frameOffset], L_SUBFR, mem_w, 1);
+       aOffset = add (aOffset, MP1);
+       frameOffset = add (frameOffset, L_SUBFR);
+   }   
+
+   return 0;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/pre_big.h FFMpeg-20050127-new/libavcodec/amr/pre_big.h
--- FFMpeg-20050127/libavcodec/amr/pre_big.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/pre_big.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,45 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : pre_big.h
+*      Purpose          : Big subframe (2 subframes) preprocessing
+*
+********************************************************************************
+*/
+#ifndef pre_big_h
+#define pre_big_h "$Id $"
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+
+int pre_big(
+    enum Mode mode,            /* i  : coder mode                             */
+    const Word16 gamma1[],     /* i  : spectral exp. factor 1                 */
+    const Word16 gamma1_12k2[],/* i  : spectral exp. factor 1 for EFR         */
+    const Word16 gamma2[],     /* i  : spectral exp. factor 2                 */
+    Word16 A_t[],              /* i  : A(z) unquantized, for 4 subframes, Q12 */
+    Word16 frameOffset,        /* i  : Start position in speech vector,   Q0  */
+    Word16 speech[],           /* i  : speech,                            Q0  */
+    Word16 mem_w[],            /* i/o: synthesis filter memory state,     Q0  */
+    Word16 wsp[]               /* o  : weighted speech                    Q0  */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/pre_proc.c FFMpeg-20050127-new/libavcodec/amr/pre_proc.c
--- FFMpeg-20050127/libavcodec/amr/pre_proc.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/pre_proc.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,173 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : pre_proc.c
+*      Purpose          : Preprocessing of input speech.
+*
+********************************************************************************
+*/
+ 
+ 
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "pre_proc.h"
+const char pre_proc_id[] = "@(#)$Id $" pre_proc_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+ 
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+/* filter coefficients (fc = 80 Hz, coeff. b[] is divided by 2) */
+static const Word16 b[3] = {1899, -3798, 1899};
+static const Word16 a[3] = {4096, 7807, -3733};
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+*
+*  Function:   Pre_Process_init
+*  Purpose:    Allocates state memory and initializes state memory
+*
+**************************************************************************
+*/
+int Pre_Process_init (Pre_ProcessState **state)
+{
+  Pre_ProcessState* s;
+ 
+  if (state == (Pre_ProcessState **) NULL){
+      fprintf(stderr, "Pre_Process_init: invalid parameter\n");
+      return -1;
+  }
+  *state = NULL;
+ 
+  /* allocate memory */
+  if ((s= (Pre_ProcessState *) malloc(sizeof(Pre_ProcessState))) == NULL){
+      fprintf(stderr, "Pre_Process_init: can not malloc state structure\n");
+      return -1;
+  }
+  
+  Pre_Process_reset(s);
+  *state = s;
+  
+  return 0;
+}
+ 
+/*************************************************************************
+*
+*  Function:   Pre_Process_reset
+*  Purpose:    Initializes state memory to zero
+*
+**************************************************************************
+*/
+int Pre_Process_reset (Pre_ProcessState *state)
+{
+  if (state == (Pre_ProcessState *) NULL){
+      fprintf(stderr, "Pre_Process_reset: invalid parameter\n");
+      return -1;
+  }
+  
+  state->y2_hi = 0;
+  state->y2_lo = 0;
+  state->y1_hi = 0;
+  state->y1_lo = 0;
+  state->x0 = 0;
+  state->x1 = 0;
+ 
+  return 0;
+}
+ 
+/*************************************************************************
+*
+*  Function:   Pre_Process_exit
+*  Purpose:    The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void Pre_Process_exit (Pre_ProcessState **state)
+{
+  if (state == NULL || *state == NULL)
+      return;
+ 
+  /* deallocate memory */
+  free(*state);
+  *state = NULL;
+  
+  return;
+}
+ 
+/*************************************************************************
+ *
+ *  FUNCTION:  Pre_Process()
+ *
+ *  PURPOSE: Preprocessing of input speech.
+ *
+ *  DESCRIPTION:
+ *     - 2nd order high pass filtering with cut off frequency at 80 Hz.
+ *     - Divide input by two.
+ *
+ *                                                                        
+ * Algorithm:                                                             
+ *                                                                        
+ *  y[i] = b[0]*x[i]/2 + b[1]*x[i-1]/2 + b[2]*x[i-2]/2                    
+ *                     + a[1]*y[i-1]   + a[2]*y[i-2];                     
+ *                                                                        
+ *                                                                        
+ *  Input is divided by two in the filtering process.
+ *
+ *************************************************************************/
+int Pre_Process (
+    Pre_ProcessState *st,
+    Word16 signal[], /* input/output signal */
+    Word16 lg)       /* lenght of signal    */
+{
+    Word16 i, x2;
+    Word32 L_tmp;
+
+    for (i = 0; i < lg; i++)
+    {
+        x2 = st->x1;                   move16 (); 
+        st->x1 = st->x0;               move16 (); 
+        st->x0 = signal[i];            move16 (); 
+
+        /*  y[i] = b[0]*x[i]/2 + b[1]*x[i-1]/2 + b140[2]*x[i-2]/2  */
+        /*                     + a[1]*y[i-1] + a[2] * y[i-2];      */
+
+        L_tmp = Mpy_32_16 (st->y1_hi, st->y1_lo, a[1]);
+        L_tmp = L_add (L_tmp, Mpy_32_16 (st->y2_hi, st->y2_lo, a[2]));
+        L_tmp = L_mac (L_tmp, st->x0, b[0]);
+        L_tmp = L_mac (L_tmp, st->x1, b[1]);
+        L_tmp = L_mac (L_tmp, x2, b[2]);
+        L_tmp = L_shl (L_tmp, 3);
+        signal[i] = round (L_tmp); move16 (); 
+
+        st->y2_hi = st->y1_hi;             move16 (); 
+        st->y2_lo = st->y1_lo;             move16 (); 
+        L_Extract (L_tmp, &st->y1_hi, &st->y1_lo);
+    }
+    return 0;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/pre_proc.h FFMpeg-20050127-new/libavcodec/amr/pre_proc.h
--- FFMpeg-20050127/libavcodec/amr/pre_proc.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/pre_proc.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,73 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : pre_proc.h
+*      Purpose          : Preprocessing of input speech.
+*
+********************************************************************************
+*/
+#ifndef pre_proc_h
+#define pre_proc_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+typedef struct {
+  Word16 y2_hi;
+  Word16 y2_lo;
+  Word16 y1_hi;
+  Word16 y1_lo;
+  Word16 x0;
+  Word16 x1;
+} Pre_ProcessState;
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+ 
+int Pre_Process_init (Pre_ProcessState **st);
+/* initialize one instance of the pre processing state.
+   Stores pointer to filter status struct in *st. This pointer has to
+   be passed to Pre_Process in each call.
+   returns 0 on success
+ */
+ 
+int Pre_Process_reset (Pre_ProcessState *st);
+/* reset of pre processing state (i.e. set state memory to zero)
+   returns 0 on success
+ */
+void Pre_Process_exit (Pre_ProcessState **st);
+/* de-initialize pre processing state (i.e. free status struct)
+   stores NULL in *st
+ */
+ 
+int Pre_Process (
+    Pre_ProcessState *st,
+    Word16 signal[],   /* Input/output signal                               */
+    Word16 lg          /* Lenght of signal                                  */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/pred_lt.c FFMpeg-20050127-new/libavcodec/amr/pred_lt.c
--- FFMpeg-20050127/libavcodec/amr/pred_lt.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/pred_lt.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,133 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : pred_lt.c
+*      Purpose          : Compute the result of long term prediction
+*
+********************************************************************************
+*/
+ 
+ 
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "pred_lt.h"
+const char pred_lt_id[] = "@(#)$Id $" pred_lt_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#define UP_SAMP_MAX  6
+#define L_INTER10    (L_INTERPOL-1)
+#define FIR_SIZE     (UP_SAMP_MAX*L_INTER10+1)
+
+/* 1/6 resolution interpolation filter  (-3 dB at 3600 Hz) */
+/* Note: the 1/3 resolution filter is simply a subsampled
+ *       version of the 1/6 resolution filter, i.e. it uses
+ *       every second coefficient:
+ *       
+ *          inter_3l[k] = inter_6[2*k], 0 <= k <= 3*L_INTER10
+ */
+static const Word16 inter_6[FIR_SIZE] =
+{
+    29443,
+    28346, 25207, 20449, 14701, 8693, 3143,
+    -1352, -4402, -5865, -5850, -4673, -2783,
+    -672, 1211, 2536, 3130, 2991, 2259,
+    1170, 0, -1001, -1652, -1868, -1666,
+    -1147, -464, 218, 756, 1060, 1099,
+    904, 550, 135, -245, -514, -634,
+    -602, -451, -231, 0, 191, 308,
+    340, 296, 198, 78, -36, -120,
+    -163, -165, -132, -79, -19, 34,
+    73, 91, 89, 70, 38, 0
+};
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:   Pred_lt_3or6()
+ *
+ *  PURPOSE:  Compute the result of long term prediction with fractional
+ *            interpolation of resolution 1/3 or 1/6. (Interpolated past
+ *            excitation).
+ *
+ *  DESCRIPTION:
+ *       The past excitation signal at the given delay is interpolated at
+ *       the given fraction to build the adaptive codebook excitation.
+ *       On return exc[0..L_subfr-1] contains the interpolated signal
+ *       (adaptive codebook excitation).
+ *
+ *************************************************************************/
+void Pred_lt_3or6 (
+    Word16 exc[],     /* in/out: excitation buffer                         */
+    Word16 T0,        /* input : integer pitch lag                         */
+    Word16 frac,      /* input : fraction of lag                           */
+    Word16 L_subfr,   /* input : subframe size                             */
+    Word16 flag3      /* input : if set, upsampling rate = 3 (6 otherwise) */
+)
+{
+    Word16 i, j, k;
+    Word16 *x0, *x1, *x2;
+    const Word16 *c1, *c2;
+    Word32 s;
+
+    x0 = &exc[-T0];             move16 (); 
+
+    frac = negate (frac);
+    test();
+    if (flag3 != 0)
+    {
+      frac = shl (frac, 1);   /* inter_3l[k] = inter_6[2*k] -> k' = 2*k */
+    }
+    
+    test (); 
+    if (frac < 0)
+    {
+        frac = add (frac, UP_SAMP_MAX);
+        x0--;
+    }
+
+    for (j = 0; j < L_subfr; j++)
+    {
+        x1 = x0++;              move16 (); 
+        x2 = x0;                move16 (); 
+        c1 = &inter_6[frac];
+        c2 = &inter_6[sub (UP_SAMP_MAX, frac)];
+
+        s = 0;                  move32 (); 
+        for (i = 0, k = 0; i < L_INTER10; i++, k += UP_SAMP_MAX)
+        {
+            s = L_mac (s, x1[-i], c1[k]);
+            s = L_mac (s, x2[i], c2[k]);
+        }
+
+        exc[j] = round (s);     move16 (); 
+    }
+
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/pred_lt.h FFMpeg-20050127-new/libavcodec/amr/pred_lt.h
--- FFMpeg-20050127/libavcodec/amr/pred_lt.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/pred_lt.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,46 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : pred_lt.h
+*      Purpose          : Compute the result of long term prediction.
+*
+*
+********************************************************************************
+*/
+#ifndef pred_lt_h
+#define pred_lt_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+ 
+void Pred_lt_3or6 (
+    Word16 exc[],     /* in/out: excitation buffer                         */
+    Word16 T0,        /* input : integer pitch lag                         */
+    Word16 frac,      /* input : fraction of lag                           */
+    Word16 L_subfr,   /* input : subframe size                             */
+    Word16 flag3      /* input : if set, upsampling rate = 3 (6 otherwise) */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/preemph.c FFMpeg-20050127-new/libavcodec/amr/preemph.c
--- FFMpeg-20050127/libavcodec/amr/preemph.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/preemph.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,147 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : preemph.c
+*      Purpose          : Preemphasis filtering
+*      Description      : Filtering through 1 - g z^-1 
+*
+********************************************************************************
+*/
+
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "preemph.h"
+const char preemph_id[] = "@(#)$Id $" preemph_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+*
+*  Function:   Post_Filter_init
+*  Purpose:    Allocates memory for filter structure and initializes
+*              state memory
+*
+**************************************************************************
+*/
+int preemphasis_init (preemphasisState **state)
+{
+  preemphasisState* s;
+ 
+  if (state == (preemphasisState **) NULL){
+      fprintf(stderr, "preemphasis_init: invalid parameter\n");
+      return -1;
+  }
+  *state = NULL;
+ 
+  /* allocate memory */
+  if ((s= (preemphasisState *) malloc(sizeof(preemphasisState))) == NULL){
+      fprintf(stderr, "preemphasis_init: can not malloc state structure\n");
+      return -1;
+  }
+  
+  preemphasis_reset(s);
+  *state = s;
+  
+  return 0;
+}
+
+/*************************************************************************
+*
+*  Function:   preemphasis_reset
+*  Purpose:    Initializes state memory to zero
+*
+**************************************************************************
+*/
+int preemphasis_reset (preemphasisState *state)
+{
+  if (state == (preemphasisState *) NULL){
+      fprintf(stderr, "preemphasis_reset: invalid parameter\n");
+      return -1;
+  }
+  
+  state->mem_pre = 0;
+ 
+  return 0;
+}
+ 
+/*************************************************************************
+*
+*  Function:   preemphasis_exit
+*  Purpose:    The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void preemphasis_exit (preemphasisState **state)
+{
+  if (state == NULL || *state == NULL)
+      return;
+ 
+  /* deallocate memory */
+  free(*state);
+  *state = NULL;
+  
+  return;
+}
+ 
+/*
+**************************************************************************
+*  Function:  preemphasis
+*  Purpose:   Filtering through 1 - g z^-1 
+*
+**************************************************************************
+*/
+int preemphasis (
+    preemphasisState *st, /* (i/o)  : preemphasis filter state    */
+    Word16 *signal, /* (i/o)   : input signal overwritten by the output */
+    Word16 g,       /* (i)     : preemphasis coefficient                */
+    Word16 L        /* (i)     : size of filtering                      */
+)
+{
+    Word16 *p1, *p2, temp, i;
+
+    p1 = signal + L - 1;                    move16 (); 
+    p2 = p1 - 1;                            move16 (); 
+    temp = *p1;                             move16 (); 
+
+    for (i = 0; i <= L - 2; i++)
+    {
+        *p1 = sub (*p1, mult (g, *p2--));   move16 (); 
+        p1--;
+    }
+
+    *p1 = sub (*p1, mult (g, st->mem_pre));     move16 (); 
+
+    st->mem_pre = temp;                         move16 (); 
+
+    return 0;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/preemph.h FFMpeg-20050127-new/libavcodec/amr/preemph.h
--- FFMpeg-20050127/libavcodec/amr/preemph.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/preemph.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,64 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : preemph.h
+*      Purpose          : Preemphasis filtering
+*      Description      : Filtering through 1 - g z^-1 
+*
+********************************************************************************
+*/
+#ifndef preemph_h
+#define preemph_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+typedef struct {
+  Word16 mem_pre;          /* filter state */
+} preemphasisState;
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+
+int preemphasis_init (preemphasisState **st);
+/* initialize one instance of the preemphasis filter
+   Stores pointer to filter status struct in *st. This pointer has to
+   be passed to preemphasis in each call.
+   returns 0 on success
+ */
+
+int preemphasis_reset (preemphasisState *st);
+/* reset of preemphasis filter (i.e. set state memory to zero)
+   returns 0 on success
+ */
+void preemphasis_exit (preemphasisState **st);
+/* de-initialize preemphasis filter (i.e. free status struct)
+   stores NULL in *st
+ */
+ 
+int preemphasis (
+    preemphasisState *st, /* (i/o): preemphasis filter state                  */
+    Word16 *signal,    /* (i/o): input signal overwritten by the output     */
+    Word16 g,          /* (i)  : preemphasis coefficient                    */
+    Word16 L           /* (i)  : size of filtering                          */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/prm2bits.c FFMpeg-20050127-new/libavcodec/amr/prm2bits.c
--- FFMpeg-20050127/libavcodec/amr/prm2bits.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/prm2bits.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,122 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : prm2bits.c
+*      Purpose          : Converts the encoder parameter vector into a
+*                       : vector of serial bits.
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "prm2bits.h"
+
+const char prm2bits_id[] = "@(#)$Id $" prm2bits_h;
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "mode.h"
+
+#include <stdlib.h>
+#include <stdio.h>
+
+ 
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#include "bitno.tab"
+#define MASK      0x0001
+ 
+/*
+********************************************************************************
+*                         LOCAL PROGRAM CODE
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ *  FUNCTION:  Int2bin
+ *
+ *  PURPOSE:  convert integer to binary and write the bits to the array
+ *            bitstream[]. The most significant bits are written first.
+ *
+ *************************************************************************/
+
+static void Int2bin (
+    Word16 value,       /* input : value to be converted to binary      */
+    Word16 no_of_bits,  /* input : number of bits associated with value */
+    Word16 *bitstream   /* output: address where bits are written       */
+)
+{
+    Word16 *pt_bitstream, i, bit;
+
+    pt_bitstream = &bitstream[no_of_bits];      move16 (); 
+
+    for (i = 0; i < no_of_bits; i++)
+    {
+        bit = value & MASK;                     logic16 (); 
+        test (); 
+        if (bit == 0)
+        {
+            *--pt_bitstream = BIT_0;            move16 (); 
+        }
+        else
+        {
+            *--pt_bitstream = BIT_1;            move16 (); 
+        }
+        value = shr (value, 1);
+    }
+}
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:    Prm2bits
+ *
+ *  PURPOSE:     converts the encoder parameter vector into a vector of serial
+ *               bits.
+ *
+ *  DESCRIPTION: depending on the mode, different numbers of parameters
+ *               (with differing numbers of bits) are processed. Details
+ *               are found in bitno.tab
+ *
+ *************************************************************************/
+void Prm2bits (
+    enum Mode mode,    /* i : AMR mode                                      */
+    Word16 prm[],      /* i : analysis parameters (size <= MAX_PRM_SIZE)    */
+    Word16 bits[]      /* o : serial bits         (size <= MAX_SERIAL_SIZE) */
+)
+{
+   Word16 i;
+
+   move16();           /* account for pointer init (bitno[mode])    */
+
+   for (i = 0; i < prmno[mode]; i++)
+   {
+       Int2bin (prm[i], bitno[mode][i], bits);
+       bits += bitno[mode][i];
+       add(0,0);       /* account for above pointer update  */
+   }      
+
+   return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/prm2bits.h FFMpeg-20050127-new/libavcodec/amr/prm2bits.h
--- FFMpeg-20050127/libavcodec/amr/prm2bits.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/prm2bits.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,44 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : prm2bits.h
+*      Purpose          : Converts the encoder parameter vector into a
+*                       : vector of serial bits.
+*
+********************************************************************************
+*/
+#ifndef prm2bits_h
+#define prm2bits_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+void Prm2bits (
+    enum Mode mode,    /* i : AMR mode */
+    Word16 prm[],      /* input : analysis parameters                       */
+    Word16 bits[]      /* output: serial bits                               */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/pstfilt.c FFMpeg-20050127-new/libavcodec/amr/pstfilt.c
--- FFMpeg-20050127/libavcodec/amr/pstfilt.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/pstfilt.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,287 @@
+/*************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : pstfilt.c
+*      Purpose          : Performs adaptive postfiltering on the synthesis
+*                       : speech
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "pstfilt.h"
+const char pstfilt_id[] = "@(#)$Id $" pstfilt_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "mode.h"
+#include "basic_op.h"
+#include "set_zero.h"
+#include "weight_a.h"
+#include "residu.h"
+#include "copy.h"
+#include "syn_filt.h"
+#include "preemph.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+/*---------------------------------------------------------------*
+ *    Postfilter constant parameters (defined in "cnst.h")       *
+ *---------------------------------------------------------------*
+ *   L_FRAME     : Frame size.                                   *
+ *   L_SUBFR     : Sub-frame size.                               *
+ *   M           : LPC order.                                    *
+ *   MP1         : LPC order+1                                   *
+ *   MU          : Factor for tilt compensation filter           *
+ *   AGC_FAC     : Factor for automatic gain control             *
+ *---------------------------------------------------------------*/
+
+#define L_H 22  /* size of truncated impulse response of A(z/g1)/A(z/g2) */
+
+/* Spectral expansion factors */
+static const Word16 gamma3_MR122[M] = {
+  22938, 16057, 11240, 7868, 5508,
+  3856, 2699, 1889, 1322, 925
+};
+
+static const Word16 gamma3[M] = {
+  18022, 9912, 5451, 2998, 1649, 907, 499, 274, 151, 83
+};
+
+static const Word16 gamma4_MR122[M] = {
+  24576, 18432, 13824, 10368, 7776,
+  5832, 4374, 3281, 2461, 1846
+};
+
+static const Word16 gamma4[M] = {
+  22938, 16057, 11240, 7868, 5508, 3856, 2699, 1889, 1322, 925
+};
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+
+/*************************************************************************
+*
+*  Function:   Post_Filter_init
+*  Purpose:    Allocates memory for filter structure and initializes
+*              state memory
+*
+**************************************************************************
+*/
+int Post_Filter_init (Post_FilterState **state)
+{
+  Post_FilterState* s;
+
+  if (state == (Post_FilterState **) NULL){
+      fprintf(stderr, "Post_Filter_init: invalid parameter\n");
+      return -1;
+  }
+  *state = NULL;
+
+  /* allocate memory */
+  if ((s= (Post_FilterState *) malloc(sizeof(Post_FilterState))) == NULL){
+      fprintf(stderr, "Post_Filter_init: can not malloc state structure\n");
+      return -1;
+  }
+  s->preemph_state = NULL;
+  s->agc_state = NULL;
+
+  if (preemphasis_init(&s->preemph_state) || agc_init(&s->agc_state)) {
+      Post_Filter_exit(&s);
+      return -1;
+  }
+      
+  Post_Filter_reset(s);
+  *state = s;
+  
+  return 0;
+}
+
+/*************************************************************************
+*
+*  Function:   Post_Filter_reset
+*  Purpose:    Initializes state memory to zero
+*
+**************************************************************************
+*/
+int Post_Filter_reset (Post_FilterState *state)
+{
+  if (state == (Post_FilterState *) NULL){
+      fprintf(stderr, "Post_Filter_reset: invalid parameter\n");
+      return -1;
+  }
+  
+  Set_zero (state->mem_syn_pst, M);
+  Set_zero (state->res2, L_SUBFR);
+  Set_zero (state->synth_buf, L_FRAME + M);
+  agc_reset(state->agc_state);
+  preemphasis_reset(state->preemph_state);
+
+  return 0;
+}
+
+/*************************************************************************
+*
+*  Function:   Post_Filter_exit
+*  Purpose:    The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void Post_Filter_exit (Post_FilterState **state)
+{
+  if (state == NULL || *state == NULL)
+      return;
+
+  agc_exit(&(*state)->agc_state);
+  preemphasis_exit(&(*state)->preemph_state);
+  
+  /* deallocate memory */
+  free(*state);
+  *state = NULL;
+  
+  return;
+}
+
+/*
+**************************************************************************
+*  Function:  Post_Filter
+*  Purpose:   postfiltering of synthesis speech.
+*  Description:
+*      The postfiltering process is described as follows:
+*
+*          - inverse filtering of syn[] through A(z/0.7) to get res2[]
+*          - tilt compensation filtering; 1 - MU*k*z^-1
+*          - synthesis filtering through 1/A(z/0.75)
+*          - adaptive gain control
+*
+**************************************************************************
+*/
+int Post_Filter (
+    Post_FilterState *st, /* i/o : post filter states                        */
+    enum Mode mode,       /* i   : AMR mode                                  */
+    Word16 *syn,          /* i/o : synthesis speech (postfiltered is output) */
+    Word16 *Az_4          /* i   : interpolated LPC parameters in all subfr. */
+)
+{
+    /*-------------------------------------------------------------------*
+     *           Declaration of parameters                               *
+     *-------------------------------------------------------------------*/
+
+    Word16 Ap3[MP1], Ap4[MP1];  /* bandwidth expanded LP parameters */
+    Word16 *Az;                 /* pointer to Az_4:                 */
+                                /*  LPC parameters in each subframe */
+    Word16 i_subfr;             /* index for beginning of subframe  */
+    Word16 h[L_H];
+
+    Word16 i;
+    Word16 temp1, temp2;
+    Word32 L_tmp;
+    Word16 *syn_work = &st->synth_buf[M]; move16 ();
+    
+
+    /*-----------------------------------------------------*
+     * Post filtering                                      *
+     *-----------------------------------------------------*/
+
+    Copy (syn, syn_work , L_FRAME);
+
+    Az = Az_4;
+
+    for (i_subfr = 0; i_subfr < L_FRAME; i_subfr += L_SUBFR)
+    {
+       /* Find weighted filter coefficients Ap3[] and ap[4] */
+
+       test (); test ();
+       if (sub(mode, MR122) == 0 || sub(mode, MR102) == 0)
+       {
+          Weight_Ai (Az, gamma3_MR122, Ap3);
+          Weight_Ai (Az, gamma4_MR122, Ap4);
+       }
+       else
+       {
+          Weight_Ai (Az, gamma3, Ap3);
+          Weight_Ai (Az, gamma4, Ap4);
+       }
+       
+       /* filtering of synthesis speech by A(z/0.7) to find res2[] */
+       
+       Residu (Ap3, &syn_work[i_subfr], st->res2, L_SUBFR);
+       
+       /* tilt compensation filter */
+       
+       /* impulse response of A(z/0.7)/A(z/0.75) */
+
+       Copy (Ap3, h, M + 1);
+       Set_zero (&h[M + 1], L_H - M - 1);
+       Syn_filt (Ap4, h, h, L_H, &h[M + 1], 0);
+        
+       /* 1st correlation of h[] */
+       
+       L_tmp = L_mult (h[0], h[0]);
+       for (i = 1; i < L_H; i++)
+       {
+          L_tmp = L_mac (L_tmp, h[i], h[i]);
+       }
+       temp1 = extract_h (L_tmp);
+       
+       L_tmp = L_mult (h[0], h[1]);
+       for (i = 1; i < L_H - 1; i++)
+       {
+          L_tmp = L_mac (L_tmp, h[i], h[i + 1]);
+       }
+       temp2 = extract_h (L_tmp);
+       
+       test (); 
+       if (temp2 <= 0)
+       {
+          temp2 = 0;          move16 (); 
+       }
+       else
+       {
+          temp2 = mult (temp2, MU);
+          temp2 = div_s (temp2, temp1);
+       }
+       
+       preemphasis (st->preemph_state, st->res2, temp2, L_SUBFR);
+       
+       /* filtering through  1/A(z/0.75) */
+       
+       Syn_filt (Ap4, st->res2, &syn[i_subfr], L_SUBFR, st->mem_syn_pst, 1);
+       
+       /* scale output to input */
+
+       agc (st->agc_state, &syn_work[i_subfr], &syn[i_subfr],
+            AGC_FAC, L_SUBFR);
+       
+       Az += MP1;
+    }
+    
+    /* update syn_work[] buffer */
+    
+    Copy (&syn_work[L_FRAME - M], &syn_work[-M], M);
+    
+    return 0;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/pstfilt.h FFMpeg-20050127-new/libavcodec/amr/pstfilt.h
--- FFMpeg-20050127/libavcodec/amr/pstfilt.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/pstfilt.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,80 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : pstfilt.h
+*      Purpose          : Performs adaptive postfiltering on the synthesis
+*                       : speech
+*
+********************************************************************************
+*/
+#ifndef pstfilt_h
+#define pstfilt_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+#include "cnst.h"
+#include "preemph.h"
+#include "agc.h"
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+typedef struct{
+  Word16 res2[L_SUBFR];
+  Word16 mem_syn_pst[M];
+  preemphasisState* preemph_state;
+  agcState* agc_state;
+  Word16 synth_buf[M + L_FRAME];  
+} Post_FilterState;
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+ 
+int Post_Filter_init (Post_FilterState **st);
+/* initialize one instance of the post filter
+   Stores pointer to filter status struct in *st. This pointer has to
+   be passed to Post_Filter in each call.
+   returns 0 on success
+ */
+ 
+int Post_Filter_reset (Post_FilterState *st);
+/* reset post filter (i.e. set state memory to zero)
+   returns 0 on success
+ */
+
+void Post_Filter_exit (Post_FilterState **st);
+/* de-initialize post filter (i.e. free status struct)
+   stores NULL in *s
+ */
+
+int Post_Filter (
+    Post_FilterState *st, /* i/o : post filter states                        */
+    enum Mode mode,       /* i   : AMR mode                                  */
+    Word16 *syn,          /* i/o : synthesis speech (postfiltered is output) */
+    Word16 *Az_4          /* i   : interpolated LPC parameters in all subfr. */
+);
+/* filters the signal syn using the parameters in Az_4 to calculate filter
+   coefficients.
+   The filter must be set up using Post_Filter_init prior to the first call
+   to Post_Filter. Post_FilterState is updated to mirror the current state
+   of the filter
+ 
+   return 0 on success
+ */
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/q_gain_c.c FFMpeg-20050127-new/libavcodec/amr/q_gain_c.c
--- FFMpeg-20050127/libavcodec/amr/q_gain_c.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/q_gain_c.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,160 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : q_gain_c.c
+*      Purpose          : Scalar quantization of the innovative
+*                       : codebook gain.
+*
+********************************************************************************
+*/
+ 
+ 
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "q_gain_c.h"
+const char q_gain_c_id[] = "@(#)$Id $" q_gain_c_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "mode.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "log2.h"
+#include "pow2.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#include "gains.tab"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+ 
+/*--------------------------------------------------------------------------*
+ * Function q_gain_code()                                                   *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                                  *
+ * Scalar quantization of the innovative codebook gain.                     *
+ *                                                                          *
+ *--------------------------------------------------------------------------*/
+Word16 q_gain_code (        /* o  : quantization index,            Q0  */
+    enum Mode mode,         /* i  : AMR mode                           */
+    Word16 exp_gcode0,      /* i  : predicted CB gain (exponent),  Q0  */
+    Word16 frac_gcode0,     /* i  : predicted CB gain (fraction),  Q15 */
+    Word16 *gain,           /* i/o: quantized fixed codebook gain, Q1  */
+    Word16 *qua_ener_MR122, /* o  : quantized energy error,        Q10 */
+                            /*      (for MR122 MA predictor update)    */
+    Word16 *qua_ener        /* o  : quantized energy error,        Q10 */
+                            /*      (for other MA predictor update)    */
+)
+{
+    const Word16 *p;
+    Word16 i, index;
+    Word16 gcode0, err, err_min;
+    Word16 g_q0;
+
+    test ();
+    g_q0 = 0;    move16 ();
+    test ();
+    if (sub(mode, MR122) == 0)
+    {
+       g_q0 = shr (*gain, 1); /* Q1 -> Q0 */
+    }
+
+    /*-------------------------------------------------------------------*
+     *  predicted codebook gain                                          *
+     *  ~~~~~~~~~~~~~~~~~~~~~~~                                          *
+     *  gc0     = Pow2(int(d)+frac(d))                                   *
+     *          = 2^exp + 2^frac                                         *
+     *                                                                   *
+     *-------------------------------------------------------------------*/
+
+    gcode0 = extract_l (Pow2 (exp_gcode0, frac_gcode0));  /* predicted gain */
+
+    test ();
+    if (sub(mode, MR122) == 0)
+    {
+       gcode0 = shl (gcode0, 4);
+    }
+    else
+    {
+       gcode0 = shl (gcode0, 5);
+    }
+    
+    /*-------------------------------------------------------------------*
+     *                   Search for best quantizer                        *
+     *-------------------------------------------------------------------*/
+
+    p = &qua_gain_code[0]; move16 ();
+    test ();
+    if (sub(mode, MR122) == 0)
+    {
+       err_min = abs_s (sub (g_q0, mult (gcode0, *p++)));
+    }
+    else
+    {
+       err_min = abs_s (sub (*gain, mult (gcode0, *p++)));
+    }
+    p += 2;                                  /* skip quantized energy errors */
+    index = 0;              move16 (); 
+
+    for (i = 1; i < NB_QUA_CODE; i++)
+    {
+       test ();
+       if (sub(mode, MR122) == 0)
+       {
+          err = abs_s (sub (g_q0,  mult (gcode0, *p++)));
+       }
+       else
+       {
+          err = abs_s (sub (*gain, mult (gcode0, *p++)));
+       }
+       
+       p += 2;                              /* skip quantized energy error */
+
+       test (); 
+       if (sub (err, err_min) < 0)
+       {
+          err_min = err;                  move16 (); 
+          index = i;                      move16 (); 
+       }
+    }
+
+    p = &qua_gain_code[add (add (index,index), index)]; move16 ();
+    test ();
+    if (sub(mode, MR122) == 0)
+    {
+       *gain = shl (mult (gcode0, *p++), 1); 
+    }
+    else
+    {
+       *gain = mult (gcode0, *p++);
+    }
+                                            move16 ();
+    
+    /* quantized error energies (for MA predictor update) */
+    *qua_ener_MR122 = *p++;                 move16 (); 
+    *qua_ener = *p;                         move16 (); 
+
+    return index;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/q_gain_c.h FFMpeg-20050127-new/libavcodec/amr/q_gain_c.h
--- FFMpeg-20050127/libavcodec/amr/q_gain_c.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/q_gain_c.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,53 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : q_gain_c.h
+*      Purpose          : Scalar quantization of the innovative
+*                       : codebook gain.
+*
+********************************************************************************
+*/
+#ifndef q_gain_c_h
+#define q_gain_c_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+#include "gc_pred.h"
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+ 
+ 
+/*--------------------------------------------------------------------------*
+ * Function q_gain_code()                                                   *
+ * ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                                  *
+ * Scalar quantization of the innovative codebook gain.                     *
+ *                                                                          *
+ * gc_pred() is used for MA prediction of the innovation energy             *
+ *--------------------------------------------------------------------------*/
+Word16 q_gain_code (        /* o  : quantization index,            Q0  */
+    enum Mode mode,         /* i  : AMR mode                           */
+    Word16 exp_gcode0,      /* i  : predicted CB gain (exponent),  Q0  */
+    Word16 frac_gcode0,     /* i  : predicted CB gain (fraction),  Q15 */
+    Word16 *gain,           /* i/o: quantized fixed codebook gain, Q1  */
+    Word16 *qua_ener_MR122, /* o  : quantized energy error,        Q10 */
+                            /*      (for MR122 MA predictor update)    */
+    Word16 *qua_ener        /* o  : quantized energy error,        Q10 */
+                            /*      (for other MA predictor update)    */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/q_gain_p.c FFMpeg-20050127-new/libavcodec/amr/q_gain_p.c
--- FFMpeg-20050127/libavcodec/amr/q_gain_p.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/q_gain_p.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,134 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : q_gain_p.c
+*      Purpose          : Scalar quantization of the pitch gain
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "q_gain_p.h"
+const char q_gain_p_id[] = "@(#)$Id $" q_gain_p_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "cnst.h"
+ 
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#include "gains.tab"
+ 
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+Word16 q_gain_pitch (   /* Return index of quantization                      */
+    enum Mode mode,     /* i  : AMR mode                                     */
+    Word16 gp_limit,    /* i  : pitch gain limit                             */
+    Word16 *gain,       /* i/o: Pitch gain (unquant/quant),              Q14 */
+    Word16 gain_cand[], /* o  : pitch gain candidates (3),   MR795 only, Q14 */ 
+    Word16 gain_cind[]  /* o  : pitch gain cand. indices (3),MR795 only, Q0  */ 
+)
+{
+    Word16 i, index, err, err_min;
+
+    err_min = abs_s (sub (*gain, qua_gain_pitch[0]));
+    index = 0;                                              move16 (); 
+
+    for (i = 1; i < NB_QUA_PITCH; i++)
+    {
+        test ();
+        if (sub (qua_gain_pitch[i], gp_limit) <= 0)
+        {
+            err = abs_s (sub (*gain, qua_gain_pitch[i]));
+            
+            test (); 
+            if (sub (err, err_min) < 0)
+            {
+                err_min = err;                                  move16 (); 
+                index = i;                                      move16 (); 
+            }
+        }
+    }
+
+    test ();
+    if (sub (mode, MR795) == 0)
+    {
+        /* in MR795 mode, compute three gain_pit candidates around the index
+         * found in the quantization loop: the index found and the two direct
+         * neighbours, except for the extreme cases (i=0 or i=NB_QUA_PITCH-1),
+         * where the direct neighbour and the neighbour to that is used.
+         */
+        Word16 ii;
+
+        test ();
+        if (index == 0)
+        {
+            ii = index;                                     move16 ();
+        }
+        else
+        {
+            test (); test ();
+            if (   sub (index, NB_QUA_PITCH-1) == 0
+                || sub (qua_gain_pitch[index+1], gp_limit) > 0)
+            {
+                ii = sub (index, 2);
+            }
+            else
+            {
+                ii = sub (index, 1);
+            }
+        }
+
+        /* store candidate indices and values */
+        for (i = 0; i < 3; i++)
+        {
+            gain_cind[i] = ii;                              move16 ();
+            gain_cand[i] = qua_gain_pitch[ii];              move16 ();
+            ii = add (ii, 1);
+        }
+        
+        *gain = qua_gain_pitch[index];                      move16 (); 
+    }
+    else
+    {
+        /* in MR122 mode, just return the index and gain pitch found.
+         * If bitexactness is required, mask away the two LSBs (because
+         * in the original EFR, gain_pit was scaled Q12)
+         */
+       test ();
+       if (sub(mode, MR122) == 0)
+       {
+          /* clear 2 LSBits */
+          *gain = qua_gain_pitch[index] & 0xFFFC; logic16 (); move16 ();
+       }
+       else
+       {
+          *gain = qua_gain_pitch[index];                      move16 (); 
+       }
+    }
+    return index;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/q_gain_p.h FFMpeg-20050127-new/libavcodec/amr/q_gain_p.h
--- FFMpeg-20050127/libavcodec/amr/q_gain_p.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/q_gain_p.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,45 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : q_gain_p.h
+*      Purpose          : Scalar quantization of the pitch gain
+*
+********************************************************************************
+*/
+#ifndef q_gain_p_h
+#define q_gain_p_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+Word16 q_gain_pitch (   /* Return index of quantization                      */
+    enum Mode mode,     /* i  : AMR mode                                     */
+    Word16 gp_limit,    /* i  : pitch gain limit                             */
+    Word16 *gain,       /* i/o: Pitch gain (unquant/quant),              Q14 */
+    Word16 gain_cand[], /* o  : pitch gain candidates (3),   MR795 only, Q14 */ 
+    Word16 gain_cind[]  /* o  : pitch gain cand. indices (3),MR795 only, Q0  */ 
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/q_plsf.c FFMpeg-20050127-new/libavcodec/amr/q_plsf.c
--- FFMpeg-20050127/libavcodec/amr/q_plsf.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/q_plsf.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,113 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : q_plsf.c
+*      Purpose          : common part (init, exit, reset) of LSF quantization
+*                         module (rest in q_plsf_3.c and q_plsf_5.c)
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "q_plsf.h"
+const char q_plsf_id[] = "@(#)$Id $" q_plsf_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+
+/*
+**************************************************************************
+*
+*  Function    : Q_plsf_init
+*  Purpose     : Allocates memory and initializes state variables
+*
+**************************************************************************
+*/
+int Q_plsf_init (Q_plsfState **state)
+{
+  Q_plsfState* s;
+ 
+  if (state == (Q_plsfState **) NULL){
+      fprintf(stderr, "Q_plsf_init: invalid parameter\n");
+      return -1;
+  }
+  *state = NULL;
+ 
+  /* allocate memory */
+  if ((s= (Q_plsfState *) malloc(sizeof(Q_plsfState))) == NULL){
+      fprintf(stderr, "Q_plsf_init: can not malloc state structure\n");
+      return -1;
+  }
+
+  Q_plsf_reset(s);
+  *state = s;
+  
+  return 0;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : Q_plsf_reset
+*  Purpose     : Resets state memory
+*
+**************************************************************************
+*/
+int Q_plsf_reset (Q_plsfState *state)
+{
+  Word16 i;
+  
+  if (state == (Q_plsfState *) NULL){
+      fprintf(stderr, "Q_plsf_reset: invalid parameter\n");
+      return -1;
+  }
+
+  for ( i = 0; i < M; i++)
+      state->past_rq[i] = 0;
+  
+  return 0;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function    : Q_plsf_exit
+*  Purpose     : The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void Q_plsf_exit (Q_plsfState **state)
+{
+  if (state == NULL || *state == NULL)
+      return;
+
+  /* deallocate memory */
+  free(*state);
+  *state = NULL;
+  
+  return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/q_plsf.h FFMpeg-20050127-new/libavcodec/amr/q_plsf.h
--- FFMpeg-20050127/libavcodec/amr/q_plsf.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/q_plsf.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,78 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : q_plsf.h
+*      Purpose          : common include file for LSF vector/matrix quanti-
+*                         sation modules (q_plsf_3.c/q_plsf_5.c)
+*
+********************************************************************************
+*/
+#ifndef q_plsf_h
+#define q_plsf_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "cnst.h"
+#include "mode.h"
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+typedef struct {
+    Word16 past_rq[M];    /* Past quantized prediction error, Q15 */
+
+} Q_plsfState;
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+
+int Q_plsf_init (Q_plsfState **st);
+/* initialize one instance of the state.
+   Stores pointer to filter status struct in *st. This pointer has to
+   be passed to Q_plsf_5 / Q_plsf_3 in each call.
+   returns 0 on success
+ */
+ 
+int Q_plsf_reset (Q_plsfState *st);
+/* reset of state (i.e. set state memory to zero)
+   returns 0 on success
+ */
+
+void Q_plsf_exit (Q_plsfState **st);
+/* de-initialize state (i.e. free status struct)
+   stores NULL in *st
+ */
+ 
+void Q_plsf_3(
+    Q_plsfState *st,    /* i/o: state struct                             */
+    enum Mode mode,     /* i  : coder mode                               */
+    Word16 *lsp1,       /* i  : 1st LSP vector                      Q15  */
+    Word16 *lsp1_q,     /* o  : quantized 1st LSP vector            Q15  */
+    Word16 *indice,     /* o  : quantization indices of 3 vectors   Q0   */
+    Word16 *pred_init_i /* o  : init index for MA prediction in DTX mode */
+);
+
+void Q_plsf_5 (
+    Q_plsfState *st,
+    Word16 *lsp1,      /* i  : 1st LSP vector,                     Q15 */
+    Word16 *lsp2,      /* i  : 2nd LSP vector,                     Q15 */   
+    Word16 *lsp1_q,    /* o  : quantized 1st LSP vector,           Q15 */
+    Word16 *lsp2_q,    /* o  : quantized 2nd LSP vector,           Q15 */
+    Word16 *indice     /* o  : quantization indices of 5 matrices, Q0  */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/q_plsf_3.c FFMpeg-20050127-new/libavcodec/amr/q_plsf_3.c
--- FFMpeg-20050127/libavcodec/amr/q_plsf_3.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/q_plsf_3.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,316 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+****************************************************************************
+*
+*      File             : q_plsf_3.c
+*      Purpose          : Quantization of LSF parameters with 1st order MA
+*                         prediction and split by 3 vector quantization
+*                         (split-VQ)
+*
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "q_plsf.h"
+const char q_plsf_3_id[] = "@(#)$Id $" q_plsf_h;
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "lsp_lsf.h"
+#include "reorder.h"
+#include "lsfwt.h"
+#include "copy.h"
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+#include "q_plsf_3.tab"        /* Codebooks of LSF prediction residual */
+#define PAST_RQ_INIT_SIZE 8
+/*
+*****************************************************************************
+*                         LOCAL PROGRAM CODE
+*****************************************************************************
+*/
+/* Quantization of a 4 dimensional subvector */
+
+static Word16
+Vq_subvec4(             /* o: quantization index,            Q0  */
+    Word16 * lsf_r1,    /* i: 1st LSF residual vector,       Q15 */
+    Word16 * dico,      /* i: quantization codebook,         Q15 */
+    Word16 * wf1,       /* i: 1st LSF weighting factors,     Q13 */
+    Word16 dico_size)   /* i: size of quantization codebook, Q0  */  
+{
+    Word16 i, index = 0;
+    Word16 *p_dico, temp;
+    Word32 dist_min, dist;
+
+    dist_min = MAX_32;                                              move32 ();
+    p_dico = dico;                                                  move16 ();
+
+    for (i = 0; i < dico_size; i++)
+    {
+        temp = sub (lsf_r1[0], *p_dico++);
+        temp = mult (wf1[0], temp);
+        dist = L_mult (temp, temp);
+
+        temp = sub (lsf_r1[1], *p_dico++);
+        temp = mult (wf1[1], temp);
+        dist = L_mac (dist, temp, temp);
+
+        temp = sub (lsf_r1[2], *p_dico++);
+        temp = mult (wf1[2], temp);
+        dist = L_mac (dist, temp, temp);
+
+        temp = sub (lsf_r1[3], *p_dico++);
+        temp = mult (wf1[3], temp);
+        dist = L_mac (dist, temp, temp);
+
+        test ();
+		if (L_sub (dist, dist_min) < (Word32) 0)
+        {
+            dist_min = dist;                                       move32 ();
+            index = i;                                             move16 ();
+        }
+    }
+
+    /* Reading the selected vector */
+
+    p_dico = &dico[shl (index, 2)];                                move16 ();
+    lsf_r1[0] = *p_dico++;                                         move16 ();
+    lsf_r1[1] = *p_dico++;                                         move16 ();
+    lsf_r1[2] = *p_dico++;                                         move16 ();
+    lsf_r1[3] = *p_dico++;                                         move16 ();
+
+    return index;
+
+}
+
+/* Quantization of a 3 dimensional subvector */
+
+static Word16
+Vq_subvec3(             /* o: quantization index,            Q0  */
+    Word16 * lsf_r1,    /* i: 1st LSF residual vector,       Q15 */
+    Word16 * dico,      /* i: quantization codebook,         Q15 */
+    Word16 * wf1,       /* i: 1st LSF weighting factors,     Q13 */
+    Word16 dico_size,   /* i: size of quantization codebook, Q0  */
+    Flag use_half)      /* i: use every second entry in codebook */
+{
+    Word16 i, index = 0;
+    Word16 *p_dico, temp;
+    Word32 dist_min, dist;
+
+    dist_min = MAX_32;                                             move32 ();
+    p_dico = dico;                                                 move16 ();
+
+    test ();
+    if (use_half == 0) {
+       for (i = 0; i < dico_size; i++)
+       {
+          temp = sub(lsf_r1[0], *p_dico++);
+          temp = mult(wf1[0], temp);
+          dist = L_mult(temp, temp);
+          
+          temp = sub(lsf_r1[1], *p_dico++);
+          temp = mult(wf1[1], temp);
+          dist = L_mac(dist, temp, temp);
+          
+          temp = sub(lsf_r1[2], *p_dico++);
+          temp = mult(wf1[2], temp);
+          dist = L_mac(dist, temp, temp);
+
+          test ();
+          if (L_sub(dist, dist_min) < (Word32) 0) {
+             dist_min = dist;                                   move32 ();
+             index = i;                                         move16 ();
+          }
+       }
+       p_dico = &dico[add(index, add(index, index))];             move16 ();
+    }
+    else
+    {
+       for (i = 0; i < dico_size; i++)
+       {
+          temp = sub(lsf_r1[0], *p_dico++);
+          temp = mult(wf1[0], temp);
+          dist = L_mult(temp, temp);
+
+          temp = sub(lsf_r1[1], *p_dico++);
+          temp = mult(wf1[1], temp);
+          dist = L_mac(dist, temp, temp);
+          
+          temp = sub(lsf_r1[2], *p_dico++);
+          temp = mult(wf1[2], temp);
+          dist = L_mac(dist, temp, temp);
+          
+          test ();
+          if (L_sub(dist, dist_min) < (Word32) 0)
+          {
+             dist_min = dist;                                   move32 ();
+             index = i;                                         move16 ();
+          }
+          p_dico = p_dico + 3; add(0,0);
+       }
+       p_dico = &dico[shl(add(index, add(index, index)),1)];      move16 ();
+    }
+    
+
+    /* Reading the selected vector */
+    lsf_r1[0] = *p_dico++;                                         move16 ();
+    lsf_r1[1] = *p_dico++;                                         move16 ();
+    lsf_r1[2] = *p_dico++;                                         move16 ();
+
+    return index;
+}
+
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+
+/***********************************************************************
+ *
+ * routine:   Q_plsf_3()
+ *
+ * Quantization of LSF parameters with 1st order MA prediction and
+ * split by 3 vector quantization (split-VQ)
+ *
+ ***********************************************************************/
+void Q_plsf_3(
+    Q_plsfState *st,    /* i/o: state struct                             */
+    enum Mode mode,     /* i  : coder mode                               */
+    Word16 *lsp1,       /* i  : 1st LSP vector                      Q15  */
+    Word16 *lsp1_q,     /* o  : quantized 1st LSP vector            Q15  */
+    Word16 *indice,     /* o  : quantization indices of 3 vectors   Q0   */
+    Word16 *pred_init_i /* o  : init index for MA prediction in DTX mode */
+)
+{
+    Word16 i, j;
+    Word16 lsf1[M], wf1[M], lsf_p[M], lsf_r1[M];
+    Word16 lsf1_q[M];
+    
+    Word32 L_pred_init_err;
+    Word32 L_min_pred_init_err;
+    Word16 temp_r1[M];
+    Word16 temp_p[M];
+
+    /* convert LSFs to normalize frequency domain 0..16384 */
+
+    Lsp_lsf(lsp1, lsf1, M);
+
+    /* compute LSF weighting factors (Q13) */
+
+    Lsf_wt(lsf1, wf1);
+
+    /* Compute predicted LSF and prediction error */
+    if (test(), sub(mode, MRDTX) != 0)
+    {
+       for (i = 0; i < M; i++)
+       {
+          lsf_p[i] = add(mean_lsf[i], 
+                         mult(st->past_rq[i], 
+                              pred_fac[i]));                            move16 ();
+          lsf_r1[i] = sub(lsf1[i], lsf_p[i]);                           move16 ();
+      }
+    }
+    else
+    {
+       /* DTX mode, search the init vector that yields */
+       /* lowest prediction resuidual energy           */
+       *pred_init_i = 0;                                                move16 ();
+       L_min_pred_init_err = 0x7fffffff; /* 2^31 - 1 */                 move32 ();
+       for (j = 0; j < PAST_RQ_INIT_SIZE; j++)
+       {
+          L_pred_init_err = 0;                                          move32 ();
+          for (i = 0; i < M; i++)
+          {
+             temp_p[i] = add(mean_lsf[i], past_rq_init[j*M+i]);
+             temp_r1[i] = sub(lsf1[i],temp_p[i]);
+             L_pred_init_err = L_mac(L_pred_init_err, temp_r1[i], temp_r1[i]);
+          }  /* next i */
+
+          test ();
+          if (L_sub(L_pred_init_err, L_min_pred_init_err) < (Word32) 0)
+          {
+             L_min_pred_init_err = L_pred_init_err;                     move32 (); 
+             Copy(temp_r1, lsf_r1, M);
+             Copy(temp_p, lsf_p, M);
+             
+             /* Set zerom */
+             Copy(&past_rq_init[j*M], st->past_rq, M);
+             *pred_init_i = j;                                          move16 ();            
+          } /* endif */
+       } /* next j */
+    } /* endif MRDTX */
+    
+    /*---- Split-VQ of prediction error ----*/
+    if (sub (mode, MR475) == 0 || sub (mode, MR515) == 0)
+    {   /* MR475, MR515 */
+      test (); test (); 
+                          
+      indice[0] = Vq_subvec3(&lsf_r1[0], dico1_lsf, &wf1[0], DICO1_SIZE, 0);
+      move16 ();
+      indice[1] = Vq_subvec3(&lsf_r1[3], dico2_lsf, &wf1[3], DICO2_SIZE/2, 1);
+      move16 ();
+      indice[2] = Vq_subvec4(&lsf_r1[6], mr515_3_lsf, &wf1[6], MR515_3_SIZE);
+      move16 ();
+    }
+    else if (sub (mode, MR795) == 0)
+    {   /* MR795 */
+      test (); test (); test ();
+       
+      indice[0] = Vq_subvec3(&lsf_r1[0], mr795_1_lsf, &wf1[0], MR795_1_SIZE, 0);
+      move16 ();
+      indice[1] = Vq_subvec3(&lsf_r1[3], dico2_lsf, &wf1[3], DICO2_SIZE, 0);
+      move16 ();
+      indice[2] = Vq_subvec4(&lsf_r1[6], dico3_lsf, &wf1[6], DICO3_SIZE);
+      move16 ();
+    }
+    else 
+    {   /* MR59, MR67, MR74, MR102 , MRDTX */
+      test (); test (); test ();
+
+      indice[0] = Vq_subvec3(&lsf_r1[0], dico1_lsf, &wf1[0], DICO1_SIZE, 0);
+      move16 ();
+      indice[1] = Vq_subvec3(&lsf_r1[3], dico2_lsf, &wf1[3], DICO2_SIZE, 0);
+      move16 ();
+      indice[2] = Vq_subvec4(&lsf_r1[6], dico3_lsf, &wf1[6], DICO3_SIZE);
+      move16 ();
+    }
+
+        
+    /* Compute quantized LSFs and update the past quantized residual */
+
+    for (i = 0; i < M; i++)
+    {
+        lsf1_q[i] = add(lsf_r1[i], lsf_p[i]);                        move16 ();
+        st->past_rq[i] = lsf_r1[i];                                  move16 ();
+    }
+
+    /* verification that LSFs has mimimum distance of LSF_GAP Hz */
+
+    Reorder_lsf(lsf1_q, LSF_GAP, M);
+
+    /*  convert LSFs to the cosine domain */
+
+    Lsf_lsp(lsf1_q, lsp1_q, M);
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/q_plsf_3.tab FFMpeg-20050127-new/libavcodec/amr/q_plsf_3.tab
--- FFMpeg-20050127/libavcodec/amr/q_plsf_3.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/q_plsf_3.tab	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,2014 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : q_plsf_3.tab
+*      Purpose          : Table for routine LSF VQ.
+*      $Id $
+*
+********************************************************************************
+*/
+
+#define PAST_RQ_INIT_SIZE 8
+ 
+/* initalization table for MA predictor in dtx mode */
+static Word16 past_rq_init[80] = {
+  -258, -318, -439, -634, -656, -773, -711, -502, -268, -193,
+    -2,  125,  122,  -39,   -9,  105,  129,  283,  372,  575,
+  -277, -324, -197, -487, -445, -362, -292,  -27,  177,  543,
+   342,  517,  516,  130,   27, -104, -120, -140,  -74,  -56,
+  -564, -943,-1520, -965, -814, -526, -322,   -2,  159,  657,
+  -312, -284, -386, -597, -493, -526, -418, -229,  105,  449,
+  -557, -870,-1075, -919, -950, -752, -709, -316,   62,  486,
+  -314, -191, -203, -330, -160, -103,  -51,  131,  338,  515
+};
+
+
+static Word16 mean_lsf[10] = {
+     1546,
+     2272,
+     3778,
+     5488,
+     6972,
+     8382,
+    10047,
+    11229,
+    12766,
+    13714 
+};
+
+
+static Word16 pred_fac[10] = {
+     9556,
+    10769,
+    12571,
+    13292,
+    14381,
+    11651,
+    10588,
+     9767,
+     8593,
+     6484 
+};
+
+
+#define DICO1_SIZE  256
+#define DICO2_SIZE  512
+#define DICO3_SIZE  512
+
+/* first codebook from IS641 */
+
+static Word16 dico1_lsf[] = {
+  6, 82, -131,
+  154, -56, -735,
+  183, -65, -265,
+  9, -210, -361,
+  113, 718, 1817,
+  1010, 1214, 1573,
+  857, 1333, 2276,
+  827, 1568, 1933,
+  717, 1989, 2206,
+  838, 1172, 1823,
+  721, 1000, 2154,
+  286, 476, 1509,
+  -247, -531, 230,
+  147, -82, 569,
+  26, -177, -944,
+  -27, -273, 692,
+  -164, -264, -183,
+  224, 790, 1039,
+  899, 946, 601,
+  485, 771, 1150,
+  524, 677, 903,
+  -140, 375, 778,
+  410, 676, 429,
+  301, 530, 1009,
+  719, 646, 38,
+  226, 367, 40,
+  145, -45, -505,
+  290, 121, -121,
+  302, 127, 166,
+  -124, -383, -956,
+  -358, -455, -977,
+  715, 878, 894,
+  978, 923, 211,
+  477, 272, 64,
+  188, -78, 17,
+  -143, -65, 38,
+  643, 586, 621,
+  -134, -426, -651,
+  347, 545, 2820,
+  1188, 2726, 2442,
+  142, -80, 1735,
+  283, 130, 461,
+  -262, -399, -1145,
+  -411, 155, 430,
+  329, 375, 779,
+  53, -226, -139,
+  -129, -236, 1682,
+  285, 744, 1327,
+  738, 697, 1664,
+  312, 409, 266,
+  325, 720, 135,
+  1, 221, 453,
+  8, 203, 145,
+  299, 640, 760,
+  29, 468, 638,
+  103, 429, 379,
+  420, 954, 932,
+  1326, 1210, 1258,
+  704, 1012, 1152,
+  -166, -444, -266,
+  -316, -130, -376,
+  191, 1151, 1904,
+  -240, -543, -1260,
+  -112, 268, 1207,
+  70, 1062, 1583,
+  278, 1360, 1574,
+  -258, -272, -768,
+  19, 563, 2240,
+  -3, -265, 135,
+  -295, -591, -388,
+  140, 354, -206,
+  -260, -504, -795,
+  -433, -718, -1319,
+  109, 331, 962,
+  -429, -87, 652,
+  -296, 426, 1019,
+  -239, 775, 851,
+  489, 1334, 1073,
+  -334, -332, 25,
+  543, 1206, 1807,
+  326, 61, 727,
+  578, 849, 1405,
+  -208, -277, 329,
+  -152, 64, 669,
+  -434, -678, -727,
+  -454, -71, 251,
+  605, 480, 254,
+  -482, 11, 996,
+  -289, 395, 486,
+  722, 1049, 1440,
+  -30, -316, -786,
+  -106, -115, -619,
+  861, 1474, 1412,
+  1055, 1366, 1184,
+  812, 1237, 925,
+  42, -251, -576,
+  342, 141, -454,
+  -168, -80, 1359,
+  -342, -656, -1763,
+  100, 821, 725,
+  990, 747, 800,
+  332, 440, 568,
+  663, 379, 852,
+  112, 165, -369,
+  597, 910, 282,
+  -8, 834, 1281,
+  -352, 572, 695,
+  462, 2246, 1806,
+  345, 190, 1374,
+  416, 915, 2166,
+  168, -82, 280,
+  -516, -446, 840,
+  47, 533, 44,
+  -362, -711, -1143,
+  22, 193, 1472,
+  -85, 233, 1813,
+  -62, 579, 1504,
+  550, 944, 1749,
+  723, 650, 1148,
+  972, 884, 1395,
+  -425, 643, 0,
+  1000, 952, 1098,
+  249, 1446, 672,
+  -334, -87, 2172,
+  -554, 1882, 2672,
+  140, 1826, 1853,
+  920, 1749, 2590,
+  1076, 1933, 2038,
+  -137, -443, -1555,
+  1269, 1174, 468,
+  -493, -122, 1521,
+  -451, 1033, 1214,
+  482, 1695, 1118,
+  815, 649, 384,
+  -446, -692, 107,
+  -319, -605, -118,
+  -207, -505, 525,
+  -468, -12, 2736,
+  75, 1934, 1305,
+  880, 2358, 2267,
+  1285, 1575, 2004,
+  -48, -304, -1186,
+  -435, -461, -251,
+  -366, -404, -547,
+  -289, -605, -597,
+  -538, -810, -165,
+  -120, 3, 356,
+  639, 1241, 1502,
+  96, 177, 750,
+  -435, -585, -1174,
+  -356, 109, -79,
+  -485, 288, 2005,
+  9, 1116, 731,
+  880, 2134, 946,
+  -265, 1585, 1065,
+  1157, 1210, 843,
+  -498, -668, 431,
+  374, 321, -229,
+  1440, 2101, 1381,
+  449, 461, 1155,
+  -105, 39, -384,
+  -263, 367, 182,
+  -371, -660, 773,
+  -188, 1151, 971,
+  1333, 1632, 1435,
+  774, 1267, 1221,
+  -482, -832, -1489,
+  -237, -210, 860,
+  890, 1615, 1064,
+  472, 1062, 1192,
+  185, 1077, 989,
+  -568, -992, -1704,
+  -449, -902, -2043,
+  -142, -377, -458,
+  -210, -554, -1029,
+  -11, 1133, 2265,
+  -329, -675, -893,
+  -250, 657, 1187,
+  519, 1510, 1779,
+  520, 539, 1403,
+  527, 1421, 1302,
+  -563, -871, -1248,
+  -147, -463, 879,
+  -76, 2334, 2840,
+  563, 2573, 2385,
+  632, 1926, 2920,
+  719, 2023, 1840,
+  -545, -723, 1108,
+  129, -125, 884,
+  1417, 1632, 925,
+  -94, 1566, 1751,
+  -341, 1533, 1551,
+  591, 395, -274,
+  -76, 981, 2831,
+  153, 2985, 1844,
+  1032, 2565, 2749,
+  1508, 2832, 1879,
+  791, 1199, 538,
+  -190, -453, 1489,
+  -278, -548, 1158,
+  -245, 1941, 2044,
+  1024, 1560, 1650,
+  512, 253, 466,
+  -62, -323, 1151,
+  -473, -376, 507,
+  -433, 1380, 2162,
+  899, 1943, 1445,
+  134, 704, 440,
+  460, 525, -28,
+  -450, 279, 1338,
+  0, 971, 252,
+  -445, -627, -991,
+  -348, -602, -1424,
+  398, 712, 1656,
+  -107, 314, -178,
+  93, 2226, 2238,
+  518, 849, 656,
+  -462, -711, -447,
+  174, -34, 1191,
+  -119, 42, 1005,
+  -372, 274, 758,
+  1036, 2352, 1838,
+  675, 1724, 1498,
+  430, 1286, 2133,
+  -129, -439, 0,
+  -373, 800, 2144,
+  6, 1587, 2478,
+  478, 596, 2128,
+  -428, -736, 1505,
+  385, 178, 980,
+  139, 449, 1225,
+  -526, -842, -982,
+  145, 1554, 1242,
+  623, 1448, 656,
+  349, 1016, 1482,
+  31, -280, 415,
+  -316, 724, 1641,
+  360, 1058, 556,
+  -436, -358, 1201,
+  -355, 1123, 1939,
+  401, 1584, 2248,
+  -527, -1012, 355,
+  233, 238, 2233,
+  -550, -897, -639,
+  -365, -501, 1957,
+  389, 1860, 1621,
+  162, 1132, 1264,
+  -237, 1174, 1390,
+  -640, -411, 116,
+  -228, 1694, 2298,
+  1639, 2186, 2267,
+  562, 1273, 2658,
+  323, 338, 1774,
+  578, 1107, 852,
+  22, 594, 934,
+  -143, 718, 446
+};
+
+
+/* second codebook from IS641 */
+
+static Word16 dico2_lsf[] = {
+  50, 71, -9,
+  -338, -698, -1407,
+  102, -138, -820,
+  -310, -469, -1147,
+  414, 67, -267,
+  1060, 814, 1441,
+  1548, 1360, 1272,
+  1754, 1895, 1661,
+  2019, 2133, 1820,
+  1808, 2318, 1845,
+  644, -93, 454,
+  858, 329, -136,
+  489, -258, -128,
+  -198, -745, -41,
+  -52, -265, -985,
+  346, 137, 479,
+  -1741, -748, -684,
+  -1163, -1725, -367,
+  -895, -1145, -784,
+  -488, -946, -968,
+  -85, -390, -725,
+  215, -340, -171,
+  1020, 916, 1969,
+  564, 179, 746,
+  662, 977, 1734,
+  887, 622, 914,
+  939, 856, 1165,
+  309, 688, 803,
+  917, 161, 570,
+  118, -20, -283,
+  -816, -42, 204,
+  -1228, -325, -462,
+  -963, -202, -143,
+  -988, -484, -361,
+  -702, -978, -477,
+  -302, -790, -1188,
+  -100, -786, -1088,
+  -1054, -947, -1684,
+  -202, -843, -782,
+  -1039, -1378, -901,
+  -624, -110, -85,
+  356, 213, -10,
+  -493, 364, 774,
+  425, 822, 479,
+  -83, 557, 520,
+  -992, -1560, -572,
+  -603, -741, -26,
+  -502, -638, -903,
+  209, 306, 147,
+  -316, -593, -596,
+  -85, -211, -225,
+  -918, -529, 117,
+  233, -439, -738,
+  1101, 751, 633,
+  1457, 1716, 1511,
+  1765, 1457, 910,
+  1122, 1156, 849,
+  1354, 868, 470,
+  -871, -1150, -1796,
+  -871, -861, -992,
+  -118, 155, 212,
+  -1051, -849, -606,
+  -1117, -1849, -2750,
+  -1019, -1427, -1869,
+  370, -184, -414,
+  959, 493, 104,
+  958, 1039, 543,
+  154, 653, 201,
+  1249, 507, 150,
+  663, 503, 230,
+  623, 777, 675,
+  659, 88, -110,
+  843, 244, 224,
+  382, 541, 302,
+  724, 433, 666,
+  1166, 734, 341,
+  -138, 20, -397,
+  -1183, -424, -46,
+  -321, -352, -124,
+  1333, 1021, 1080,
+  262, 366, 723,
+  922, 283, -551,
+  31, -636, -611,
+  -689, -697, -415,
+  -952, -779, -201,
+  -1329, -598, -359,
+  -953, -1285, 166,
+  493, 305, 221,
+  846, 703, 610,
+  840, 936, 774,
+  -723, -1324, -1261,
+  -357, -1025, -1388,
+  -1096, -1376, -365,
+  -1416, -1881, -608,
+  -1798, -1727, -674,
+  -545, -1173, -703,
+  678, 786, 148,
+  -123, 696, 1288,
+  644, 350, -10,
+  414, 614, 15,
+  137, 344, -211,
+  -814, -1512, -819,
+  -391, -930, -588,
+  47, -591, -898,
+  -909, -1097, -163,
+  -1272, -1167, -157,
+  -1464, -1525, -389,
+  -1274, -1188, -624,
+  671, 213, 454,
+  124, -274, -525,
+  -729, -496, -152,
+  -1344, 122, 135,
+  -2905, -589, -394,
+  -1728, 441, -50,
+  1476, 904, 787,
+  316, 236, -440,
+  -347, 217, 413,
+  -911, -917, 121,
+  -455, -932, 202,
+  -92, -465, -375,
+  488, 390, 474,
+  876, 729, 316,
+  -1815, -1312, -669,
+  87, 962, 432,
+  563, -249, -1058,
+  250, 285, 1105,
+  1141, 427, 696,
+  -1038, -1664, -1582,
+  -948, 346, 160,
+  -309, -272, -858,
+  670, 624, 1250,
+  -944, -408, -666,
+  -606, -320, -384,
+  -492, 230, 65,
+  334, -50, -16,
+  -16, -690, -1397,
+  1791, 1716, 1399,
+  2478, 2063, 1404,
+  1245, 1471, 1426,
+  -382, -1037, -2,
+  173, -398, 1145,
+  1491, 2024, 1801,
+  772, 1274, 1506,
+  1429, 1735, 2001,
+  1079, 1218, 1273,
+  -1154, -1851, -1329,
+  -808, -1133, -1096,
+  -451, -1033, -1722,
+  65, 578, -84,
+  -1476, -2434, -1778,
+  -765, -1366, -494,
+  -218, -594, -931,
+  337, -236, 562,
+  2357, 2662, 1938,
+  1489, 1276, 874,
+  189, 358, 374,
+  -1519, -2281, -2346,
+  -967, -1271, -2095,
+  -628, -1188, -1542,
+  1661, 1043, 546,
+  565, 1061, 732,
+  -64, -836, -434,
+  -436, -96, 203,
+  1078, 1216, 1636,
+  907, 1534, 986,
+  326, 965, 845,
+  142, -84, 197,
+  470, 2379, 1570,
+  1133, 470, 1214,
+  395, 1376, 1200,
+  1125, 1042, 348,
+  -543, -1234, -376,
+  -215, -181, 481,
+  -1947, -1621, -210,
+  -750, -1185, 390,
+  29, -399, 27,
+  820, 1236, 755,
+  695, 979, 409,
+  -174, 1197, 1035,
+  912, 1356, 1846,
+  -992, -1437, 484,
+  -1485, -1700, 208,
+  -412, 1204, 1432,
+  -271, 896, 1144,
+  -416, 1777, 1434,
+  -1696, -2644, -204,
+  -1789, -1551, 1033,
+  -1656, -1559, 1303,
+  -1253, -1589, 1081,
+  -669, -1095, -66,
+  -682, 320, -345,
+  659, 305, 1069,
+  -1292, -804, -19,
+  -1635, -1291, 29,
+  -1683, -497, 71,
+  -287, -7, -100,
+  -494, -962, -237,
+  852, 1881, 1740,
+  -1217, -1387, 227,
+  -660, 302, 373,
+  96, 1087, 1257,
+  -1074, -1669, 160,
+  485, 2076, 1798,
+  -934, -220, 552,
+  -596, -612, 237,
+  336, 1720, 879,
+  643, 629, 434,
+  1267, 522, 1633,
+  15, 244, -441,
+  1475, 717, 184,
+  1819, 1590, 1709,
+  988, 261, 937,
+  2093, 2345, 1520,
+  2139, 1858, 1606,
+  -577, -579, -1203,
+  -956, 135, -488,
+  -464, 51, -338,
+  -629, -348, -723,
+  1146, 2073, 1442,
+  2192, 1466, 911,
+  -1444, -1572, -2278,
+  1400, 710, 1297,
+  1335, 633, 928,
+  1434, 2194, 2594,
+  2422, 2204, 1881,
+  982, 2242, 1854,
+  380, 792, 1145,
+  -63, -539, 414,
+  -252, -964, -314,
+  -1261, -683, -780,
+  -831, -526, -1005,
+  -1666, -1135, -424,
+  -1611, -452, -299,
+  1268, 1048, 642,
+  1147, 853, 856,
+  -675, -336, 139,
+  2268, 1343, 1418,
+  29, 768, 797,
+  -1224, 423, 564,
+  -1318, -1082, 245,
+  -1302, -812, 573,
+  -1298, -1617, 646,
+  -968, 834, 723,
+  993, 1652, 2027,
+  -191, -817, 432,
+  662, 60, 198,
+  626, 997, 1330,
+  1648, 1963, 1289,
+  -1597, -93, -45,
+  -1088, 37, -84,
+  1653, 2607, 2337,
+  1065, 2040, 2377,
+  1139, 2326, 2118,
+  859, 357, 1510,
+  664, 1227, 1099,
+  479, 1360, 912,
+  1897, 1754, 2019,
+  1168, 1909, 1784,
+  399, 34, 256,
+  -593, -304, -1053,
+  547, 1694, 1407,
+  647, -99, -341,
+  1492, 1647, 1190,
+  38, -644, -212,
+  395, 846, 222,
+  -704, -765, -716,
+  -724, -1964, -2804,
+  -150, 291, -82,
+  1233, 1459, 1007,
+  -140, -155, 153,
+  439, 297, 1568,
+  -1529, -410, -636,
+  1536, 455, -237,
+  -1328, -139, -260,
+  531, 554, 868,
+  269, 1264, 606,
+  -233, 883, 463,
+  742, 600, -120,
+  -73, 421, 212,
+  -439, -58, 804,
+  -1286, -1241, 728,
+  294, -490, 50,
+  -591, -905, -1254,
+  42, -687, 147,
+  -25, 273, 596,
+  -311, 1213, 601,
+  -754, 849, 584,
+  429, 607, 587,
+  -602, -166, 461,
+  -796, -823, 777,
+  1380, 910, 1755,
+  119, 1417, 972,
+  -219, -880, -1596,
+  -1049, -1010, 438,
+  -713, -1379, 78,
+  0, -447, -1179,
+  -1136, -1319, -1573,
+  2248, 1767, 1309,
+  946, 1583, 1432,
+  1150, 482, 436,
+  -469, -1108, 618,
+  -447, -966, 1088,
+  -1252, -1515, -114,
+  -1104, -2008, -579,
+  210, 613, 497,
+  -1975, -1437, 642,
+  -1269, -856, 1011,
+  -1646, -1185, 1063,
+  -1555, -672, 1204,
+  -1692, -1114, 623,
+  -979, -1326, -1277,
+  539, -147, 894,
+  -1354, -897, -434,
+  888, 475, 428,
+  153, -384, 338,
+  -1492, -511, 359,
+  -974, -1115, -470,
+  105, -550, 677,
+  -937, -1145, 877,
+  380, -260, 210,
+  1685, 924, 1256,
+  1775, 1190, 1095,
+  1419, 631, 533,
+  627, 299, -347,
+  -411, -534, 647,
+  -650, 29, -595,
+  -378, -1367, 1563,
+  1402, 1121, 1465,
+  1089, 1410, 648,
+  -2096, -1090, -6,
+  311, -194, -869,
+  -639, -831, 416,
+  -1162, -1224, 1349,
+  -1247, -941, 1813,
+  -2193, -1987, 453,
+  -619, -1367, -956,
+  -1606, -1972, -1507,
+  -1175, -1057, -1104,
+  -377, 601, 201,
+  1876, 825, 374,
+  -430, -1323, 29,
+  -1397, -1249, -1331,
+  -1007, -1504, 960,
+  -1401, -2009, 197,
+  -1379, -1949, -236,
+  -1077, 123, 422,
+  615, 1269, 546,
+  -306, 1526, 904,
+  1194, 1788, 1177,
+  -626, -884, -1526,
+  199, 766, 1504,
+  -1065, 862, 197,
+  -1034, -1773, -887,
+  -800, 145, 599,
+  -1134, -519, 626,
+  -1205, -1926, 500,
+  -910, -1041, -1395,
+  -1476, -1567, -969,
+  -523, 842, 34,
+  1794, 646, 862,
+  -1207, -1888, -1002,
+  -78, -9, -672,
+  1044, 759, 80,
+  -600, 1139, 1019,
+  57, 2000, 1422,
+  -833, 1414, 1121,
+  -1202, 1630, 1260,
+  -461, 1420, 1244,
+  1537, 975, 253,
+  -283, 324, -359,
+  599, -195, 106,
+  588, 62, -587,
+  -757, 645, 205,
+  51, 1201, 758,
+  -1209, 673, -390,
+  -624, 1581, 941,
+  -151, 1023, 735,
+  2820, 1301, 690,
+  -302, 524, -99,
+  -900, -1588, -1189,
+  1084, 251, 238,
+  2014, 1792, 1010,
+  1245, 1633, 1741,
+  -1227, -1540, -1208,
+  -621, 456, -109,
+  40, -65, 788,
+  -805, -699, -1350,
+  -583, 904, 832,
+  -801, 532, 594,
+  1972, 1408, 1351,
+  -1177, -1880, -2114,
+  -773, 568, 948,
+  -1015, 1079, 1260,
+  -1111, 482, -130,
+  1778, 1044, 780,
+  -1491, 245, 912,
+  -316, -1141, -917,
+  -536, -1442, -2346,
+  -785, -1546, -1988,
+  -2003, 257, 909,
+  -1849, -633, -1209,
+  -1538, -1918, -1054,
+  1606, 2239, 1576,
+  -567, -1500, -1544,
+  -1279, 195, 1369,
+  -817, 293, 1219,
+  -525, 630, 1197,
+  -1698, -2425, -1840,
+  -303, 731, 747,
+  -1169, -251, 269,
+  -950, -75, 1684,
+  -1182, -453, 1005,
+  -1599, 585, 378,
+  -2075, -571, -427,
+  -529, -1159, -1171,
+  -283, -205, -564,
+  -796, 1246, 717,
+  2277, 927, 539,
+  -454, 559, 440,
+  -717, 1460, 1615,
+  -1030, 1052, 1610,
+  -1169, -138, 847,
+  226, 39, -612,
+  -1251, -106, -729,
+  -651, 968, 1302,
+  -714, -636, 1727,
+  353, 1069, 410,
+  -798, -156, 1099,
+  -574, 918, 446,
+  -1310, 1012, 466,
+  1408, 1591, 765,
+  1429, 1380, 1757,
+  1949, 1956, 2378,
+  1578, 2047, 2148,
+  916, 98, -7,
+  1893, 1418, 2141,
+  348, 1405, 1579,
+  152, 1134, 1801,
+  -267, 154, 1395,
+  -1166, 469, 1054,
+  -1142, -405, -1073,
+  -1341, -2264, -1581,
+  -364, 869, 1706,
+  -1162, 549, 1550,
+  -1225, -1932, -1666,
+  -1485, -1977, -2055,
+  -1727, -906, -98,
+  -1897, 233, 1492,
+  892, 108, -331,
+  -1728, -1170, -1700,
+  -1060, 1980, 1790,
+  -1070, -1741, -1909,
+  -11, 1539, 1317,
+  -1600, 94, 497,
+  421, 443, -197,
+  -1578, -349, -994,
+  -599, -539, 1140,
+  -965, -1419, -129,
+  -1341, 175, -447,
+  -375, 1311, 2055,
+  -371, -650, -307,
+  -1073, 605, 365,
+  -2057, -113, 430,
+  652, 914, 967,
+  -1012, -1586, -2323,
+  1505, 1248, 559,
+  262, -486, -401,
+  -1727, 1342, 1546,
+  50, 56, 432,
+  -330, 119, -604,
+  -1517, -1080, -810,
+  946, 1127, 1055,
+  -1400, -1703, -1712,
+  -1270, -704, -1317,
+  807, 1821, 1143,
+  2760, 1606, 2171,
+  1120, 409, -150,
+  -147, 404, 959,
+  2439, 1911, 2189,
+  -906, -141, -866,
+  -904, -142, -458,
+  -557, -708, -1679,
+  -830, -1431, -1583,
+  -1842, -1346, -1086,
+  -1604, -272, 915,
+  -1196, 772, 1056,
+  -638, -1234, -1897,
+  -500, -81, -822,
+  -1289, -1613, -735,
+  -117, 785, 168,
+  -1090, 1133, 922,
+  -1096, -746, 1384,
+  287, -547, -1063,
+  -1376, -2201, -1204,
+  -2176, -1570, -1757,
+  -1511, -2241, -771,
+  -1737, 1099, 830,
+  -1588, 724, 1243,
+  -1542, 693, 805,
+  -1690, -240, 1665,
+  -1700, -4, -668,
+  2149, 816, 1042,
+  -818, -1841, 22,
+  -764, -507, 449,
+  -1151, -617, 289,
+  -843, -1596, -240,
+  498, -234, -657,
+  -752, 480, 1678,
+  -319, -481, 193,
+  -811, 171, -119,
+  -2128, -202, -848,
+  1717, 1140, 1700
+};
+
+
+/* third codebook from IS641 */
+
+static Word16 dico3_lsf[] = {
+  67, -17, 66, -12,
+  -1690, -581, -104, -272,
+  -1076, -1186, -1845, -376,
+  -1140, -926, -420, -58,
+  -259, -656, -1134, -553,
+  1788, 1227, 455, 129,
+  462, 441, -240, -528,
+  840, 514, 130, -75,
+  1114, 623, 153, 216,
+  1068, 564, -6, -276,
+  1119, 727, 190, -68,
+  704, 306, 119, -264,
+  329, 61, -100, 156,
+  364, 123, 183, -208,
+  -171, -123, 220, -65,
+  -306, -62, 402, 17,
+  -660, -938, -266, 0,
+  385, 235, 276, 285,
+  320, 268, -336, -200,
+  -724, 17, -84, 381,
+  -544, 429, 494, 519,
+  -117, 288, 304, 329,
+  643, 157, 701, 508,
+  1200, 625, 796, 608,
+  998, 421, 492, 632,
+  1204, 780, 446, 132,
+  1257, 844, 547, 449,
+  829, 658, 541, 470,
+  1132, 1258, 918, 639,
+  547, 51, 423, 279,
+  9, 392, 83, 94,
+  542, 543, 229, -147,
+  -198, 129, 194, -185,
+  -863, -1321, -302, 30,
+  -597, -629, -19, 114,
+  -900, -1081, 466, 353,
+  -1483, -1573, 15, -143,
+  -1708, -2059, -751, 196,
+  -1876, -2067, -642, -258,
+  -2335, -1470, -450, -564,
+  -584, -186, -872, -414,
+  -1805, -988, -1125, -1310,
+  -726, -1129, 28, 169,
+  -1039, -864, -718, -246,
+  484, 36, -233, -49,
+  265, 67, 289, 467,
+  178, 543, 810, 540,
+  84, 282, 672, 703,
+  -975, -777, 129, 287,
+  -938, -227, 955, 595,
+  -1617, -289, 836, 649,
+  -1847, -215, 1106, 718,
+  -2034, -1085, 650, 440,
+  -2101, -529, 907, 575,
+  -2011, -336, 670, 204,
+  -2389, -692, 360, 137,
+  -2156, -2204, -9, 280,
+  -266, 119, 39, 193,
+  78, -59, -120, 226,
+  -975, -858, -781, -1095,
+  -619, -413, -451, -842,
+  -1216, -1321, -813, -883,
+  -1376, -1615, -394, -428,
+  -737, -1113, -549, -790,
+  -880, -975, -967, -642,
+  -985, -886, -1273, -1361,
+  -473, -804, -1401, -1407,
+  160, -265, -919, -275,
+  -248, -250, -718, -380,
+  97, -103, -375, -229,
+  -415, -193, -135, -555,
+  628, 361, 119, 216,
+  579, 364, 391, 209,
+  634, 522, -154, -148,
+  526, 389, 170, 33,
+  105, 267, 64, 380,
+  -1503, -1000, -30, -369,
+  -1070, 58, 647, 223,
+  -1520, -291, 621, 307,
+  -1531, 156, 762, 404,
+  -2029, 141, 734, 499,
+  -1849, -650, 306, 512,
+  -187, -104, -59, 438,
+  134, -230, 156, -186,
+  -61, -260, -16, 10,
+  -569, -3, -421, -297,
+  -1725, -521, -346, 178,
+  -1362, -59, -44, 157,
+  -2146, -461, -470, -349,
+  -2170, -1, -369, -121,
+  -1579, -373, -900, -1015,
+  -1117, -591, -613, -784,
+  -561, 122, -75, -449,
+  -4, -171, -123, -372,
+  192, 168, -76, -132,
+  252, -107, 340, 210,
+  392, 509, 272, 181,
+  -109, 145, 218, 119,
+  -416, -263, 485, 265,
+  -181, -8, -286, 226,
+  -244, -218, 69, -290,
+  -158, 191, -1, -64,
+  -592, -90, 213, -96,
+  255, 435, 178, -80,
+  -369, -18, -33, -80,
+  -42, 415, 140, -222,
+  1143, 651, 649, 329,
+  767, 556, 249, 235,
+  948, 413, 442, 279,
+  141, 339, 356, 557,
+  -470, -170, 99, 237,
+  -569, -800, 352, 565,
+  282, 473, 470, 332,
+  -199, -690, -1284, -917,
+  -193, -426, -800, -1122,
+  -26, -371, -490, -193,
+  637, 595, 519, 330,
+  408, -115, 79, 12,
+  477, 87, -103, -376,
+  -666, -347, -277, -291,
+  -510, -481, 169, 297,
+  -829, -738, -205, -171,
+  -320, -540, 328, 283,
+  -859, -958, 442, -2,
+  556, 686, 130, 56,
+  1383, 1012, 755, 427,
+  612, 741, 628, 553,
+  -339, -796, 134, 277,
+  -633, -1085, -2, -246,
+  -880, -1035, -1607, -1064,
+  -994, -474, -1138, -488,
+  -414, -795, 73, -206,
+  -8, -139, 439, 204,
+  -176, -578, 23, 131,
+  -269, -757, -191, 245,
+  -109, -338, 112, 316,
+  120, -406, -118, 611,
+  -180, -186, -645, 115,
+  -173, 34, -518, -489,
+  -151, 61, -583, -844,
+  220, -138, -681, -1020,
+  391, -17, -598, -321,
+  157, -295, 129, 155,
+  -926, -875, -987, 285,
+  241, -83, -125, -125,
+  620, 597, 432, 92,
+  393, 78, 409, 61,
+  -393, -739, -413, -748,
+  83, 54, 361, 27,
+  -1084, 130, -337, -694,
+  -1565, 297, 318, -19,
+  -1873, 36, 51, -317,
+  -2323, -246, 231, -84,
+  -2306, -783, 40, -179,
+  -2233, -930, -474, -462,
+  -754, -86, -288, -626,
+  -2411, -455, -63, 171,
+  -1099, -1094, -26, -143,
+  -1193, -455, -406, -381,
+  -605, -210, -96, -51,
+  -580, -476, -276, -15,
+  -1195, -634, -1203, -881,
+  -378, -221, -669, -952,
+  594, 178, -403, -676,
+  763, 327, 601, 290,
+  172, 300, 203, 157,
+  -56, -336, 356, 24,
+  -228, -296, -259, -29,
+  -186, 263, 416, 14,
+  -353, 373, -12, -216,
+  257, 96, 174, 57,
+  -1526, -616, -954, -499,
+  -497, -152, -333, 125,
+  105, 200, 179, -97,
+  -331, -224, 765, 697,
+  760, 256, 301, 59,
+  455, -85, 204, 288,
+  -514, 240, 251, -109,
+  256, 417, -34, -413,
+  101, 430, 384, 156,
+  -31, -10, 206, 426,
+  589, 145, 143, 71,
+  808, 906, 333, 349,
+  986, 938, 589, 331,
+  1300, 824, 187, 509,
+  1062, 653, 379, 466,
+  1462, 937, 401, 274,
+  787, 861, 265, 2,
+  609, 553, 28, 305,
+  926, 340, 106, 386,
+  241, -267, -147, 225,
+  -178, -534, 347, 502,
+  -643, -381, 397, 30,
+  -651, -733, -435, 398,
+  -407, -726, -484, -248,
+  -789, -914, -438, -476,
+  -498, -390, 75, -295,
+  -964, -590, -606, 150,
+  -121, -49, -155, -78,
+  935, 550, 389, 38,
+  -321, 127, 424, 315,
+  -285, -113, 283, 259,
+  658, 203, 322, 486,
+  903, 505, 748, 417,
+  611, 423, 555, 512,
+  239, -83, -578, -19,
+  -339, -731, 349, 13,
+  -934, -1399, -114, -360,
+  107, 692, 182, 90,
+  -1243, -1538, -1551, -725,
+  -568, -903, -1363, -525,
+  -517, -853, -861, -1004,
+  -168, -690, -835, 63,
+  -137, -556, -547, 144,
+  -286, -817, 485, 319,
+  -147, -408, 526, 246,
+  -347, -434, 297, -28,
+  -290, -471, -1110, -1285,
+  -460, -359, -988, -794,
+  1347, 1299, 690, 523,
+  1216, 1068, 1094, 757,
+  825, 1140, 752, 494,
+  1252, 1365, 1195, 898,
+  521, 1053, 532, 432,
+  -334, -216, -313, -263,
+  -160, 52, -472, -155,
+  127, 136, -380, 44,
+  851, 410, -162, -489,
+  123, -255, -796, -667,
+  1090, 917, 789, 493,
+  1397, 1197, 558, 202,
+  -51, -118, -342, -701,
+  83, 108, -42, -441,
+  61, 95, 287, 256,
+  -27, 89, 524, 531,
+  351, 227, 592, 545,
+  697, 155, -164, 307,
+  638, 274, -489, -50,
+  754, 240, -166, -124,
+  -116, -579, -1212, -63,
+  190, -295, -1040, -1296,
+  147, -376, -177, -113,
+  841, 1241, 1051, 668,
+  2, 293, 551, 304,
+  -1096, -953, -248, 376,
+  -750, -965, 87, 516,
+  -275, -516, 689, 391,
+  -379, -643, 876, 594,
+  -390, -1013, -645, 573,
+  -107, -568, -689, -826,
+  -1025, -27, -328, -203,
+  861, 749, 548, 233,
+  -1660, -1043, 451, 108,
+  -660, -620, 430, 236,
+  21, -396, -1158, -631,
+  1372, 1298, 967, 577,
+  1125, 1125, 589, 454,
+  -323, -865, -467, 153,
+  -468, -699, -804, -509,
+  -392, -718, -204, -35,
+  -603, -1093, -567, -162,
+  -505, -1004, -102, 350,
+  219, 224, 423, 252,
+  395, 591, 608, 363,
+  -746, -96, 373, 172,
+  171, 295, 714, 339,
+  233, 77, 107, 277,
+  157, 153, -499, -356,
+  1547, 1073, 576, 494,
+  -292, -339, -504, -592,
+  -903, -72, -619, -481,
+  -1594, -1117, -567, -254,
+  -793, -507, -564, -291,
+  -492, -532, 502, 560,
+  -382, 427, 600, 230,
+  -227, 477, 251, 75,
+  285, 842, 813, 476,
+  -1310, -1333, 186, 377,
+  -587, -917, 643, 381,
+  -1186, -553, 411, 82,
+  -1127, -820, -174, -540,
+  -604, 119, 543, 205,
+  -380, 657, 909, 567,
+  112, -298, -374, 114,
+  -857, -251, 56, 159,
+  401, 345, -34, -140,
+  -111, -607, 41, 614,
+  355, -114, -77, 474,
+  578, 56, 1450, 924,
+  1098, 1420, 741, 400,
+  246, 22, 588, 313,
+  -121, 327, 831, 472,
+  -1138, -608, 856, 552,
+  -1241, -1072, 638, 600,
+  -358, 254, -333, -303,
+  -646, 739, 358, 74,
+  1226, 1671, 1221, 849,
+  2241, 1624, 983, 636,
+  1841, 1477, 749, 384,
+  350, 263, 87, 128,
+  -1902, -941, -144, -64,
+  -1734, -255, 288, -31,
+  -2644, -1238, 366, 235,
+  -1643, -1092, -1344, -304,
+  -541, -1075, -1116, 123,
+  -1178, -252, -816, -180,
+  -1016, 533, 565, 233,
+  -487, -430, -188, 334,
+  867, 1236, 534, 171,
+  -1590, -1607, 635, 630,
+  -2196, 310, 924, 412,
+  -2358, -328, 956, 529,
+  -2639, -377, 630, 278,
+  -2602, 317, 799, 299,
+  -2406, 133, 340, 31,
+  -2156, -1468, 131, 125,
+  -1184, -490, -139, 46,
+  -744, 447, 891, 564,
+  67, -451, 646, 604,
+  -553, -429, -876, 396,
+  162, -66, 1305, 915,
+  479, 579, 1088, 794,
+  450, 278, 566, 324,
+  -1057, -154, 148, -177,
+  -2545, 168, 1070, 592,
+  -2351, -42, 819, 345,
+  -2344, -707, 721, 250,
+  -2175, -1497, -309, 122,
+  -78, -73, 120, 173,
+  -4, 262, -263, -261,
+  -431, -64, -405, -732,
+  -2609, 116, -83, -193,
+  -1525, -944, -477, -725,
+  -508, 307, 170, 172,
+  832, 417, 832, 686,
+  -225, 177, 894, 818,
+  -482, -389, 1279, 1039,
+  -383, 201, -350, 40,
+  730, 635, 226, 526,
+  503, 462, 338, 398,
+  535, 714, 40, -282,
+  1482, 1471, 1085, 731,
+  1561, 1072, 909, 693,
+  1419, 1282, 889, 879,
+  1153, 728, 1186, 840,
+  -226, 1130, 949, 689,
+  -494, -986, -1556, -128,
+  -568, -721, -713, -26,
+  317, 524, 70, 135,
+  -405, -865, -1766, -652,
+  -174, -801, 885, 773,
+  -153, -91, 1099, 751,
+  -506, -1149, 853, 646,
+  241, 782, 519, 539,
+  1853, 1700, 1101, 684,
+  -1249, -1486, -464, 188,
+  -893, -1409, -1312, -341,
+  -135, 438, -175, 18,
+  1111, 976, 319, 208,
+  -1430, -1768, 83, 458,
+  -530, -1000, 307, 129,
+  -840, -15, -29, -356,
+  -911, -924, -1147, -242,
+  -119, -528, 127, -133,
+  -761, -765, 190, -83,
+  -315, 895, 522, 231,
+  -222, 102, -63, -428,
+  316, 699, 379, 70,
+  25, 716, 314, -108,
+  507, 874, 566, 238,
+  108, 941, 519, 195,
+  425, -60, -427, 257,
+  139, -103, -630, 446,
+  334, 370, 412, 48,
+  -172, -690, -283, 557,
+  187, -286, 158, 483,
+  140, 270, -344, -631,
+  924, 579, -116, 132,
+  142, 466, -68, -64,
+  230, -145, -302, -542,
+  -803, -912, 1018, 737,
+  -773, 1015, 630, 297,
+  -2596, 95, 445, 336,
+  -2122, 491, 510, 191,
+  -1253, 161, -2, -324,
+  -1450, -633, -712, -105,
+  -842, -254, -411, 100,
+  -640, -290, 1010, 763,
+  -650, 313, 1169, 730,
+  140, 505, 1030, 766,
+  772, 287, 1067, 823,
+  495, 749, 305, 323,
+  -164, 462, 78, 399,
+  -342, -874, 69, 597,
+  -16, 620, 621, 337,
+  -138, -444, -265, 218,
+  84, -450, 953, 666,
+  -222, -803, 541, 604,
+  -921, -1376, 244, 116,
+  -841, -723, 630, 588,
+  140, 663, 294, 368,
+  935, 1046, 881, 759,
+  1746, 1464, 916, 628,
+  436, 963, 281, 1,
+  -119, 74, 542, 213,
+  1, -567, 301, 241,
+  260, 435, 222, 396,
+  936, 957, 1108, 703,
+  510, 506, 808, 478,
+  601, 694, 960, 620,
+  972, 741, 980, 600,
+  834, 717, 767, 684,
+  643, 972, 935, 638,
+  501, 661, 720, 851,
+  -105, -632, -303, -117,
+  -429, 130, 789, 442,
+  -522, -188, 704, 373,
+  -759, 42, 814, 523,
+  -531, -1137, 373, 578,
+  -682, -1203, -455, 285,
+  -1163, -1577, -1098, 44,
+  81, -82, 712, 363,
+  477, 246, 954, 622,
+  1604, 1622, 1277, 891,
+  1409, 859, 924, 892,
+  774, 1041, 947, 1142,
+  40, -546, -75, 288,
+  -616, -106, -697, -26,
+  -169, -160, -891, -739,
+  -279, -384, -1029, -350,
+  1781, 1308, 1046, 816,
+  1580, 1533, 1472, 1178,
+  1505, 1076, 1216, 899,
+  890, 904, 564, 654,
+  920, 692, 1021, 856,
+  -493, 132, 177, 505,
+  71, 195, -28, 97,
+  456, 351, -164, 88,
+  439, 278, -40, 350,
+  1395, 949, 234, -95,
+  -805, -472, 38, -163,
+  367, -98, 489, 523,
+  1025, 1178, 1212, 906,
+  319, 1314, 814, 461,
+  -123, -543, -804, 447,
+  -748, -324, -897, -1127,
+  -737, -501, -789, -713,
+  715, 777, 1239, 922,
+  1949, 1939, 1368, 865,
+  730, 880, 758, 388,
+  -871, 454, 17, -251,
+  -381, -810, -1583, 239,
+  -521, -966, -792, 259,
+  -890, -1358, -770, -73,
+  166, 349, -212, 323,
+  -840, -301, 473, 435,
+  -679, -464, 728, 351,
+  -156, -199, 667, 432,
+  29, -252, 415, 480,
+  -731, -379, 145, 559,
+  -528, -631, -1158, -159,
+  445, 273, 123, 639,
+  373, -126, 800, 568,
+  84, -162, 720, 712,
+  -830, -536, -185, 222,
+  408, 452, 501, 771,
+  -897, -1355, -67, 442,
+  -792, -1406, 566, 602,
+  167, -326, 509, 330,
+  -95, -626, -730, -344,
+  1668, 1217, 779, 455,
+  1316, 828, 584, 719,
+  404, -31, 1013, 789,
+  89, 107, 891, 549,
+  871, 1581, 917, 671,
+  866, 1479, 1289, 854,
+  391, 1068, 1122, 812,
+  78, -562, 345, 563,
+  429, -103, 417, 787,
+  -122, -437, 411, 788,
+  -913, -417, 602, 754,
+  -226, -16, 151, 760,
+  -700, 118, -104, -14,
+  -1128, 48, 284, 393,
+  -390, -419, -639, -116,
+  -910, 306, 316, -13,
+  1207, 984, 821, 669,
+  -1195, -693, 140, -213,
+  -884, -416, -199, -558,
+  -616, 245, -404, -664,
+  262, 56, -617, -724,
+  -85, -491, -320, -656,
+  -570, -831, -129, -528,
+  -1506, -63, -367, -385,
+  -358, -321, 4, 51,
+  -366, -214, 319, 511,
+  146, 671, -17, -291,
+  -110, 464, -139, -496,
+  -202, 220, -312, -631,
+  -660, -73, -655, -820,
+  -662, -653, -1288, -857,
+  -430, -953, -959, -264,
+  -49, -468, -72, -381,
+  -350, -563, -193, -407,
+  55, -408, -803, 11,
+  -309, 649, 188, -198,
+  -512, 461, -79, -458,
+  -1318, -263, -134, -523,
+  -1657, -435, -495, -765,
+  57, -347, -414, 434,
+  -1141, -242, -664, -857,
+  34, -68, -707, -338
+};
+
+#define MR515_3_SIZE  128
+
+
+/* third codebook for MR475, MR515 */
+
+static Word16 mr515_3_lsf[] = {
+    419,   163,   -30,  -262, 
+   -455,  -789, -1430,  -721, 
+   1006,   664,   269,    25, 
+    619,   260,   183,    96, 
+   -968, -1358,  -388,   135, 
+   -693,   835,   456,   154, 
+   1105,   703,   569,   363, 
+   1625,  1326,   985,   748, 
+   -220,   219,    76,  -208, 
+  -1455, -1662,    49,   149, 
+   -964,  -172,  -752,  -336, 
+    625,   209,  -250,   -66, 
+  -1017,  -838,    -2,   317, 
+  -2168, -1485,  -138,   123, 
+  -1876, -2099,  -521,    85, 
+   -967,  -366,  -695,  -881, 
+   -921, -1011,  -763,  -949, 
+   -124,  -256,  -352,  -660, 
+    178,   463,   354,   304, 
+  -1744,  -591,  -282,    79, 
+  -2249,   175,   867,   499, 
+   -138,  -180,  -181,   -21, 
+  -2291, -1241,  -460,  -520, 
+   -771,   451,   -10,  -308, 
+    271,   -65,     4,   214, 
+   -279,  -435,   -43,  -348, 
+   -670,    35,   -65,  -211, 
+    806,   535,    85,   297, 
+     57,   239,   722,   493, 
+    225,   661,   840,   547, 
+   -540,  -376,    14,   349, 
+    469,   721,   331,   162, 
+   -544,  -752,   -62,   -10, 
+    398,   -88,   724,   701, 
+    -19,  -533,   -94,   601, 
+    136,   -71,  -681,  -747, 
+   -166,  -344,   261,   -50, 
+    161,   -52,   485,   337, 
+  -1675,    50,   190,   -93, 
+  -2282,  -231,  -194,   -82, 
+    -95,  -595,  -154,   128, 
+    894,   501,   588,   457, 
+   -345,   206,   122,   110, 
+   -631,  -227,  -569,     3, 
+    408,   239,   397,   226, 
+   -197,    -2,   128,   491, 
+   1281,   904,   292,   215, 
+    538,   306,   259,   509, 
+   -677, -1047,    13,   321, 
+   -679,  -588,  -358,  -212, 
+   -558,   243,   646,   479, 
+    486,   342,   634,   532, 
+    107,   802,   331,   136, 
+   -112,  -398, -1031,  -286, 
+   -326,  -705,   288,   272, 
+   1299,  1144,  1178,   860, 
+   -423,   121,  -385,  -148, 
+   -295,  -302,  -834,  -819, 
+     16,   -24,  -201,  -476, 
+    555,    91,  -245,   294, 
+    -38,  -379,  -962, -1221, 
+  -1191, -1518,  -273,  -395, 
+   -390, -1013,  -645,   573, 
+  -1843, -1030,   505,   468, 
+    744,   947,   609,   493, 
+   -689, -1172,  -628,  -135, 
+  -1026,   195,   411,   196, 
+   1582,  1147,   575,   337, 
+  -1239,  -777,  -648,  -142, 
+    595,   825,   967,   735, 
+  -1206,  -970,   -81,  -342, 
+   -745,    13,   -72,   375, 
+    454,    19,  1407,   921, 
+  -1647,  -172,   861,   562, 
+    928,  1537,  1063,   740, 
+  -2472,  -952,   264,    82, 
+   -502,  -965, -1334,   123, 
+    867,  1236,   534,   171, 
+  -2320,  -460,   780,   363, 
+  -1190,  -617,   252,   -61, 
+   -174,    34,  1011,   788, 
+  -2333,   247,   423,   153, 
+    -16,  -355,   262,   449, 
+  -1576, -1073,  -544,  -371, 
+   -615,  -305,  1051,   805, 
+    687,   528,     6,  -182, 
+    935,   875,  1002,   809, 
+    199,   257,   126,    76, 
+   -584, -1138,   599,   556, 
+  -1105, -1391, -1591,  -519, 
+   -977, -1325,   108,   347, 
+   -722,  -975,   365,   101, 
+   -145,   681,   249,  -153, 
+      0,  -334,  -570,   159, 
+    412,   285,  -336,  -617, 
+   -953,  -966,   887,   689, 
+  -1251,    84,  -185,  -398, 
+   -592,   433,  1044,   653, 
+     85,   329,   -40,   361, 
+   -433,  -705,   466,   574, 
+   -154,   654,   592,   290, 
+   -167,    72,   349,   175, 
+    674,   297,   977,   720, 
+   1235,  1204,   757,   488, 
+   -400,  -269,   538,   372, 
+  -1350, -1387, -1194,   -91, 
+   1262,   876,   775,   700, 
+   -599,   -38,  -430,  -722, 
+   1976,  1630,   991,   608, 
+    111,   276,  -226,   -96, 
+   -947,  -388,   -11,    -7, 
+   -303,  -531,  -839,   338, 
+   1734,  1710,  1405,  1013, 
+   -516,  -855,  -645,   210, 
+   -688,  -416,   513,   230, 
+   -822,  -637, -1146,  -320, 
+   -952,  -658,  -694,   183, 
+   -114,  -623,   818,   674, 
+   -191,  -204,   731,   635, 
+     51,  1221,   883,   576, 
+   -954,  -431,   826,   598, 
+   -342,  -755,  -900,  -407, 
+  -1126,  -354,  -206,  -512, 
+   -547,  -810,  -357,  -620, 
+     66,   515,   -73,  -410, 
+   -872,  -945, -1444, -1227, 
+    191,   -17,  -544,  -231, 
+  -1540,  -544,  -901,  -886
+};
+
+#define MR795_1_SIZE  512
+
+/* first codebook for MR795 */
+
+static Word16 mr795_1_lsf[] = {
+   -890, -1550, -2541, 
+   -819,  -970,   175, 
+   -826, -1234,  -762, 
+   -599,   -22,   634, 
+   -811,  -987,  -902, 
+   -323,   203,    26, 
+   -383,  -235,  -781, 
+   -399,  1262,   906, 
+   -932, -1399, -1380, 
+   -624,    93,    87, 
+   -414,  -539,  -691, 
+     37,   633,   510, 
+   -387,  -476, -1330, 
+    399,    66,   263, 
+   -407,   -49,  -335, 
+   -417,  1041,  1865, 
+   -779, -1089, -1440, 
+   -746,  -858,   832, 
+   -581,  -759,  -371, 
+   -673,  -506,  2088, 
+   -560,  -634, -1179, 
+    271,   241,    14, 
+   -438,  -244,  -397, 
+    463,  1202,  1047, 
+   -606,  -797, -1438, 
+    -51,  -323,   481, 
+   -224,  -584,  -527, 
+    494,   881,   682, 
+   -433,  -306, -1002, 
+    554,   659,   222, 
+    171,  -160,  -353, 
+    681,  1798,  1565, 
+   -852, -1181, -1695, 
+   -336,  -666,   114, 
+   -581,  -756,  -744, 
+   -195,   375,   497, 
+   -465,  -804, -1098, 
+    154,   282,  -131, 
+    -50,  -191,  -719, 
+    323,   732,  1542, 
+   -722,  -819, -1404, 
+    105,  -250,   185, 
+   -178,  -502,  -742, 
+    321,   510,  1111, 
+   -323,  -567,  -966, 
+    127,   484,   338, 
+   -160,    52,  -338, 
+    732,  1367,  1554, 
+   -626,  -802, -1696, 
+   -286,  -586,   676, 
+   -695,  -343,  -370, 
+   -490,   295,  1893, 
+   -630,  -574, -1014, 
+    -80,   645,   -69, 
+     -6,  -318,  -364, 
+    782,  1450,  1038, 
+   -313,  -733, -1395, 
+    120,    60,   477, 
+   -264,  -585,  -123, 
+    711,  1245,   633, 
+    -91,  -355, -1016, 
+    771,   758,   261, 
+    253,    81,  -474, 
+    930,  2215,  1720, 
+   -808, -1099, -1925, 
+   -560,  -782,   169, 
+   -804, -1074,  -188, 
+   -626,   -55,  1405, 
+   -694,  -716, -1194, 
+   -660,   354,   329, 
+   -514,   -55,  -543, 
+    366,  1033,  1182, 
+   -658,  -959, -1357, 
+    -55,  -184,    93, 
+   -605,  -286,  -662, 
+    404,   449,   827, 
+   -286,  -350, -1263, 
+    628,   306,   227, 
+    -16,   147,  -623, 
+    186,   923,  2146, 
+   -674,  -890, -1606, 
+   -443,  -228,   339, 
+   -369,  -790,  -409, 
+    231,    86,  1469, 
+   -448,  -581, -1061, 
+    594,   450,  -177, 
+   -124,  -170,  -447, 
+    671,  1159,  1404, 
+   -476,  -667, -1511, 
+    -77,  -138,   716, 
+   -177,  -372,  -381, 
+    451,   934,   915, 
+   -250,  -432,  -822, 
+    272,   828,   446, 
+     26,    19,   -31, 
+    698,  1692,  2168, 
+   -646,  -977, -1924, 
+   -179,  -473,   268, 
+   -379,  -745,  -691, 
+     11,   127,  1033, 
+   -488,  -917,  -825, 
+     61,   323,   135, 
+    147,  -145,  -686, 
+    685,   786,  1682, 
+   -506,  -848, -1297, 
+     35,    90,   222, 
+    -23,  -346,  -670, 
+    455,   591,  1287, 
+   -203,  -593, -1086, 
+    652,   352,   437, 
+     39,    63,  -457, 
+    841,  1265,  2105, 
+   -520,  -882, -1584, 
+   -328,  -711,  1421, 
+   -596,  -342,   -70, 
+    209,   173,  1928, 
+   -423,  -598,  -921, 
+    421,   605,   -38, 
+     -2,  -245,  -127, 
+    896,  1969,  1135, 
+   -379,  -518, -1579, 
+    173,   118,   753, 
+    -55,  -381,   -52, 
+    985,  1021,   753, 
+     -2,  -291,  -891, 
+    753,   992,   423, 
+    264,   131,  -196, 
+    895,  2274,  2543, 
+   -635, -1088, -2499, 
+   -529,  -982,   526, 
+   -764,  -830,  -548, 
+   -436,   316,   599, 
+   -675,  -940,  -746, 
+    -57,   236,   -11, 
+   -201,   -81,  -798, 
+     16,   845,  1558, 
+   -737,  -985, -1212, 
+   -468,    17,   290, 
+   -279,  -584,  -700, 
+    183,   822,   705, 
+   -265,  -492, -1187, 
+    421,   152,   468, 
+   -390,   166,  -268, 
+     39,  1550,  1868, 
+   -635,  -966, -1571, 
+   -453,  -492,   910, 
+   -284, -1027,   -75, 
+   -181,  -133,  1852, 
+   -445,  -624, -1174, 
+    420,   367,   -49, 
+   -389,  -212,  -169, 
+    707,  1073,  1208, 
+   -539,  -710, -1449, 
+     83,  -163,   484, 
+   -236,  -543,  -355, 
+    338,  1175,   814, 
+   -246,  -309,  -958, 
+    606,   760,    60, 
+    166,    -8,  -163, 
+   -306,  1849,  2563, 
+   -747, -1025, -1783, 
+   -419,  -446,   209, 
+   -718,  -566,  -534, 
+   -506,   693,   857, 
+   -463,  -697, -1082, 
+    325,   431,  -206, 
+    -15,    -8,  -763, 
+    545,   919,  1518, 
+   -611,  -783, -1313, 
+    256,   -55,   208, 
+   -165,  -348,  -662, 
+    321,   680,   930, 
+   -326,  -429,  -951, 
+    484,   446,   570, 
+   -197,    72,   -73, 
+    909,  1455,  1741, 
+   -563,  -737, -1974, 
+   -124,  -416,   718, 
+   -478,  -404,  -314, 
+    -16,   446,  1636, 
+   -551,  -537,  -750, 
+    -58,   638,   214, 
+     55,  -185,  -271, 
+   1148,  1301,  1212, 
+   -483,  -671, -1264, 
+    117,   285,   543, 
+   -204,  -391,  -111, 
+    513,  1538,   854, 
+   -114,  -190,  -978, 
+    877,   595,   464, 
+    260,   260,  -311, 
+    748,  2283,  2216, 
+   -517,  -945, -2171, 
+   -326,  -708,   378, 
+   -812,  -691,  -232, 
+   -560,   687,  1409, 
+   -732,  -690,  -836, 
+   -359,   645,   386, 
+   -265,    62,  -678, 
+    145,  1644,  1208, 
+   -555,  -988, -1233, 
+    -78,    14,   114, 
+   -327,  -358,  -489, 
+    392,   677,   697, 
+   -201,  -236, -1140, 
+    693,   449,   178, 
+   -243,   256,  -433, 
+    611,  1385,  2456, 
+   -612,  -901, -1464, 
+   -307,   -17,   499, 
+   -315,  -667,  -254, 
+    256,   428,  1463, 
+   -486,  -422, -1056, 
+    655,   370,    18, 
+   -102,  -185,  -276, 
+    755,  1578,  1335, 
+   -488,  -603, -1418, 
+    182,   -93,   870, 
+    -73,  -458,  -348, 
+    835,   862,   957, 
+   -282,  -333,  -746, 
+    547,   839,   428, 
+    273,   -89,    13, 
+    940,  1708,  2576, 
+   -418, -1084, -1758, 
+    -44,  -358,   259, 
+   -497,  -643,  -560, 
+     99,   557,   961, 
+   -421,  -766,  -917, 
+    295,   326,   184, 
+    175,    15,  -626, 
+    532,   878,  1981, 
+   -443,  -768, -1275, 
+    221,   156,   268, 
+     39,  -363,  -505, 
+    695,   772,  1140, 
+   -162,  -459,  -912, 
+    709,   444,   658, 
+     25,   303,  -312, 
+   1268,  1410,  1715, 
+   -297,  -766, -1836, 
+   -263,  -108,  1070, 
+   -406,   -13,  -129, 
+     57,   438,  2734, 
+   -374,  -487,  -835, 
+    304,   696,   164, 
+    104,  -235,     5, 
+   1611,  1900,  1399, 
+   -229,  -582, -1325, 
+    405,   192,   817, 
+    -87,  -438,   111, 
+   1028,  1199,   993, 
+     68,  -175,  -934, 
+   1033,  1117,   451, 
+    478,   200,  -248, 
+   2127,  2696,  2042, 
+   -835, -1323, -2131, 
+   -799,  -692,   466, 
+   -812, -1032,  -469, 
+   -622,   288,   920, 
+   -701,  -841, -1070, 
+   -411,   512,     8, 
+   -390,   -91,  -744, 
+    -30,  1043,  1161, 
+   -822, -1148, -1156, 
+   -294,   -46,   110, 
+   -411,  -374,  -678, 
+    214,   531,   668, 
+   -406,  -420, -1194, 
+    487,   232,   303, 
+   -318,    91,  -472, 
+    123,  1232,  2445, 
+   -722,  -952, -1495, 
+   -738,  -675,  1332, 
+   -543,  -606,  -211, 
+    -95,   -98,  1508, 
+   -549,  -514, -1193, 
+    473,   211,    73, 
+   -288,  -112,  -389, 
+    537,  1332,  1258, 
+   -567,  -755, -1545, 
+     71,  -283,   632, 
+   -170,  -481,  -493, 
+    681,  1002,   817, 
+   -356,  -331,  -877, 
+    419,   706,   346, 
+    241,   -34,  -326, 
+    377,  1950,  1883, 
+   -727, -1075, -1625, 
+   -233,  -543,   116, 
+   -524,  -806,  -585, 
+    -73,   478,   729, 
+   -288,  -925, -1143, 
+    173,   447,   -52, 
+     68,  -229,  -606, 
+    449,   529,  1797, 
+   -591,  -875, -1363, 
+    183,  -144,   324, 
+   -103,  -452,  -666, 
+    623,   488,  1176, 
+   -238,  -511, -1004, 
+    326,   552,   458, 
+    136,   108,  -319, 
+    626,  1343,  1883, 
+   -490,  -646, -1730, 
+   -186,  -449,   984, 
+   -738,   -76,  -170, 
+   -550,   755,  2560, 
+   -496,  -510,  -947, 
+    210,   694,   -52, 
+     84,  -322,  -199, 
+   1090,  1625,  1224, 
+   -376,  -603, -1396, 
+    343,    74,   632, 
+   -175,  -502,   -32, 
+    972,  1332,   734, 
+     52,  -295, -1113, 
+   1065,   918,   160, 
+    393,   107,  -397, 
+   1214,  2649,  1741, 
+   -632, -1201, -1891, 
+   -719,  -277,   353, 
+   -651,  -880,  -122, 
+   -211,   209,  1338, 
+   -562,  -714, -1059, 
+   -208,   388,   159, 
+   -320,   -61,  -551, 
+    293,  1092,  1443, 
+   -648,  -865, -1253, 
+    -49,  -143,   305, 
+   -401,  -227,  -585, 
+    561,   532,   927, 
+   -117,  -443, -1188, 
+    507,   436,   292, 
+    -79,   233,  -458, 
+    671,  1025,  2396, 
+   -633,  -842, -1525, 
+   -308,  -286,   640, 
+   -373,  -621,  -407, 
+    418,   253,  1305, 
+   -315,  -581, -1137, 
+    572,   685,  -281, 
+     61,   -68,  -371, 
+    991,  1101,  1498, 
+   -493,  -683, -1362, 
+    -47,   164,   704, 
+   -256,  -314,  -268, 
+    631,   949,  1052, 
+   -118,  -348,  -833, 
+     68,  1180,   568, 
+    152,   117,    34, 
+   1113,  1902,  2239, 
+   -601,  -959, -1706, 
+   -143,  -489,   480, 
+   -332,  -655,  -574, 
+     54,   353,  1192, 
+   -462,  -652,  -796, 
+    150,   549,   112, 
+    195,  -111,  -515, 
+    679,  1108,  1647, 
+   -558,  -749, -1217, 
+     -9,   272,   341, 
+    -53,  -265,  -535, 
+    489,   843,  1298, 
+   -120,  -482, -1032, 
+    632,   543,   408, 
+    179,   306,  -526, 
+   1124,  1464,  2244, 
+   -417,  -786, -1562, 
+   -224,  -384,  1364, 
+   -377,  -459,   -25, 
+    385,   489,  2174, 
+   -332,  -651,  -829, 
+    544,   553,    61, 
+     22,  -113,   -89, 
+   1128,  1725,  1524, 
+   -216,  -373, -1653, 
+    161,   316,   908, 
+   -165,  -222,   -67, 
+   1362,  1175,   789, 
+     73,  -252,  -767, 
+    738,   932,   616, 
+    362,   246,  -126, 
+    787,  2654,  3027, 
+   -691, -1106, -2190, 
+   -565,  -588,   524, 
+   -590,  -979,  -490, 
+   -263,   397,   982, 
+   -577,  -837,  -945, 
+    -22,   435,   -49, 
+   -190,  -118,  -629, 
+    -88,  1240,  1513, 
+   -636, -1051, -1019, 
+   -291,   189,   259, 
+   -257,  -470,  -629, 
+    145,   945,   894, 
+   -326,  -364, -1094, 
+    543,   260,   630, 
+   -202,   189,  -209, 
+    357,  1379,  2091, 
+   -569, -1075, -1449, 
+   -714,  -239,   919, 
+   -420,  -705,   -84, 
+   -109,  -114,  2407, 
+   -413,  -529, -1177, 
+    482,   368,   131, 
+   -186,   -72,  -131, 
+    861,  1255,  1220, 
+   -611,  -658, -1341, 
+    227,  -121,   631, 
+   -176,  -489,  -218, 
+    745,  1175,   957, 
+   -321,  -148,  -936, 
+    671,   966,   216, 
+    340,    -3,  -143, 
+    469,  1848,  2437, 
+   -729,  -961, -1683, 
+   -213,  -254,   321, 
+   -511,  -438,  -521, 
+   -126,   725,   903, 
+   -340,  -685, -1032, 
+    316,   480,    20, 
+     23,   -89,  -551, 
+    353,  1051,  1789, 
+   -544,  -757, -1364, 
+    298,   -25,   436, 
+   -100,  -392,  -519, 
+    467,   754,  1078, 
+   -210,  -398, -1078, 
+    620,   658,   630, 
+     33,   147,  -178, 
+    921,  1687,  1921, 
+   -325,  -528, -1978, 
+      2,  -285,   910, 
+   -371,  -490,  -230, 
+      0,   597,  2010, 
+   -496,  -395,  -834, 
+     37,   945,   245, 
+    181,  -160,  -144, 
+   1481,  1373,  1357, 
+   -355,  -601, -1270, 
+    298,   322,   672, 
+   -193,  -336,    77, 
+   1089,  1533,   922, 
+    177,   -39, -1125, 
+    996,   781,   536, 
+    456,   366,  -432, 
+   1415,  2440,  2279, 
+   -466,  -758, -2325, 
+   -303,  -509,   387, 
+   -727,  -557,    66, 
+   -145,   643,  1248, 
+   -544,  -676,  -916, 
+   -225,   862,   588, 
+   -152,    40,  -533, 
+    423,  1423,  1558, 
+   -572,  -843, -1145, 
+   -128,    85,   461, 
+   -238,  -257,  -584, 
+    605,   748,   861, 
+     24,  -202, -1409, 
+    797,   487,   303, 
+   -181,   364,  -182, 
+    616,  1378,  2942, 
+   -494,  -852, -1441, 
+   -292,    61,   812, 
+    -84,  -723,  -182, 
+    555,   532,  1506, 
+   -365,  -493, -1057, 
+    822,   588,    11, 
+    -14,   -18,  -230, 
+   1001,  1401,  1451, 
+   -474,  -569, -1292, 
+    302,    62,  1062, 
+    -70,  -376,  -222, 
+    982,   974,  1149, 
+   -196,  -234,  -795, 
+    479,  1098,   499, 
+    362,    58,    70, 
+   1147,  2069,  2857, 
+   -487,  -878, -1824, 
+     73,  -288,   348, 
+   -358,  -500,  -508, 
+    199,   721,  1242, 
+    -78,  -697,  -795, 
+    361,   536,   196, 
+    374,   110,  -735, 
+    847,  1051,  1896, 
+   -366,  -713, -1182, 
+    315,   320,   429, 
+     72,  -215,  -450, 
+    759,   886,  1363, 
+    -30,  -428,  -834, 
+    861,   627,   796, 
+    118,   468,  -279, 
+   1355,  1883,  1893, 
+   -188,  -642, -1612, 
+     63,  -175,  1198, 
+   -418,  -211,    51, 
+    414,   587,  2601, 
+   -234,  -557,  -858, 
+    424,   889,   222, 
+    136,  -101,    83, 
+   1413,  2278,  1383, 
+    -84,  -445, -1389, 
+    414,   313,  1045, 
+     29,  -343,    65, 
+   1552,  1647,   980, 
+    183,   -91,  -829, 
+   1273,  1413,   360, 
+    553,   272,  -107, 
+   1587,  3149,  2603
+};
diff -Nur FFMpeg-20050127/libavcodec/amr/q_plsf_5.c FFMpeg-20050127-new/libavcodec/amr/q_plsf_5.c
--- FFMpeg-20050127/libavcodec/amr/q_plsf_5.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/q_plsf_5.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,315 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : q_plsf_5.c
+*      Purpose          : Quantization of 2 sets of LSF parameters using 1st 
+*                         order MA prediction and split by 5 matrix
+*                         quantization (split-MQ)
+*
+********************************************************************************
+*/
+ 
+ 
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "q_plsf.h"
+const char q_plsf_5_id[] = "@(#)$Id $" q_plsf_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "lsp_lsf.h"
+#include "reorder.h"
+#include "lsfwt.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+#include "q_plsf_5.tab"         /* Codebooks of LSF prediction residual */
+ 
+/*
+********************************************************************************
+*                         LOCAL PROGRAM CODE
+********************************************************************************
+*/
+/* Quantization of a 4 dimensional subvector */
+
+static Word16 Vq_subvec (/* o : quantization index,            Q0  */
+    Word16 *lsf_r1,      /* i : 1st LSF residual vector,       Q15 */
+    Word16 *lsf_r2,      /* i : 2nd LSF residual vector,       Q15 */
+    const Word16 *dico,  /* i : quantization codebook,         Q15 */
+    Word16 *wf1,         /* i : 1st LSF weighting factors      Q13 */
+    Word16 *wf2,         /* i : 2nd LSF weighting factors      Q13 */  
+    Word16 dico_size     /* i : size of quantization codebook, Q0  */
+)
+{
+    Word16 index = 0; /* initialization only needed to keep gcc silent */
+    Word16 i, temp;
+    const Word16 *p_dico;
+    Word32 dist_min, dist;
+
+    dist_min = MAX_32;                                  move32 (); 
+    p_dico = dico;                                      move16 (); 
+
+    for (i = 0; i < dico_size; i++)
+    {
+        temp = sub (lsf_r1[0], *p_dico++);
+        temp = mult (wf1[0], temp);
+        dist = L_mult (temp, temp);
+
+        temp = sub (lsf_r1[1], *p_dico++);
+        temp = mult (wf1[1], temp);
+        dist = L_mac (dist, temp, temp);
+
+        temp = sub (lsf_r2[0], *p_dico++);
+        temp = mult (wf2[0], temp);
+        dist = L_mac (dist, temp, temp);
+
+        temp = sub (lsf_r2[1], *p_dico++);
+        temp = mult (wf2[1], temp);
+        dist = L_mac (dist, temp, temp);
+
+        test (); 
+        if (L_sub (dist, dist_min) < (Word32) 0)
+        {
+            dist_min = dist;                            move32 (); 
+            index = i;                                  move16 (); 
+        }
+    }
+
+    /* Reading the selected vector */
+
+    p_dico = &dico[shl (index, 2)];                     move16 (); 
+    lsf_r1[0] = *p_dico++;                              move16 (); 
+    lsf_r1[1] = *p_dico++;                              move16 (); 
+    lsf_r2[0] = *p_dico++;                              move16 (); 
+    lsf_r2[1] = *p_dico++;                              move16 (); 
+
+    return index;
+
+}
+
+/* Quantization of a 4 dimensional subvector with a signed codebook */
+
+static Word16 Vq_subvec_s ( /* o : quantization index            Q0  */
+    Word16 *lsf_r1,         /* i : 1st LSF residual vector       Q15 */
+    Word16 *lsf_r2,         /* i : and LSF residual vector       Q15 */
+    const Word16 *dico,     /* i : quantization codebook         Q15 */
+    Word16 *wf1,            /* i : 1st LSF weighting factors     Q13 */
+    Word16 *wf2,            /* i : 2nd LSF weighting factors     Q13 */
+    Word16 dico_size)       /* i : size of quantization codebook Q0  */  
+{
+    Word16 index = 0;  /* initialization only needed to keep gcc silent */
+    Word16 sign = 0;   /* initialization only needed to keep gcc silent */
+    Word16 i, temp;
+    const Word16 *p_dico;
+    Word32 dist_min, dist;
+
+    dist_min = MAX_32;                                  move32 (); 
+    p_dico = dico;                                      move16 (); 
+
+    for (i = 0; i < dico_size; i++)
+    {
+        /* test positive */
+
+        temp = sub (lsf_r1[0], *p_dico++);
+        temp = mult (wf1[0], temp);
+        dist = L_mult (temp, temp);
+
+        temp = sub (lsf_r1[1], *p_dico++);
+        temp = mult (wf1[1], temp);
+        dist = L_mac (dist, temp, temp);
+
+        temp = sub (lsf_r2[0], *p_dico++);
+        temp = mult (wf2[0], temp);
+        dist = L_mac (dist, temp, temp);
+
+        temp = sub (lsf_r2[1], *p_dico++);
+        temp = mult (wf2[1], temp);
+        dist = L_mac (dist, temp, temp);
+
+        test (); 
+        if (L_sub (dist, dist_min) < (Word32) 0)
+        {
+            dist_min = dist;                            move32 (); 
+            index = i;                                  move16 (); 
+            sign = 0;                                   move16 (); 
+        }
+        /* test negative */
+
+        p_dico -= 4;                                    move16 (); 
+        temp = add (lsf_r1[0], *p_dico++);
+        temp = mult (wf1[0], temp);
+        dist = L_mult (temp, temp);
+
+        temp = add (lsf_r1[1], *p_dico++);
+        temp = mult (wf1[1], temp);
+        dist = L_mac (dist, temp, temp);
+
+        temp = add (lsf_r2[0], *p_dico++);
+        temp = mult (wf2[0], temp);
+        dist = L_mac (dist, temp, temp);
+
+        temp = add (lsf_r2[1], *p_dico++);
+        temp = mult (wf2[1], temp);
+        dist = L_mac (dist, temp, temp);
+
+        test (); 
+        if (L_sub (dist, dist_min) < (Word32) 0)
+        {
+            dist_min = dist;                            move32 (); 
+            index = i;                                  move16 (); 
+            sign = 1;                                   move16 (); 
+        }
+    }
+
+    /* Reading the selected vector */
+
+    p_dico = &dico[shl (index, 2)];                     move16 (); 
+    test (); 
+    if (sign == 0)
+    {
+        lsf_r1[0] = *p_dico++;                          move16 (); 
+        lsf_r1[1] = *p_dico++;                          move16 (); 
+        lsf_r2[0] = *p_dico++;                          move16 (); 
+        lsf_r2[1] = *p_dico++;                          move16 (); 
+    }
+    else
+    {
+        lsf_r1[0] = negate (*p_dico++);                 move16 (); 
+        lsf_r1[1] = negate (*p_dico++);                 move16 (); 
+        lsf_r2[0] = negate (*p_dico++);                 move16 (); 
+        lsf_r2[1] = negate (*p_dico++);                 move16 (); 
+    }
+
+    index = shl (index, 1);
+    index = add (index, sign);
+
+    return index;
+
+}
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+ 
+/*************************************************************************
+ *   FUNCTION:  Q_plsf_5()
+ *
+ *   PURPOSE:  Quantization of 2 sets of LSF parameters using 1st order MA
+ *             prediction and split by 5 matrix quantization (split-MQ)
+ *
+ *   DESCRIPTION:
+ *
+ *        p[i] = pred_factor*past_rq[i];   i=0,...,m-1
+ *        r1[i]= lsf1[i] - p[i];           i=0,...,m-1
+ *        r2[i]= lsf2[i] - p[i];           i=0,...,m-1
+ *   where:
+ *        lsf1[i]           1st mean-removed LSF vector.
+ *        lsf2[i]           2nd mean-removed LSF vector.
+ *        r1[i]             1st residual prediction vector.
+ *        r2[i]             2nd residual prediction vector.
+ *        past_r2q[i]       Past quantized residual (2nd vector).
+ *
+ *   The residual vectors r1[i] and r2[i] are jointly quantized using
+ *   split-MQ with 5 codebooks. Each 4th dimension submatrix contains 2
+ *   elements from each residual vector. The 5 submatrices are as follows:
+ *     {r1[0], r1[1], r2[0], r2[1]};  {r1[2], r1[3], r2[2], r2[3]};
+ *     {r1[4], r1[5], r2[4], r2[5]};  {r1[6], r1[7], r2[6], r2[7]};
+ *                    {r1[8], r1[9], r2[8], r2[9]};
+ *
+ *************************************************************************/
+void Q_plsf_5 (
+    Q_plsfState *st,
+    Word16 *lsp1,      /* i : 1st LSP vector,                     Q15 */
+    Word16 *lsp2,      /* i : 2nd LSP vector,                     Q15 */   
+    Word16 *lsp1_q,    /* o : quantized 1st LSP vector,           Q15 */
+    Word16 *lsp2_q,    /* o : quantized 2nd LSP vector,           Q15 */
+    Word16 *indice     /* o : quantization indices of 5 matrices, Q0  */
+)
+{
+    Word16 i;
+    Word16 lsf1[M], lsf2[M], wf1[M], wf2[M], lsf_p[M], lsf_r1[M], lsf_r2[M];
+    Word16 lsf1_q[M], lsf2_q[M];
+
+    /* convert LSFs to normalize frequency domain 0..16384  */
+
+    Lsp_lsf (lsp1, lsf1, M);
+    Lsp_lsf (lsp2, lsf2, M);
+
+    /* Compute LSF weighting factors (Q13) */
+    
+    Lsf_wt (lsf1, wf1);
+    Lsf_wt (lsf2, wf2);
+
+    /* Compute predicted LSF and prediction error */
+
+    for (i = 0; i < M; i++)
+    {
+        lsf_p[i] = add (mean_lsf[i], mult (st->past_rq[i], LSP_PRED_FAC_MR122));
+        move16 (); 
+        lsf_r1[i] = sub (lsf1[i], lsf_p[i]);           move16 (); 
+        lsf_r2[i] = sub (lsf2[i], lsf_p[i]);           move16 (); 
+    }
+
+    /*---- Split-MQ of prediction error ----*/
+
+    indice[0] = Vq_subvec (&lsf_r1[0], &lsf_r2[0], dico1_lsf,
+                           &wf1[0], &wf2[0], DICO1_SIZE);
+                                                        move16 (); 
+
+    indice[1] = Vq_subvec (&lsf_r1[2], &lsf_r2[2], dico2_lsf,
+                           &wf1[2], &wf2[2], DICO2_SIZE);
+                                                        move16 (); 
+
+    indice[2] = Vq_subvec_s (&lsf_r1[4], &lsf_r2[4], dico3_lsf,
+                             &wf1[4], &wf2[4], DICO3_SIZE);
+                                                        move16 (); 
+
+    indice[3] = Vq_subvec (&lsf_r1[6], &lsf_r2[6], dico4_lsf,
+                           &wf1[6], &wf2[6], DICO4_SIZE);
+                                                        move16 (); 
+
+    indice[4] = Vq_subvec (&lsf_r1[8], &lsf_r2[8], dico5_lsf,
+                           &wf1[8], &wf2[8], DICO5_SIZE);
+                                                        move16 (); 
+
+    /* Compute quantized LSFs and update the past quantized residual */
+    for (i = 0; i < M; i++)
+    {
+        lsf1_q[i] = add (lsf_r1[i], lsf_p[i]);          move16 (); 
+        lsf2_q[i] = add (lsf_r2[i], lsf_p[i]);          move16 (); 
+        st->past_rq[i] = lsf_r2[i];                     move16 (); 
+    }
+
+    /* verification that LSFs has minimum distance of LSF_GAP */
+
+    Reorder_lsf (lsf1_q, LSF_GAP, M);
+    Reorder_lsf (lsf2_q, LSF_GAP, M);
+
+    /*  convert LSFs to the cosine domain */
+    
+    Lsf_lsp (lsf1_q, lsp1_q, M);
+    Lsf_lsp (lsf2_q, lsp2_q, M);
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/q_plsf_5.tab FFMpeg-20050127-new/libavcodec/amr/q_plsf_5.tab
--- FFMpeg-20050127/libavcodec/amr/q_plsf_5.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/q_plsf_5.tab	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,1018 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : pow2.c
+*      Purpose          : Quantization tables for split_MQ of 2 sets of 
+*                       : LSFs in a 20 ms frame.
+*                       : See "q_plsf_5.c"   
+*      $Id $
+*
+********************************************************************************
+*/
+/* LSF means ->normalize frequency domain */
+
+static const Word16 mean_lsf[10] =
+{
+    1384,
+    2077,
+    3420,
+    5108,
+    6742,
+    8122,
+    9863,
+    11092,
+    12714,
+    13701
+};
+
+#define DICO1_SIZE  128
+#define DICO2_SIZE  256
+#define DICO3_SIZE  256
+#define DICO4_SIZE  256
+#define DICO5_SIZE  64
+
+static const Word16 dico1_lsf[DICO1_SIZE * 4] =
+{
+    -451, -1065, -529, -1305,
+    -450, -756, -497, -863,
+    -384, -619, -413, -669,
+    -317, -538, -331, -556,
+    -414, -508, -424, -378,
+    -274, -324, -434, -614,
+    -226, -500, -232, -514,
+    -263, -377, -298, -410,
+    -151, -710, -174, -818,
+    -149, -412, -156, -429,
+    -288, -462, -186, -203,
+    -170, -302, -191, -321,
+    -131, -147, -297, -395,
+    -228, -214, -245, -192,
+    -67, -316, -71, -327,
+    -104, -205, -94, -183,
+    -143, -38, -193, -95,
+    16, -76, -124, -248,
+    23, -237, 24, -244,
+    18, -136, 44, -111,
+    -33, -24, -25, 0,
+    149, 19, 23, -143,
+    158, -169, 174, -181,
+    133, -55, 165, -26,
+    111, 84, 98, 75,
+    87, 183, -115, -11,
+    -8, 130, 11, 170,
+    254, 77, 205, 17,
+    183, 112, 262, 194,
+    202, 287, 95, 189,
+    -42, -105, 234, 179,
+    39, 186, 163, 345,
+    332, 199, 299, 161,
+    -54, 285, -78, 281,
+    -133, 141, -182, 111,
+    249, 341, 271, 364,
+    93, 403, 75, 391,
+    92, 510, -138, 220,
+    -185, -29, -34, 361,
+    -115, 320, 3, 554,
+    99, 286, 218, 591,
+    -245, 406, -268, 453,
+    0, 580, 25, 606,
+    275, 532, 148, 450,
+    -73, 739, -285, 518,
+    -288, 94, -203, 674,
+    -140, -74, 205, 714,
+    -114, 299, 176, 923,
+    182, 557, 240, 705,
+    -16, 513, 485, 593,
+    293, 384, 451, 617,
+    -38, 50, 563, 529,
+    303, 209, 459, 363,
+    433, 452, 450, 454,
+    367, 606, 477, 741,
+    432, 353, 368, 267,
+    361, 716, 273, 583,
+    453, 166, 510, 172,
+    201, 629, 274, 191,
+    568, 639, 302, 298,
+    634, 387, 643, 350,
+    587, 560, 612, 565,
+    600, 788, 487, 672,
+    512, 1015, 321, 333,
+    357, 854, -125, 413,
+    474, 712, 17, -151,
+    564, 285, 270, -241,
+    971, 889, 489, 220,
+    510, 896, 549, 924,
+    327, 825, 290, 911,
+    540, 1108, 158, 805,
+    199, 957, 511, 730,
+    100, 874, 13, 791,
+    435, 632, 676, 972,
+    249, 900, 467, 1218,
+    781, 1074, 585, 785,
+    -23, 669, 267, 1043,
+    619, 1084, 615, 1145,
+    622, 905, 916, 1049,
+    80, 331, 584, 1075,
+    89, 639, 988, 961,
+    770, 720, 798, 699,
+    492, 447, 899, 627,
+    271, 1188, 725, 1333,
+    87, 603, 832, 1603,
+    616, 1127, 890, 1505,
+    1000, 1156, 866, 1009,
+    995, 827, 1149, 858,
+    817, 1450, 773, 1320,
+    500, 1389, 312, 1153,
+    -20, 1084, 64, 1283,
+    2, 1172, 399, 1869,
+    514, 1706, 502, 1636,
+    886, 1522, 416, 600,
+    1131, 1350, 1275, 1390,
+    889, 1795, 914, 1766,
+    227, 1183, 1250, 1826,
+    505, 1854, 919, 2353,
+    -199, 431, 152, 1735,
+    -213, -28, 392, 1334,
+    -153, -52, 978, 1151,
+    -323, -400, 813, 1703,
+    -136, 84, 1449, 2015,
+    -331, -143, -137, 1192,
+    -256, 534, -157, 1031,
+    -307, -439, 542, 731,
+    -329, -420, -97, 616,
+    -362, -168, -322, 366,
+    -247, -110, -211, 89,
+    -196, -309, 20, 59,
+    -364, -463, -286, 89,
+    -336, 175, -432, 141,
+    -379, -190, -434, -196,
+    -79, 150, -278, -227,
+    -280, 166, -555, -422,
+    -155, 541, -366, 54,
+    -29, -83, -301, -774,
+    186, 628, -397, -264,
+    242, 293, -197, -585,
+    124, 410, 53, -133,
+    10, 340, -570, -1065,
+    65, -446, 68, -493,
+    383, 937, -357, -711,
+    -359, -250, -677, -1068,
+    292, -26, 363, 6,
+    607, 1313, -127, -10,
+    1513, 1886, 713, 972,
+    1469, 2181, 1443, 2016
+};
+
+static const Word16 dico2_lsf[DICO2_SIZE * 4] =
+{
+    -1631, -1600, -1796, -2290,
+    -1027, -1770, -1100, -2025,
+    -1277, -1388, -1367, -1534,
+    -947, -1461, -972, -1524,
+    -999, -1222, -1020, -1172,
+    -815, -987, -992, -1371,
+    -1216, -1006, -1289, -1094,
+    -744, -1268, -755, -1293,
+    -862, -923, -905, -984,
+    -678, -1051, -685, -1050,
+    -1087, -985, -1062, -679,
+    -989, -641, -1127, -976,
+    -762, -654, -890, -806,
+    -833, -1091, -706, -629,
+    -621, -806, -640, -812,
+    -775, -634, -779, -543,
+    -996, -565, -1075, -580,
+    -546, -611, -572, -619,
+    -760, -290, -879, -526,
+    -823, -462, -795, -253,
+    -553, -415, -589, -439,
+    -533, -340, -692, -935,
+    -505, -772, -702, -1131,
+    -263, -306, -971, -483,
+    -445, -74, -555, -548,
+    -614, -129, -693, -234,
+    -396, -246, -475, -250,
+    -265, -404, -376, -514,
+    -417, -510, -300, -313,
+    -334, -664, -463, -814,
+    -386, -704, -337, -615,
+    -234, -201, -233, -239,
+    -167, -567, -203, -619,
+    -147, -415, -115, -352,
+    -166, -750, -171, -761,
+    -270, -879, -264, -903,
+    -367, -744, 43, -475,
+    14, -653, 43, -670,
+    11, -448, -59, -521,
+    -126, -119, -155, -613,
+    -42, -863, -27, -931,
+    136, -483, 183, -468,
+    55, -298, 55, -304,
+    313, -609, 313, -720,
+    322, -167, 100, -541,
+    -3, -119, -111, -187,
+    233, -236, 260, -234,
+    26, -165, 134, -45,
+    -40, -549, 360, -203,
+    378, -388, 450, -383,
+    275, 20, 182, -103,
+    246, -111, 431, 37,
+    462, -146, 487, -157,
+    -284, -59, 503, -184,
+    24, 53, -3, 54,
+    122, 259, 333, 66,
+    484, 104, 436, 68,
+    195, 116, 190, 206,
+    269, -9, 482, 352,
+    382, 285, 399, 277,
+    452, 256, 69, 186,
+    13, 297, -13, 259,
+    -95, 30, 56, 394,
+    196, 425, 205, 456,
+    281, 577, 15, 191,
+    375, 290, 407, 576,
+    -56, 227, 544, 405,
+    0, 549, -92, 528,
+    -229, 351, -245, 338,
+    -362, 435, 167, 527,
+    -75, 302, 91, 824,
+    129, 599, 496, 679,
+    186, 749, 153, 737,
+    -281, 600, -348, 615,
+    -236, 769, 41, 881,
+    38, 890, -220, 841,
+    -357, 883, -393, 903,
+    -634, 474, -444, 850,
+    -175, 678, -493, 242,
+    -519, 785, -714, 582,
+    -541, 366, -543, 434,
+    -597, 500, -765, 222,
+    -702, 917, -743, 962,
+    -869, 501, -899, 548,
+    -379, 200, -435, 157,
+    -819, 214, -861, 157,
+    -614, 40, -632, 94,
+    -883, -54, -741, 516,
+    -501, 298, -614, -171,
+    -870, -161, -865, -23,
+    -818, 93, -1015, -267,
+    -662, -359, -549, 2,
+    -442, -121, -377, 0,
+    -227, 33, -414, -126,
+    -129, 212, -934, 34,
+    -1082, -282, -1119, -268,
+    -710, -825, -420, -191,
+    -1076, -928, -917, -93,
+    -628, -358, 97, 7,
+    -206, -393, -101, 24,
+    -203, 38, -168, 83,
+    -599, -423, -279, 426,
+    -700, 118, -75, 206,
+    -981, -673, -680, 417,
+    -367, 37, -279, 474,
+    -129, -318, 319, 296,
+    -626, -39, 343, 602,
+    -696, -39, -303, 940,
+    104, 233, -380, 137,
+    -36, 269, -75, -214,
+    120, 43, -529, -477,
+    459, 164, -202, -229,
+    -49, -167, 609, 792,
+    98, -220, 915, 148,
+    293, 283, 869, 91,
+    575, 394, 326, -78,
+    717, 67, 365, -323,
+    616, -36, 731, 27,
+    619, 238, 632, 273,
+    448, 99, 801, 476,
+    869, 273, 685, 64,
+    789, 72, 1021, 217,
+    793, 459, 734, 360,
+    646, 480, 360, 322,
+    429, 464, 638, 430,
+    756, 363, 1000, 404,
+    683, 528, 602, 615,
+    655, 413, 946, 687,
+    937, 602, 904, 604,
+    555, 737, 786, 662,
+    467, 654, 362, 589,
+    929, 710, 498, 478,
+    415, 420, 693, 883,
+    813, 683, 781, 925,
+    913, 939, 726, 732,
+    491, 853, 531, 948,
+    734, 963, 315, 808,
+    761, 755, 1144, 760,
+    655, 1076, 826, 1057,
+    1091, 838, 1003, 808,
+    1047, 1133, 659, 1101,
+    992, 1050, 1074, 1075,
+    971, 694, 1226, 1054,
+    571, 841, 884, 1404,
+    1379, 1096, 1080, 861,
+    1231, 735, 1284, 760,
+    1272, 991, 1367, 1053,
+    1257, 700, 1050, 534,
+    988, 453, 1264, 599,
+    1140, 679, 1621, 815,
+    1384, 521, 1317, 393,
+    1564, 805, 1448, 686,
+    1068, 648, 875, 307,
+    1083, 361, 1047, 317,
+    1417, 964, 675, 571,
+    1152, 79, 1114, -47,
+    1530, 311, 1721, 314,
+    1166, 689, 514, -94,
+    349, 282, 1412, 328,
+    1025, 487, -65, 57,
+    805, 970, 36, 62,
+    769, -263, 791, -346,
+    637, 699, -137, 620,
+    534, 541, -735, 194,
+    711, 300, -268, -863,
+    926, 769, -708, -428,
+    506, 174, -892, -630,
+    435, 547, -1435, -258,
+    621, 471, -1018, -1368,
+    -393, 521, -920, -686,
+    -25, 20, -982, -1156,
+    340, 9, -1558, -1135,
+    -352, 48, -1579, -402,
+    -887, 6, -1156, -888,
+    -548, -352, -1643, -1168,
+    -159, 610, -2024, -963,
+    -225, 193, -1656, -1960,
+    -245, -493, -964, -1680,
+    -936, -635, -1299, -1744,
+    -1388, -604, -1540, -835,
+    -1397, -135, -1588, -290,
+    -1670, -712, -2011, -1632,
+    -1663, -27, -2258, -811,
+    -1157, 184, -1265, 189,
+    -1367, 586, -2011, 201,
+    -790, 712, -1210, 3,
+    -1033, 808, -1251, 830,
+    -111, 635, -1636, 447,
+    -463, -949, -445, -928,
+    -504, -1162, -501, -1211,
+    144, -351, -372, -1052,
+    -283, -1059, -279, -1123,
+    -575, -1438, -587, -1614,
+    -935, -984, 229, 690,
+    -921, -719, -403, 1362,
+    -685, -465, 874, 397,
+    -509, -46, 317, 1334,
+    -485, 456, 813, 439,
+    -411, 339, 898, 1067,
+    -425, 46, 1441, 497,
+    -909, -800, 1465, 1046,
+    -254, -321, 1430, 1165,
+    68, 350, 1034, 666,
+    370, 11, 1311, 790,
+    143, 232, 1041, 1562,
+    -114, 663, 1616, 1078,
+    454, 579, 1275, 1040,
+    -76, 909, 752, 1067,
+    153, 512, 348, 1214,
+    614, 385, 1843, 808,
+    269, 1034, 203, 1086,
+    652, 1017, 1783, 1130,
+    429, 1327, 387, 1384,
+    -49, 1183, -72, 1215,
+    -416, 1001, 544, 1749,
+    -352, 1223, -502, 1199,
+    -589, 569, -227, 1630,
+    -142, 1578, -230, 1715,
+    -714, 1288, -838, 1398,
+    1131, 1357, -208, 1232,
+    437, 965, -929, 818,
+    811, 1410, 859, 1507,
+    164, 1212, 1387, 1793,
+    484, 1874, 456, 2063,
+    996, 1170, 1326, 1402,
+    1316, 1360, 1135, 1262,
+    1234, 1618, 1361, 1768,
+    1421, 1227, 1584, 1347,
+    854, 672, 1685, 1566,
+    1139, 1270, 2016, 1825,
+    1773, 1581, 1532, 1460,
+    1487, 946, 1659, 1021,
+    1744, 1212, 1392, 977,
+    1772, 1161, 1826, 1164,
+    1718, 1429, 1973, 1591,
+    1185, 864, 2132, 1061,
+    1799, 814, 1838, 757,
+    2104, 1315, 2054, 1258,
+    2113, 915, 2331, 930,
+    1467, 1147, 2590, 1439,
+    2245, 1744, 2090, 1620,
+    2358, 1454, 2666, 1506,
+    1876, 1837, 2070, 1975,
+    1739, 1577, 682, 1289,
+    1584, 2045, 1454, 2098,
+    2498, 2004, 2711, 2066,
+    726, 1588, 2756, 2336,
+    228, 847, 2456, 1659,
+    36, 301, 1942, 1957,
+    -446, -96, 2154, 1396,
+    1533, 1101, 14, 608,
+    -923, -732, 1383, 1982,
+    1345, 952, -680, 321,
+    1281, 1268, -1594, 365,
+    941, 946, -1737, -822,
+    2374, 2787, 1821, 2788
+};
+
+static const Word16 dico3_lsf[DICO3_SIZE * 4] =
+{
+    -1812, -2275, -1879, -2537,
+    -1640, -1848, -1695, -2004,
+    -1220, -1912, -1221, -2106,
+    -1559, -1588, -1573, -1556,
+    -1195, -1615, -1224, -1727,
+    -1359, -1151, -1616, -1948,
+    -1274, -1391, -1305, -1403,
+    -1607, -1179, -1676, -1311,
+    -1443, -1478, -1367, -898,
+    -1256, -1059, -1331, -1134,
+    -982, -1133, -1149, -1504,
+    -1080, -1308, -1020, -1183,
+    -980, -1486, -967, -1495,
+    -988, -922, -1047, -1077,
+    -838, -1179, -858, -1222,
+    -1131, -1041, -1064, -767,
+    -872, -1157, -701, -880,
+    -706, -906, -774, -1016,
+    -578, -1080, -801, -1478,
+    -591, -1111, -592, -1146,
+    -713, -1388, -640, -1376,
+    -597, -1059, -416, -903,
+    -686, -832, -661, -708,
+    -444, -868, -490, -921,
+    -374, -776, -619, -1170,
+    -585, -549, -769, -795,
+    -435, -659, -530, -741,
+    -498, -837, -357, -597,
+    -279, -871, -243, -887,
+    -282, -665, -280, -667,
+    -165, -560, -394, -903,
+    -362, -410, -448, -583,
+    -409, -574, -313, -357,
+    -637, -548, -570, -436,
+    -896, -504, -382, -757,
+    -58, -481, -165, -618,
+    -191, -374, -234, -382,
+    -222, -683, -25, -480,
+    -418, -359, -730, -353,
+    -324, -157, -432, -322,
+    -394, -303, -284, -104,
+    -601, -289, -556, -196,
+    -588, -150, -659, -608,
+    -473, -24, -68, -448,
+    -474, -8, -506, -45,
+    -748, -184, -844, -252,
+    -901, -91, -584, -97,
+    -652, 138, -764, -131,
+    -678, -12, -670, 165,
+    -259, -3, -840, -107,
+    -909, 37, -992, 44,
+    -854, -415, -839, 13,
+    -1001, -271, -1026, -309,
+    -798, -478, -832, -488,
+    -943, 168, -1112, -387,
+    -1185, -101, -1183, -40,
+    -941, -316, -1030, -770,
+    -1044, -625, -1081, -538,
+    -1224, -299, -1312, -436,
+    -1197, -663, -1167, -161,
+    -1216, -690, -1237, -831,
+    -1432, -720, -1403, -493,
+    -898, -740, -922, -801,
+    -1102, -402, -1579, -964,
+    -1061, -638, -1269, -1438,
+    -1499, -934, -1502, -895,
+    -1598, -564, -1723, -717,
+    -606, -597, -1166, -1085,
+    -1369, -468, -1946, -1493,
+    -1838, -953, -1932, -931,
+    -1499, -188, -1635, -421,
+    -1457, -338, -1448, -22,
+    -1942, -422, -2006, -249,
+    -496, -114, -1910, -755,
+    -1289, 174, -1451, -109,
+    -482, -257, -1221, -508,
+    -1617, 151, -1694, 208,
+    -654, 107, -1651, 29,
+    -1141, 279, -1215, 306,
+    -1228, -506, -730, -175,
+    -1236, -101, -969, 551,
+    -870, 278, -823, 315,
+    -563, 376, -1051, 228,
+    -507, 280, -599, 281,
+    -758, 253, -305, 379,
+    -755, -134, -611, 660,
+    -824, 536, -817, 646,
+    -413, 49, -341, 177,
+    -453, 526, -482, 589,
+    -71, 339, -657, 264,
+    -244, 295, -237, 315,
+    -387, 569, -506, -9,
+    -377, 14, -160, 661,
+    -216, 40, -308, -46,
+    95, 214, -242, 167,
+    -86, 192, -56, 27,
+    -76, 31, 36, 309,
+    -106, -182, -113, 74,
+    -441, -22, 23, 139,
+    81, -11, 44, 15,
+    -87, -137, -118, -207,
+    -158, -58, 272, -92,
+    -156, -441, 8, -136,
+    128, -221, 101, -218,
+    40, -197, -76, -456,
+    9, -445, 33, -423,
+    226, 60, 73, -222,
+    156, -399, 280, -318,
+    245, -341, 166, -499,
+    339, -190, 327, -219,
+    325, -137, -89, -596,
+    100, -627, 144, -677,
+    487, 28, 252, -391,
+    214, -41, 282, -28,
+    99, -286, 331, 49,
+    459, -388, 565, -369,
+    436, 28, 336, -9,
+    397, -167, 618, 34,
+    596, -17, 561, -140,
+    299, 79, 522, 125,
+    203, 2, 244, 288,
+    255, 211, 175, 82,
+    596, 187, 517, 108,
+    381, 255, 365, 297,
+    497, 352, 327, -82,
+    25, 210, 371, 245,
+    261, 3, 545, 449,
+    140, 294, 44, 295,
+    212, 347, 244, 494,
+    331, 528, 201, 307,
+    349, 411, 613, 284,
+    614, 413, 464, 322,
+    624, 397, 97, 200,
+    -160, 384, 149, 362,
+    495, 525, 269, 585,
+    33, 491, -121, 433,
+    427, 611, 498, 516,
+    171, 443, 497, 666,
+    440, 275, 566, 575,
+    146, 639, 155, 670,
+    -33, 173, 212, 696,
+    -166, 601, -191, 695,
+    -489, 503, 175, 742,
+    214, 476, 372, 1083,
+    578, 530, 586, 777,
+    425, 874, 315, 841,
+    374, 848, -165, 565,
+    35, 991, -39, 1062,
+    329, 712, 786, 840,
+    645, 795, 661, 676,
+    571, 918, 632, 1079,
+    673, 817, 318, 388,
+    874, 1012, 564, 848,
+    880, 620, 557, 479,
+    671, 453, 692, 468,
+    840, 642, 844, 645,
+    506, 428, 897, 567,
+    837, 387, 962, 499,
+    691, 561, 939, 926,
+    783, 296, 790, 268,
+    1028, 530, 874, 329,
+    548, 143, 675, 291,
+    503, 66, 1041, 359,
+    786, 97, 805, 33,
+    837, 470, 511, 49,
+    1092, 327, 1174, 323,
+    3, 242, 872, 474,
+    689, 429, 1329, 678,
+    1042, 620, 1109, 664,
+    321, 193, 889, 950,
+    1153, 874, 893, 635,
+    877, 862, 948, 913,
+    1293, 665, 1320, 639,
+    997, 793, 1402, 1030,
+    1176, 1012, 1110, 959,
+    1410, 925, 1403, 915,
+    543, 862, 1116, 1222,
+    835, 1190, 835, 1190,
+    959, 1148, 1147, 1376,
+    1300, 1193, 1415, 1231,
+    1335, 1341, 746, 1092,
+    1711, 1283, 1389, 1073,
+    1334, 1566, 1153, 1475,
+    1645, 1137, 1825, 1220,
+    1056, 1382, 1521, 1730,
+    1632, 1545, 1620, 1542,
+    855, 1596, 865, 1667,
+    693, 885, 1716, 1519,
+    1167, 1296, 2209, 1760,
+    1952, 1493, 2020, 1482,
+    1534, 1866, 1694, 2008,
+    1566, 748, 1761, 825,
+    294, 1392, 1084, 2058,
+    621, 1315, 365, 1287,
+    198, 1028, 488, 1408,
+    249, 403, 1014, 1561,
+    324, 363, 1645, 1044,
+    193, 367, 2034, 1859,
+    -251, 579, 750, 994,
+    -243, 30, 1325, 879,
+    -28, -169, 624, 917,
+    -453, 159, 186, 1370,
+    -614, 6, 537, 392,
+    -94, -291, 781, 229,
+    -128, -298, 245, 491,
+    -701, -648, 972, 789,
+    -501, -640, 178, 255,
+    -365, -390, -255, 317,
+    -958, -294, -191, 228,
+    -775, -447, 157, -237,
+    -657, -720, -407, 92,
+    -117, -611, 334, -230,
+    -679, -1084, -144, -317,
+    -901, -861, -738, -360,
+    -85, -727, -90, -787,
+    100, -22, -391, -263,
+    -56, -73, -337, -754,
+    5, -189, -706, -624,
+    89, -344, -135, -1113,
+    -353, -237, -684, -1135,
+    -275, -1102, -269, -1203,
+    152, 145, -722, -1232,
+    49, 80, -1248, -776,
+    -248, 391, -732, -547,
+    469, 218, -255, -864,
+    69, 366, -166, -485,
+    -688, 191, -1212, -1196,
+    -170, -169, -1308, -1631,
+    321, 470, -1419, -1243,
+    -64, 272, -1361, -248,
+    492, 565, -721, -609,
+    195, 485, -573, -133,
+    427, 202, -171, -118,
+    199, 575, 2, -31,
+    694, 755, -1366, -39,
+    552, 557, -489, 271,
+    680, 537, 13, -453,
+    855, 954, -133, -52,
+    -81, 738, -1169, 637,
+    1055, 1059, -95, 676,
+    1259, 1081, 489, 305,
+    -449, 954, -534, 996,
+    -969, 866, -1058, 1059,
+    -1294, 618, -1416, 617,
+    -458, 1366, -159, 1821,
+    -774, -528, -14, 1110,
+    -1202, -901, -772, 433,
+    -1256, -1255, -1011, -302,
+    -602, -585, -759, -1618,
+    -760, -1549, -840, -1921,
+    -816, -539, -1769, -2235,
+    -227, -36, -2034, -1831,
+    -2107, -1126, -2471, -1816,
+    -1470, 252, -2701, -415,
+    -571, -467, 1509, 1554,
+    2180, 1975, 2326, 2020
+};
+
+static const Word16 dico4_lsf[DICO4_SIZE * 4] =
+{
+    -1857, -1681, -1857, -1755,
+    -2056, -1150, -2134, -1654,
+    -1619, -1099, -1704, -1131,
+    -1345, -1608, -1359, -1638,
+    -1338, -1293, -1325, -1265,
+    -1664, -1649, -1487, -851,
+    -1346, -1832, -1413, -2188,
+    -1282, -681, -1785, -1649,
+    -966, -1082, -1183, -1676,
+    -1054, -1073, -1142, -1158,
+    -1207, -744, -1274, -997,
+    -934, -1383, -927, -1416,
+    -1010, -1305, -783, -955,
+    -1049, -900, -993, -817,
+    -737, -823, -972, -1189,
+    -738, -1094, -738, -1154,
+    -784, -801, -810, -786,
+    -892, -520, -1000, -818,
+    -644, -965, -577, -882,
+    -541, -694, -671, -917,
+    -595, -642, -646, -615,
+    -956, -621, -925, -515,
+    -727, -483, -815, -485,
+    -840, -578, -440, -713,
+    -578, -325, -657, -670,
+    -386, -570, -441, -666,
+    -514, -787, -392, -529,
+    -522, -453, -487, -423,
+    -616, -585, -617, -157,
+    -662, -268, -680, -348,
+    -322, -323, -632, -444,
+    -304, -430, -332, -458,
+    -277, -468, -659, -793,
+    -319, -636, -227, -554,
+    -373, -347, -334, -210,
+    -456, -192, -530, -242,
+    -216, -198, -366, -370,
+    -338, -161, -409, -748,
+    -107, -380, -294, -643,
+    -223, -665, -234, -741,
+    -141, -496, -130, -510,
+    -139, -327, -172, -305,
+    -306, -580, -164, -263,
+    -262, -172, -67, -402,
+    31, -366, -10, -436,
+    -86, -527, 71, -377,
+    -22, -609, -12, -678,
+    -67, -319, 63, -191,
+    35, -181, -39, -242,
+    126, -167, -140, -544,
+    155, -297, 174, -297,
+    38, -8, 117, -380,
+    197, -452, 240, -522,
+    223, -103, 110, -187,
+    87, -155, 169, -47,
+    157, 26, -83, -100,
+    128, 80, 209, -62,
+    6, 7, 22, 5,
+    318, -20, 248, -45,
+    -200, -63, 156, -69,
+    250, -183, 369, -126,
+    -113, -76, -142, -122,
+    -64, -254, -31, 35,
+    -177, -71, -7, 171,
+    93, 27, 108, 212,
+    -330, -209, -123, -70,
+    -279, 95, -96, 20,
+    -188, -61, -314, 87,
+    -300, -78, -354, -134,
+    11, 122, -140, 122,
+    -275, 152, -293, 140,
+    -82, 138, -321, -111,
+    -480, -156, -359, 76,
+    -254, -40, -635, -96,
+    -522, 79, -507, 8,
+    -268, 303, -539, 68,
+    -446, 61, -522, 306,
+    111, 189, -435, 122,
+    -379, 166, -571, -398,
+    -632, -74, -747, -95,
+    -455, 194, -952, 83,
+    -798, 192, -755, 192,
+    -781, -162, -619, 234,
+    -663, -297, -488, -109,
+    -964, -132, -838, -68,
+    -843, 58, -1112, -86,
+    -805, -299, -944, -253,
+    -778, -50, -965, -549,
+    -352, -98, -992, -343,
+    -1117, -315, -1117, -307,
+    -1155, -374, -637, -230,
+    -1166, -43, -1299, -100,
+    -925, -393, -1274, -600,
+    -689, -130, -1479, -312,
+    -1321, -254, -1464, -442,
+    -1292, -613, -1261, -503,
+    -1501, -368, -1322, 26,
+    -1432, -66, -1743, -161,
+    -1644, -467, -1760, -548,
+    -1393, -568, -1556, -871,
+    -1495, -1034, -1387, -571,
+    -1917, -528, -1783, -123,
+    -1897, -231, -2054, -323,
+    -2052, -906, -1976, -567,
+    -1917, -620, -2047, -989,
+    -1077, -370, -2031, -704,
+    -2355, -749, -2740, -1089,
+    -1909, 159, -2012, 248,
+    -626, -123, -2339, -962,
+    -669, -408, -1379, -1174,
+    -452, -364, -1044, -735,
+    -132, 183, -1620, -752,
+    -547, -307, -777, -1261,
+    -98, 41, -880, -1091,
+    -257, 97, -1602, -1833,
+    31, -26, -644, -561,
+    -180, -546, -385, -1095,
+    -410, -802, -414, -827,
+    -457, -970, -490, -1109,
+    -215, -916, -144, -937,
+    -493, -1269, -517, -1507,
+    181, 101, -332, -889,
+    -836, -937, -559, -429,
+    -629, -547, -183, -337,
+    -545, -82, -250, -286,
+    5, -132, -348, -252,
+    -293, -472, -158, 100,
+    -29, 197, -236, -424,
+    -861, -213, -140, -7,
+    -427, -443, 187, -97,
+    -684, -736, -293, 258,
+    -368, -152, -150, 392,
+    -609, 175, -142, 299,
+    -138, 152, -119, 329,
+    -486, -52, 293, 198,
+    -183, 117, 175, 331,
+    -58, -274, 231, 300,
+    -288, 330, -305, 372,
+    -111, 409, -9, 423,
+    83, 256, 67, 367,
+    -19, 248, 91, 113,
+    -35, 406, -191, 154,
+    238, 296, 5, 197,
+    141, 221, 313, 198,
+    211, 421, 244, 334,
+    88, 426, -243, 454,
+    202, 552, -5, 403,
+    291, 185, 219, 301,
+    251, 138, 128, 69,
+    197, 288, -140, -61,
+    188, 361, 197, 598,
+    442, 273, 290, 143,
+    472, 482, 157, 370,
+    415, 321, 372, 385,
+    402, 552, 155, 24,
+    550, 263, -11, 21,
+    360, 227, 147, -254,
+    424, 97, 366, -13,
+    375, 141, 449, 232,
+    396, 507, 474, 272,
+    701, 324, 362, -47,
+    587, 148, 543, 69,
+    400, -51, 561, 59,
+    220, -10, 352, 147,
+    206, 211, 653, 185,
+    563, 297, 565, 284,
+    594, 121, 766, 192,
+    398, 118, 642, 434,
+    233, 264, 481, 467,
+    129, -165, 699, 239,
+    90, 26, 342, 474,
+    -55, 27, 388, 94,
+    -172, 0, 725, 379,
+    -60, 337, 370, 465,
+    95, 319, 806, 595,
+    78, 260, 497, 851,
+    210, 560, 458, 574,
+    -464, 202, 497, 625,
+    -202, 152, 48, 712,
+    -20, 566, 100, 715,
+    455, 468, 411, 605,
+    319, 646, 195, 615,
+    401, 538, 680, 739,
+    201, 667, 434, 954,
+    454, 425, 646, 491,
+    606, 681, 416, 508,
+    497, 822, 426, 815,
+    660, 647, 628, 716,
+    697, 466, 618, 457,
+    685, 460, 365, 309,
+    721, 567, 836, 601,
+    609, 300, 825, 459,
+    943, 687, 681, 533,
+    915, 598, 591, 243,
+    876, 451, 874, 420,
+    786, 317, 732, 220,
+    922, 317, 1108, 367,
+    531, 466, 1028, 649,
+    1053, 615, 1034, 553,
+    829, 602, 1021, 799,
+    927, 803, 878, 763,
+    799, 496, 1373, 773,
+    585, 770, 803, 930,
+    1099, 793, 1222, 862,
+    1209, 895, 1025, 727,
+    772, 845, 1172, 1115,
+    867, 1021, 830, 1013,
+    841, 910, 506, 703,
+    1239, 1077, 620, 819,
+    1196, 1083, 1155, 1081,
+    1142, 907, 1547, 1121,
+    1309, 648, 1343, 612,
+    1484, 988, 1479, 937,
+    985, 1328, 955, 1341,
+    429, 910, 841, 1338,
+    564, 1179, 412, 1156,
+    1427, 1320, 1434, 1330,
+    640, 760, 1726, 1410,
+    190, 555, 1073, 1005,
+    426, 257, 839, 980,
+    235, 231, 1520, 1167,
+    109, 293, 1014, 1569,
+    305, 142, 1148, 539,
+    -291, -108, 1213, 972,
+    22, -216, 667, 828,
+    -482, 438, 453, 1431,
+    -581, -422, 789, 387,
+    -358, -454, 174, 780,
+    -36, -372, 390, -134,
+    -629, 160, -306, 751,
+    -1258, -331, 177, 522,
+    -248, 574, -251, 639,
+    -531, 407, -596, 394,
+    -419, 789, -617, 801,
+    -986, 399, -857, 727,
+    -7, 518, -703, 310,
+    -1143, -24, -1002, 287,
+    -960, 363, -1299, 312,
+    -1534, 245, -1557, 305,
+    28, 153, -859, -175,
+    -33, 332, -1398, -154,
+    212, 410, -593, -197,
+    -1092, -704, -904, -65,
+    282, 367, -918, -686,
+    345, 93, -258, -357,
+    696, 644, -693, -28,
+    448, 493, -273, 193,
+    527, 546, -243, -513,
+    384, -136, 273, -353,
+    512, -142, 537, -198,
+    941, 750, 83, 248,
+    578, 861, -56, 592,
+    842, 44, 892, 24,
+    33, 890, -16, 982,
+    831, 1398, 1535, 1898,
+    1716, 1376, 1948, 1465
+};
+
+static const Word16 dico5_lsf[DICO5_SIZE * 4] =
+{
+    -1002, -929, -1096, -1203,
+    -641, -931, -604, -961,
+    -779, -673, -835, -788,
+    -416, -664, -458, -766,
+    -652, -521, -662, -495,
+    -1023, -509, -1023, -428,
+    -444, -552, -368, -449,
+    -479, -211, -1054, -903,
+    -316, -249, -569, -591,
+    -569, -275, -541, -191,
+    -716, -188, -842, -264,
+    -333, -248, -318, -228,
+    -275, 1, -567, -228,
+    -115, -221, -238, -374,
+    -197, -507, -222, -579,
+    -258, -432, -61, -244,
+    -345, 2, -338, 39,
+    -215, -169, -58, 0,
+    -56, -6, -203, -131,
+    1, -186, -5, -211,
+    6, -380, 11, -418,
+    -116, 131, -134, 113,
+    89, -4, 71, -2,
+    -19, -192, 262, 24,
+    189, 151, -133, -109,
+    186, -153, 166, -219,
+    37, 139, 193, 171,
+    337, 124, 158, -61,
+    141, 226, -13, 190,
+    231, 34, 354, 109,
+    316, 201, 244, 164,
+    330, -85, 390, -84,
+    254, 327, 257, 335,
+    491, 147, 476, 105,
+    54, 77, 437, 370,
+    421, 314, 449, 342,
+    329, 126, 673, 292,
+    571, 388, 243, 193,
+    653, 320, 621, 280,
+    194, 380, 517, 581,
+    45, 323, 111, 422,
+    489, 395, 734, 534,
+    622, 546, 486, 502,
+    318, 572, 189, 550,
+    385, 422, -157, 153,
+    -125, 382, -197, 386,
+    -263, 334, 228, 697,
+    -188, 1, 51, 297,
+    -507, 213, -376, 397,
+    -24, 255, -547, 89,
+    -502, -94, 387, 179,
+    -620, 68, -684, 112,
+    -642, -350, -260, 172,
+    -438, -324, 264, 648,
+    -964, -4, -1121, 7,
+    -134, 134, -1133, -306,
+    143, 96, -420, -497,
+    -1221, -350, -1527, -685,
+    -161, 72, 873, 691,
+    732, 283, 921, 353,
+    334, 475, 1095, 821,
+    864, 524, 843, 497,
+    714, 711, 788, 750,
+    1076, 714, 1204, 753
+};
diff -Nur FFMpeg-20050127/libavcodec/amr/qgain475.c FFMpeg-20050127-new/libavcodec/amr/qgain475.c
--- FFMpeg-20050127/libavcodec/amr/qgain475.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/qgain475.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,511 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : qg475.c
+*      Purpose          : Quantization of pitch and codebook gains for MR475.
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "qgain475.h"
+const char qgain475_id[] = "@(#)$Id $" qgain475_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "mac_32.h"
+#include "mode.h"
+#include "count.h"
+#include "cnst.h"
+#include "pow2.h"
+#include "log2.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+/* minimum allowed gain code prediction error: 102.887/4096 = 0.0251189 */
+#define MIN_QUA_ENER         ( -5443) /* Q10 <->    log2 (0.0251189) */
+#define MIN_QUA_ENER_MR122   (-32768) /* Q10 <-> 20*log10(0.0251189) */
+
+/* minimum allowed gain code prediction error: 32000/4096 = 7.8125 */
+#define MAX_QUA_ENER         (  3037) /* Q10 <->    log2 (7.8125)    */
+#define MAX_QUA_ENER_MR122   ( 18284) /* Q10 <-> 20*log10(7.8125)    */
+
+
+#include "qgain475.tab"
+
+/*
+********************************************************************************
+*                         PRIVATE PROGRAM CODE
+********************************************************************************
+*/
+static void MR475_quant_store_results(
+
+    gc_predState *pred_st, /* i/o: gain predictor state struct               */
+    const Word16 *p,       /* i  : pointer to selected quantizer table entry */
+    Word16 gcode0,         /* i  : predicted CB gain,     Q(14 - exp_gcode0) */
+    Word16 exp_gcode0,     /* i  : exponent of predicted CB gain,        Q0  */
+    Word16 *gain_pit,      /* o  : Pitch gain,                           Q14 */
+    Word16 *gain_cod       /* o  : Code gain,                            Q1  */
+)
+{
+
+    Word16 g_code, exp, frac, tmp;
+    Word32 L_tmp;
+
+    Word16 qua_ener_MR122; /* o  : quantized energy error, MR122 version Q10 */
+    Word16 qua_ener;       /* o  : quantized energy error,               Q10 */
+
+    /* Read the quantized gains */
+    *gain_pit = *p++;                move16 ();
+    g_code = *p++;                   move16 ();
+
+    /*------------------------------------------------------------------*
+     *  calculate final fixed codebook gain:                            *
+     *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                            *
+     *                                                                  *
+     *   gc = gc0 * g                                                   *
+     *------------------------------------------------------------------*/
+
+    L_tmp = L_mult(g_code, gcode0);
+    L_tmp = L_shr(L_tmp, sub(10, exp_gcode0));
+    *gain_cod = extract_h(L_tmp);
+
+    /*------------------------------------------------------------------*
+     *  calculate predictor update values and update gain predictor:    *
+     *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    *
+     *                                                                  *
+     *   qua_ener       = log2(g)                                       *
+     *   qua_ener_MR122 = 20*log10(g)                                   *
+     *------------------------------------------------------------------*/
+
+    Log2 (L_deposit_l (g_code), &exp, &frac); /* Log2(x Q12) = log2(x) + 12 */
+    exp = sub(exp, 12);
+
+    tmp = shr_r (frac, 5);
+    qua_ener_MR122 = add (tmp, shl (exp, 10));
+
+    L_tmp = Mpy_32_16(exp, frac, 24660); /* 24660 Q12 ~= 6.0206 = 20*log10(2) */
+    qua_ener = round (L_shl (L_tmp, 13)); /* Q12 * Q0 = Q13 -> Q10 */
+
+    gc_pred_update(pred_st, qua_ener_MR122, qua_ener);
+}
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ * FUNCTION:  MR475_update_unq_pred()
+ *
+ * PURPOSE:   use optimum codebook gain and update "unquantized"
+ *            gain predictor with the (bounded) prediction error
+ *
+ *************************************************************************/
+void
+MR475_update_unq_pred(
+    gc_predState *pred_st, /* i/o: gain predictor state struct            */
+    Word16 exp_gcode0,     /* i  : predicted CB gain (exponent MSW),  Q0  */
+    Word16 frac_gcode0,    /* i  : predicted CB gain (exponent LSW),  Q15 */
+    Word16 cod_gain_exp,   /* i  : optimum codebook gain (exponent),  Q0  */
+    Word16 cod_gain_frac   /* i  : optimum codebook gain (fraction),  Q15 */
+)
+{
+    Word16 tmp, exp, frac;
+    Word16 qua_ener, qua_ener_MR122;
+    Word32 L_tmp;
+
+    /* calculate prediction error factor (given optimum CB gain gcu):
+     *
+     *   predErrFact = gcu / gcode0
+     *   (limit to MIN_PRED_ERR_FACT <= predErrFact <= MAX_PRED_ERR_FACT
+     *    -> limit qua_ener*)
+     *
+     * calculate prediction error (log):
+     *
+     *   qua_ener_MR122 = log2(predErrFact)
+     *   qua_ener       = 20*log10(predErrFact)
+     *
+     */
+
+    if (test(), cod_gain_frac <= 0)
+    {
+        /* if gcu <= 0 -> predErrFact = 0 < MIN_PRED_ERR_FACT */
+        /* -> set qua_ener(_MR122) directly                   */
+        qua_ener = MIN_QUA_ENER;             move16 ();
+        qua_ener_MR122 = MIN_QUA_ENER_MR122; move16 ();
+    }
+    else
+    {
+        /* convert gcode0 from DPF to standard fraction/exponent format */
+        /* with normalized frac, i.e. 16384 <= frac <= 32767            */
+        /* Note: exponent correction (exp=exp-14) is done after div_s   */
+        frac_gcode0 = extract_l (Pow2 (14, frac_gcode0));
+
+        /* make sure cod_gain_frac < frac_gcode0  for div_s */
+        if (test (), sub(cod_gain_frac, frac_gcode0) >= 0)
+        {
+            cod_gain_frac = shr (cod_gain_frac, 1);
+            cod_gain_exp = add (cod_gain_exp, 1);
+        }
+
+        /*
+          predErrFact
+             = gcu / gcode0
+             = cod_gain_frac/frac_gcode0 * 2^(cod_gain_exp-(exp_gcode0-14))
+             = div_s (c_g_f, frac_gcode0)*2^-15 * 2^(c_g_e-exp_gcode0+14)
+             = div_s * 2^(cod_gain_exp-exp_gcode0 - 1)
+        */
+        frac = div_s (cod_gain_frac, frac_gcode0);
+        tmp = sub (sub (cod_gain_exp, exp_gcode0), 1);
+
+        Log2 (L_deposit_l (frac), &exp, &frac);
+        exp = add (exp, tmp);
+
+        /* calculate prediction error (log2, Q10) */
+        qua_ener_MR122 = shr_r (frac, 5);
+        qua_ener_MR122 = add (qua_ener_MR122, shl (exp, 10));
+
+        if (test (), sub(qua_ener_MR122, MIN_QUA_ENER_MR122) < 0)
+        {
+            qua_ener = MIN_QUA_ENER;             move16 ();
+            qua_ener_MR122 = MIN_QUA_ENER_MR122; move16 ();
+        }
+        else if (test (), sub(qua_ener_MR122, MAX_QUA_ENER_MR122) > 0)
+        {
+            qua_ener = MAX_QUA_ENER;             move16 ();
+            qua_ener_MR122 = MAX_QUA_ENER_MR122; move16 ();
+        }
+        else
+        {
+            /* calculate prediction error (20*log10, Q10) */
+            L_tmp = Mpy_32_16(exp, frac, 24660);
+            /* 24660 Q12 ~= 6.0206 = 20*log10(2) */
+            qua_ener = round (L_shl (L_tmp, 13));
+            /* Q12 * Q0 = Q13 -> Q26 -> Q10     */
+        }
+    }
+
+    /* update MA predictor memory */
+    gc_pred_update(pred_st, qua_ener_MR122, qua_ener);
+}
+
+
+/*************************************************************************
+ *
+ * FUNCTION:  MR475_gain_quant()
+ *
+ * PURPOSE: Quantization of pitch and codebook gains for two subframes
+ *          (using predicted codebook gain)
+ *
+ *************************************************************************/
+Word16
+MR475_gain_quant(              /* o  : index of quantization.                 */
+    gc_predState *pred_st,     /* i/o: gain predictor state struct            */
+
+                               /* data from subframe 0 (or 2) */
+    Word16 sf0_exp_gcode0,     /* i  : predicted CB gain (exponent),      Q0  */
+    Word16 sf0_frac_gcode0,    /* i  : predicted CB gain (fraction),      Q15 */
+    Word16 sf0_exp_coeff[],    /* i  : energy coeff. (5), exponent part,  Q0  */
+    Word16 sf0_frac_coeff[],   /* i  : energy coeff. (5), fraction part,  Q15 */
+                               /*      (frac_coeff and exp_coeff computed in  */
+                               /*       calc_filt_energies())                 */
+    Word16 sf0_exp_target_en,  /* i  : exponent of target energy,         Q0  */
+    Word16 sf0_frac_target_en, /* i  : fraction of target energy,         Q15 */
+
+                               /* data from subframe 1 (or 3) */
+    Word16 sf1_code_nosharp[], /* i  : innovative codebook vector (L_SUBFR)   */
+                               /*      (whithout pitch sharpening)            */
+    Word16 sf1_exp_gcode0,     /* i  : predicted CB gain (exponent),      Q0  */
+    Word16 sf1_frac_gcode0,    /* i  : predicted CB gain (fraction),      Q15 */
+    Word16 sf1_exp_coeff[],    /* i  : energy coeff. (5), exponent part,  Q0  */
+    Word16 sf1_frac_coeff[],   /* i  : energy coeff. (5), fraction part,  Q15 */
+                               /*      (frac_coeff and exp_coeff computed in  */
+                               /*       calc_filt_energies())                 */
+    Word16 sf1_exp_target_en,  /* i  : exponent of target energy,         Q0  */
+    Word16 sf1_frac_target_en, /* i  : fraction of target energy,         Q15 */
+
+    Word16 gp_limit,           /* i  : pitch gain limit                       */
+
+    Word16 *sf0_gain_pit,      /* o  : Pitch gain,                        Q14 */
+    Word16 *sf0_gain_cod,      /* o  : Code gain,                         Q1  */
+
+    Word16 *sf1_gain_pit,      /* o  : Pitch gain,                        Q14 */
+    Word16 *sf1_gain_cod       /* o  : Code gain,                         Q1  */
+)
+{
+    const Word16 *p;
+    Word16 i, index = 0;
+    Word16 tmp;
+    Word16 exp;
+    Word16 sf0_gcode0, sf1_gcode0;
+    Word16 g_pitch, g2_pitch, g_code, g2_code, g_pit_cod;
+    Word16 coeff[10], coeff_lo[10], exp_max[10];  /* 0..4: sf0; 5..9: sf1 */
+    Word32 L_tmp, dist_min;
+
+    /*-------------------------------------------------------------------*
+     *  predicted codebook gain                                          *
+     *  ~~~~~~~~~~~~~~~~~~~~~~~                                          *
+     *  gc0     = 2^exp_gcode0 + 2^frac_gcode0                           *
+     *                                                                   *
+     *  gcode0 (Q14) = 2^14*2^frac_gcode0 = gc0 * 2^(14-exp_gcode0)      *
+     *-------------------------------------------------------------------*/
+
+    sf0_gcode0 = extract_l(Pow2(14, sf0_frac_gcode0));
+    sf1_gcode0 = extract_l(Pow2(14, sf1_frac_gcode0));
+
+    /*
+     * For each subframe, the error energy (sum) to be minimized consists
+     * of five terms, t[0..4].
+     *
+     *                      t[0] =    gp^2  * <y1 y1>
+     *                      t[1] = -2*gp    * <xn y1>
+     *                      t[2] =    gc^2  * <y2 y2>
+     *                      t[3] = -2*gc    * <xn y2>
+     *                      t[4] =  2*gp*gc * <y1 y2>
+     *
+     */
+
+    /* sf 0 */
+    /* determine the scaling exponent for g_code: ec = ec0 - 11 */
+    exp = sub(sf0_exp_gcode0, 11);
+
+    /* calculate exp_max[i] = s[i]-1 */
+    exp_max[0] = sub(sf0_exp_coeff[0], 13);                        move16 ();
+    exp_max[1] = sub(sf0_exp_coeff[1], 14);                        move16 ();
+    exp_max[2] = add(sf0_exp_coeff[2], add(15, shl(exp, 1)));      move16 ();
+    exp_max[3] = add(sf0_exp_coeff[3], exp);                       move16 ();
+    exp_max[4] = add(sf0_exp_coeff[4], add(1, exp));               move16 ();
+
+    /* sf 1 */
+    /* determine the scaling exponent for g_code: ec = ec0 - 11 */
+    exp = sub(sf1_exp_gcode0, 11);
+
+    /* calculate exp_max[i] = s[i]-1 */
+    exp_max[5] = sub(sf1_exp_coeff[0], 13);                        move16 ();
+    exp_max[6] = sub(sf1_exp_coeff[1], 14);                        move16 ();
+    exp_max[7] = add(sf1_exp_coeff[2], add(15, shl(exp, 1)));      move16 ();
+    exp_max[8] = add(sf1_exp_coeff[3], exp);                       move16 ();
+    exp_max[9] = add(sf1_exp_coeff[4], add(1, exp));               move16 ();
+
+
+
+    /*-------------------------------------------------------------------*
+     *  Gain search equalisation:                                        *
+     *  ~~~~~~~~~~~~~~~~~~~~~~~~~                                        *
+     *  The MSE for the two subframes is weighted differently if there   *
+     *  is a big difference in the corresponding target energies         *
+     *-------------------------------------------------------------------*/
+
+    /* make the target energy exponents the same by de-normalizing the
+       fraction of the smaller one. This is necessary to be able to compare
+       them
+     */
+    exp = sf0_exp_target_en - sf1_exp_target_en;
+    test ();
+    if (exp > 0)
+    {
+        sf1_frac_target_en = shr (sf1_frac_target_en, exp);
+    }
+    else
+    {
+        sf0_frac_target_en = shl (sf0_frac_target_en, exp);
+    }
+
+    /* assume no change of exponents */
+    exp = 0; move16 ();
+
+    /* test for target energy difference; set exp to +1 or -1 to scale
+     * up/down coefficients for sf 1
+     */
+    tmp = shr_r (sf1_frac_target_en, 1);   /* tmp = ceil(0.5*en(sf1)) */
+    test ();
+    if (sub (tmp, sf0_frac_target_en) > 0) /* tmp > en(sf0)? */
+    {
+        /*
+         * target_energy(sf1) > 2*target_energy(sf0)
+         *   -> scale up MSE(sf0) by 2 by adding 1 to exponents 0..4
+         */
+        exp = 1; move16 ();
+    }
+    else
+    {
+        tmp = shr (add (sf0_frac_target_en, 3), 2); /* tmp=ceil(0.25*en(sf0)) */
+        test();
+        if (sub (tmp, sf1_frac_target_en) > 0)      /* tmp > en(sf1)? */
+        {
+            /*
+             * target_energy(sf1) < 0.25*target_energy(sf0)
+             *   -> scale down MSE(sf0) by 0.5 by subtracting 1 from
+             *      coefficients 0..4
+             */
+            exp = -1; move16 ();
+        }
+    }
+    
+    for (i = 0; i < 5; i++)
+    {
+        exp_max[i] = add (exp_max[i], exp); move16 ();
+    }
+                                                                       
+    /*-------------------------------------------------------------------*
+     *  Find maximum exponent:                                           *
+     *  ~~~~~~~~~~~~~~~~~~~~~~                                           *
+     *                                                                   *
+     *  For the sum operation, all terms must have the same scaling;     *
+     *  that scaling should be low enough to prevent overflow. There-    *
+     *  fore, the maximum scale is determined and all coefficients are   *
+     *  re-scaled:                                                       *
+     *                                                                   *
+     *    exp = max(exp_max[i]) + 1;                                     *
+     *    e = exp_max[i]-exp;         e <= 0!                            *
+     *    c[i] = c[i]*2^e                                                *
+     *-------------------------------------------------------------------*/
+
+    exp = exp_max[0];                                        move16 ();
+    for (i = 1; i < 10; i++)
+    {
+        move16(); test();
+        if (sub(exp_max[i], exp) > 0)
+        {
+            exp = exp_max[i];                                move16 ();
+        }
+    }
+    exp = add(exp, 1);      /* To avoid overflow */
+
+    p = &sf0_frac_coeff[0]; move16 ();
+    for (i = 0; i < 5; i++) {
+        tmp = sub(exp, exp_max[i]);
+        L_tmp = L_deposit_h(*p++);
+        L_tmp = L_shr(L_tmp, tmp);
+        L_Extract(L_tmp, &coeff[i], &coeff_lo[i]);
+    }
+    p = &sf1_frac_coeff[0]; move16 ();
+    for (; i < 10; i++) {
+        tmp = sub(exp, exp_max[i]);
+        L_tmp = L_deposit_h(*p++);
+        L_tmp = L_shr(L_tmp, tmp);
+        L_Extract(L_tmp, &coeff[i], &coeff_lo[i]);
+    }
+
+
+    /*-------------------------------------------------------------------*
+     *  Codebook search:                                                 *
+     *  ~~~~~~~~~~~~~~~~                                                 *
+     *                                                                   *
+     *  For each pair (g_pitch, g_fac) in the table calculate the        *
+     *  terms t[0..4] and sum them up; the result is the mean squared    *
+     *  error for the quantized gains from the table. The index for the  *
+     *  minimum MSE is stored and finally used to retrieve the quantized *
+     *  gains                                                            *
+     *-------------------------------------------------------------------*/
+
+    /* start with "infinite" MSE */
+    dist_min = MAX_32;        move32();
+
+    p = &table_gain_MR475[0]; move16 ();
+
+    for (i = 0; i < MR475_VQ_SIZE; i++)
+    {
+        /* subframe 0 (and 2) calculations */
+        g_pitch = *p++;       move16 ();
+        g_code = *p++;        move16 ();
+
+        g_code = mult(g_code, sf0_gcode0);
+        g2_pitch = mult(g_pitch, g_pitch);
+        g2_code = mult(g_code, g_code);
+        g_pit_cod = mult(g_code, g_pitch);
+        
+        L_tmp = Mpy_32_16(       coeff[0], coeff_lo[0], g2_pitch);
+        L_tmp = Mac_32_16(L_tmp, coeff[1], coeff_lo[1], g_pitch);
+        L_tmp = Mac_32_16(L_tmp, coeff[2], coeff_lo[2], g2_code);
+        L_tmp = Mac_32_16(L_tmp, coeff[3], coeff_lo[3], g_code);
+        L_tmp = Mac_32_16(L_tmp, coeff[4], coeff_lo[4], g_pit_cod);
+
+        tmp = sub (g_pitch, gp_limit);
+
+        /* subframe 1 (and 3) calculations */
+        g_pitch = *p++;      move16 ();
+        g_code = *p++;       move16 ();
+
+        test (); test (); test ();
+        if (tmp <= 0 && sub(g_pitch, gp_limit) <= 0)
+        {
+            g_code = mult(g_code, sf1_gcode0);
+            g2_pitch = mult(g_pitch, g_pitch);
+            g2_code = mult(g_code, g_code);
+            g_pit_cod = mult(g_code, g_pitch);
+            
+            L_tmp = Mac_32_16(L_tmp, coeff[5], coeff_lo[5], g2_pitch);
+            L_tmp = Mac_32_16(L_tmp, coeff[6], coeff_lo[6], g_pitch);
+            L_tmp = Mac_32_16(L_tmp, coeff[7], coeff_lo[7], g2_code);
+            L_tmp = Mac_32_16(L_tmp, coeff[8], coeff_lo[8], g_code);
+            L_tmp = Mac_32_16(L_tmp, coeff[9], coeff_lo[9], g_pit_cod);
+            
+            /* store table index if MSE for this index is lower
+               than the minimum MSE seen so far */
+            test ();
+            if (L_sub(L_tmp, dist_min) < (Word32) 0)
+            {
+                dist_min = L_tmp; move32 ();
+                index = i;        move16 ();
+            }
+        }
+    }
+
+    /*------------------------------------------------------------------*
+     *  read quantized gains and update MA predictor memories           *
+     *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~           *
+     *------------------------------------------------------------------*/
+
+    /* for subframe 0, the pre-calculated gcode0/exp_gcode0 are the same
+       as those calculated from the "real" predictor using quantized gains */
+    tmp = shl(index, 2);
+    MR475_quant_store_results(pred_st,
+                              &table_gain_MR475[tmp],
+                              sf0_gcode0,
+                              sf0_exp_gcode0,
+                              sf0_gain_pit,
+                              sf0_gain_cod);
+
+    /* calculate new predicted gain for subframe 1 (this time using
+       the real, quantized gains)                                   */
+    gc_pred(pred_st, MR475, sf1_code_nosharp,
+            &sf1_exp_gcode0, &sf1_frac_gcode0,
+            &sf0_exp_gcode0, &sf0_gcode0); /* last two args are dummy */
+    sf1_gcode0 = extract_l(Pow2(14, sf1_frac_gcode0));
+
+
+    tmp = add (tmp, 2);
+    MR475_quant_store_results(pred_st,
+                              &table_gain_MR475[tmp],
+                              sf1_gcode0,
+                              sf1_exp_gcode0,
+                              sf1_gain_pit,
+                              sf1_gain_cod);
+
+    return index;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/qgain475.h FFMpeg-20050127-new/libavcodec/amr/qgain475.h
--- FFMpeg-20050127/libavcodec/amr/qgain475.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/qgain475.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,93 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : qgain475.h
+*      Purpose          : Quantization of pitch and codebook gains for MR475.
+*
+********************************************************************************
+*/
+#ifndef qgain475_h
+#define qgain475_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "gc_pred.h"
+#include "mode.h"
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ * FUNCTION:  MR475_update_unq_pred()
+ *
+ * PURPOSE:   use optimum codebook gain and update "unquantized"
+ *            gain predictor with the (bounded) prediction error
+ *
+ *************************************************************************/
+void 
+MR475_update_unq_pred(
+    gc_predState *pred_st, /* i/o: gain predictor state struct            */
+    Word16 exp_gcode0,     /* i  : predicted CB gain (exponent),      Q0  */
+    Word16 frac_gcode0,    /* i  : predicted CB gain (fraction),      Q15 */
+    Word16 cod_gain_exp,   /* i  : optimum codebook gain (exponent),  Q0  */
+    Word16 cod_gain_frac   /* i  : optimum codebook gain (fraction),  Q15 */
+);
+
+/*************************************************************************
+ *
+ * FUNCTION:  MR475_gain_quant()
+ *
+ * PURPOSE: Quantization of pitch and codebook gains for two subframes
+ *          (using predicted codebook gain)
+ *
+ *************************************************************************/
+
+Word16
+MR475_gain_quant(              /* o  : index of quantization.                 */
+    gc_predState *pred_st,     /* i/o: gain predictor state struct            */
+      
+                               /* data from subframe 0 (or 2) */
+    Word16 sf0_exp_gcode0,     /* i  : predicted CB gain (exponent),      Q0  */
+    Word16 sf0_frac_gcode0,    /* i  : predicted CB gain (fraction),      Q15 */
+    Word16 sf0_exp_coeff[],    /* i  : energy coeff. (5), exponent part,  Q0  */
+    Word16 sf0_frac_coeff[],   /* i  : energy coeff. (5), fraction part,  Q15 */
+                               /*      (frac_coeff and exp_coeff computed in  */
+                               /*       calc_filt_energies())                 */
+    Word16 sf0_exp_target_en,  /* i  : exponent of target energy,         Q0  */
+    Word16 sf0_frac_target_en, /* i  : fraction of target energy,         Q15 */
+      
+                               /* data from subframe 1 (or 3) */
+    Word16 sf1_code_nosharp[], /* i  : innovative codebook vector (L_SUBFR)   */
+                               /*      (whithout pitch sharpening)            */
+    Word16 sf1_exp_gcode0,     /* i  : predicted CB gain (exponent),      Q0  */
+    Word16 sf1_frac_gcode0,    /* i  : predicted CB gain (fraction),      Q15 */
+    Word16 sf1_exp_coeff[],    /* i  : energy coeff. (5), exponent part,  Q0  */
+    Word16 sf1_frac_coeff[],   /* i  : energy coeff. (5), fraction part,  Q15 */
+                               /*      (frac_coeff and exp_coeff computed in  */
+                               /*       calc_filt_energies())                 */
+    Word16 sf1_exp_target_en,  /* i  : exponent of target energy,         Q0  */
+    Word16 sf1_frac_target_en, /* i  : fraction of target energy,         Q15 */
+
+    Word16 gp_limit,           /* i  : pitch gain limit                       */
+
+    Word16 *sf0_gain_pit,      /* o  : Pitch gain,                        Q14 */
+    Word16 *sf0_gain_cod,      /* o  : Code gain,                         Q1  */
+      
+    Word16 *sf1_gain_pit,      /* o  : Pitch gain,                        Q14 */
+    Word16 *sf1_gain_cod       /* o  : Code gain,                         Q1  */
+);
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/qgain475.tab FFMpeg-20050127-new/libavcodec/amr/qgain475.tab
--- FFMpeg-20050127/libavcodec/amr/qgain475.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/qgain475.tab	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,285 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : qgain475.tab
+*      Purpose          : Tables for function qgain475()
+*      $Id $
+*
+********************************************************************************
+*/
+
+#define MR475_VQ_SIZE 256
+
+/* The table contains the following data:
+ *
+ *    g_pitch(0)        (Q14) // for sub-
+ *    g_fac(0)          (Q12) // frame 0 and 2
+ *    g_pitch(1)        (Q14) // for sub-
+ *    g_fac(2)          (Q12) // frame 1 and 3
+ *
+ */
+static const Word16 table_gain_MR475[MR475_VQ_SIZE*4] = {
+/*g_pit(0), g_fac(0),      g_pit(1), g_fac(1) */
+   812,          128,           542,      140,
+  2873,         1135,          2266,     3402,
+  2067,          563,         12677,      647,
+  4132,         1798,          5601,     5285,
+  7689,          374,          3735,      441,
+ 10912,         2638,         11807,     2494,
+ 20490,          797,          5218,      675,
+  6724,         8354,          5282,     1696,
+  1488,          428,          5882,      452,
+  5332,         4072,          3583,     1268,
+  2469,          901,         15894,     1005,
+ 14982,         3271,         10331,     4858,
+  3635,         2021,          2596,      835,
+ 12360,         4892,         12206,     1704,
+ 13432,         1604,          9118,     2341,
+  3968,         1538,          5479,     9936,
+  3795,          417,          1359,      414,
+  3640,         1569,          7995,     3541,
+ 11405,          645,          8552,      635,
+  4056,         1377,         16608,     6124,
+ 11420,          700,          2007,      607,
+ 12415,         1578,         11119,     4654,
+ 13680,         1708,         11990,     1229,
+  7996,         7297,         13231,     5715,
+  2428,         1159,          2073,     1941,
+  6218,         6121,          3546,     1804,
+  8925,         1802,          8679,     1580,
+ 13935,         3576,         13313,     6237,
+  6142,         1130,          5994,     1734,
+ 14141,         4662,         11271,     3321,
+ 12226,         1551,         13931,     3015,
+  5081,        10464,          9444,     6706,
+  1689,          683,          1436,     1306,
+  7212,         3933,          4082,     2713,
+  7793,          704,         15070,      802,
+  6299,         5212,          4337,     5357,
+  6676,          541,          6062,      626,
+ 13651,         3700,         11498,     2408,
+ 16156,          716,         12177,      751,
+  8065,        11489,          6314,     2256,
+  4466,          496,          7293,      523,
+ 10213,         3833,          8394,     3037,
+  8403,          966,         14228,     1880,
+  8703,         5409,         16395,     4863,
+  7420,         1979,          6089,     1230,
+  9371,         4398,         14558,     3363,
+ 13559,         2873,         13163,     1465,
+  5534,         1678,         13138,    14771,
+  7338,          600,          1318,      548,
+  4252,         3539,         10044,     2364,
+ 10587,          622,         13088,      669,
+ 14126,         3526,          5039,     9784,
+ 15338,          619,          3115,      590,
+ 16442,         3013,         15542,     4168,
+ 15537,         1611,         15405,     1228,
+ 16023,         9299,          7534,     4976,
+  1990,         1213,         11447,     1157,
+ 12512,         5519,          9475,     2644,
+  7716,         2034,         13280,     2239,
+ 16011,         5093,          8066,     6761,
+ 10083,         1413,          5002,     2347,
+ 12523,         5975,         15126,     2899,
+ 18264,         2289,         15827,     2527,
+ 16265,        10254,         14651,    11319,
+  1797,          337,          3115,      397,
+  3510,         2928,          4592,     2670,
+  7519,          628,         11415,      656,
+  5946,         2435,          6544,     7367,
+  8238,          829,          4000,      863,
+ 10032,         2492,         16057,     3551,
+ 18204,         1054,          6103,     1454,
+  5884,         7900,         18752,     3468,
+  1864,          544,          9198,      683,
+ 11623,         4160,          4594,     1644,
+  3158,         1157,         15953,     2560,
+ 12349,         3733,         17420,     5260,
+  6106,         2004,          2917,     1742,
+ 16467,         5257,         16787,     1680,
+ 17205,         1759,          4773,     3231,
+  7386,         6035,         14342,    10012,
+  4035,          442,          4194,      458,
+  9214,         2242,          7427,     4217,
+ 12860,          801,         11186,      825,
+ 12648,         2084,         12956,     6554,
+  9505,          996,          6629,      985,
+ 10537,         2502,         15289,     5006,
+ 12602,         2055,         15484,     1653,
+ 16194,         6921,         14231,     5790,
+  2626,          828,          5615,     1686,
+ 13663,         5778,          3668,     1554,
+ 11313,         2633,          9770,     1459,
+ 14003,         4733,         15897,     6291,
+  6278,         1870,          7910,     2285,
+ 16978,         4571,         16576,     3849,
+ 15248,         2311,         16023,     3244,
+ 14459,        17808,         11847,     2763,
+  1981,         1407,          1400,      876,
+  4335,         3547,          4391,     4210,
+  5405,          680,         17461,      781,
+  6501,         5118,          8091,     7677,
+  7355,          794,          8333,     1182,
+ 15041,         3160,         14928,     3039,
+ 20421,          880,         14545,      852,
+ 12337,        14708,          6904,     1920,
+  4225,          933,          8218,     1087,
+ 10659,         4084,         10082,     4533,
+  2735,          840,         20657,     1081,
+ 16711,         5966,         15873,     4578,
+ 10871,         2574,          3773,     1166,
+ 14519,         4044,         20699,     2627,
+ 15219,         2734,         15274,     2186,
+  6257,         3226,         13125,    19480,
+  7196,          930,          2462,     1618,
+  4515,         3092,         13852,     4277,
+ 10460,          833,         17339,      810,
+ 16891,         2289,         15546,     8217,
+ 13603,         1684,          3197,     1834,
+ 15948,         2820,         15812,     5327,
+ 17006,         2438,         16788,     1326,
+ 15671,         8156,         11726,     8556,
+  3762,         2053,          9563,     1317,
+ 13561,         6790,         12227,     1936,
+  8180,         3550,         13287,     1778,
+ 16299,         6599,         16291,     7758,
+  8521,         2551,          7225,     2645,
+ 18269,         7489,         16885,     2248,
+ 17882,         2884,         17265,     3328,
+  9417,        20162,         11042,     8320,
+  1286,          620,          1431,      583,
+  5993,         2289,          3978,     3626,
+  5144,          752,         13409,      830,
+  5553,         2860,         11764,     5908,
+ 10737,          560,          5446,      564,
+ 13321,         3008,         11946,     3683,
+ 19887,          798,          9825,      728,
+ 13663,         8748,          7391,     3053,
+  2515,          778,          6050,      833,
+  6469,         5074,          8305,     2463,
+  6141,         1865,         15308,     1262,
+ 14408,         4547,         13663,     4515,
+  3137,         2983,          2479,     1259,
+ 15088,         4647,         15382,     2607,
+ 14492,         2392,         12462,     2537,
+  7539,         2949,         12909,    12060,
+  5468,          684,          3141,      722,
+  5081,         1274,         12732,     4200,
+ 15302,          681,          7819,      592,
+  6534,         2021,         16478,     8737,
+ 13364,          882,          5397,      899,
+ 14656,         2178,         14741,     4227,
+ 14270,         1298,         13929,     2029,
+ 15477,         7482,         15815,     4572,
+  2521,         2013,          5062,     1804,
+  5159,         6582,          7130,     3597,
+ 10920,         1611,         11729,     1708,
+ 16903,         3455,         16268,     6640,
+  9306,         1007,          9369,     2106,
+ 19182,         5037,         12441,     4269,
+ 15919,         1332,         15357,     3512,
+ 11898,        14141,         16101,     6854,
+  2010,          737,          3779,      861,
+ 11454,         2880,          3564,     3540,
+  9057,         1241,         12391,      896,
+  8546,         4629,         11561,     5776,
+  8129,          589,          8218,      588,
+ 18728,         3755,         12973,     3149,
+ 15729,          758,         16634,      754,
+ 15222,        11138,         15871,     2208,
+  4673,          610,         10218,      678,
+ 15257,         4146,          5729,     3327,
+  8377,         1670,         19862,     2321,
+ 15450,         5511,         14054,     5481,
+  5728,         2888,          7580,     1346,
+ 14384,         5325,         16236,     3950,
+ 15118,         3744,         15306,     1435,
+ 14597,         4070,         12301,    15696,
+  7617,         1699,          2170,      884,
+  4459,         4567,         18094,     3306,
+ 12742,          815,         14926,      907,
+ 15016,         4281,         15518,     8368,
+ 17994,         1087,          2358,      865,
+ 16281,         3787,         15679,     4596,
+ 16356,         1534,         16584,     2210,
+ 16833,         9697,         15929,     4513,
+  3277,         1085,          9643,     2187,
+ 11973,         6068,          9199,     4462,
+  8955,         1629,         10289,     3062,
+ 16481,         5155,         15466,     7066,
+ 13678,         2543,          5273,     2277,
+ 16746,         6213,         16655,     3408,
+ 20304,         3363,         18688,     1985,
+ 14172,        12867,         15154,    15703,
+  4473,         1020,          1681,      886,
+  4311,         4301,          8952,     3657,
+  5893,         1147,         11647,     1452,
+ 15886,         2227,          4582,     6644,
+  6929,         1205,          6220,      799,
+ 12415,         3409,         15968,     3877,
+ 19859,         2109,          9689,     2141,
+ 14742,         8830,         14480,     2599,
+  1817,         1238,          7771,      813,
+ 19079,         4410,          5554,     2064,
+  3687,         2844,         17435,     2256,
+ 16697,         4486,         16199,     5388,
+  8028,         2763,          3405,     2119,
+ 17426,         5477,         13698,     2786,
+ 19879,         2720,          9098,     3880,
+ 18172,         4833,         17336,    12207,
+  5116,          996,          4935,      988,
+  9888,         3081,          6014,     5371,
+ 15881,         1667,          8405,     1183,
+ 15087,         2366,         19777,     7002,
+ 11963,         1562,          7279,     1128,
+ 16859,         1532,         15762,     5381,
+ 14708,         2065,         20105,     2155,
+ 17158,         8245,         17911,     6318,
+  5467,         1504,          4100,     2574,
+ 17421,         6810,          5673,     2888,
+ 16636,         3382,          8975,     1831,
+ 20159,         4737,         19550,     7294,
+  6658,         2781,         11472,     3321,
+ 19397,         5054,         18878,     4722,
+ 16439,         2373,         20430,     4386,
+ 11353,        26526,         11593,     3068,
+  2866,         1566,          5108,     1070,
+  9614,         4915,          4939,     3536,
+  7541,          878,         20717,      851,
+  6938,         4395,         16799,     7733,
+ 10137,         1019,          9845,      964,
+ 15494,         3955,         15459,     3430,
+ 18863,          982,         20120,      963,
+ 16876,        12887,         14334,     4200,
+  6599,         1220,          9222,      814,
+ 16942,         5134,          5661,     4898,
+  5488,         1798,         20258,     3962,
+ 17005,         6178,         17929,     5929,
+  9365,         3420,          7474,     1971,
+ 19537,         5177,         19003,     3006,
+ 16454,         3788,         16070,     2367,
+  8664,         2743,          9445,    26358,
+ 10856,         1287,          3555,     1009,
+  5606,         3622,         19453,     5512,
+ 12453,          797,         20634,      911,
+ 15427,         3066,         17037,    10275,
+ 18883,         2633,          3913,     1268,
+ 19519,         3371,         18052,     5230,
+ 19291,         1678,         19508,     3172,
+ 18072,        10754,         16625,     6845,
+  3134,         2298,         10869,     2437,
+ 15580,         6913,         12597,     3381,
+ 11116,         3297,         16762,     2424,
+ 18853,         6715,         17171,     9887,
+ 12743,         2605,          8937,     3140,
+ 19033,         7764,         18347,     3880,
+ 20475,         3682,         19602,     3380,
+ 13044,        19373,         10526,    23124
+};
diff -Nur FFMpeg-20050127/libavcodec/amr/qgain795.c FFMpeg-20050127-new/libavcodec/amr/qgain795.c
--- FFMpeg-20050127/libavcodec/amr/qgain795.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/qgain795.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,589 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : qgain795.c
+*      Purpose          : pitch and codebook gain quantization for MR795
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "qgain795.h"
+const char qgain795_id[] = "@(#)$Id $" qgain795_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "cnst.h"
+#include "log2.h"
+#include "pow2.h"
+#include "sqrt_l.h"
+#include "g_adapt.h"
+#include "calc_en.h"
+#include "q_gain_p.h"
+#include "mac_32.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#include "gains.tab"
+
+/*
+********************************************************************************
+*                         LOCAL PROGRAM CODE
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ * FUNCTION:  MR795_gain_code_quant3
+ *
+ * PURPOSE: Pre-quantization of codebook gains, given three possible
+ *          LTP gains (using predicted codebook gain)
+ *
+ *************************************************************************/
+static void
+MR795_gain_code_quant3(
+    Word16 exp_gcode0,        /* i  : predicted CB gain (exponent), Q0  */
+    Word16 gcode0,            /* i  : predicted CB gain (norm.),    Q14 */
+    Word16 g_pitch_cand[],    /* i  : Pitch gain candidates (3),    Q14 */
+    Word16 g_pitch_cind[],    /* i  : Pitch gain cand. indices (3), Q0  */
+    Word16 frac_coeff[],      /* i  : coefficients (5),             Q15 */
+    Word16 exp_coeff[],       /* i  : energy coefficients (5),      Q0  */
+                              /*      coefficients from calc_filt_ener()*/
+    Word16 *gain_pit,         /* o  : Pitch gain,                   Q14 */
+    Word16 *gain_pit_ind,     /* o  : Pitch gain index,             Q0  */
+    Word16 *gain_cod,         /* o  : Code gain,                    Q1  */
+    Word16 *gain_cod_ind,     /* o  : Code gain index,              Q0  */
+    Word16 *qua_ener_MR122,   /* o  : quantized energy error,       Q10 */
+                              /*      (for MR122 MA predictor update)   */
+    Word16 *qua_ener          /* o  : quantized energy error,       Q10 */
+                              /*      (for other MA predictor update)   */
+)
+{
+    const Word16 *p;
+    Word16 i, j, cod_ind, pit_ind;
+    Word16 e_max, exp_code;
+    Word16 g_pitch, g2_pitch, g_code, g2_code_h, g2_code_l;
+    Word16 g_pit_cod_h, g_pit_cod_l;
+    Word16 coeff[5], coeff_lo[5];
+    Word16 exp_max[5];
+    Word32 L_tmp, L_tmp0, dist_min;
+
+    /*
+     * The error energy (sum) to be minimized consists of five terms, t[0..4].
+     *
+     *                      t[0] =    gp^2  * <y1 y1>
+     *                      t[1] = -2*gp    * <xn y1>
+     *                      t[2] =    gc^2  * <y2 y2>
+     *                      t[3] = -2*gc    * <xn y2>
+     *                      t[4] =  2*gp*gc * <y1 y2>
+     *
+     */
+
+    /* determine the scaling exponent for g_code: ec = ec0 - 10 */
+    exp_code = sub(exp_gcode0, 10);
+
+    /* calculate exp_max[i] = s[i]-1 */
+    exp_max[0] = sub(exp_coeff[0], 13);                        move16 ();
+    exp_max[1] = sub(exp_coeff[1], 14);                        move16 ();
+    exp_max[2] = add(exp_coeff[2], add(15, shl(exp_code, 1))); move16 ();
+    exp_max[3] = add(exp_coeff[3], exp_code);                  move16 ();
+    exp_max[4] = add(exp_coeff[4], add(exp_code,1));           move16 ();
+
+
+    /*-------------------------------------------------------------------*
+     *  Find maximum exponent:                                           *
+     *  ~~~~~~~~~~~~~~~~~~~~~~                                           *
+     *                                                                   *
+     *  For the sum operation, all terms must have the same scaling;     *
+     *  that scaling should be low enough to prevent overflow. There-    *
+     *  fore, the maximum scale is determined and all coefficients are   *
+     *  re-scaled:                                                       *
+     *                                                                   *
+     *    e_max = max(exp_max[i]) + 1;                                   *
+     *    e = exp_max[i]-e_max;         e <= 0!                          *
+     *    c[i] = c[i]*2^e                                                *
+     *-------------------------------------------------------------------*/
+
+    e_max = exp_max[0];                                        move16 ();
+    for (i = 1; i < 5; i++)     /* implemented flattened */
+    {
+        move16(); test();
+        if (sub(exp_max[i], e_max) > 0)
+        {
+            e_max = exp_max[i];                                move16 ();
+        }
+    }
+
+    e_max = add(e_max, 1);      /* To avoid overflow */
+
+    for (i = 0; i < 5; i++) {
+        j = sub(e_max, exp_max[i]);
+        L_tmp = L_deposit_h(frac_coeff[i]);
+        L_tmp = L_shr(L_tmp, j);
+        L_Extract(L_tmp, &coeff[i], &coeff_lo[i]);
+    }
+
+
+    /*-------------------------------------------------------------------*
+     *  Codebook search:                                                 *
+     *  ~~~~~~~~~~~~~~~~                                                 *
+     *                                                                   *
+     *  For each of the candiates LTP gains in g_pitch_cand[], the terms *
+     *  t[0..4] are calculated from the values in the table (and the     *
+     *  pitch gain candidate) and summed up; the result is the mean      *
+     *  squared error for the LPT/CB gain pair. The index for the mini-  *
+     *  mum MSE is stored and finally used to retrieve the quantized CB  *
+     *  gain                                                             *
+     *-------------------------------------------------------------------*/
+
+    /* start with "infinite" MSE */
+    dist_min = MAX_32;        move16 ();
+    cod_ind = 0;              move16 ();
+    pit_ind = 0;              move16 ();
+
+    /* loop through LTP gain candidates */
+    for (j = 0; j < 3; j++)
+    {
+        /* pre-calculate terms only dependent on pitch gain */
+        g_pitch = g_pitch_cand[j];    move16 ();
+        g2_pitch = mult(g_pitch, g_pitch);
+        L_tmp0 = Mpy_32_16(        coeff[0], coeff_lo[0], g2_pitch);
+        L_tmp0 = Mac_32_16(L_tmp0, coeff[1], coeff_lo[1], g_pitch);
+
+        p = &qua_gain_code[0];
+        for (i = 0; i < NB_QUA_CODE; i++)
+        {
+            g_code = *p++;        move16 (); /* this is g_fac        Q11 */
+            p++;                             /* skip log2(g_fac)         */
+            p++;                             /* skip 20*log10(g_fac)     */
+
+            g_code = mult(g_code, gcode0);
+
+            L_tmp = L_mult (g_code, g_code);
+            L_Extract (L_tmp, &g2_code_h, &g2_code_l);
+
+            L_tmp = L_mult(g_code, g_pitch);
+            L_Extract (L_tmp, &g_pit_cod_h, &g_pit_cod_l);
+
+            L_tmp = Mac_32  (L_tmp0, coeff[2], coeff_lo[2],
+                                     g2_code_h, g2_code_l);
+            L_tmp = Mac_32_16(L_tmp, coeff[3], coeff_lo[3],
+                                     g_code);
+            L_tmp = Mac_32   (L_tmp, coeff[4], coeff_lo[4],
+                                     g_pit_cod_h, g_pit_cod_l);
+
+            /* store table index if MSE for this index is lower
+               than the minimum MSE seen so far; also store the
+               pitch gain for this (so far) lowest MSE          */
+            test ();
+            if (L_sub(L_tmp, dist_min) < (Word32) 0)
+            {
+                dist_min = L_tmp;                move32 ();
+                cod_ind = i;                     move16 ();
+                pit_ind = j;                     move16 ();
+            }
+        }
+    }
+
+    /*------------------------------------------------------------------*
+     *  read quantized gains and new values for MA predictor memories   *
+     *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   *
+     *------------------------------------------------------------------*/
+
+    /* Read the quantized gains */
+    p = &qua_gain_code[add (add (cod_ind, cod_ind), cod_ind)]; move16 ();
+    g_code = *p++;            move16();
+    *qua_ener_MR122 = *p++;   move16();
+    *qua_ener = *p;           move16();
+
+    /*------------------------------------------------------------------*
+     *  calculate final fixed codebook gain:                            *
+     *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                            *
+     *                                                                  *
+     *   gc = gc0 * g                                                   *
+     *------------------------------------------------------------------*/
+
+    L_tmp = L_mult(g_code, gcode0);
+    L_tmp = L_shr(L_tmp, sub(9, exp_gcode0));
+    *gain_cod = extract_h(L_tmp);
+    *gain_cod_ind = cod_ind;                move16 ();
+    *gain_pit = g_pitch_cand[pit_ind];      move16 ();
+    *gain_pit_ind = g_pitch_cind[pit_ind];  move16 ();
+}
+
+
+/*************************************************************************
+ *
+ * FUNCTION:  MR795_gain_code_quant_mod
+ *
+ * PURPOSE: Modified quantization of the MR795 codebook gain
+ *
+ * Uses pre-computed energy coefficients in frac_en[]/exp_en[]
+ *
+ *       frac_en[0]*2^exp_en[0] = <res res>   // LP residual energy
+ *       frac_en[1]*2^exp_en[1] = <exc exc>   // LTP residual energy
+ *       frac_en[2]*2^exp_en[2] = <exc code>  // LTP/CB innovation dot product
+ *       frac_en[3]*2^exp_en[3] = <code code> // CB innovation energy
+ *
+ *************************************************************************/
+static Word16
+MR795_gain_code_quant_mod(  /* o  : index of quantization.            */
+    Word16 gain_pit,        /* i  : pitch gain,                   Q14 */
+    Word16 exp_gcode0,      /* i  : predicted CB gain (exponent), Q0  */
+    Word16 gcode0,          /* i  : predicted CB gain (norm.),    Q14 */
+    Word16 frac_en[],       /* i  : energy coefficients (4),
+                                    fraction part,                Q15 */
+    Word16 exp_en[],        /* i  : energy coefficients (4),
+                                    eponent part,                 Q0  */
+    Word16 alpha,           /* i  : gain adaptor factor (>0),     Q15 */
+    Word16 gain_cod_unq,    /* i  : Code gain (unquantized)           */
+                            /*      (scaling: Q10 - exp_gcode0)       */
+    Word16 *gain_cod,       /* i/o: Code gain (pre-/quantized),   Q1  */
+    Word16 *qua_ener_MR122, /* o  : quantized energy error,       Q10 */
+                            /*      (for MR122 MA predictor update)   */
+    Word16 *qua_ener        /* o  : quantized energy error,       Q10 */
+                            /*      (for other MA predictor update)   */
+ )
+{
+    const Word16 *p;
+    Word16 i, index, tmp;
+    Word16 one_alpha;
+    Word16 exp, e_max;
+    Word16 g2_pitch, g_code;
+    Word16 g2_code_h, g2_code_l;
+    Word16 d2_code_h, d2_code_l;
+    Word16 coeff[5], coeff_lo[5], exp_coeff[5];
+    Word32 L_tmp, L_t0, L_t1, dist_min;
+    Word16 gain_code;
+
+    /*
+      Steps in calculation of the error criterion (dist):
+      ---------------------------------------------------
+
+      underlined = constant; alp = FLP value of alpha, alpha = FIP
+      ----------
+
+
+        ExEn = gp^2 * LtpEn + 2.0*gp*gc[i] * XC + gc[i]^2 * InnEn;
+               ------------   ------         --             -----
+
+        aExEn= alp * ExEn
+             = alp*gp^2*LtpEn + 2.0*alp*gp*XC* gc[i] + alp*InnEn* gc[i]^2
+               --------------   -------------          ---------
+
+             =         t[1]   +              t[2]    +          t[3]
+
+        dist = d1 + d2;
+
+          d1 = (1.0 - alp) * InnEn * (gcu - gc[i])^2 = t[4]
+               -------------------    ---
+
+          d2 =        alp  * (ResEn - 2.0 * sqrt(ResEn*ExEn) + ExEn);
+                      ---     -----   ---        -----
+
+             =        alp  * (sqrt(ExEn) - sqrt(ResEn))^2
+                      ---                  -----------
+
+             =               (sqrt(aExEn) - sqrt(alp*ResEn))^2
+                                            ---------------
+
+             =               (sqrt(aExEn) -       t[0]     )^2
+                                                  ----
+
+     */
+
+    /*
+     * calculate scalings of the constant terms
+     */
+    gain_code = shl (*gain_cod, sub (10, exp_gcode0)); /* Q1  -> Q11 (-ec0) */
+    g2_pitch = mult (gain_pit, gain_pit);              /* Q14 -> Q13        */
+    /* 0 < alpha <= 0.5 => 0.5 <= 1-alpha < 1, i.e one_alpha is normalized  */
+    one_alpha = add (sub (32767, alpha), 1); /* 32768 - alpha */
+
+
+    /*  alpha <= 0.5 -> mult. by 2 to keep precision; compensate in exponent */
+    tmp = extract_h (L_shl (L_mult (alpha, frac_en[1]), 1));
+    /* directly store in 32 bit variable because no further mult. required */
+    L_t1 = L_mult (tmp, g2_pitch);                    move16 ();
+    exp_coeff[1] = sub (exp_en[1], 15);               move16 ();
+
+
+    tmp = extract_h (L_shl (L_mult (alpha, frac_en[2]), 1));
+    coeff[2] = mult (tmp, gain_pit);                  move16 ();
+    exp = sub (exp_gcode0, 10);
+    exp_coeff[2] = add (exp_en[2], exp);              move16 ();
+
+
+    /* alpha <= 0.5 -> mult. by 2 to keep precision; compensate in exponent */
+    coeff[3] = extract_h (L_shl (L_mult (alpha, frac_en[3]), 1));
+    exp = sub (shl (exp_gcode0, 1), 7);
+    exp_coeff[3] = add (exp_en[3], exp);              move16 ();
+
+
+    coeff[4] = mult (one_alpha, frac_en[3]);          move16 ();
+    exp_coeff[4] = add (exp_coeff[3], 1);             move16 ();
+
+
+    L_tmp = L_mult (alpha, frac_en[0]);
+    /* sqrt_l returns normalized value and 2*exponent
+       -> result = val >> (exp/2)
+       exp_coeff holds 2*exponent for c[0]            */
+    /* directly store in 32 bit variable because no further mult. required */
+    L_t0 = sqrt_l_exp (L_tmp, &exp); /* normalization included in sqrt_l_exp */
+                                     move32 (); /* function result */
+    exp = add (exp, 47);
+    exp_coeff[0] = sub (exp_en[0], exp);              move16 ();
+
+    /*
+     * Determine the maximum exponent occuring in the distance calculation
+     * and adjust all fractions accordingly (including a safety margin)
+     *
+     */
+
+    /* find max(e[1..4],e[0]+31) */
+    e_max = add (exp_coeff[0], 31);
+    for (i = 1; i <= 4; i++)
+    {
+        test ();
+        if (sub (exp_coeff[i], e_max) > 0)
+        {
+            e_max = exp_coeff[i];                     move16 ();
+        }
+    }
+
+    /* scale c[1]         (requires no further multiplication) */
+    tmp = sub (e_max, exp_coeff[1]);
+    L_t1 = L_shr(L_t1, tmp);
+
+    /* scale c[2..4] (used in Mpy_32_16 in the quantizer loop) */
+    for (i = 2; i <= 4; i++)
+    {
+        tmp = sub (e_max, exp_coeff[i]);
+        L_tmp = L_deposit_h(coeff[i]);
+        L_tmp = L_shr(L_tmp, tmp);
+        L_Extract(L_tmp, &coeff[i], &coeff_lo[i]);
+    }
+
+    /* scale c[0]         (requires no further multiplication) */
+    exp = sub (e_max, 31);             /* new exponent */
+    tmp = sub (exp, exp_coeff[0]);
+    L_t0 = L_shr (L_t0, shr (tmp, 1));
+    /* perform correction by 1/sqrt(2) if exponent difference is odd */
+    test (); logic16 ();
+    if ((tmp & 0x1) != 0)
+    {
+        L_Extract(L_t0, &coeff[0], &coeff_lo[0]);
+        L_t0 = Mpy_32_16(coeff[0], coeff_lo[0],
+                         23170);                    /* 23170 Q15 = 1/sqrt(2)*/
+    }
+
+    /* search the quantizer table for the lowest value
+       of the search criterion                           */
+    dist_min = MAX_32; move32 ();
+    index = 0;         move16 ();
+    p = &qua_gain_code[0]; move16 ();
+
+    for (i = 0; i < NB_QUA_CODE; i++)
+    {
+        g_code = *p++;        move16 (); /* this is g_fac (Q11)  */
+        p++;                             /* skip log2(g_fac)     */
+        p++;                             /* skip 20*log10(g_fac) */
+        g_code = mult (g_code, gcode0);
+
+        /* only continue if    gc[i]            < 2.0*gc
+           which is equiv. to  g_code (Q10-ec0) < gain_code (Q11-ec0) */
+        test ();
+        if (sub (g_code, gain_code) >= 0)
+            break;
+
+        L_tmp = L_mult (g_code, g_code);
+        L_Extract (L_tmp, &g2_code_h, &g2_code_l);
+
+        tmp = sub (g_code, gain_cod_unq);
+        L_tmp = L_mult (tmp, tmp);
+        L_Extract (L_tmp, &d2_code_h, &d2_code_l);
+
+        /* t2, t3, t4 */
+        L_tmp = Mac_32_16 (L_t1, coeff[2], coeff_lo[2], g_code);
+        L_tmp = Mac_32(L_tmp,    coeff[3], coeff_lo[3], g2_code_h, g2_code_l);
+
+        L_tmp = sqrt_l_exp (L_tmp, &exp);
+        L_tmp = L_shr (L_tmp, shr (exp, 1));
+
+        /* d2 */
+        tmp = round (L_sub (L_tmp, L_t0));
+        L_tmp = L_mult (tmp, tmp);
+
+        /* dist */
+        L_tmp = Mac_32(L_tmp, coeff[4], coeff_lo[4], d2_code_h, d2_code_l);
+
+        /* store table index if distance measure for this
+            index is lower than the minimum seen so far   */
+        test ();
+        if (L_sub (L_tmp, dist_min) < (Word32) 0)
+        {
+            dist_min = L_tmp;                move16 ();
+            index = i;                       move16 ();
+        }
+    }
+
+    /*------------------------------------------------------------------*
+     *  read quantized gains and new values for MA predictor memories   *
+     *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   *
+     *------------------------------------------------------------------*/
+
+    /* Read the quantized gains */
+    p = &qua_gain_code[add (add (index, index), index)]; move16 ();
+    g_code = *p++;            move16();
+    *qua_ener_MR122 = *p++;   move16();
+    *qua_ener = *p;           move16();
+
+    /*------------------------------------------------------------------*
+     *  calculate final fixed codebook gain:                            *
+     *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                            *
+     *                                                                  *
+     *   gc = gc0 * g                                                   *
+     *------------------------------------------------------------------*/
+
+    L_tmp = L_mult(g_code, gcode0);
+    L_tmp = L_shr(L_tmp, sub(9, exp_gcode0));
+    *gain_cod = extract_h(L_tmp);
+
+    return index;
+}
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ * FUNCTION:  MR795_gain_quant
+ *
+ * PURPOSE:   pitch and codebook quantization for MR795
+ *
+ *************************************************************************/
+void
+MR795_gain_quant(
+    GainAdaptState *adapt_st, /* i/o: gain adapter state structure       */
+    Word16 res[],             /* i  : LP residual,                  Q0   */
+    Word16 exc[],             /* i  : LTP excitation (unfiltered),  Q0   */
+    Word16 code[],            /* i  : CB innovation (unfiltered),   Q13  */
+    Word16 frac_coeff[],      /* i  : coefficients (5),             Q15  */
+    Word16 exp_coeff[],       /* i  : energy coefficients (5),      Q0   */
+                              /*      coefficients from calc_filt_ener() */
+    Word16 exp_code_en,       /* i  : innovation energy (exponent), Q0   */
+    Word16 frac_code_en,      /* i  : innovation energy (fraction), Q15  */
+    Word16 exp_gcode0,        /* i  : predicted CB gain (exponent), Q0   */
+    Word16 frac_gcode0,       /* i  : predicted CB gain (fraction), Q15  */
+    Word16 L_subfr,           /* i  : Subframe length                    */
+    Word16 cod_gain_frac,     /* i  : opt. codebook gain (fraction),Q15  */
+    Word16 cod_gain_exp,      /* i  : opt. codebook gain (exponent), Q0  */
+    Word16 gp_limit,          /* i  : pitch gain limit                   */
+    Word16 *gain_pit,         /* i/o: Pitch gain,                   Q14  */
+    Word16 *gain_cod,         /* o  : Code gain,                    Q1   */
+    Word16 *qua_ener_MR122,   /* o  : quantized energy error,       Q10  */
+                              /*      (for MR122 MA predictor update)    */
+    Word16 *qua_ener,         /* o  : quantized energy error,       Q10  */
+                              /*      (for other MA predictor update)    */
+    Word16 **anap             /* o  : Index of quantization              */
+                              /*      (first gain pitch, then code pitch)*/
+)
+{
+    Word16 frac_en[4];
+    Word16 exp_en[4];
+    Word16 ltpg, alpha, gcode0;
+    Word16 g_pitch_cand[3];      /* pitch gain candidates   Q14 */
+    Word16 g_pitch_cind[3];      /* pitch gain indices      Q0  */
+    Word16 gain_pit_index;
+    Word16 gain_cod_index;
+    Word16 exp;
+    Word16 gain_cod_unq;         /* code gain (unq.) Q(10-exp_gcode0)  */
+
+
+    /* get list of candidate quantized pitch gain values
+     * and corresponding quantization indices
+     */
+    gain_pit_index = q_gain_pitch (MR795, gp_limit, gain_pit,
+                                   g_pitch_cand, g_pitch_cind); 
+                     move16 (); /* function result */
+
+    /*-------------------------------------------------------------------*
+     *  predicted codebook gain                                          *
+     *  ~~~~~~~~~~~~~~~~~~~~~~~                                          *
+     *  gc0     = 2^exp_gcode0 + 2^frac_gcode0                           *
+     *                                                                   *
+     *  gcode0 (Q14) = 2^14*2^frac_gcode0 = gc0 * 2^(14-exp_gcode0)      *
+     *-------------------------------------------------------------------*/
+    gcode0 = extract_l(Pow2(14, frac_gcode0));          /* Q14 */
+
+    /* pre-quantization of codebook gain
+     * (using three pitch gain candidates);
+     * result: best guess of pitch gain and code gain
+     */
+    MR795_gain_code_quant3(
+        exp_gcode0, gcode0, g_pitch_cand, g_pitch_cind,
+        frac_coeff, exp_coeff,
+        gain_pit, &gain_pit_index, gain_cod, &gain_cod_index,
+        qua_ener_MR122, qua_ener);
+
+    /* calculation of energy coefficients and LTP coding gain */
+    calc_unfilt_energies(res, exc, code, *gain_pit, L_subfr,
+                         frac_en, exp_en, &ltpg);
+
+    /* run gain adaptor, calculate alpha factor to balance LTP/CB gain
+     * (this includes the gain adaptor update)
+     * Note: ltpg = 0 if frac_en[0] == 0, so the update is OK in that case
+     */
+    gain_adapt(adapt_st, ltpg, *gain_cod, &alpha);
+
+    /* if this is a very low energy signal (threshold: see
+     * calc_unfilt_energies) or alpha <= 0 then don't run the modified quantizer
+     */
+    test (); move16 (); test ();
+    if (frac_en[0] != 0 && alpha > 0)
+    {
+        /* innovation energy <cod cod> was already computed in gc_pred() */
+        /* (this overwrites the LtpResEn which is no longer needed)      */
+        frac_en[3] = frac_code_en;          move16 ();
+        exp_en[3] = exp_code_en;            move16 ();
+        
+        /* store optimum codebook gain in Q(10-exp_gcode0) */
+        exp = add (sub (cod_gain_exp, exp_gcode0), 10);
+        gain_cod_unq = shl (cod_gain_frac, exp);
+        
+        /* run quantization with modified criterion */
+        gain_cod_index = MR795_gain_code_quant_mod(
+            *gain_pit, exp_gcode0, gcode0,
+            frac_en, exp_en, alpha, gain_cod_unq,
+            gain_cod, qua_ener_MR122, qua_ener); move16 (); /* function result */
+    }
+
+    *(*anap)++ = gain_pit_index;        move16 ();
+    *(*anap)++ = gain_cod_index;        move16 ();
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/qgain795.h FFMpeg-20050127-new/libavcodec/amr/qgain795.h
--- FFMpeg-20050127/libavcodec/amr/qgain795.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/qgain795.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,66 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : qgain795.h
+*      Purpose          : (pre-) quantization of pitch gain for MR795
+*
+********************************************************************************
+*/
+#ifndef qgain795_h
+#define qgain795_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "g_adapt.h"
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ * FUNCTION:  MR795_gain_quant
+ *
+ * PURPOSE:   pitch and codebook quantization for MR795
+ *
+ *************************************************************************/
+void
+MR795_gain_quant(
+    GainAdaptState *adapt_st, /* i/o: gain adapter state structure       */
+    Word16 res[],             /* i  : LP residual,                  Q0   */
+    Word16 exc[],             /* i  : LTP excitation (unfiltered),  Q0   */
+    Word16 code[],            /* i  : CB innovation (unfiltered),   Q13  */
+    Word16 frac_coeff[],      /* i  : coefficients (5),             Q15  */
+    Word16 exp_coeff[],       /* i  : energy coefficients (5),      Q0   */
+                              /*      coefficients from calc_filt_ener() */
+    Word16 exp_code_en,       /* i  : innovation energy (exponent), Q0   */
+    Word16 frac_code_en,      /* i  : innovation energy (fraction), Q15  */
+    Word16 exp_gcode0,        /* i  : predicted CB gain (exponent), Q0   */
+    Word16 frac_gcode0,       /* i  : predicted CB gain (fraction), Q15  */
+    Word16 L_subfr,           /* i  : Subframe length                    */
+    Word16 cod_gain_frac,     /* i  : opt. codebook gain (fraction),Q15  */
+    Word16 cod_gain_exp,      /* i  : opt. codebook gain (exponent), Q0  */
+    Word16 gp_limit,          /* i  : pitch gain limit                   */
+    Word16 *gain_pit,         /* i/o: Pitch gain (unquant/quant),   Q14  */
+    Word16 *gain_cod,         /* o  : Code gain,                    Q1   */
+    Word16 *qua_ener_MR122,   /* o  : quantized energy error,       Q10  */
+                              /*      (for MR122 MA predictor update)    */
+    Word16 *qua_ener,         /* o  : quantized energy error,       Q10  */
+                              /*      (for other MA predictor update)    */
+    Word16 **anap             /* o  : Index of quantization              */
+                              /*      (first gain pitch, then code pitch)*/
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/qua_gain.c FFMpeg-20050127-new/libavcodec/amr/qua_gain.c
--- FFMpeg-20050127/libavcodec/amr/qua_gain.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/qua_gain.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,244 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : qua_gain.c
+*      Purpose          : Quantization of pitch and codebook gains.
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "qua_gain.h"
+const char qua_gain_id[] = "@(#)$Id $" qua_gain_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "mode.h"
+#include "count.h"
+#include "cnst.h"
+#include "pow2.h"
+#include "gc_pred.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#include "qua_gain.tab"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ * FUNCTION:  Qua_gain()
+ *
+ * PURPOSE: Quantization of pitch and codebook gains.
+ *          (using predicted codebook gain)
+ *
+ *************************************************************************/
+Word16
+Qua_gain(                   /* o  : index of quantization.                 */   
+    enum Mode mode,         /* i  : AMR mode                               */
+    Word16 exp_gcode0,      /* i  : predicted CB gain (exponent),      Q0  */
+    Word16 frac_gcode0,     /* i  : predicted CB gain (fraction),      Q15 */
+    Word16 frac_coeff[],    /* i  : energy coeff. (5), fraction part,  Q15 */
+    Word16 exp_coeff[],     /* i  : energy coeff. (5), exponent part,  Q0  */
+                            /*      (frac_coeff and exp_coeff computed in  */
+                            /*       calc_filt_energies())                 */
+    Word16 gp_limit,        /* i  : pitch gain limit                       */
+    Word16 *gain_pit,       /* o  : Pitch gain,                        Q14 */
+    Word16 *gain_cod,       /* o  : Code gain,                         Q1  */
+    Word16 *qua_ener_MR122, /* o  : quantized energy error,            Q10 */
+                            /*      (for MR122 MA predictor update)        */
+    Word16 *qua_ener        /* o  : quantized energy error,            Q10 */
+                            /*      (for other MA predictor update)        */
+)
+{
+    const Word16 *p;
+    Word16 i, j, index = 0;
+    Word16 gcode0, e_max, exp_code;
+    Word16 g_pitch, g2_pitch, g_code, g2_code, g_pit_cod;
+    Word16 coeff[5], coeff_lo[5];
+    Word16 exp_max[5];
+    Word32 L_tmp, dist_min;
+    const Word16 *table_gain;
+    Word16 table_len;
+    
+    test();  test(); test();
+    if ( sub (mode, MR102) == 0 || sub (mode, MR74) == 0 || sub (mode, MR67) == 0)
+    {
+       table_len = VQ_SIZE_HIGHRATES;            move16 ();
+       table_gain = table_gain_highrates;        move16 ();
+    }
+    else
+    {
+       table_len = VQ_SIZE_LOWRATES;             move16 ();
+       table_gain = table_gain_lowrates;         move16 ();
+    }
+    
+    /*-------------------------------------------------------------------*
+     *  predicted codebook gain                                          *
+     *  ~~~~~~~~~~~~~~~~~~~~~~~                                          *
+     *  gc0     = 2^exp_gcode0 + 2^frac_gcode0                           *
+     *                                                                   *
+     *  gcode0 (Q14) = 2^14*2^frac_gcode0 = gc0 * 2^(14-exp_gcode0)      *
+     *-------------------------------------------------------------------*/
+
+    gcode0 = extract_l(Pow2(14, frac_gcode0));
+
+    /*-------------------------------------------------------------------*
+     *  Scaling considerations:                                          *
+     *  ~~~~~~~~~~~~~~~~~~~~~~~                                          *
+     *-------------------------------------------------------------------*/
+
+    /*
+     * The error energy (sum) to be minimized consists of five terms, t[0..4].
+     *
+     *                      t[0] =    gp^2  * <y1 y1>
+     *                      t[1] = -2*gp    * <xn y1>
+     *                      t[2] =    gc^2  * <y2 y2>
+     *                      t[3] = -2*gc    * <xn y2>
+     *                      t[4] =  2*gp*gc * <y1 y2>
+     *
+     */
+
+    /* determine the scaling exponent for g_code: ec = ec0 - 11 */
+    exp_code = sub(exp_gcode0, 11);
+
+    /* calculate exp_max[i] = s[i]-1 */
+    exp_max[0] = sub(exp_coeff[0], 13);                        move16 ();
+    exp_max[1] = sub(exp_coeff[1], 14);                        move16 ();
+    exp_max[2] = add(exp_coeff[2], add(15, shl(exp_code, 1))); move16 ();
+    exp_max[3] = add(exp_coeff[3], exp_code);                  move16 ();
+    exp_max[4] = add(exp_coeff[4], add(1, exp_code));          move16 ();
+
+
+    /*-------------------------------------------------------------------*
+     *  Find maximum exponent:                                           *
+     *  ~~~~~~~~~~~~~~~~~~~~~~                                           *
+     *                                                                   *
+     *  For the sum operation, all terms must have the same scaling;     *
+     *  that scaling should be low enough to prevent overflow. There-    *
+     *  fore, the maximum scale is determined and all coefficients are   *
+     *  re-scaled:                                                       *
+     *                                                                   *
+     *    e_max = max(exp_max[i]) + 1;                                   *
+     *    e = exp_max[i]-e_max;         e <= 0!                          *
+     *    c[i] = c[i]*2^e                                                *
+     *-------------------------------------------------------------------*/
+
+    e_max = exp_max[0];                                        move16 ();
+    for (i = 1; i < 5; i++)
+    {
+        move16(); test();
+        if (sub(exp_max[i], e_max) > 0)
+        {
+            e_max = exp_max[i];                                move16 ();
+        }
+    }
+
+    e_max = add(e_max, 1);      /* To avoid overflow */
+
+    for (i = 0; i < 5; i++) {
+        j = sub(e_max, exp_max[i]);
+        L_tmp = L_deposit_h(frac_coeff[i]);
+        L_tmp = L_shr(L_tmp, j);
+        L_Extract(L_tmp, &coeff[i], &coeff_lo[i]);
+    }
+
+
+    /*-------------------------------------------------------------------*
+     *  Codebook search:                                                 *
+     *  ~~~~~~~~~~~~~~~~                                                 *
+     *                                                                   *
+     *  For each pair (g_pitch, g_fac) in the table calculate the        *
+     *  terms t[0..4] and sum them up; the result is the mean squared    *
+     *  error for the quantized gains from the table. The index for the  *
+     *  minimum MSE is stored and finally used to retrieve the quantized *
+     *  gains                                                            *
+     *-------------------------------------------------------------------*/
+
+    /* start with "infinite" MSE */
+    dist_min = MAX_32;        move32();
+
+    p = &table_gain[0];       move16 ();
+
+    for (i = 0; i < table_len; i++)
+    {
+        g_pitch = *p++;       move16 ();
+        g_code = *p++;        move16 (); /* this is g_fac        */
+        p++;                             /* skip log2(g_fac)     */
+        p++;                             /* skip 20*log10(g_fac) */
+            
+        test ();
+        if (sub(g_pitch, gp_limit) <= 0)
+        {
+            g_code = mult(g_code, gcode0);
+            g2_pitch = mult(g_pitch, g_pitch);
+            g2_code = mult(g_code, g_code);
+            g_pit_cod = mult(g_code, g_pitch);
+
+            L_tmp = Mpy_32_16(coeff[0], coeff_lo[0], g2_pitch);
+            L_tmp = L_add(L_tmp, Mpy_32_16(coeff[1], coeff_lo[1], g_pitch));
+            L_tmp = L_add(L_tmp, Mpy_32_16(coeff[2], coeff_lo[2], g2_code));
+            L_tmp = L_add(L_tmp, Mpy_32_16(coeff[3], coeff_lo[3], g_code));
+            L_tmp = L_add(L_tmp, Mpy_32_16(coeff[4], coeff_lo[4], g_pit_cod));
+
+            /* store table index if MSE for this index is lower
+               than the minimum MSE seen so far */
+            test ();
+            if (L_sub(L_tmp, dist_min) < (Word32) 0)
+            {
+                dist_min = L_tmp; move32 ();
+                index = i;        move16 ();
+            }
+        }
+    }
+
+    /*------------------------------------------------------------------*
+     *  read quantized gains and new values for MA predictor memories   *
+     *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   *
+     *------------------------------------------------------------------*/
+
+    /* Read the quantized gains */
+    p = &table_gain[shl (index, 2)]; move16 ();
+    *gain_pit = *p++;         move16();
+    g_code = *p++;            move16();
+    *qua_ener_MR122 = *p++;   move16();
+    *qua_ener = *p;           move16();
+
+    /*------------------------------------------------------------------*
+     *  calculate final fixed codebook gain:                            *
+     *  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~                            *
+     *                                                                  *
+     *   gc = gc0 * g                                                   *
+     *------------------------------------------------------------------*/
+
+    L_tmp = L_mult(g_code, gcode0);
+    L_tmp = L_shr(L_tmp, sub(10, exp_gcode0));
+    *gain_cod = extract_h(L_tmp);
+
+    return index;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/qua_gain.h FFMpeg-20050127-new/libavcodec/amr/qua_gain.h
--- FFMpeg-20050127/libavcodec/amr/qua_gain.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/qua_gain.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,57 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : qua_gain.h
+*      Purpose          : Quantization of pitch and codebook gains.
+*
+********************************************************************************
+*/
+#ifndef qua_gain_h
+#define qua_gain_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "gc_pred.h"
+#include "mode.h"
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ * FUNCTION:  Qua_gain()
+ *
+ * PURPOSE: Quantization of pitch and codebook gains.
+ *          (using predicted codebook gain)
+ *
+ *************************************************************************/
+Word16
+Qua_gain(                   /* o  : index of quantization.                 */   
+    enum Mode mode,         /* i  : AMR mode                               */
+    Word16 exp_gcode0,      /* i  : predicted CB gain (exponent),      Q0  */
+    Word16 frac_gcode0,     /* i  : predicted CB gain (fraction),      Q15 */
+    Word16 frac_coeff[],    /* i  : energy coeff. (5), fraction part,  Q15 */
+    Word16 exp_coeff[],     /* i  : energy coeff. (5), exponent part,  Q0  */
+                            /*      (frac_coeff and exp_coeff computed in  */
+                            /*       calc_filt_energies())                 */
+    Word16 gp_limit,        /* i  : pitch gain limit                       */
+    Word16 *gain_pit,       /* o  : Pitch gain,                        Q14 */
+    Word16 *gain_cod,       /* o  : Code gain,                         Q1  */
+    Word16 *qua_ener_MR122, /* o  : quantized energy error,            Q10 */
+                            /*      (for MR122 MA predictor update)        */
+    Word16 *qua_ener        /* o  : quantized energy error,            Q10 */
+                            /*      (for other MA predictor update)        */
+);
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/qua_gain.tab FFMpeg-20050127-new/libavcodec/amr/qua_gain.tab
--- FFMpeg-20050127/libavcodec/amr/qua_gain.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/qua_gain.tab	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,235 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : qua_gain.tab
+*      Purpose          : Tables for function Qua_gain()
+*      $Id $
+*
+********************************************************************************
+*/
+
+/* The tables contains the following data:
+
+      g_pitch        (Q14),
+      g_fac          (Q12), (g_code = g_code0*g_fac),
+      qua_ener_MR122 (Q10), (log2(g_fac))
+      qua_ener       (Q10)  (20*log10(g_fac))
+
+      The log2() and log10() values are calculated on the fixed point value
+      (g_fac Q12) and not on the original floating point value of g_fac
+      to make the quantizer/MA predictdor use corresponding values.
+ */
+
+/* table used in 'high' rates: MR67 MR74 */
+#define VQ_SIZE_HIGHRATES 128
+static const Word16 table_gain_highrates[VQ_SIZE_HIGHRATES*4] = {
+/* Note: column 4 (qua_ener) contains the original values from IS641
+         to ensure bit-exactness; however, they are not exactly the
+         rounded value of (20*log10(g_fac))                          */
+/*g_pit,    g_fac,  qua_ener_MR122, qua_ener */
+    577,      662,           -2692,   -16214,
+    806,     1836,           -1185,    -7135,
+   3109,     1052,           -2008,   -12086,
+   4181,     1387,           -1600,    -9629,
+   2373,     1425,           -1560,    -9394,
+   3248,     1985,           -1070,    -6442,
+   1827,     2320,            -840,    -5056,
+    941,     3314,            -313,    -1885,
+   2351,     2977,            -471,    -2838,
+   3616,     2420,            -777,    -4681,
+   3451,     3096,            -414,    -2490,
+   2955,     4301,              72,      434,
+   1848,     4500,             139,      836,
+   3884,     5416,             413,     2484,
+   1187,     7210,             835,     5030,
+   3083,     9000,            1163,     7002,
+   7384,      883,           -2267,   -13647,
+   5962,     1506,           -1478,    -8900,
+   5155,     2134,            -963,    -5800,
+   7944,     2009,           -1052,    -6335,
+   6507,     2250,            -885,    -5327,
+   7670,     2752,            -588,    -3537,
+   5952,     3016,            -452,    -2724,
+   4898,     3764,            -125,     -751,
+   6989,     3588,            -196,    -1177,
+   8174,     3978,             -43,     -260,
+   6064,     4404,             107,      645,
+   7709,     5087,             320,     1928,
+   5523,     6021,             569,     3426,
+   7769,     7126,             818,     4926,
+   6060,     7938,             977,     5885,
+   5594,    11487,            1523,     9172,
+  10581,     1356,           -1633,    -9831,
+   9049,     1597,           -1391,    -8380,
+   9794,     2035,           -1033,    -6220,
+   8946,     2415,            -780,    -4700,
+  10296,     2584,            -681,    -4099,
+   9407,     2734,            -597,    -3595,
+   8700,     3218,            -356,    -2144,
+   9757,     3395,            -277,    -1669,
+  10177,     3892,             -75,     -454,
+   9170,     4528,             148,      891,
+  10152,     5004,             296,     1781,
+   9114,     5735,             497,     2993,
+  10500,     6266,             628,     3782,
+  10110,     7631,             919,     5534,
+   8844,     8727,            1117,     6728,
+   8956,    12496,            1648,     9921,
+  12924,      976,           -2119,   -12753,
+  11435,     1755,           -1252,    -7539,
+  12138,     2328,            -835,    -5024,
+  11388,     2368,            -810,    -4872,
+  10700,     3064,            -429,    -2580,
+  12332,     2861,            -530,    -3192,
+  11722,     3327,            -307,    -1848,
+  11270,     3700,            -150,     -904,
+  10861,     4413,             110,      663,
+  12082,     4533,             150,      902,
+  11283,     5205,             354,     2132,
+  11960,     6305,             637,     3837,
+  11167,     7534,             900,     5420,
+  12128,     8329,            1049,     6312,
+  10969,    10777,            1429,     8604,
+  10300,    17376,            2135,    12853,
+  13899,     1681,           -1316,    -7921,
+  12580,     2045,           -1026,    -6179,
+  13265,     2439,            -766,    -4610,
+  14033,     2989,            -465,    -2802,
+  13452,     3098,            -413,    -2482,
+  12396,     3658,            -167,    -1006,
+  13510,     3780,            -119,     -713,
+  12880,     4272,              62,      374,
+  13533,     4861,             253,     1523,
+  12667,     5457,             424,     2552,
+  13854,     6106,             590,     3551,
+  13031,     6483,             678,     4084,
+  13557,     7721,             937,     5639,
+  12957,     9311,            1213,     7304,
+  13714,    11551,            1532,     9221,
+  12591,    15206,            1938,    11667,
+  15113,     1540,           -1445,    -8700,
+  15072,     2333,            -832,    -5007,
+  14527,     2511,            -723,    -4352,
+  14692,     3199,            -365,    -2197,
+  15382,     3560,            -207,    -1247,
+  14133,     3960,             -50,     -300,
+  15102,     4236,              50,      298,
+  14332,     4824,             242,     1454,
+  14846,     5451,             422,     2542,
+  15306,     6083,             584,     3518,
+  14329,     6888,             768,     4623,
+  15060,     7689,             930,     5602,
+  14406,     9426,            1231,     7413,
+  15387,     9741,            1280,     7706,
+  14824,    14271,            1844,    11102,
+  13600,    24939,            2669,    16067,
+  16396,     1969,           -1082,    -6517,
+  16817,     2832,            -545,    -3283,
+  15713,     2843,            -539,    -3248,
+  16104,     3336,            -303,    -1825,
+  16384,     3963,             -49,     -294,
+  16940,     4579,             165,      992,
+  15711,     4599,             171,     1030,
+  16222,     5448,             421,     2537,
+  16832,     6382,             655,     3945,
+  15745,     7141,             821,     4944,
+  16326,     7469,             888,     5343,
+  16611,     8624,            1100,     6622,
+  17028,    10418,            1379,     8303,
+  15905,    11817,            1565,     9423,
+  16878,    14690,            1887,    11360,
+  16515,    20870,            2406,    14483,
+  18142,     2083,            -999,    -6013,
+  19401,     3178,            -375,    -2257,
+  17508,     3426,            -264,    -1589,
+  20054,     4027,             -25,     -151,
+  18069,     4249,              54,      326,
+  18952,     5066,             314,     1890,
+  17711,     5402,             409,     2461,
+  19835,     6192,             610,     3676,
+  17950,     7014,             795,     4784,
+  21318,     7877,             966,     5816,
+  17910,     9289,            1210,     7283,
+  19144,     9290,            1210,     7284,
+  20517,    11381,            1510,     9089,
+  18075,    14485,            1866,    11234,
+  19999,    17882,            2177,    13108,
+  18842,    32764,            3072,    18494
+};
+
+
+/* table used in 'low' rates: MR475, MR515, MR59 */
+#define VQ_SIZE_LOWRATES 64
+static const Word16 table_gain_lowrates[VQ_SIZE_LOWRATES*4] = {
+/*g_pit,    g_fac,  qua_ener_MR122, qua_ener */
+  10813,    28753,            2879,    17333,
+  20480,     2785,            -570,    -3431,
+  18841,     6594,             703,     4235,
+   6225,     7413,             876,     5276,
+  17203,    10444,            1383,     8325,
+  21626,     1269,           -1731,   -10422,
+  21135,     4423,             113,      683,
+  11304,     1556,           -1430,    -8609,
+  19005,    12820,            1686,    10148,
+  17367,     2498,            -731,    -4398,
+  17858,     4833,             244,     1472,
+   9994,     2498,            -731,    -4398,
+  17530,     7864,             964,     5802,
+  14254,     1884,           -1147,    -6907,
+  15892,     3153,            -387,    -2327,
+   6717,     1802,           -1213,    -7303,
+  18186,    20193,            2357,    14189,
+  18022,     3031,            -445,    -2678,
+  16711,     5857,             528,     3181,
+   8847,     4014,             -30,     -180,
+  15892,     8970,            1158,     6972,
+  18022,     1392,           -1594,    -9599,
+  16711,     4096,               0,        0,
+   8192,      655,           -2708,   -16305,
+  15237,    13926,            1808,    10884,
+  14254,     3112,            -406,    -2444,
+  14090,     4669,             193,     1165,
+   5406,     2703,            -614,    -3697,
+  13434,     6553,             694,     4180,
+  12451,      901,           -2237,   -13468,
+  12451,     2662,            -637,    -3833,
+   3768,      655,           -2708,   -16305,
+  14745,    23511,            2582,    15543,
+  19169,     2457,            -755,    -4546,
+  20152,     5079,             318,     1913,
+   6881,     4096,               0,        0,
+  20480,     8560,            1089,     6556,
+  19660,      737,           -2534,   -15255,
+  19005,     4259,              58,      347,
+   7864,     2088,            -995,    -5993,
+  11468,    12288,            1623,     9771,
+  15892,     1474,           -1510,    -9090,
+  15728,     4628,             180,     1086,
+   9175,     1433,           -1552,    -9341,
+  16056,     7004,             793,     4772,
+  14827,      737,           -2534,   -15255,
+  15073,     2252,            -884,    -5321,
+   5079,     1228,           -1780,   -10714,
+  13271,    17326,            2131,    12827,
+  16547,     2334,            -831,    -5002,
+  15073,     5816,             518,     3118,
+   3932,     3686,            -156,     -938,
+  14254,     8601,            1096,     6598,
+  16875,      778,           -2454,   -14774,
+  15073,     3809,            -107,     -646,
+   6062,      614,           -2804,   -16879,
+   9338,     9256,            1204,     7251,
+  13271,     1761,           -1247,    -7508,
+  13271,     3522,            -223,    -1343,
+   2457,     1966,           -1084,    -6529,
+  11468,     5529,             443,     2668,
+  10485,      737,           -2534,   -15255,
+  11632,     3194,            -367,    -2212,
+   1474,      778,           -2454,   -14774
+};
diff -Nur FFMpeg-20050127/libavcodec/amr/r_fft.c FFMpeg-20050127-new/libavcodec/amr/r_fft.c
--- FFMpeg-20050127/libavcodec/amr/r_fft.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/r_fft.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,235 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : r_fft.c
+*      Purpose          : Fast Fourier Transform (FFT) algorithm
+*
+*****************************************************************************
+*/
+
+/*****************************************************************
+*
+* This is an implementation of decimation-in-time FFT algorithm for
+* real sequences.  The techniques used here can be found in several
+* books, e.g., i) Proakis and Manolakis, "Digital Signal Processing",
+* 2nd Edition, Chapter 9, and ii) W.H. Press et. al., "Numerical
+* Recipes in C", 2nd Ediiton, Chapter 12.
+*
+* Input -  There is one input to this function:
+*
+*	1) An integer pointer to the input data array 
+*
+* Output - There is no return value.
+*	The input data are replaced with transformed data.  If the
+*	input is a real time domain sequence, it is replaced with
+*	the complex FFT for positive frequencies.  The FFT value 
+*	for DC and the foldover frequency are combined to form the
+*	first complex number in the array.  The remaining complex
+*	numbers correspond to increasing frequencies.  If the input
+*	is a complex frequency domain sequence arranged	as above,
+*	it is replaced with the corresponding time domain sequence. 
+*
+* Notes:
+*
+*	1) This function is designed to be a part of a VAD
+*	   algorithm that requires 128-point FFT of real
+*	   sequences.  This is achieved here through a 64-point
+*	   complex FFT.  Consequently, the FFT size information is
+*	   not transmitted explicitly.  However, some flexibility
+*	   is provided in the function to change the size of the 
+*	   FFT by specifying the size information through "define"
+*	   statements.
+*
+*	2) The values of the complex sinusoids used in the FFT 
+*	   algorithm are stored in a ROM table.
+*
+*	3) In the c_fft function, the FFT values are divided by
+*	   2 after each stage of computation thus dividing the
+*	   final FFT values by 64.  This is somewhat different
+*          from the usual definition of FFT where the factor 1/N,
+*          i.e., 1/64, used for the IFFT and not the FFT.  No factor
+*          is used in the r_fft function.
+*
+*****************************************************************/
+
+const char r_fft_id[] = "@(#)$Id $";
+
+
+#include "typedef.h"
+#include "cnst.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+
+#include "vad2.h"
+
+#define			SIZE			128
+#define			SIZE_BY_TWO		64
+#define			NUM_STAGE		6
+#define			TRUE			1
+#define			FALSE			0
+
+static Word16 phs_tbl[] =
+{
+
+	32767, 0, 32729, -1608, 32610, -3212, 32413, -4808,
+	32138, -6393, 31786, -7962, 31357, -9512, 30853, -11039,
+	30274, -12540, 29622, -14010, 28899, -15447, 28106, -16846,
+	27246, -18205, 26320, -19520, 25330, -20788, 24279, -22006,
+	23170, -23170, 22006, -24279, 20788, -25330, 19520, -26320,
+	18205, -27246, 16846, -28106, 15447, -28899, 14010, -29622,
+	12540, -30274, 11039, -30853, 9512, -31357, 7962, -31786,
+	6393, -32138, 4808, -32413, 3212, -32610, 1608, -32729,
+	0, -32768, -1608, -32729, -3212, -32610, -4808, -32413,
+	-6393, -32138, -7962, -31786, -9512, -31357, -11039, -30853,
+	-12540, -30274, -14010, -29622, -15447, -28899, -16846, -28106,
+	-18205, -27246, -19520, -26320, -20788, -25330, -22006, -24279,
+	-23170, -23170, -24279, -22006, -25330, -20788, -26320, -19520,
+	-27246, -18205, -28106, -16846, -28899, -15447, -29622, -14010,
+	-30274, -12540, -30853, -11039, -31357, -9512, -31786, -7962,
+	-32138, -6393, -32413, -4808, -32610, -3212, -32729, -1608
+
+};
+
+static Word16 ii_table[] =
+{SIZE / 2, SIZE / 4, SIZE / 8, SIZE / 16, SIZE / 32, SIZE / 64};
+
+/* FFT function for complex sequences */
+
+/*
+ * The decimation-in-time complex FFT is implemented below.
+ * The input complex numbers are presented as real part followed by
+ * imaginary part for each sample.  The counters are therefore
+ * incremented by two to access the complex valued samples.
+ */
+
+void c_fft(Word16 * farray_ptr)
+{
+
+	Word16 i, j, k, ii, jj, kk, ji, kj, ii2;
+	Word32 ftmp, ftmp_real, ftmp_imag;
+	Word16 tmp, tmp1, tmp2;
+
+	/* Rearrange the input array in bit reversed order */
+	for (i = 0, j = 0; i < SIZE - 2; i = i + 2)
+	{										test();
+		if (sub(j, i) > 0)
+		{
+			ftmp = *(farray_ptr + i);					move16();
+			*(farray_ptr + i) = *(farray_ptr + j);				move16();
+			*(farray_ptr + j) = ftmp;					move16();
+
+			ftmp = *(farray_ptr + i + 1);					move16();
+			*(farray_ptr + i + 1) = *(farray_ptr + j + 1);			move16();
+			*(farray_ptr + j + 1) = ftmp;					move16();
+		}
+
+		k = SIZE_BY_TWO;							move16();
+											test();
+		while (sub(j, k) >= 0)
+		{
+			j = sub(j, k);
+			k = shr(k, 1);
+		}
+		j = add(j, k);
+	}
+
+	/* The FFT part */
+	for (i = 0; i < NUM_STAGE; i++)
+	{				/* i is stage counter */
+		jj = shl(2, i);		/* FFT size */
+		kk = shl(jj, 1);	/* 2 * FFT size */
+		ii = ii_table[i];	/* 2 * number of FFT's */			move16();
+		ii2 = shl(ii, 1);
+		ji = 0;			/* ji is phase table index */			move16();
+
+		for (j = 0; j < jj; j = j + 2)
+		{					/* j is sample counter */
+
+			for (k = j; k < SIZE; k = k + kk)
+			{				/* k is butterfly top */
+				kj = add(k, jj);	/* kj is butterfly bottom */
+
+				/* Butterfly computations */
+				ftmp_real = L_mult(*(farray_ptr + kj), phs_tbl[ji]);
+				ftmp_real = L_msu(ftmp_real, *(farray_ptr + kj + 1), phs_tbl[ji + 1]);
+
+				ftmp_imag = L_mult(*(farray_ptr + kj + 1), phs_tbl[ji]);
+				ftmp_imag = L_mac(ftmp_imag, *(farray_ptr + kj), phs_tbl[ji + 1]);
+
+				tmp1 = round(ftmp_real);
+				tmp2 = round(ftmp_imag);
+
+				tmp = sub(*(farray_ptr + k), tmp1);
+				*(farray_ptr + kj) = shr(tmp, 1);			move16();
+
+				tmp = sub(*(farray_ptr + k + 1), tmp2);
+				*(farray_ptr + kj + 1) = shr(tmp, 1);			move16();
+
+				tmp = add(*(farray_ptr + k), tmp1);
+				*(farray_ptr + k) = shr(tmp, 1);			move16();
+
+				tmp = add(*(farray_ptr + k + 1), tmp2);
+				*(farray_ptr + k + 1) = shr(tmp, 1);			move16();
+			}
+
+			ji =  add(ji, ii2);
+		}
+	}
+}								/* end of c_fft () */
+
+
+
+void r_fft(Word16 * farray_ptr)
+{
+
+	Word16 ftmp1_real, ftmp1_imag, ftmp2_real, ftmp2_imag;
+	Word32 Lftmp1_real, Lftmp1_imag;
+	Word16 i, j;
+	Word32 Ltmp1;
+
+	/* Perform the complex FFT */
+	c_fft(farray_ptr);
+
+	/* First, handle the DC and foldover frequencies */
+	ftmp1_real = *farray_ptr;							move16();
+	ftmp2_real = *(farray_ptr + 1);							move16();
+	*farray_ptr = add(ftmp1_real, ftmp2_real);					move16();
+	*(farray_ptr + 1) = sub(ftmp1_real, ftmp2_real);				move16();
+
+	/* Now, handle the remaining positive frequencies */
+	for (i = 2, j = SIZE - i; i <= SIZE_BY_TWO; i = i + 2, j = SIZE - i)
+	{
+		ftmp1_real = add(*(farray_ptr + i), *(farray_ptr + j));
+		ftmp1_imag = sub(*(farray_ptr + i + 1), *(farray_ptr + j + 1));
+		ftmp2_real = add(*(farray_ptr + i + 1), *(farray_ptr + j + 1));
+		ftmp2_imag = sub(*(farray_ptr + j), *(farray_ptr + i));
+
+		Lftmp1_real = L_deposit_h(ftmp1_real);
+		Lftmp1_imag = L_deposit_h(ftmp1_imag);
+
+		Ltmp1 = L_mac(Lftmp1_real, ftmp2_real, phs_tbl[i]);
+		Ltmp1 = L_msu(Ltmp1, ftmp2_imag, phs_tbl[i + 1]);
+		*(farray_ptr + i) = round(L_shr(Ltmp1, 1));				move16();
+
+		Ltmp1 = L_mac(Lftmp1_imag, ftmp2_imag, phs_tbl[i]);
+		Ltmp1 = L_mac(Ltmp1, ftmp2_real, phs_tbl[i + 1]);
+		*(farray_ptr + i + 1) = round(L_shr(Ltmp1, 1));				move16();
+
+		Ltmp1 = L_mac(Lftmp1_real, ftmp2_real, phs_tbl[j]);
+		Ltmp1 = L_mac(Ltmp1, ftmp2_imag, phs_tbl[j + 1]);
+		*(farray_ptr + j) = round(L_shr(Ltmp1, 1));				move16();
+
+		Ltmp1 = L_negate(Lftmp1_imag);
+		Ltmp1 = L_msu(Ltmp1, ftmp2_imag, phs_tbl[j]);
+		Ltmp1 = L_mac(Ltmp1, ftmp2_real, phs_tbl[j + 1]);
+		*(farray_ptr + j + 1) = round(L_shr(Ltmp1, 1));				move16();
+
+	}
+}								/* end r_fft () */
diff -Nur FFMpeg-20050127/libavcodec/amr/reorder.c FFMpeg-20050127-new/libavcodec/amr/reorder.c
--- FFMpeg-20050127/libavcodec/amr/reorder.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/reorder.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,74 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : reorder.c
+*      Purpose          : To make sure that the LSFs are properly ordered
+*                       : and to keep a certain minimum distance between
+*                       : adjacent LSFs. 
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "reorder.h"
+const char reorder_id[] = "@(#)$Id $" reorder_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+ 
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+/*************************************************************************
+ *
+ *  FUNCTION:  Reorder_lsf()
+ *
+ *  PURPOSE: To make sure that the LSFs are properly ordered and to keep a
+ *           certain minimum distance between adjacent LSFs.
+ *
+ *           The LSFs are in the frequency range 0-0.5 and represented in Q15
+ *
+ *************************************************************************/
+void Reorder_lsf (
+    Word16 *lsf,        /* (i/o)     : vector of LSFs   (range: 0<=val<=0.5) */
+    Word16 min_dist,    /* (i)       : minimum required distance             */
+    Word16 n            /* (i)       : LPC order                             */
+)
+{
+    Word16 i;
+    Word16 lsf_min;
+
+    lsf_min = min_dist;         move16 (); 
+    for (i = 0; i < n; i++)
+    {
+        test (); 
+        if (sub (lsf[i], lsf_min) < 0)
+        {
+            lsf[i] = lsf_min;   move16 (); 
+        }
+        lsf_min = add (lsf[i], min_dist);
+    }
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/reorder.h FFMpeg-20050127-new/libavcodec/amr/reorder.h
--- FFMpeg-20050127/libavcodec/amr/reorder.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/reorder.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,44 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : reorder.h
+*      Purpose          : To make sure that the LSFs are properly ordered
+*                       : and to keep a certain minimum distance between
+*                       : adjacent LSFs. 
+*
+********************************************************************************
+*/
+#ifndef reorder_h
+#define reorder_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+void Reorder_lsf (
+    Word16 *lsf,       /* (i/o)  : vector of LSFs   (range: 0<=val<=0.5)    */
+    Word16 min_dist,   /* (i)    : minimum required distance                */
+    Word16 n           /* (i)    : LPC order                                */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/residu.c FFMpeg-20050127-new/libavcodec/amr/residu.c
--- FFMpeg-20050127/libavcodec/amr/residu.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/residu.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,74 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : residu.c
+*      Purpose          : Computes the LP residual.
+*      Description      : The LP residual is computed by filtering the input
+*                       : speech through the LP inverse filter A(z).
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "residu.h"
+const char residu_id[] = "@(#)$Id $" residu_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+/*
+*--------------------------------------*
+* Constants (defined in cnst.h         *
+*--------------------------------------*
+*  M         : LPC order               *
+*--------------------------------------*
+*/
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+void Residu (
+    Word16 a[], /* (i)     : prediction coefficients                      */
+    Word16 x[], /* (i)     : speech signal                                */
+    Word16 y[], /* (o)     : residual signal                              */
+    Word16 lg   /* (i)     : size of filtering                            */
+)
+{
+    Word16 i, j;
+    Word32 s;
+
+    for (i = 0; i < lg; i++)
+    {
+        s = L_mult (x[i], a[0]);
+        for (j = 1; j <= M; j++)
+        {
+            s = L_mac (s, a[j], x[i - j]);
+        }
+        s = L_shl (s, 3);
+        y[i] = round (s);       move16 (); 
+    }
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/residu.h FFMpeg-20050127-new/libavcodec/amr/residu.h
--- FFMpeg-20050127/libavcodec/amr/residu.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/residu.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,47 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : residu.h
+*      Purpose          : Computes the LP residual.
+*      Description      : The LP residual is computed by filtering the input
+*                       : speech through the LP inverse filter A(z).
+*
+*
+********************************************************************************
+*/
+#ifndef residu_h
+#define residu_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+ 
+void Residu (
+    Word16 a[],        /* (i)  : prediction coefficients                    */
+    Word16 x[],        /* (i)  : speech signal                              */
+    Word16 y[],        /* (o)  : residual signal                            */
+    Word16 lg          /* (i)  : size of filtering                          */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/s10_8pf.c FFMpeg-20050127-new/libavcodec/amr/s10_8pf.c
--- FFMpeg-20050127/libavcodec/amr/s10_8pf.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/s10_8pf.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,458 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : s10_8pf.c
+*      Purpose          : Searches a 35/31 bit algebraic codebook containing 
+*                       : 10/8 pulses in a frame of 40 samples.
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "s10_8pf.h"
+const char s10_8pf_id[] = "@(#)$Id $" s10_8pf_h;
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ *  FUNCTION  search_10and8i40()
+ *
+ *  PURPOSE: Search the best codevector; determine positions of the 10/8 
+ *           pulses in the 40-sample frame.
+ *
+ *   search_10and8i40 (10,5,5,dn, rr, ipos, pos_max, codvec);   for GSMEFR
+ *   search_10and8i40 (8, 4,4,dn, rr, ipos, pos_max, codvec);   for 10.2
+ *
+ *************************************************************************/
+
+#define _1_2    (Word16)(32768L/2)
+#define _1_4    (Word16)(32768L/4)
+#define _1_8    (Word16)(32768L/8)
+#define _1_16   (Word16)(32768L/16)
+#define _1_32   (Word16)(32768L/32)
+#define _1_64   (Word16)(32768L/64)
+#define _1_128  (Word16)(32768L/128)
+
+void search_10and8i40 (
+    Word16 nbPulse,      /* i : nbpulses to find                       */
+    Word16 step,         /* i :  stepsize                              */
+    Word16 nbTracks,     /* i :  nbTracks                              */
+    Word16 dn[],         /* i : correlation between target and h[]     */
+    Word16 rr[][L_CODE], /* i : matrix of autocorrelation              */
+    Word16 ipos[],       /* i : starting position for each pulse       */
+    Word16 pos_max[],    /* i : position of maximum of dn[]            */
+    Word16 codvec[]      /* o : algebraic codebook vector              */
+)
+{
+   Word16 i0, i1, i2, i3, i4, i5, i6, i7, i8, i9;
+   Word16 i, j, k, pos, ia, ib;
+   Word16 psk, ps, ps0, ps1, ps2, sq, sq2;
+   Word16 alpk, alp, alp_16;
+   Word16 rrv[L_CODE];
+   Word32 s, alp0, alp1, alp2;
+   Word16 gsmefrFlag;
+   
+
+   test(); 
+   if (sub(nbPulse, 10) == 0)
+   {
+      gsmefrFlag=1;                             move16 ();
+   }
+   else
+   {
+      gsmefrFlag=0;                             move16 (); 
+   }
+
+   /* fix i0 on maximum of correlation position */
+   i0 = pos_max[ipos[0]];                       move16 (); 
+   
+   /*------------------------------------------------------------------*
+    * i1 loop:                                                         *
+    *------------------------------------------------------------------*/
+   
+   /* Default value */
+   psk = -1;                                    move16 (); 
+   alpk = 1;                                    move16 (); 
+   for (i = 0; i < nbPulse; i++)
+   {
+      codvec[i] = i;                            move16 ();
+   }
+
+   for (i = 1; i < nbTracks; i++)
+   {
+      i1 = pos_max[ipos[1]];                    move16 (); 
+      ps0 = add (dn[i0], dn[i1]);
+      alp0 = L_mult (rr[i0][i0], _1_16);
+      alp0 = L_mac (alp0, rr[i1][i1], _1_16);
+      alp0 = L_mac (alp0, rr[i0][i1], _1_8);
+      
+      /*----------------------------------------------------------------*
+       * i2 and i3 loop:                                                *
+       *----------------------------------------------------------------*/
+      
+      /* initialize 4 indices for next loop. */
+      move16 (); /* initialize "rr[i3][i3]" pointer */
+      move16 (); /* initialize "rr[i0][i3]" pointer */
+      move16 (); /* initialize "rr[i1][i3]" pointer */
+      move16 (); /* initialize "rrv[i3]" pointer    */
+      
+      for (i3 = ipos[3]; i3 < L_CODE; i3 += step)
+      {
+         s = L_mult (rr[i3][i3], _1_8);       /* index incr= step+L_CODE */
+         s = L_mac (s, rr[i0][i3], _1_4);     /* index increment = step  */
+         s = L_mac (s, rr[i1][i3], _1_4);     /* index increment = step  */
+         rrv[i3] = round (s);                 move16 (); 
+      }
+      
+      /* Default value */
+      sq = -1;                                 move16 (); 
+      alp = 1;                                 move16 (); 
+      ps = 0;                                  move16 ();
+      ia = ipos[2];                            move16 ();
+      ib = ipos[3];                            move16 ();
+      
+      /* initialize 4 indices for i2 loop. */
+      move16 (); /* initialize "dn[i2]" pointer     */
+      move16 (); /* initialize "rr[i2][i2]" pointer */
+      move16 (); /* initialize "rr[i0][i2]" pointer */
+      move16 (); /* initialize "rr[i1][i2]" pointer */
+        
+      for (i2 = ipos[2]; i2 < L_CODE; i2 += step)
+      {
+         /* index increment = step  */            
+         ps1 = add (ps0, dn[i2]);    
+         
+         /* index incr= step+L_CODE */
+         alp1 = L_mac (alp0, rr[i2][i2], _1_16);
+            /* index increment = step  */
+         alp1 = L_mac (alp1, rr[i0][i2], _1_8);
+         /* index increment = step  */
+         alp1 = L_mac (alp1, rr[i1][i2], _1_8);
+         
+         /* initialize 3 indices for i3 inner loop */
+         move16 (); /* initialize "dn[i3]" pointer     */
+         move16 (); /* initialize "rrv[i3]" pointer    */
+         move16 (); /* initialize "rr[i2][i3]" pointer */
+         
+         for (i3 = ipos[3]; i3 < L_CODE; i3 += step)
+         {
+            /* index increment = step */                
+            ps2 = add (ps1, dn[i3]);    
+                
+            /* index increment = step */
+            alp2 = L_mac (alp1, rrv[i3], _1_2);
+            /* index increment = step */
+            alp2 = L_mac (alp2, rr[i2][i3], _1_8);
+            
+            sq2 = mult (ps2, ps2);
+            
+            alp_16 = round (alp2);
+            
+            s = L_msu (L_mult (alp, sq2), sq, alp_16);
+                
+            test (); 
+            if (s > 0)
+            {
+               sq = sq2;                    move16 (); 
+               ps = ps2;                    move16 (); 
+               alp = alp_16;                move16 (); 
+               ia = i2;                     move16 (); 
+               ib = i3;                     move16 (); 
+            }
+         }
+      }
+      i2 = ia;                                 move16 (); 
+      i3 = ib;                                 move16 (); 
+      
+        /*----------------------------------------------------------------*
+         * i4 and i5 loop:                                                *
+         *----------------------------------------------------------------*/
+        
+        ps0 = ps;                                move16 (); 
+        alp0 = L_mult (alp, _1_2);
+        
+        /* initialize 6 indices for next loop (see i2-i3 loop) */
+        move16 (); move16 (); move16 (); move16 (); move16 (); move16 (); 
+        
+        for (i5 = ipos[5]; i5 < L_CODE; i5 += step)
+        {
+            s = L_mult (rr[i5][i5], _1_8);
+            s = L_mac (s, rr[i0][i5], _1_4);
+            s = L_mac (s, rr[i1][i5], _1_4);
+            s = L_mac (s, rr[i2][i5], _1_4);
+            s = L_mac (s, rr[i3][i5], _1_4);
+            rrv[i5] = round (s);                 move16 (); 
+        }
+        
+        /* Default value */
+        sq = -1;                                 move16 (); 
+        alp = 1;                                 move16 (); 
+        ps = 0;                                  move16 ();
+        ia = ipos[4];                            move16 ();
+        ib = ipos[5];                            move16 ();
+        
+        /* initialize 6 indices for i4 loop (see i2-i3 loop) */
+        move16 (); move16 (); move16 (); move16 (); move16 (); move16 (); 
+        
+        for (i4 = ipos[4]; i4 < L_CODE; i4 += step)
+        {
+            ps1 = add (ps0, dn[i4]);
+            
+            alp1 = L_mac (alp0, rr[i4][i4], _1_32);
+            alp1 = L_mac (alp1, rr[i0][i4], _1_16);
+            alp1 = L_mac (alp1, rr[i1][i4], _1_16);
+            alp1 = L_mac (alp1, rr[i2][i4], _1_16);
+            alp1 = L_mac (alp1, rr[i3][i4], _1_16);
+            
+            /* initialize 3 indices for i5 inner loop (see i2-i3 loop) */
+            move16 (); move16 (); move16 (); 
+            
+            for (i5 = ipos[5]; i5 < L_CODE; i5 += step)
+            {
+                ps2 = add (ps1, dn[i5]);
+                
+                alp2 = L_mac (alp1, rrv[i5], _1_4);
+                alp2 = L_mac (alp2, rr[i4][i5], _1_16);
+                
+                sq2 = mult (ps2, ps2);
+                
+                alp_16 = round (alp2);
+                
+                s = L_msu (L_mult (alp, sq2), sq, alp_16);
+                
+                test (); 
+                if (s > 0)
+                {
+                    sq = sq2;                    move16 (); 
+                    ps = ps2;                    move16 (); 
+                    alp = alp_16;                move16 (); 
+                    ia = i4;                     move16 (); 
+                    ib = i5;                     move16 (); 
+                }
+            }
+        }
+        i4 = ia;                                 move16 (); 
+        i5 = ib;                                 move16 (); 
+        
+        /*----------------------------------------------------------------*
+         * i6 and i7 loop:                                                *
+         *----------------------------------------------------------------*/
+        
+        ps0 = ps;                                move16 (); 
+        alp0 = L_mult (alp, _1_2);
+        
+        /* initialize 8 indices for next loop (see i2-i3 loop) */
+        move16 (); move16 (); move16 (); move16 (); 
+        move16 (); move16 (); move16 (); move16 (); 
+        
+        for (i7 = ipos[7]; i7 < L_CODE; i7 += step)
+        {
+            s = L_mult (rr[i7][i7], _1_16);
+            s = L_mac (s, rr[i0][i7], _1_8);
+            s = L_mac (s, rr[i1][i7], _1_8);
+            s = L_mac (s, rr[i2][i7], _1_8);
+            s = L_mac (s, rr[i3][i7], _1_8);
+            s = L_mac (s, rr[i4][i7], _1_8);
+            s = L_mac (s, rr[i5][i7], _1_8);
+            rrv[i7] = round (s);                 move16 (); 
+        }
+        
+        /* Default value */
+        sq = -1;                                 move16 (); 
+        alp = 1;                                 move16 (); 
+        ps = 0;                                  move16 ();
+        ia = ipos[6];                            move16 ();
+        ib = ipos[7];                            move16 ();
+        
+        /* initialize 8 indices for i6 loop (see i2-i3 loop) */
+        move16 (); move16 (); move16 (); move16 (); 
+        move16 (); move16 (); move16 (); move16 (); 
+        
+        for (i6 = ipos[6]; i6 < L_CODE; i6 += step)
+        {
+            ps1 = add (ps0, dn[i6]);
+            
+            alp1 = L_mac (alp0, rr[i6][i6], _1_64);
+            alp1 = L_mac (alp1, rr[i0][i6], _1_32);
+            alp1 = L_mac (alp1, rr[i1][i6], _1_32);
+            alp1 = L_mac (alp1, rr[i2][i6], _1_32);
+            alp1 = L_mac (alp1, rr[i3][i6], _1_32);
+            alp1 = L_mac (alp1, rr[i4][i6], _1_32);
+            alp1 = L_mac (alp1, rr[i5][i6], _1_32);
+            
+            /* initialize 3 indices for i7 inner loop (see i2-i3 loop) */
+            move16 (); move16 (); move16 (); 
+            
+            for (i7 = ipos[7]; i7 < L_CODE; i7 += step)
+            {
+                ps2 = add (ps1, dn[i7]);
+                
+                alp2 = L_mac (alp1, rrv[i7], _1_4);
+                alp2 = L_mac (alp2, rr[i6][i7], _1_32);
+                
+                sq2 = mult (ps2, ps2);
+                
+                alp_16 = round (alp2);
+                
+                s = L_msu (L_mult (alp, sq2), sq, alp_16);
+                
+                test (); 
+                if (s > 0)
+                {
+                    sq = sq2;                    move16 (); 
+                    ps = ps2;                    move16 (); 
+                    alp = alp_16;                move16 (); 
+                    ia = i6;                     move16 (); 
+                    ib = i7;                     move16 (); 
+                }
+            }
+        }
+        i6 = ia;                                 move16 (); 
+        i7 = ib;                                 move16 (); 
+        
+        /* now finished searching a set of 8 pulses */
+
+        test();
+        if(gsmefrFlag != 0){
+           /* go on with the two last pulses for GSMEFR                      */
+           /*----------------------------------------------------------------*
+            * i8 and i9 loop:                                                *
+            *----------------------------------------------------------------*/
+        
+           ps0 = ps;                                move16 (); 
+           alp0 = L_mult (alp, _1_2);
+           
+           /* initialize 10 indices for next loop (see i2-i3 loop) */
+           move16 (); move16 (); move16 (); move16 (); move16 (); 
+           move16 (); move16 (); move16 (); move16 (); move16 (); 
+           
+           for (i9 = ipos[9]; i9 < L_CODE; i9 += step)
+           {
+              s = L_mult (rr[i9][i9], _1_16);
+              s = L_mac (s, rr[i0][i9], _1_8);
+              s = L_mac (s, rr[i1][i9], _1_8);
+              s = L_mac (s, rr[i2][i9], _1_8);
+              s = L_mac (s, rr[i3][i9], _1_8);
+              s = L_mac (s, rr[i4][i9], _1_8);
+              s = L_mac (s, rr[i5][i9], _1_8);
+              s = L_mac (s, rr[i6][i9], _1_8);
+              s = L_mac (s, rr[i7][i9], _1_8);
+              rrv[i9] = round (s);                 move16 (); 
+           }
+           
+           /* Default value */
+           sq = -1;                                 move16 (); 
+           alp = 1;                                 move16 (); 
+           ps = 0;                                  move16 ();
+           ia = ipos[8];                            move16 ();
+           ib = ipos[9];                            move16 ();
+           
+           /* initialize 10 indices for i8 loop (see i2-i3 loop) */
+           move16 (); move16 (); move16 (); move16 (); move16 (); 
+           move16 (); move16 (); move16 (); move16 (); move16 (); 
+           
+           for (i8 = ipos[8]; i8 < L_CODE; i8 += step)
+           {
+              ps1 = add (ps0, dn[i8]);
+              
+              alp1 = L_mac (alp0, rr[i8][i8], _1_128);
+              alp1 = L_mac (alp1, rr[i0][i8], _1_64);
+              alp1 = L_mac (alp1, rr[i1][i8], _1_64);
+              alp1 = L_mac (alp1, rr[i2][i8], _1_64);
+              alp1 = L_mac (alp1, rr[i3][i8], _1_64);
+              alp1 = L_mac (alp1, rr[i4][i8], _1_64);
+              alp1 = L_mac (alp1, rr[i5][i8], _1_64);
+              alp1 = L_mac (alp1, rr[i6][i8], _1_64);
+              alp1 = L_mac (alp1, rr[i7][i8], _1_64);
+              
+              /* initialize 3 indices for i9 inner loop (see i2-i3 loop) */
+              move16 (); move16 (); move16 (); 
+              
+              for (i9 = ipos[9]; i9 < L_CODE; i9 += step)
+              {
+                 ps2 = add (ps1, dn[i9]);
+                 
+                 alp2 = L_mac (alp1, rrv[i9], _1_8);
+                 alp2 = L_mac (alp2, rr[i8][i9], _1_64);
+                 
+                 sq2 = mult (ps2, ps2);
+                
+                 alp_16 = round (alp2);
+                 
+                 s = L_msu (L_mult (alp, sq2), sq, alp_16);
+                 
+                 test (); 
+                 if (s > 0)
+                 {
+                    sq = sq2;                    move16 (); 
+                    ps = ps2;                    move16 (); 
+                    alp = alp_16;                move16 (); 
+                    ia = i8;                     move16 (); 
+                    ib = i9;                     move16 (); 
+                 }
+              }
+           }
+        }/* end  gsmefrFlag */
+        
+        /*----------------------------------------------------------------  *
+         * test and memorise if this combination is better than the last one.*
+         *----------------------------------------------------------------*/
+        
+        s = L_msu (L_mult (alpk, sq), psk, alp);
+        
+        test (); 
+        if (s > 0)
+        {
+            psk = sq;                            move16 (); 
+            alpk = alp;                          move16 (); 
+            codvec[0] = i0;                      move16 (); 
+            codvec[1] = i1;                      move16 (); 
+            codvec[2] = i2;                      move16 (); 
+            codvec[3] = i3;                      move16 (); 
+            codvec[4] = i4;                      move16 (); 
+            codvec[5] = i5;                      move16 (); 
+            codvec[6] = i6;                      move16 (); 
+            codvec[7] = i7;                      move16 ();
+         
+            test();
+            if (gsmefrFlag != 0)
+            {
+               codvec[8] = ia;                   move16 (); 
+               codvec[9] = ib;                   move16 (); 
+            }
+        }
+        /*----------------------------------------------------------------*
+         * Cyclic permutation of i1,i2,i3,i4,i5,i6,i7,(i8 and i9).          *
+         *----------------------------------------------------------------*/
+        
+        pos = ipos[1];                           move16 (); 
+        for (j = 1, k = 2; k < nbPulse; j++, k++)
+        {
+            ipos[j] = ipos[k];                   move16 (); 
+        }
+        ipos[sub(nbPulse,1)] = pos;              move16 (); 
+   } /* end 1..nbTracks  loop*/
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/s10_8pf.h FFMpeg-20050127-new/libavcodec/amr/s10_8pf.h
--- FFMpeg-20050127/libavcodec/amr/s10_8pf.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/s10_8pf.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,50 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : s10_8pf.h
+*      Purpose          : Searches a 35/31 bit algebraic codebook containing 
+*                       : 10/8 pulses in a frame of 40 samples.
+*
+********************************************************************************
+*/
+#ifndef s10_8pf_h
+#define s10_8pf_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "cnst.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+
+void search_10and8i40 (
+    Word16 nbPulse,      /* i : nbpulses to find                       */
+    Word16 step,         /* i :  stepsize                              */
+    Word16 nbTracks,     /* i :  nbTracks                              */
+    Word16 dn[],         /* i : correlation between target and h[]     */
+    Word16 rr[][L_CODE], /* i : matrix of autocorrelation              */
+    Word16 ipos[],       /* i : starting position for each pulse       */
+    Word16 pos_max[],    /* i : position of maximum of dn[]            */
+    Word16 codvec[]      /* o : algebraic codebook vector              */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/set_sign.c FFMpeg-20050127-new/libavcodec/amr/set_sign.c
--- FFMpeg-20050127/libavcodec/amr/set_sign.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/set_sign.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,213 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : set_sign.c
+*      Purpose          : Builds sign vector according to "dn[]" and "cn[]".
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "set_sign.h"
+const char set_sign_id[] = "@(#)$Id $" set_sign_h;
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "inv_sqrt.h"
+#include "cnst.h" 
+ 
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ *  FUNCTION  set_sign()
+ *
+ *  PURPOSE: Builds sign[] vector according to "dn[]" and "cn[]".
+ *           Also finds the position of maximum of correlation in each track
+ *           and the starting position for each pulse.
+ *
+ *************************************************************************/
+void set_sign(Word16 dn[],   /* i/o : correlation between target and h[]    */
+              Word16 sign[], /* o   : sign of dn[]                          */
+              Word16 dn2[],  /* o   : maximum of correlation in each track. */
+              Word16 n       /* i   : # of maximum correlations in dn2[]    */
+)
+{
+   Word16 i, j, k;
+   Word16 val, min;
+   Word16 pos = 0; /* initialization only needed to keep gcc silent */
+   
+   /* set sign according to dn[] */
+   
+   for (i = 0; i < L_CODE; i++) {
+      val = dn[i];                                 move16 ();
+      
+      test ();
+      if (val >= 0) {
+         sign[i] = 32767;                          move16 ();
+      } else {
+         sign[i] = -32767;                         move16 ();
+         val = negate(val);
+      }
+      dn[i] = val;    move16 (); /* modify dn[] according to the fixed sign */
+      dn2[i] = val;   move16 ();
+   }
+   
+   /* keep 8-n maximum positions/8 of each track and store it in dn2[] */
+   
+   for (i = 0; i < NB_TRACK; i++)
+   {
+      for (k = 0; k < (8-n); k++)
+      {
+         min = 0x7fff;                             move16 ();
+         for (j = i; j < L_CODE; j += STEP)
+         {
+            test ();                               move16 ();
+            if (dn2[j] >= 0)
+            {
+               val = sub(dn2[j], min);
+               test ();
+               if (val < 0)
+               {
+                  min = dn2[j];                    move16 ();
+                  pos = j;                         move16 ();
+               }
+            }
+         }
+         dn2[pos] = -1;                            move16 ();
+      }
+   }
+   
+   return;
+}
+
+/*************************************************************************
+ *
+ *  FUNCTION  set_sign12k2()
+ *
+ *  PURPOSE: Builds sign[] vector according to "dn[]" and "cn[]", and modifies
+ *           dn[] to include the sign information (dn[i]=sign[i]*dn[i]).
+ *           Also finds the position of maximum of correlation in each track
+ *           and the starting position for each pulse.
+ *
+ *************************************************************************/
+void set_sign12k2 (
+    Word16 dn[],      /* i/o : correlation between target and h[]         */
+    Word16 cn[],      /* i   : residual after long term prediction        */
+    Word16 sign[],    /* o   : sign of d[n]                               */
+    Word16 pos_max[], /* o   : position of maximum correlation            */
+    Word16 nb_track,  /* i   : number of tracks tracks                    */        
+    Word16 ipos[],    /* o   : starting position for each pulse           */
+    Word16 step       /* i   : the step size in the tracks                */        
+)
+{
+    Word16 i, j;
+    Word16 val, cor, k_cn, k_dn, max, max_of_all;
+    Word16 pos = 0; /* initialization only needed to keep gcc silent */
+    Word16 en[L_CODE];                  /* correlation vector */
+    Word32 s;
+ 
+    /* calculate energy for normalization of cn[] and dn[] */
+ 
+    s = 256;                                     move32 (); 
+    for (i = 0; i < L_CODE; i++)
+    {
+        s = L_mac (s, cn[i], cn[i]);
+    }
+    s = Inv_sqrt (s);                            move32 (); 
+    k_cn = extract_h (L_shl (s, 5));
+    
+    s = 256;                                     move32 (); 
+    for (i = 0; i < L_CODE; i++)
+    {
+        s = L_mac (s, dn[i], dn[i]);
+    }
+    s = Inv_sqrt (s);                            move32 (); 
+    k_dn = extract_h (L_shl (s, 5));
+    
+    for (i = 0; i < L_CODE; i++)
+    {
+        val = dn[i];                             move16 (); 
+        cor = round (L_shl (L_mac (L_mult (k_cn, cn[i]), k_dn, val), 10));
+ 
+        test (); 
+        if (cor >= 0)
+        {
+            sign[i] = 32767;                     move16 (); /* sign = +1 */
+        }
+        else
+        {
+            sign[i] = -32767;                    move16 (); /* sign = -1 */
+            cor = negate (cor);
+            val = negate (val);
+        }
+        /* modify dn[] according to the fixed sign */        
+        dn[i] = val;                             move16 (); 
+        en[i] = cor;                             move16 (); 
+    }
+    
+    max_of_all = -1;                             move16 (); 
+    for (i = 0; i < nb_track; i++)
+    {
+        max = -1;                                move16 (); 
+        
+        for (j = i; j < L_CODE; j += step)
+        {
+            cor = en[j];                         move16 (); 
+            val = sub (cor, max);
+            test (); 
+            if (val > 0)
+            {
+                max = cor;                       move16 (); 
+                pos = j;                         move16 (); 
+            }
+        }
+        /* store maximum correlation position */
+        pos_max[i] = pos;                        move16 (); 
+        val = sub (max, max_of_all);
+        test (); 
+        if (val > 0)
+        {
+            max_of_all = max;                    move16 ();
+            /* starting position for i0 */            
+            ipos[0] = i;                         move16 (); 
+        }
+    }
+    
+    /*----------------------------------------------------------------*
+     *     Set starting position of each pulse.                       *
+     *----------------------------------------------------------------*/
+    
+    pos = ipos[0];                               move16 (); 
+    ipos[nb_track] = pos;                        move16 (); 
+    
+    for (i = 1; i < nb_track; i++)
+    {
+        pos = add (pos, 1);
+        test ();
+        if (sub (pos, nb_track) >= 0)
+        {
+           pos = 0;                              move16 (); 
+        }
+        ipos[i] = pos;                           move16 (); 
+        ipos[add(i, nb_track)] = pos;            move16 (); 
+    }
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/set_sign.h FFMpeg-20050127-new/libavcodec/amr/set_sign.h
--- FFMpeg-20050127/libavcodec/amr/set_sign.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/set_sign.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,50 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : set_sign.h
+*      Purpose          : Builds sign vector according to "dn[]" and "cn[]".
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#ifndef set_sign_h
+#define set_sign_h "@(#)$Id $"
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+void set_sign(Word16 dn[],   /* i/o : correlation between target and h[]    */
+              Word16 sign[], /* o   : sign of dn[]                          */
+              Word16 dn2[],  /* o   : maximum of correlation in each track. */
+              Word16 n       /* i   : # of maximum correlations in dn2[]    */
+);
+
+void set_sign12k2 (
+    Word16 dn[],      /* i/o : correlation between target and h[]         */
+    Word16 cn[],      /* i   : residual after long term prediction        */
+    Word16 sign[],    /* o   : sign of d[n]                               */
+    Word16 pos_max[], /* o   : position of maximum correlation            */
+    Word16 nb_track,  /* i   : number of tracks tracks                    */        
+    Word16 ipos[],    /* o   : starting position for each pulse           */
+    Word16 step       /* i   : the step size in the tracks                */        
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/set_zero.c FFMpeg-20050127-new/libavcodec/amr/set_zero.c
--- FFMpeg-20050127/libavcodec/amr/set_zero.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/set_zero.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,48 @@
+/*
+********************************************************************************
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : set_zero.h
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "set_zero.h"
+const char set_zero_id[] = "@(#)$Id $" set_zero_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+void Set_zero (
+    Word16 x[],         /* (o)    : vector to clear     */
+    Word16 L            /* (i)    : length of vector    */
+)
+{
+    Word16 i;
+
+    for (i = 0; i < L; i++)
+    {
+        x[i] = 0;               move16 (); 
+    }
+
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/set_zero.h FFMpeg-20050127-new/libavcodec/amr/set_zero.h
--- FFMpeg-20050127/libavcodec/amr/set_zero.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/set_zero.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,43 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : set_zero.h
+*      Description      : Set vector x[] to zero
+*
+*
+********************************************************************************
+*/
+#ifndef set_zero_h
+#define set_zero_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+ 
+void Set_zero (
+    Word16 x[],        /* (o)  : vector to clear                            */
+    Word16 L           /* (i)  : length of vector                           */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/sid_sync.c FFMpeg-20050127-new/libavcodec/amr/sid_sync.c
--- FFMpeg-20050127/libavcodec/amr/sid_sync.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/sid_sync.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,142 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : sid_sync.c
+*
+*****************************************************************************
+*/
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "sid_sync.h"
+const char sid_sync_id[] = "@(#)$Id $" sid_sync_h;
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include <stdio.h>
+#include <stdlib.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "mode.h"
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+int sid_sync_init (sid_syncState **state)
+{
+    sid_syncState* s;
+    if (state == (sid_syncState **) NULL){
+        fprintf(stderr, "sid_sync_init:invalid state parameter\n");
+        return -1;
+    }
+
+    *state = NULL;
+
+    /* allocate memory */
+    if ((s= (sid_syncState *)
+         malloc(sizeof(sid_syncState))) == NULL){
+        fprintf(stderr,
+                "sid_sync_init: "
+                "can not malloc state structure\n");
+        return -1;
+    }
+    s->sid_update_rate = 8;
+    *state = s;
+    return sid_sync_reset(s);
+}
+
+int sid_sync_reset (sid_syncState *st)
+{
+    st->sid_update_counter = 3;
+    st->sid_handover_debt = 0;
+    st->prev_ft = TX_SPEECH_GOOD;
+    return 0;
+}
+
+
+void sid_sync_exit (sid_syncState **state)
+{
+  if (state == NULL || *state == NULL)
+      return;
+ 
+  /* deallocate memory */
+  free(*state);
+  *state = NULL;
+  
+  return;
+
+}
+
+int sid_sync_set_handover_debt (sid_syncState *st,
+                                Word16 debtFrames) 
+{
+   /* debtFrames >= 0 */ 
+   st->sid_handover_debt = debtFrames;
+   return 0;
+}
+
+
+void sid_sync (sid_syncState *st, enum Mode mode,
+               enum TXFrameType *tx_frame_type)
+{
+ 
+    if ( mode == MRDTX){
+
+       st->sid_update_counter--;
+       
+        if (st->prev_ft == TX_SPEECH_GOOD) 
+        {
+           *tx_frame_type = TX_SID_FIRST;
+           st->sid_update_counter = 3;
+        } 
+        else 
+        {
+           /* TX_SID_UPDATE or TX_NO_DATA */
+           if( (st->sid_handover_debt > 0) &&
+               (st->sid_update_counter > 2) )
+           {
+              /* ensure extra updates are  properly delayed after 
+                 a possible SID_FIRST */
+              *tx_frame_type = TX_SID_UPDATE;
+              st->sid_handover_debt--;
+           }
+           else 
+           {
+              if (st->sid_update_counter == 0)
+              {
+                 *tx_frame_type = TX_SID_UPDATE;
+                 st->sid_update_counter = st->sid_update_rate;
+              } else {
+                 *tx_frame_type = TX_NO_DATA;
+              }
+           }
+        }
+    }
+    else
+    {
+       st->sid_update_counter = st->sid_update_rate ;
+       *tx_frame_type = TX_SPEECH_GOOD;
+    }
+    st->prev_ft = *tx_frame_type;
+}
+
diff -Nur FFMpeg-20050127/libavcodec/amr/sid_sync.h FFMpeg-20050127-new/libavcodec/amr/sid_sync.h
--- FFMpeg-20050127/libavcodec/amr/sid_sync.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/sid_sync.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,85 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : sid_sync.h
+*      Purpose          : To ensure that the mode only switches to a
+*                         neighbouring mode
+*
+*****************************************************************************
+*/
+#ifndef sid_sync_h
+#define sid_sync_h "$Id $"
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+#include "frame.h"
+ 
+/*
+******************************************************************************
+*                         CONSTANTS
+******************************************************************************
+*/
+
+/*
+******************************************************************************
+*                         DEFINITION OF DATA TYPES
+******************************************************************************
+*/
+typedef struct {
+    Word16 sid_update_rate;  /* Send SID Update every sid_update_rate frame */
+    Word16 sid_update_counter; /* Number of frames since last SID          */
+    Word16 sid_handover_debt;  /* Number of extra SID_UPD frames to schedule*/
+    enum TXFrameType prev_ft;
+} sid_syncState;
+ 
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+ 
+/*
+*****************************************************************************
+*                         DECLARATION OF PROTOTYPES
+*****************************************************************************
+*/
+int sid_sync_init (sid_syncState **st);
+/* initialize one instance of the sid_sync module
+   Stores pointer to state struct in *st. This pointer has to
+   be passed to sid_sync in each call.
+   returns 0 on success
+ */
+ 
+int sid_sync_reset (sid_syncState *st);
+/* reset of sid_sync module (i.e. set state memory to zero)
+   returns 0 on success
+ */
+void sid_sync_exit (sid_syncState **st);
+/* de-initialize sid_sync module (i.e. free status struct)
+   stores NULL in *st
+ */
+
+int sid_sync_set_handover_debt (sid_syncState *st, /* i/o: sid_sync state  */
+                                Word16 debtFrames);
+/*  update handover debt 
+    debtFrames extra SID_UPD are scheduled .
+    to update remote decoder CNI states, right after an handover.
+    (primarily for use on MS UL side )  
+*/ 
+
+ 
+void sid_sync(sid_syncState *st , /* i/o: sid_sync state      */
+              enum Mode mode,
+              enum TXFrameType *tx_frame_type); 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/sp_dec.c FFMpeg-20050127-new/libavcodec/amr/sp_dec.c
--- FFMpeg-20050127/libavcodec/amr/sp_dec.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/sp_dec.c	2003-02-18 11:32:00.000000000 +0000
@@ -0,0 +1,298 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : sp_dec.c
+*      Purpose          : Decoding and post filtering of one speech frame.
+*
+*****************************************************************************
+*/
+ 
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "sp_dec.h"
+const char sp_dec_id[] = "@(#)$Id $" sp_dec_h;
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+#include "set_zero.h"
+#include "dec_amr.h"
+#include "pstfilt.h"
+#include "bits2prm.h"
+#include "mode.h"
+#include "post_pro.h"
+
+#ifdef MMS_IO
+#include "bitno.tab"
+#endif
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+/*---------------------------------------------------------------*
+ *    Constants (defined in "cnst.h")                            *
+ *---------------------------------------------------------------*
+ * L_FRAME     :
+ * M           :
+ * PRM_SIZE    :
+ * AZ_SIZE     :
+ * SERIAL_SIZE :
+ *---------------------------------------------------------------*/
+
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+ 
+/*************************************************************************
+*
+*  Function:   Speech_Decode_Frame_init
+*  Purpose:    Allocates memory for filter structure and initializes
+*              state memory
+*
+**************************************************************************
+*/
+int Speech_Decode_Frame_init (Speech_Decode_FrameState **state,
+                              char *id)
+{
+  Speech_Decode_FrameState* s;
+ 
+  if (state == (Speech_Decode_FrameState **) NULL){
+      fprintf(stderr, "Speech_Decode_Frame_init: invalid parameter\n");
+      return -1;
+  }
+  *state = NULL;
+ 
+  /* allocate memory */
+  if ((s= (Speech_Decode_FrameState *)
+          malloc(sizeof(Speech_Decode_FrameState))) == NULL) {
+      fprintf(stderr, "Speech_Decode_Frame_init: can not malloc state "
+              "structure\n");
+      return -1;
+  }
+  s->decoder_amrState = NULL;
+  s->post_state = NULL;
+  s->postHP_state = NULL;
+
+  if (Decoder_amr_init(&s->decoder_amrState) ||
+      Post_Filter_init(&s->post_state) ||
+      Post_Process_init(&s->postHP_state) ) {
+      Speech_Decode_Frame_exit(&s);
+      return -1;
+  }
+
+  s->complexityCounter = getCounterId(id);
+  
+  Speech_Decode_Frame_reset(s);
+  *state = s;
+  
+  return 0;
+}
+ 
+/*************************************************************************
+*
+*  Function:   Speech_Decode_Frame_reset
+*  Purpose:    Resetses state memory
+*
+**************************************************************************
+*/
+int Speech_Decode_Frame_reset (Speech_Decode_FrameState *state)
+{
+  if (state == (Speech_Decode_FrameState *) NULL){
+      fprintf(stderr, "Speech_Decode_Frame_reset: invalid parameter\n");
+      return -1;
+  }
+  
+  Decoder_amr_reset(state->decoder_amrState, (enum Mode)0);
+  Post_Filter_reset(state->post_state);
+  Post_Process_reset(state->postHP_state);
+
+  state->prev_mode = (enum Mode)0;
+
+  setCounter(state->complexityCounter);
+  Init_WMOPS_counter();
+  setCounter(0); /* set counter to global counter */
+
+  return 0;
+}
+ 
+/*
+**************************************************************************
+*
+*  Function:   Speech_Decode_Frame_exit
+*  Purpose:    The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void Speech_Decode_Frame_exit (Speech_Decode_FrameState **state)
+{
+  if (state == NULL || *state == NULL)
+      return;
+ 
+  Decoder_amr_exit(&(*state)->decoder_amrState);
+  Post_Filter_exit(&(*state)->post_state);
+  Post_Process_exit(&(*state)->postHP_state);
+
+  setCounter((*state)->complexityCounter);
+  WMOPS_output(0);
+  setCounter(0); /* set counter to global counter */
+ 
+  /* deallocate memory */
+  free(*state);
+  *state = NULL;
+  
+  return;
+}
+ 
+int Speech_Decode_Frame (
+    Speech_Decode_FrameState *st, /* io: post filter states                */
+    enum Mode mode,               /* i : AMR mode                          */
+    Word16 *serial,               /* i : serial bit stream                 */
+    enum RXFrameType frame_type,    /* i : Frame type                        */
+    Word16 *synth                 /* o : synthesis speech (postfiltered    */
+                                  /*     output)                           */
+)
+{
+  Word16 parm[MAX_PRM_SIZE + 1];  /* Synthesis parameters                */
+  Word16 Az_dec[AZ_SIZE];         /* Decoded Az for post-filter          */
+                                  /* in 4 subframes                      */
+
+#if !defined(NO13BIT)
+  Word16 i;
+#endif
+
+  setCounter(st->complexityCounter);
+  Reset_WMOPS_counter ();          /* reset WMOPS counter for the new frame */
+
+
+  /* Serial to parameters   */
+  test(); test(); sub(0,0); sub(0,0); logic16();
+  if ((frame_type == RX_SID_BAD) ||
+      (frame_type == RX_SID_UPDATE)) {
+    /* Override mode to MRDTX */
+    Bits2prm (MRDTX, serial, parm);
+  } else {
+    Bits2prm (mode, serial, parm);
+  }
+
+  /* Synthesis */
+  Decoder_amr(st->decoder_amrState, mode, parm, frame_type,
+              synth, Az_dec);
+
+  Post_Filter(st->post_state, mode, synth, Az_dec);   /* Post-filter */
+
+  /* post HP filter, and 15->16 bits */
+  Post_Process(st->postHP_state, synth, L_FRAME);  
+  
+#if !defined(NO13BIT)
+  /* Truncate to 13 bits */
+  for (i = 0; i < L_FRAME; i++) 
+  {
+     synth[i] = synth[i] & 0xfff8;    logic16 (); move16 ();
+  }
+#endif
+  
+  fwc();          /* function worst case */
+  setCounter(0); /* set counter to global counter */
+  return 0;
+}
+
+#ifdef MMS_IO
+
+/*
+**************************************************************************
+*
+*  Function    : UnpackBits
+*  Purpose     : Unpack and re-arrange bits from file storage format to the
+*                format required by speech decoder.
+*
+**************************************************************************
+*/
+enum RXFrameType UnpackBits (
+    Word8  q,              /* i : Q-bit (i.e. BFI)        */
+	Word16 ft,             /* i : frame type (i.e. mode)  */
+    UWord8 packed_bits[],  /* i : sorted & packed bits    */
+	enum Mode *mode,       /* o : mode information        */
+    Word16 bits[]          /* o : serial bits             */
+)
+{
+	Word16 i, sid_type;
+	UWord8 *pack_ptr, temp;
+
+	pack_ptr = (UWord8*)packed_bits;
+
+	/* real NO_DATA frame or unspecified frame type */
+	if (ft == 15 || (ft > 8 && ft < 15))
+	{
+		*mode = (enum Mode)-1;
+		return RX_NO_DATA;
+	}
+
+	temp = *pack_ptr;
+	pack_ptr++;
+
+	for (i = 1; i < unpacked_size[ft] + 1; i++)
+	{
+		if (temp & 0x80)	bits[sort_ptr[ft][i-1]] = BIT_1;
+		else				bits[sort_ptr[ft][i-1]] = BIT_0;
+
+		if (i % 8)
+		{
+			temp <<= 1;
+		}
+		else
+		{
+			temp = *pack_ptr;
+			pack_ptr++;
+		}
+	}
+
+	/* SID frame */
+	if (ft == MRDTX)
+	{
+		if (temp & 0x80)	sid_type = 1;
+		else				sid_type = 0;
+
+		*mode = (enum Mode)((temp >> 4) & 0x07);
+
+		if (q)
+		{
+			if (sid_type)	return  RX_SID_UPDATE;
+			else			return	RX_SID_FIRST;
+		}
+		else
+		{
+			return	RX_SID_BAD;
+		}
+	}
+	/* speech frame */
+	else
+	{
+		*mode = (enum Mode)ft;
+
+		if (q)	return RX_SPEECH_GOOD;
+		else	return RX_SPEECH_BAD;
+	}
+}
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/sp_dec.h FFMpeg-20050127-new/libavcodec/amr/sp_dec.h
--- FFMpeg-20050127/libavcodec/amr/sp_dec.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/sp_dec.h	2003-02-17 16:14:00.000000000 +0000
@@ -0,0 +1,90 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : sp_dec.h
+*      Purpose          : Decoding and post filtering of one speech frame.
+*
+*****************************************************************************
+*/
+#ifndef sp_dec_h
+#define sp_dec_h "$Id $"
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include "typedef.h"
+#include "cnst.h"
+#include "dec_amr.h"
+#include "pstfilt.h"
+#include "post_pro.h"
+#include "mode.h"
+
+/*
+*****************************************************************************
+*                         DEFINITION OF DATA TYPES
+*****************************************************************************
+*/
+typedef struct{
+  Decoder_amrState* decoder_amrState;
+  Post_FilterState*  post_state;
+  Post_ProcessState* postHP_state;
+  enum Mode prev_mode;
+
+  int complexityCounter;   /* Only for complexity computation            */
+} Speech_Decode_FrameState;
+ 
+/*
+*****************************************************************************
+*                         DECLARATION OF PROTOTYPES
+*****************************************************************************
+*/
+ 
+int Speech_Decode_Frame_init (Speech_Decode_FrameState **st,
+                              char *id);
+/* initialize one instance of the speech decoder
+   Stores pointer to filter status struct in *st. This pointer has to
+   be passed to Speech_Decode_Frame in each call.
+   returns 0 on success
+ */
+ 
+int Speech_Decode_Frame_reset (Speech_Decode_FrameState *st);
+/* reset speech decoder (i.e. set state memory to zero)
+   returns 0 on success
+ */
+ 
+void Speech_Decode_Frame_exit (Speech_Decode_FrameState **st);
+/* de-initialize speech decoder (i.e. free status struct)
+   stores NULL in *s
+ */
+ 
+int Speech_Decode_Frame (
+    Speech_Decode_FrameState *st, /* io: post filter states                */
+    enum Mode mode,               /* i : AMR mode                          */
+    Word16 *serial,               /* i : serial bit stream                 */
+    enum RXFrameType frame_type,  /* i : Frame type                        */
+    Word16 *synth                 /* o : synthesis speech (postfiltered    */
+                                  /*     output)                           */
+);
+/*    return 0 on success
+ */
+
+#ifdef MMS_IO
+
+enum RXFrameType UnpackBits (
+    Word8  q,              /* i : Q-bit (i.e. BFI)        */
+	Word16 ft,             /* i : frame type (i.e. mode)  */
+    UWord8 packed_bits[],  /* i : sorted & packed bits    */
+	enum Mode *mode,       /* o : mode information        */
+    Word16 bits[]          /* o : serial bits             */
+);
+#endif
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/sp_enc.c FFMpeg-20050127-new/libavcodec/amr/sp_enc.c
--- FFMpeg-20050127/libavcodec/amr/sp_enc.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/sp_enc.c	2003-10-02 10:32:00.000000000 +0000
@@ -0,0 +1,331 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : sp_enc.c
+*      Purpose          : Pre filtering and encoding of one speech frame.
+*
+*****************************************************************************
+*/
+ 
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "cnst.h"
+#include "count.h"
+#include "set_zero.h"
+#include "pre_proc.h"
+#include "prm2bits.h"
+#include "mode.h"
+#include "cod_amr.h"
+
+#ifdef MMS_IO
+#include "frame.h"
+#include "bitno.tab"
+#endif
+
+#include "sp_enc.h"
+const char sp_enc_id[] = "@(#)$Id $" sp_enc_h;
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+/*---------------------------------------------------------------*
+ *    Constants (defined in "cnst.h")                            *
+ *---------------------------------------------------------------*
+ * L_FRAME     :
+ * M           :
+ * PRM_SIZE    :
+ * AZ_SIZE     :
+ * SERIAL_SIZE :
+ *---------------------------------------------------------------*/
+
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+ 
+/*************************************************************************
+*
+*  Function:   Speech_Encode_Frame_init
+*  Purpose:    Allocates memory for filter structure and initializes
+*              state memory
+*
+**************************************************************************
+*/
+int Speech_Encode_Frame_init (Speech_Encode_FrameState **state,
+                              Flag dtx,
+                              char *id)
+{
+  Speech_Encode_FrameState* s;
+ 
+  if (state == (Speech_Encode_FrameState **) NULL){
+      fprintf(stderr, "Speech_Encode_Frame_init: invalid parameter\n");
+      return -1;
+  }
+  *state = NULL;
+ 
+  /* allocate memory */
+  if ((s= (Speech_Encode_FrameState *) malloc(sizeof(Speech_Encode_FrameState))) == NULL){
+      fprintf(stderr, "Speech_Encode_Frame_init: can not malloc state "
+                      "structure\n");
+      return -1;
+  }
+
+  s->complexityCounter = getCounterId(id);
+
+  s->pre_state = NULL;
+  s->cod_amr_state = NULL;
+  s->dtx = dtx;
+
+  if (Pre_Process_init(&s->pre_state) ||
+      cod_amr_init(&s->cod_amr_state, s->dtx)) {
+      Speech_Encode_Frame_exit(&s);
+      return -1;
+  }
+
+  Speech_Encode_Frame_reset(s);
+  *state = s;
+  
+  return 0;
+}
+ 
+/*************************************************************************
+*
+*  Function:   Speech_Encode_Frame_reset
+*  Purpose:    Resetses state memory
+*
+**************************************************************************
+*/
+int Speech_Encode_Frame_reset (Speech_Encode_FrameState *state)
+{
+  if (state == (Speech_Encode_FrameState *) NULL){
+      fprintf(stderr, "Speech_Encode_Frame_reset: invalid parameter\n");
+      return -1;
+  }
+  
+  Pre_Process_reset(state->pre_state);
+  cod_amr_reset(state->cod_amr_state);
+
+  setCounter(state->complexityCounter);
+  Init_WMOPS_counter();
+  setCounter(0); /* set counter to global counter */
+
+  return 0;
+}
+ 
+/*************************************************************************
+*
+*  Function:   Speech_Encode_Frame_exit
+*  Purpose:    The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void Speech_Encode_Frame_exit (Speech_Encode_FrameState **state)
+{
+  if (state == NULL || *state == NULL)
+      return;
+ 
+  Pre_Process_exit(&(*state)->pre_state);
+  cod_amr_exit(&(*state)->cod_amr_state);
+
+  setCounter((*state)->complexityCounter);
+  WMOPS_output(0);
+  setCounter(0); /* set counter to global counter */
+ 
+  /* deallocate memory */
+  free(*state);
+  *state = NULL;
+  
+  return;
+}
+ 
+ 
+int Speech_Encode_Frame_First (
+    Speech_Encode_FrameState *st,  /* i/o : post filter states       */
+    Word16 *new_speech)            /* i   : speech input             */
+{
+#if !defined(NO13BIT)
+   Word16 i;
+#endif
+
+   setCounter(st->complexityCounter);
+
+#if !defined(NO13BIT)
+  /* Delete the 3 LSBs (13-bit input) */
+  for (i = 0; i < L_NEXT; i++) 
+  {
+     new_speech[i] = new_speech[i] & 0xfff8;    move16 (); logic16 ();
+  }
+#endif
+
+  /* filter + downscaling */
+  Pre_Process (st->pre_state, new_speech, L_NEXT);
+
+  cod_amr_first(st->cod_amr_state, new_speech);
+
+  Init_WMOPS_counter (); /* reset WMOPS counter for the new frame */
+
+  return 0;
+}
+
+int Speech_Encode_Frame (
+    Speech_Encode_FrameState *st, /* i/o : post filter states          */
+    enum Mode mode,               /* i   : speech coder mode           */
+    Word16 *new_speech,           /* i   : speech input                */
+    Word16 *serial,               /* o   : serial bit stream           */
+    enum Mode *usedMode           /* o   : used speech coder mode */
+    )
+{
+  Word16 prm[MAX_PRM_SIZE];   /* Analysis parameters.                  */
+  Word16 syn[L_FRAME];        /* Buffer for synthesis speech           */
+  Word16 i;
+
+  setCounter(st->complexityCounter);
+  Reset_WMOPS_counter (); /* reset WMOPS counter for the new frame */
+
+  /* initialize the serial output frame to zero */
+  for (i = 0; i < MAX_SERIAL_SIZE; i++)   
+  {
+    serial[i] = 0;                                           move16 ();
+  }
+
+#if !defined(NO13BIT)
+  /* Delete the 3 LSBs (13-bit input) */
+  for (i = 0; i < L_FRAME; i++)   
+  {
+     new_speech[i] = new_speech[i] & 0xfff8;    move16 (); logic16 ();
+  }
+#endif
+
+  /* filter + downscaling */
+  Pre_Process (st->pre_state, new_speech, L_FRAME);           
+  
+  /* Call the speech encoder */
+  cod_amr(st->cod_amr_state, mode, new_speech, prm, usedMode, syn);
+  
+  /* Parameters to serial bits */
+  Prm2bits (*usedMode, prm, &serial[0]); 
+
+  fwc();
+  setCounter(0); /* set counter to global counter */
+
+  return 0;
+}
+
+#ifdef MMS_IO
+
+/*************************************************************************
+ *
+ *  FUNCTION:    PackBits
+ *
+ *  PURPOSE:     Sorts speech bits according decreasing subjective importance
+ *               and packs into octets according to AMR file storage format
+ *               as specified in RFC 3267 (Sections 5.1 and 5.3).
+ *
+ *  DESCRIPTION: Depending on the mode, different numbers of bits are
+ *               processed. Details can be found in specification mentioned
+ *               above and in file "bitno.tab".
+ *
+ *************************************************************************/
+Word16 PackBits(
+    enum Mode used_mode,       /* i : actual AMR mode             */
+    enum Mode mode,            /* i : requested AMR (speech) mode */
+    enum TXFrameType fr_type,  /* i : frame type                  */
+    Word16 bits[],             /* i : serial bits                 */
+    UWord8 packed_bits[]       /* o : sorted&packed bits          */
+)
+{
+   Word16 i;
+   UWord8 temp;
+   UWord8 *pack_ptr;
+
+   temp = 0;
+   pack_ptr = (UWord8*)packed_bits;
+
+   /* file storage format can handle only speech frames, AMR SID frames and NO_DATA frames */
+   /* -> force NO_DATA frame */
+   if (used_mode < 0 || used_mode > 15 || (used_mode > 8 && used_mode < 15))
+   {
+	   used_mode = 15;
+   }
+
+   /* mark empty frames between SID updates as NO_DATA frames */
+   if (used_mode == MRDTX && fr_type == TX_NO_DATA)
+   {
+	   used_mode = 15;
+   }
+
+   /* insert table of contents (ToC) byte at the beginning of the frame */
+   *pack_ptr = toc_byte[used_mode];
+   pack_ptr++;
+
+   /* note that NO_DATA frames (used_mode==15) do not need further processing */
+   if (used_mode == 15)
+   {
+	   return 1;
+   }
+
+   temp = 0;
+
+   /* sort and pack speech bits */
+   for (i = 1; i < unpacked_size[used_mode] + 1; i++)
+   {
+       if (bits[sort_ptr[used_mode][i-1]] == BIT_1)
+	   {
+		   temp++;
+	   }
+
+	   if (i % 8)
+	   {
+		   temp <<= 1;
+	   }
+	   else
+	   {
+		   *pack_ptr = temp;
+		   pack_ptr++;
+		   temp = 0;
+	   }
+   }
+
+   /* insert SID type indication and speech mode in case of SID frame */
+   if (used_mode == MRDTX)
+   {
+	   if (fr_type == TX_SID_UPDATE)
+	   {
+		   temp++;
+	   }
+	   temp <<= 3;
+
+	   temp += mode & 0x0007;
+	   temp <<= 1;
+   }
+
+   /* insert unused bits (zeros) at the tail of the last byte */
+   temp <<= (unused_size[used_mode] - 1);
+   *pack_ptr = temp;
+
+   return packed_size[used_mode];
+}
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/sp_enc.h FFMpeg-20050127-new/libavcodec/amr/sp_enc.h
--- FFMpeg-20050127/libavcodec/amr/sp_enc.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/sp_enc.h	2003-02-14 13:18:00.000000000 +0000
@@ -0,0 +1,92 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : sp_enc.h
+*      Purpose          : Encoding of one speech frame.
+*
+*****************************************************************************
+*/
+#ifndef sp_enc_h
+#define sp_enc_h "$Id $"
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include "typedef.h"
+#include "cnst.h"
+#include "pre_proc.h"
+#include "mode.h"
+#include "cod_amr.h"
+
+/*
+*****************************************************************************
+*                         DEFINITION OF DATA TYPES
+*****************************************************************************
+*/
+typedef struct{
+    Pre_ProcessState *pre_state;
+    cod_amrState   *cod_amr_state;
+    Flag dtx;
+    int complexityCounter;   /* Only for complexity computation            */
+} Speech_Encode_FrameState;
+ 
+/*
+*****************************************************************************
+*                         ENCLARATION OF PROTOTYPES
+*****************************************************************************
+*/
+ 
+int Speech_Encode_Frame_init (Speech_Encode_FrameState **st,
+                              Flag dtx,
+                              char *id);
+/* initialize one instance of the speech encoder
+   Stores pointer to filter status struct in *st. This pointer has to
+   be passed to Speech_Encode_Frame in each call.
+   returns 0 on success
+ */
+ 
+int Speech_Encode_Frame_reset (Speech_Encode_FrameState *st);
+/* reset speech encoder (i.e. set state memory to zero)
+   returns 0 on success
+ */
+ 
+void Speech_Encode_Frame_exit (Speech_Encode_FrameState **st);
+/* de-initialize speech encoder (i.e. free status struct)
+   stores NULL in *s
+ */
+ 
+int Speech_Encode_Frame_First (
+    Speech_Encode_FrameState *st, /* i/o : post filter states     */
+    Word16 *new_speech);          /* i   : speech input           */
+
+int Speech_Encode_Frame (
+    Speech_Encode_FrameState *st, /* i/o : encoder states         */
+    enum Mode mode,               /* i   : speech coder mode      */
+    Word16 *new_speech,           /* i   : input speech           */
+    Word16 *serial,               /* o   : serial bit stream      */
+    enum Mode *usedMode           /* o   : used speech coder mode */
+);
+/*    return 0 on success
+ */
+
+#ifdef MMS_IO
+
+Word16 PackBits(
+    enum Mode used_mode,       /* i : actual AMR mode             */
+    enum Mode mode,            /* i : requested AMR (speech) mode */
+    enum TXFrameType fr_type,  /* i : frame type                  */
+    Word16 bits[],             /* i : serial bits                 */
+    UWord8 packed_bits[]       /* o : sorted&packed bits          */
+);
+
+#endif
+ 
+#endif
Binary files FFMpeg-20050127/libavcodec/amr/spc.a and FFMpeg-20050127-new/libavcodec/amr/spc.a differ
Binary files FFMpeg-20050127/libavcodec/amr/spch_do2.cod and FFMpeg-20050127-new/libavcodec/amr/spch_do2.cod differ
Binary files FFMpeg-20050127/libavcodec/amr/spch_do2.out and FFMpeg-20050127-new/libavcodec/amr/spch_do2.out differ
Binary files FFMpeg-20050127/libavcodec/amr/spch_dos.cod and FFMpeg-20050127-new/libavcodec/amr/spch_dos.cod differ
Binary files FFMpeg-20050127/libavcodec/amr/spch_dos.inp and FFMpeg-20050127-new/libavcodec/amr/spch_dos.inp differ
Binary files FFMpeg-20050127/libavcodec/amr/spch_dos.out and FFMpeg-20050127-new/libavcodec/amr/spch_dos.out differ
Binary files FFMpeg-20050127/libavcodec/amr/spch_un2.cod and FFMpeg-20050127-new/libavcodec/amr/spch_un2.cod differ
Binary files FFMpeg-20050127/libavcodec/amr/spch_un2.out and FFMpeg-20050127-new/libavcodec/amr/spch_un2.out differ
Binary files FFMpeg-20050127/libavcodec/amr/spch_unx.cod and FFMpeg-20050127-new/libavcodec/amr/spch_unx.cod differ
Binary files FFMpeg-20050127/libavcodec/amr/spch_unx.inp and FFMpeg-20050127-new/libavcodec/amr/spch_unx.inp differ
Binary files FFMpeg-20050127/libavcodec/amr/spch_unx.out and FFMpeg-20050127-new/libavcodec/amr/spch_unx.out differ
diff -Nur FFMpeg-20050127/libavcodec/amr/spreproc.c FFMpeg-20050127-new/libavcodec/amr/spreproc.c
--- FFMpeg-20050127/libavcodec/amr/spreproc.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/spreproc.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,116 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : spreproc.c
+*      Purpose          : Subframe preprocessing
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "spreproc.h"
+const char spreproc_id[] = "@(#)$Id $" spreproc_h;
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "weight_a.h"
+#include "syn_filt.h"
+#include "residu.h"
+#include "copy.h"
+#include "count.h"
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+int subframePreProc(
+    enum Mode mode,            /* i  : coder mode                            */
+    const Word16 gamma1[],     /* i  : spectral exp. factor 1                */
+    const Word16 gamma1_12k2[],/* i  : spectral exp. factor 1 for EFR        */
+    const Word16 gamma2[],     /* i  : spectral exp. factor 2                */
+    Word16 *A,                 /* i  : A(z) unquantized for the 4 subframes  */
+    Word16 *Aq,                /* i  : A(z)   quantized for the 4 subframes  */
+    Word16 *speech,            /* i  : speech segment                        */
+    Word16 *mem_err,           /* i  : pointer to error signal               */
+    Word16 *mem_w0,            /* i  : memory of weighting filter            */
+    Word16 *zero,              /* i  : pointer to zero vector                */
+    Word16 ai_zero[],          /* o  : history of weighted synth. filter     */
+    Word16 exc[],              /* o  : long term prediction residual         */
+    Word16 h1[],               /* o  : impulse response                      */
+    Word16 xn[],               /* o  : target vector for pitch search        */
+    Word16 res2[],             /* o  : long term prediction residual         */
+    Word16 error[]             /* o  : error of LPC synthesis filter         */
+)
+{
+   Word16 i;
+   Word16 Ap1[MP1];              /* A(z) with spectral expansion         */
+   Word16 Ap2[MP1];              /* A(z) with spectral expansion         */
+   const Word16 *g1;             /* Pointer to correct gammma1 vector    */
+
+   /*---------------------------------------------------------------*
+    * mode specific pointer to gamma1 values                        *
+    *---------------------------------------------------------------*/
+	test (); test ();
+	if ( sub(mode, MR122) == 0 || sub(mode, MR102) == 0 )
+        {
+           g1 = gamma1_12k2; move16 (); 
+	}
+        else
+        {
+           g1 = gamma1;      move16 (); 
+	}
+   /*---------------------------------------------------------------*
+    * Find the weighted LPC coefficients for the weighting filter.  *
+    *---------------------------------------------------------------*/
+   Weight_Ai(A, g1, Ap1);
+   Weight_Ai(A, gamma2, Ap2);
+   
+   /*---------------------------------------------------------------*
+    * Compute impulse response, h1[], of weighted synthesis filter  *
+    *---------------------------------------------------------------*/
+   for (i = 0; i <= M; i++)
+   {
+      ai_zero[i] = Ap1[i];        move16 ();
+   }
+
+   Syn_filt(Aq, ai_zero, h1, L_SUBFR, zero, 0);
+   Syn_filt(Ap2, h1, h1, L_SUBFR, zero, 0);
+   
+   /*------------------------------------------------------------------------*
+    *                                                                        *
+    *          Find the target vector for pitch search:                      *
+    *                                                                        *
+    *------------------------------------------------------------------------*/
+   
+   /* LPC residual */
+   Residu(Aq, speech, res2, L_SUBFR); 
+   Copy(res2, exc, L_SUBFR);
+
+   Syn_filt(Aq, exc, error, L_SUBFR, mem_err, 0);
+   
+   Residu(Ap1, error, xn, L_SUBFR);
+   
+   /* target signal xn[]*/
+   Syn_filt(Ap2, xn, xn, L_SUBFR, mem_w0, 0);    
+
+   return 0;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/spreproc.h FFMpeg-20050127-new/libavcodec/amr/spreproc.h
--- FFMpeg-20050127/libavcodec/amr/spreproc.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/spreproc.h	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,51 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : spreproc.h
+*      Purpose          : Subframe preprocessing
+*
+********************************************************************************
+*/
+#ifndef spreproc_h
+#define spreproc_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "cnst.h"
+#include "mode.h"
+#include "typedef.h"
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+int subframePreProc(
+    enum Mode mode,            /* i  : coder mode                            */
+    const Word16 gamma1[],     /* i  : spectral exp. factor 1                */
+    const Word16 gamma1_12k2[],/* i  : spectral exp. factor 1 for EFR        */
+    const Word16 gamma2[],     /* i  : spectral exp. factor 2                */
+    Word16 *A,                 /* i  : A(z) unquantized for the 4 subframes  */
+    Word16 *Aq,                /* i  : A(z)   quantized for the 4 subframes  */
+    Word16 *speech,            /* i  : speech segment                        */
+    Word16 *mem_err,           /* i  : pointer to error signal               */
+    Word16 *mem_w0,            /* i  : memory of weighting filter            */
+    Word16 *zero,              /* i  : pointer to zero vector                */
+    Word16 ai_zero[],          /* o  : history of weighted synth. filter     */
+    Word16 exc[],              /* o  : long term prediction residual         */
+    Word16 h1[],               /* o  : impulse response                      */
+    Word16 xn[],               /* o  : target vector for pitch search        */
+    Word16 res2[],             /* o  : long term prediction residual         */
+    Word16 error[]             /* o  : error of LPC synthesis filter         */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/spstproc.c FFMpeg-20050127-new/libavcodec/amr/spstproc.c
--- FFMpeg-20050127/libavcodec/amr/spstproc.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/spstproc.c	2001-12-12 20:09:00.000000000 +0000
@@ -0,0 +1,162 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : subframePostProc.c
+*      Purpose          : Subframe post processing
+*
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "spstproc.h"
+const char spstproc_id[] = "@(#)$Id $" spstproc_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "syn_filt.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+int subframePostProc(
+    Word16 *speech,   /* i   : speech segment                        */
+    enum Mode mode,   /* i   : coder mode                            */
+    Word16 i_subfr,   /* i   : Subframe nr                           */
+    Word16 gain_pit,  /* i   : Pitch gain                       Q14  */
+    Word16 gain_code, /* i   : Decoded innovation gain               */
+    Word16 *Aq,       /* i   : A(z) quantized for the 4 subframes    */
+    Word16 synth[],   /* i   : Local snthesis                        */
+    Word16 xn[],      /* i   : Target vector for pitch search        */
+    Word16 code[],    /* i   : Fixed codebook exitation              */
+    Word16 y1[],      /* i   : Filtered adaptive exitation           */
+    Word16 y2[],      /* i   : Filtered fixed codebook excitation    */
+    Word16 *mem_syn,  /* i/o : memory of synthesis filter            */
+    Word16 *mem_err,  /* o   : pointer to error signal               */
+    Word16 *mem_w0,   /* o   : memory of weighting filter            */
+    Word16 *exc,      /* o   : long term prediction residual         */
+    Word16 *sharp     /* o   : pitch sharpening value                */
+)
+{
+   Word16 i, j, k;
+   Word16 temp;
+   Word32 L_temp;
+   Word16 tempShift;
+   Word16 kShift;
+   Word16 pitch_fac;
+
+   test ();
+   if (sub(mode, MR122) != 0)
+   {
+      tempShift = 1;                     move16 ();
+      kShift = 2;                        move16 ();
+      pitch_fac = gain_pit;              move16 ();
+   }
+   else
+   {
+      tempShift = 2;                     move16 ();
+      kShift = 4;                        move16 ();
+      pitch_fac = shr (gain_pit, 1);
+   }
+   
+   /*------------------------------------------------------------*
+    * - Update pitch sharpening "sharp" with quantized gain_pit  *
+    *------------------------------------------------------------*/
+   
+   *sharp = gain_pit;                    move16 ();
+   test ();
+   if (sub(*sharp, SHARPMAX) > 0)
+   {
+      *sharp = SHARPMAX;                 move16 ();
+   }
+   /*------------------------------------------------------*
+    * - Find the total excitation                          *
+    * - find synthesis speech corresponding to exc[]       *
+    * - update filters memories for finding the target     *
+    *   vector in the next subframe                        *
+    *   (update error[-m..-1] and mem_w_err[])             *
+    *------------------------------------------------------*/
+
+   for (i = 0; i < L_SUBFR; i++) {
+      /* exc[i] = gain_pit*exc[i] + gain_code*code[i]; */
+
+      /*
+       *                      12k2  others
+       * ---------------------------------
+       * exc                   Q0      Q0
+       * gain_pit              Q14     Q14
+       * pitch_fac             Q13     Q14
+       *    product:           Q14     Q15
+       *                               
+       * code                  Q12     Q13
+       * gain_code             Q1      Q1
+       *    product            Q14     Q15
+       *    sum                Q14     Q15
+       *                               
+       * tempShift             2       1
+       *    sum<<tempShift     Q16     Q16
+       * result -> exc         Q0      Q0
+       */
+      L_temp = L_mult (exc[i + i_subfr], pitch_fac);
+      L_temp = L_mac (L_temp, code[i], gain_code);
+      L_temp = L_shl (L_temp, tempShift);
+      exc[i + i_subfr] = round (L_temp);              move16 ();
+   }
+
+   Syn_filt(Aq, &exc[i_subfr], &synth[i_subfr], L_SUBFR,
+            mem_syn, 1);
+
+   for (i = L_SUBFR - M, j = 0; i < L_SUBFR; i++, j++) {
+       mem_err[j] = sub(speech[i_subfr + i],
+                        synth[i_subfr + i]);          move16 ();
+      /*
+       *                      12k2  others
+       * ---------------------------------
+       * y1                    Q0      Q0
+       * gain_pit              Q14     Q14
+       *    product            Q15     Q15
+       *    shifted prod.      Q16     Q16
+       * temp                  Q0      Q0
+       *                                
+       * y2                    Q10     Q12
+       * gain_code             Q1      Q1
+       *    product            Q12     Q14
+       * kshift                 4       2
+       *    shifted prod.      Q16     Q16
+       * k                     Q0      Q0
+       * mem_w0,xn,sum         Q0      Q0
+       */
+      temp = extract_h(L_shl(L_mult(y1[i], gain_pit), 1));
+      k = extract_h(L_shl(L_mult(y2[i], gain_code), kShift));
+      mem_w0[j] = sub(xn[i], add(temp, k));          move16 ();
+   }
+
+   return 0;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/spstproc.h FFMpeg-20050127-new/libavcodec/amr/spstproc.h
--- FFMpeg-20050127/libavcodec/amr/spstproc.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/spstproc.h	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,57 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : subframePostProc.h
+*      Purpose          : Subframe post processing
+*
+********************************************************************************
+*/
+#ifndef spstproc_h
+#define spstproc_h "$Id $"
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+
+int subframePostProc(
+    Word16 *speech,   /* i   : speech segment                        */
+    enum Mode mode,   /* i   : coder mode                            */
+    Word16 i_subfr,   /* i   : Subframe nr                           */
+    Word16 gain_pit,  /* i   : Pitch gain                       Q14  */
+    Word16 gain_code, /* i   : Decoded innovation gain               */
+    Word16 *Aq,       /* i   : A(z) quantized for the 4 subframes    */
+    Word16 synth[],   /* i   : Local snthesis                        */
+    Word16 xn[],      /* i   : Target vector for pitch search        */
+    Word16 code[],    /* i   : Fixed codebook exitation              */
+    Word16 y1[],      /* i   : Filtered adaptive exitation           */
+    Word16 y2[],      /* i   : Filtered fixed codebook excitation    */
+    Word16 *mem_syn,  /* i/o : memory of synthesis filter            */
+    Word16 *mem_err,  /* o   : pointer to error signal               */
+    Word16 *mem_w0,   /* o   : memory of weighting filter            */
+    Word16 *exc,      /* o   : long term prediction residual         */
+    Word16 *sharp     /* o   : pitch sharpening value                */
+);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/sqrt_l.c FFMpeg-20050127-new/libavcodec/amr/sqrt_l.c
--- FFMpeg-20050127/libavcodec/amr/sqrt_l.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/sqrt_l.c	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,107 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : sqrt_l.c
+*      Purpose          : Computes sqrt(L_x),  where  L_x is positive.
+*                       : If L_var is negative or zero, the result is 0
+*      Description      :
+*            The function sqrt(L_x) is approximated by a table and linear
+*            interpolation. The square root is computed using the
+*            following steps:
+*                1- Normalization of L_x.
+*                2- If exponent is even then shift right once.
+*                3- exponent = exponent/2
+*                4- i = bit25-b31 of L_x;  16<=i<=63  because of normalization.
+*                5- a = bit10-b24
+*                6- i -=16
+*                7- L_y = table[i]<<16 - (table[i] - table[i+1]) * a * 2
+*                8- return L_y and exponent so caller can do denormalization
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "sqrt_l.h"
+const char sqrt_l_id[] = "@(#)$Id $" sqrt_l_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+#include "sqrt_l.tab" /* Table for sqrt_l_exp() */
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+
+Word32 sqrt_l_exp (/* o : output value,                          Q31 */
+    Word32 L_x,    /* i : input value,                           Q31 */
+    Word16 *exp    /* o : right shift to be applied to result,   Q1  */
+)
+{
+    /*
+          y = sqrt(x)
+
+          x = f * 2^-e,   0.5 <= f < 1   (normalization)
+
+          y = sqrt(f) * 2^(-e/2)  
+
+          a) e = 2k   --> y = sqrt(f)   * 2^-k  (k = e div 2,
+                                                 0.707 <= sqrt(f) < 1)
+          b) e = 2k+1 --> y = sqrt(f/2) * 2^-k  (k = e div 2,
+                                                 0.5 <= sqrt(f/2) < 0.707)
+     */
+    
+    
+    Word16 e, i, a, tmp;
+    Word32 L_y;
+
+    test (); 
+    if (L_x <= (Word32) 0)
+    {
+        *exp = 0;               move16 ();
+        return (Word32) 0;
+    }
+
+    e = norm_l (L_x) & 0xFFFE;  logic16 (); /* get next lower EVEN norm. exp  */
+    L_x = L_shl (L_x, e);                   /* L_x is normalized to [0.25..1) */
+    *exp = e;                   move16 ();  /* return 2*exponent (or Q1)      */
+
+    L_x = L_shr (L_x, 9);
+    i = extract_h (L_x);            /* Extract b25-b31, 16 <= i <= 63 because
+                                       of normalization                       */
+    L_x = L_shr (L_x, 1);   
+    a = extract_l (L_x);            /* Extract b10-b24                        */
+    a = a & (Word16) 0x7fff;    logic16 (); 
+
+    i = sub (i, 16);                /* 0 <= i <= 47                           */
+
+    L_y = L_deposit_h (table[i]);           /* table[i] << 16                 */
+    tmp = sub (table[i], table[i + 1]);     /* table[i] - table[i+1])         */
+    L_y = L_msu (L_y, tmp, a);              /* L_y -= tmp*a*2                 */
+       
+    /* L_y = L_shr (L_y, *exp); */          /* denormalization done by caller */
+
+    return (L_y);
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/sqrt_l.h FFMpeg-20050127-new/libavcodec/amr/sqrt_l.h
--- FFMpeg-20050127/libavcodec/amr/sqrt_l.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/sqrt_l.h	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,38 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : sqrt_l.h
+*      Purpose          : Computes sqrt(L_x),  where  L_x is positive.
+*                       : If L_x is negative or zero, the result is
+*                       : 0 (3fff ffff).
+*
+********************************************************************************
+*/
+#ifndef sqrt_l_h
+#define sqrt_l_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+ 
+Word32 sqrt_l_exp (/* o : output value,                        Q31 */
+    Word32 L_x,    /* i : input value,                         Q31 */
+    Word16 *exp    /* o : right shift to be applied to result, Q0  */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/sqrt_l.tab FFMpeg-20050127-new/libavcodec/amr/sqrt_l.tab
--- FFMpeg-20050127/libavcodec/amr/sqrt_l.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/sqrt_l.tab	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,69 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : sqrt_l.tab
+*      Purpose          : Table for routine sqrt_l_exp()
+*      $Id $
+*
+********************************************************************************
+*/
+/* table[i] = sqrt((i+16)*2^-6) * 2^15, i.e. sqrt(x) scaled Q15 */
+
+static const Word16 table[49] =
+{
+ 16384,
+ 16888,
+ 17378,
+ 17854,
+ 18318,
+ 18770,
+ 19212,
+ 19644,
+ 20066,
+ 20480,
+ 20886,
+ 21283,
+ 21674,
+ 22058,
+ 22435,
+ 22806,
+ 23170,
+ 23530,
+ 23884,
+ 24232,
+ 24576,
+ 24915,
+ 25249,
+ 25580,
+ 25905,
+ 26227,
+ 26545,
+ 26859,
+ 27170,
+ 27477,
+ 27780,
+ 28081,
+ 28378,
+ 28672,
+ 28963,
+ 29251,
+ 29537,
+ 29819,
+ 30099,
+ 30377,
+ 30652,
+ 30924,
+ 31194,
+ 31462,
+ 31727,
+ 31991,
+ 32252,
+ 32511,
+ 32767
+};
diff -Nur FFMpeg-20050127/libavcodec/amr/strfunc.c FFMpeg-20050127-new/libavcodec/amr/strfunc.c
--- FFMpeg-20050127/libavcodec/amr/strfunc.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/strfunc.c	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,203 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : strfunc.c
+*      Purpose          : string <-> mode and string <-> traffic channel
+*                         conversion functions
+*
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "strfunc.h"
+const char strfunc_id[] = "@(#)$Id $" strfunc_h;
+ 
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include <stdlib.h>
+#include <string.h>
+
+#include "mode.h"
+#include "frame.h"
+
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+
+/*
+ * generic string <-> id lookup table
+ */
+typedef struct {
+    char *name; /* name string */
+    int   id;   /* integer id  */
+} conv_table;
+
+/*
+ * mode name <-> mode id conversion table
+ */
+static const conv_table modetable[] = {
+    {"MR475", MR475},
+    {"MR515", MR515},
+    {"MR59",  MR59},
+    {"MR67",  MR67},
+    {"MR74",  MR74},
+    {"MR795", MR795},
+    {"MR102", MR102},
+    {"MR122", MR122},
+    {"MRDTX", MRDTX},
+    {NULL,    -1}
+};
+
+/*
+ * frame type name <-> frame type id conversion table
+ */
+static const conv_table rxframetable[] = {
+  {"RX_SPEECH_GOOD", RX_SPEECH_GOOD},
+  {"RX_SPEECH_DEGRADED", RX_SPEECH_DEGRADED},
+  {"RX_SPEECH_BAD", RX_SPEECH_BAD},
+  {"RX_SID_FIRST", RX_SID_FIRST},
+  {"RX_SID_UPDATE", RX_SID_UPDATE},
+  {"RX_SID_BAD", RX_SID_BAD},
+  {"RX_ONSET", RX_ONSET},
+  {"RX_NO_DATA", RX_NO_DATA},
+  {NULL, -1}
+};
+/*
+ * frame type name <-> frame type id conversion table
+ */
+static const conv_table txframetable[] = {
+  {"TX_SPEECH_GOOD", TX_SPEECH_GOOD},
+  {"TX_SPEECH_DEGRADED", TX_SPEECH_DEGRADED},
+  {"TX_SPEECH_BAD", TX_SPEECH_BAD},
+  {"TX_SID_FIRST", TX_SID_FIRST},
+  {"TX_SID_UPDATE", TX_SID_UPDATE},
+  {"TX_SID_BAD", TX_SID_BAD},
+  {"TX_ONSET", TX_ONSET},
+  {"TX_NO_DATA", TX_NO_DATA},
+  {NULL, -1}
+};
+
+/*
+*****************************************************************************
+*                         LOCAL PROGRAM CODE
+*****************************************************************************
+*/
+/*************************************************************************
+*
+*  Function:   search_string
+*  Purpose:    search table for string; return id if found, -1 otherwise
+*
+**************************************************************************
+*/
+static int search_string(const conv_table *p, const char *str)
+{
+    if (str == NULL)
+        return -1;
+    
+    do
+    {
+        if (strcmp(p->name, str) == 0)
+            return p->id;
+        p++;
+    } while (p->name != NULL);
+
+    return -1;
+}
+    
+/*************************************************************************
+*
+*  Function:   search_id
+*  Purpose:    search table for id; return string if found, NULL otherwise
+*
+**************************************************************************
+*/
+static char *search_id(const conv_table *p, int id)
+{
+    if (id == -1)
+        return NULL;
+    
+    do
+    {
+        if (p->id == id)
+            return p->name;
+        p++;
+    } while (p->name != NULL);
+
+    return NULL;
+}
+    
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+/*************************************************************************
+*
+*  Function:   str2mode
+*  Purpose:    convert AMR mode string into mode id; return 0 on success,
+*              1 otherwise
+*
+**************************************************************************
+*/
+int str2mode(const char* str, enum Mode *mode)
+{
+    int m;
+
+    if ((m = search_string(modetable, str)) == -1)
+        return 1;
+
+    *mode = (enum Mode) m;
+    return 0;
+}
+
+/*************************************************************************
+*
+*  Function:   mode2str
+*  Purpose:    convert AMR mode id into mode name string; return 0 on success,
+*              1 otherwise
+*
+**************************************************************************
+*/
+int mode2str(enum Mode mode, char** str)
+{
+    return ((*str = search_id(modetable, (int) mode)) != NULL);
+}
+
+/*************************************************************************
+*
+*  Function:   frame2str
+*
+**************************************************************************
+*/
+int rxframe2str(enum RXFrameType ft, char** str)
+{
+    return ((*str = search_id(rxframetable, (int) ft)) != NULL);
+}
+
+/*************************************************************************
+*
+*  Function:   txframe2str
+*
+**************************************************************************
+*/
+int txframe2str(enum TXFrameType ft, char** str)
+{
+    return ((*str = search_id(txframetable, (int) ft)) != NULL);
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/strfunc.h FFMpeg-20050127-new/libavcodec/amr/strfunc.h
--- FFMpeg-20050127/libavcodec/amr/strfunc.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/strfunc.h	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,39 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : strfunc.h
+*      Purpose          : string <-> mode and string <-> traffic channel
+*                         conversion functions
+*
+*****************************************************************************
+*/
+
+#ifndef strfunc_h
+#define strfunc_h "$Id $"
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include "mode.h"
+#include "frame.h"
+
+/*
+*****************************************************************************
+*                         DECLARATION OF PROTOTYPES
+*****************************************************************************
+*/
+
+int str2mode(const char* str, enum Mode    *mode);
+int mode2str(enum Mode    mode, char** str);
+int rxframe2str(enum RXFrameType ft, char** str);
+int txframe2str(enum TXFrameType ft, char** str);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/syn_filt.c FFMpeg-20050127-new/libavcodec/amr/syn_filt.c
--- FFMpeg-20050127/libavcodec/amr/syn_filt.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/syn_filt.c	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,103 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : syn_filt.c
+*      Purpose          : Perform synthesis filtering through 1/A(z).
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "syn_filt.h"
+const char syn_filt_id[] = "@(#)$Id $" syn_filt_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+/*
+*--------------------------------------*
+* Constants (defined in cnst.h         *
+*--------------------------------------*
+*  M         : LPC order               *
+*--------------------------------------*
+*/
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+void Syn_filt (
+    Word16 a[],     /* (i)     : a[M+1] prediction coefficients   (M=10)  */
+    Word16 x[],     /* (i)     : input signal                             */
+    Word16 y[],     /* (o)     : output signal                            */
+    Word16 lg,      /* (i)     : size of filtering                        */
+    Word16 mem[],   /* (i/o)   : memory associated with this filtering.   */
+    Word16 update   /* (i)     : 0=no update, 1=update of memory.         */
+)
+{
+    Word16 i, j;
+    Word32 s;
+    Word16 tmp[80];   /* This is usually done by memory allocation (lg+M) */
+    Word16 *yy;
+
+    /* Copy mem[] to yy[] */
+
+    yy = tmp;                           move16 (); 
+
+    for (i = 0; i < M; i++)
+    {
+        *yy++ = mem[i];                 move16 (); 
+    } 
+
+    /* Do the filtering. */
+
+    for (i = 0; i < lg; i++)
+    {
+        s = L_mult (x[i], a[0]);
+        for (j = 1; j <= M; j++)
+        {
+            s = L_msu (s, a[j], yy[-j]);
+        }
+        s = L_shl (s, 3);
+        *yy++ = round (s);              move16 (); 
+    }
+
+    for (i = 0; i < lg; i++)
+    {
+        y[i] = tmp[i + M];              move16 (); 
+    }
+
+    /* Update of memory if update==1 */
+
+    test (); 
+    if (update != 0)
+    {
+        for (i = 0; i < M; i++)
+        {
+            mem[i] = y[lg - M + i];     move16 (); 
+        }
+    }
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/syn_filt.h FFMpeg-20050127-new/libavcodec/amr/syn_filt.h
--- FFMpeg-20050127/libavcodec/amr/syn_filt.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/syn_filt.h	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,47 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : syn_filt.h
+*      Purpose          : Perform synthesis filtering through 1/A(z).
+*
+*
+********************************************************************************
+*/
+#ifndef syn_filt_h
+#define syn_filt_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+ 
+void Syn_filt (
+    Word16 a[],        /* (i)  : a[m+1] prediction coefficients   (m=10)    */
+    Word16 x[],        /* (i)  : input signal                               */
+    Word16 y[],        /* (o)  : output signal                              */
+    Word16 lg,         /* (i)  : size of filtering                          */
+    Word16 mem[],      /* (i/o): memory associated with this filtering.     */
+    Word16 update      /* (i)  : 0=no update, 1=update of memory.           */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/ton_stab.c FFMpeg-20050127-new/libavcodec/amr/ton_stab.c
--- FFMpeg-20050127/libavcodec/amr/ton_stab.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/ton_stab.c	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,240 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : ton_stab.c
+*
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "ton_stab.h"
+const char ton_stab_id[] = "@(#)$Id $" ton_stab_h;
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "oper_32b.h"
+#include "cnst.h"
+#include "set_zero.h"
+#include "copy.h"
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+/*************************************************************************
+ *
+ *  Function:   ton_stab_init
+ *  Purpose:    Allocates state memory and initializes state memory
+ *
+ **************************************************************************
+ */
+int ton_stab_init (tonStabState **state)
+{
+    tonStabState* s;
+    
+    if (state == (tonStabState **) NULL){
+        fprintf(stderr, "ton_stab_init: invalid parameter\n");
+        return -1;
+    }
+    *state = NULL;
+    
+    /* allocate memory */
+    if ((s= (tonStabState *) malloc(sizeof(tonStabState))) == NULL){
+        fprintf(stderr, "ton_stab_init: can not malloc state structure\n");
+        return -1;
+    }
+    
+    ton_stab_reset(s);
+    
+    *state = s;
+    
+    return 0;
+}
+
+/*************************************************************************
+ *
+ *  Function:   ton_stab_reset
+ *  Purpose:    Initializes state memory to zero
+ *
+ **************************************************************************
+ */
+int ton_stab_reset (tonStabState *st)
+{
+    if (st == (tonStabState *) NULL){
+        fprintf(stderr, "ton_stab_init: invalid parameter\n");
+        return -1;
+    }
+
+    /* initialize tone stabilizer state */ 
+    st->count = 0;
+    Set_zero(st->gp, N_FRAME);    /* Init Gp_Clipping */
+    
+    return 0;
+}
+
+/*************************************************************************
+ *
+ *  Function:   ton_stab_exit
+ *  Purpose:    The memory used for state memory is freed
+ *
+ **************************************************************************
+ */
+void ton_stab_exit (tonStabState **state)
+{
+    if (state == NULL || *state == NULL)
+        return;
+
+    /* deallocate memory */
+    free(*state);
+    *state = NULL;
+    
+    return;
+}
+
+/***************************************************************************
+ *                                                                          *
+ *  Function:  check_lsp()                                                  *
+ *  Purpose:   Check the LSP's to detect resonances                         *
+ *                                                                          *
+ ****************************************************************************
+ */
+Word16 check_lsp(tonStabState *st, /* i/o : State struct            */
+                 Word16 *lsp       /* i   : unquantized LSP's       */
+)
+{
+   Word16 i, dist, dist_min1, dist_min2, dist_th;
+ 
+   /* Check for a resonance:                             */
+   /* Find minimum distance between lsp[i] and lsp[i+1]  */
+ 
+   dist_min1 = MAX_16;                       move16 ();
+   for (i = 3; i < M-2; i++)
+   {
+      dist = sub(lsp[i], lsp[i+1]);
+
+      test ();
+      if (sub(dist, dist_min1) < 0)
+      {
+         dist_min1 = dist;                   move16 ();
+      }
+   }
+
+   dist_min2 = MAX_16;                       move16 ();
+   for (i = 1; i < 3; i++)
+   {
+      dist = sub(lsp[i], lsp[i+1]);
+
+      test ();
+      if (sub(dist, dist_min2) < 0)
+      {
+         dist_min2 = dist;                   move16 ();
+      }
+   }
+
+   if (test (), sub(lsp[1], 32000) > 0)
+   {
+      dist_th = 600;                         move16 ();
+   }
+   else if (test (), sub(lsp[1], 30500) > 0)
+   {
+      dist_th = 800;                         move16 ();
+   }
+   else
+   {
+      dist_th = 1100;                        move16 ();
+   }
+
+   test (); test ();
+   if (sub(dist_min1, 1500) < 0 ||
+       sub(dist_min2, dist_th) < 0)
+   {
+      st->count = add(st->count, 1);
+   }
+   else
+   {
+      st->count = 0;                         move16 ();
+   }
+   
+   /* Need 12 consecutive frames to set the flag */
+   test ();
+   if (sub(st->count, 12) >= 0)
+   {
+      st->count = 12;                        move16 ();
+      return 1;
+   }
+   else
+   {
+      return 0;
+   }
+}
+
+/***************************************************************************
+ *
+ *  Function:   Check_Gp_Clipping()                                          
+ *  Purpose:    Verify that the sum of the last (N_FRAME+1) pitch  
+ *              gains is under a certain threshold.              
+ *                                                                         
+ ***************************************************************************
+ */ 
+Word16 check_gp_clipping(tonStabState *st, /* i/o : State struct            */
+                         Word16 g_pitch    /* i   : pitch gain              */
+)
+{
+   Word16 i, sum;
+   
+   sum = shr(g_pitch, 3);          /* Division by 8 */
+   for (i = 0; i < N_FRAME; i++)
+   {
+      sum = add(sum, st->gp[i]);
+   }
+
+   test ();
+   if (sub(sum, GP_CLIP) > 0)
+   {
+      return 1;
+   }
+   else
+   {
+      return 0;
+   }
+}
+
+/***************************************************************************
+ *
+ *  Function:  Update_Gp_Clipping()                                          
+ *  Purpose:   Update past pitch gain memory
+ *                                                                         
+ ***************************************************************************
+ */
+void update_gp_clipping(tonStabState *st, /* i/o : State struct            */
+                        Word16 g_pitch    /* i   : pitch gain              */
+)
+{
+   Copy(&st->gp[1], &st->gp[0], N_FRAME-1);
+   st->gp[N_FRAME-1] = shr(g_pitch, 3);
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/ton_stab.h FFMpeg-20050127-new/libavcodec/amr/ton_stab.h
--- FFMpeg-20050127/libavcodec/amr/ton_stab.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/ton_stab.h	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,83 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : ton_stab.h
+*      Purpose          : Tone stabilization routines 
+*
+********************************************************************************
+*/
+#ifndef ton_stab_h
+#define ton_stab_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "mode.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+
+/* state variable */
+typedef struct {
+
+   /* counters */
+   Word16 count;
+   
+   /* gain history Q11 */
+   Word16 gp[N_FRAME];
+   
+} tonStabState;
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+int ton_stab_init (tonStabState **st);
+/* initialize one instance of the pre processing state.
+   Stores pointer to filter status struct in *st. This pointer has to
+   be passed to ton_stab in each call.
+   returns 0 on success
+ */
+ 
+int ton_stab_reset (tonStabState *st);
+/* reset of pre processing state (i.e. set state memory to zero)
+   returns 0 on success
+ */
+
+void ton_stab_exit (tonStabState **st);
+/* de-initialize pre processing state (i.e. free status struct)
+   stores NULL in *st
+ */
+
+Word16 check_lsp(tonStabState *st, /* i/o : State struct            */
+                 Word16 *lsp       /* i   : unquantized LSP's       */
+);
+
+Word16 check_gp_clipping(tonStabState *st, /* i/o : State struct            */
+                         Word16 g_pitch    /* i   : pitch gain              */
+);
+
+void update_gp_clipping(tonStabState *st, /* i/o : State struct            */
+                        Word16 g_pitch    /* i   : pitch gain              */
+);
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/typedef.h FFMpeg-20050127-new/libavcodec/amr/typedef.h
--- FFMpeg-20050127/libavcodec/amr/typedef.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/typedef.h	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,55 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : typedef.c
+*      Purpose          : Basic types.
+*
+********************************************************************************
+*/
+#ifndef typedef_h
+#define typedef_h "$Id $"
+
+#undef ORIGINAL_TYPEDEF_H /* define to get "original" ETSI version
+                             of typedef.h                           */
+
+#ifdef ORIGINAL_TYPEDEF_H
+/*
+ * this is the original code from the ETSI file typedef.h
+ */
+   
+#if defined(__BORLANDC__) || defined(__WATCOMC__) || defined(_MSC_VER) || defined(__ZTC__)
+typedef signed char Word8;
+typedef short Word16;
+typedef long Word32;
+typedef int Flag;
+
+#elif defined(__sun)
+typedef signed char Word8;
+typedef short Word16;
+typedef long Word32;
+typedef int Flag;
+
+#elif defined(__unix__) || defined(__unix)
+typedef signed char Word8;
+typedef short Word16;
+typedef int Word32;
+typedef int Flag;
+
+#endif
+#else /* not original typedef.h */
+
+/*
+ * use (improved) type definition file typdefs.h and add a "Flag" type
+ */
+#include "typedefs.h"
+typedef int Flag;
+
+#endif
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/typedefs.h FFMpeg-20050127-new/libavcodec/amr/typedefs.h
--- FFMpeg-20050127/libavcodec/amr/typedefs.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/typedefs.h	2005-01-28 16:53:04.000000000 +0000
@@ -0,0 +1,186 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : typedefs.h
+*      Description      : Definition of platform independent data
+*                         types and constants
+*
+*
+*      The following platform independent data types and corresponding
+*      preprocessor (#define) constants are defined:
+*
+*        defined type  meaning           corresponding constants
+*        ----------------------------------------------------------
+*        Char          character         (none)
+*        Bool          boolean           true, false
+*        Word8         8-bit signed      minWord8,   maxWord8
+*        UWord8        8-bit unsigned    minUWord8,  maxUWord8
+*        Word16        16-bit signed     minWord16,  maxWord16
+*        UWord16       16-bit unsigned   minUWord16, maxUWord16
+*        Word32        32-bit signed     minWord32,  maxWord32
+*        UWord32       32-bit unsigned   minUWord32, maxUWord32
+*        Float         floating point    minFloat,   maxFloat
+*
+*
+*      The following compile switches are #defined:
+*
+*        PLATFORM      string indicating platform progam is compiled on
+*                      possible values: "OSF", "PC", "SUN"
+*
+*        OSF           only defined if the current platform is an Alpha
+*        PC            only defined if the current platform is a PC
+*        SUN           only defined if the current platform is a Sun
+*        
+*        LSBFIRST      is defined if the byte order on this platform is
+*                      "least significant byte first" -> defined on DEC Alpha
+*                      and PC, undefined on Sun
+*
+********************************************************************************
+*/
+#ifndef typedefs_h
+#define typedefs_h "$Id $"
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include <float.h>
+#include <limits.h>
+
+
+
+/*
+********************************************************************************
+*                         DEFINITION OF CONSTANTS 
+********************************************************************************
+*/
+/*
+ ********* define char type
+ */
+typedef char Char;
+
+/*
+ ********* define 8 bit signed/unsigned types & constants
+ */
+#if SCHAR_MAX == 127
+typedef signed char Word8;
+#define minWord8  SCHAR_MIN
+#define maxWord8  SCHAR_MAX
+
+typedef unsigned char UWord8;
+#define minUWord8 0
+#define maxUWord8 UCHAR_MAX
+#else
+#error cannot find 8-bit type
+#endif
+
+
+/*
+ ********* define 16 bit signed/unsigned types & constants
+ */
+#if INT_MAX == 32767
+typedef int Word16;
+#define minWord16     INT_MIN
+#define maxWord16     INT_MAX
+typedef unsigned int UWord16;
+#define minUWord16    0
+#define maxUWord16    UINT_MAX
+#elif SHRT_MAX == 32767
+typedef short Word16;
+#define minWord16     SHRT_MIN
+#define maxWord16     SHRT_MAX
+typedef unsigned short UWord16;
+#define minUWord16    0
+#define maxUWord16    USHRT_MAX
+#else
+#error cannot find 16-bit type
+#endif
+
+
+/*
+ ********* define 32 bit signed/unsigned types & constants
+ */
+#if INT_MAX == 2147483647
+typedef int Word32;
+#define minWord32     INT_MIN
+#define maxWord32     INT_MAX
+typedef unsigned int UWord32;
+#define minUWord32    0
+#define maxUWord32    UINT_MAX
+#elif LONG_MAX == 2147483647
+typedef long Word32;
+#define minWord32     LONG_MIN
+#define maxWord32     LONG_MAX
+typedef unsigned long UWord32;
+#define minUWord32    0
+#define maxUWord32    ULONG_MAX
+#else
+#error cannot find 32-bit type
+#endif
+
+/*
+ ********* define floating point type & constants
+ */
+/* use "#if 0" below if Float should be double;
+   use "#if 1" below if Float should be float
+ */
+#if 0
+typedef float Float;
+#define maxFloat      FLT_MAX
+#define minFloat      FLT_MIN
+#else
+typedef double Float;
+#define maxFloat      DBL_MAX
+#define minFloat      DBL_MIN
+#endif
+
+/*
+ ********* define complex type
+ */
+typedef struct {
+  Float r;  /* real      part */
+  Float i;  /* imaginary part */
+} CPX;
+
+/*
+ ********* define boolean type
+ */
+typedef int Bool;
+#define false 0
+#define true 1
+
+/*
+ ********* Check current platform
+ */
+#if defined(__MSDOS__)
+#define PC
+#define PLATFORM "PC"
+#define LSBFIRST
+#elif defined(__osf__)
+#define OSF
+#define PLATFORM "OSF"
+#define LSBFIRST
+#elif defined(__sun__) || defined(__sun)
+#define SUN
+#define PLATFORM "SUN"
+#undef LSBFIRST
+#elif defined(linux) && defined(i386)
+#define PC
+#define PLATFORM "PC"
+#define LSBFIRST
+#elif defined(__arm__)
+#define PC
+#define PLATFORM "ARM"
+#define LSBFIRST
+#else
+#error "can't determine architecture; adapt typedefs.h to your platform"
+#endif
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/vad.h FFMpeg-20050127-new/libavcodec/amr/vad.h
--- FFMpeg-20050127/libavcodec/amr/vad.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/vad.h	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,48 @@
+/*
+********************************************************************************
+**-------------------------------------------------------------------------**
+**                                                                         **
+**     GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001       **
+**                               R99   Version 3.3.0                       **
+**                               REL-4 Version 4.1.0                       **
+**                                                                         **
+**-------------------------------------------------------------------------**
+********************************************************************************
+*
+*      File             : vad.h
+*      Purpose          : Voice Activity Detection (VAD) for AMR
+*
+********************************************************************************
+*/
+#ifndef vad_h
+#define vad_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+
+#include "vad1.h"	/* for VAD option 1 */
+#include "vad2.h"	/* for VAD option 2 */
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+
+#ifndef	VAD2
+#define vadState vadState1
+#else
+#define vadState vadState2
+#endif
+
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/vad1.c FFMpeg-20050127-new/libavcodec/amr/vad1.c
--- FFMpeg-20050127/libavcodec/amr/vad1.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/vad1.c	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,1071 @@
+/*
+*****************************************************************************
+**-------------------------------------------------------------------------**
+**                                                                         **
+**     GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001       **
+**                               R99   Version 3.3.0                       **
+**                               REL-4 Version 4.1.0                       **
+**                                                                         **
+**-------------------------------------------------------------------------**
+*****************************************************************************
+*
+*      File             : vad1.c
+*      Purpose          : Voice Activity Detection (VAD) for AMR (option 1)
+*
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "vad.h"
+const char vad1_id[] = "@(#)$Id $" vad_h;
+ 
+/*
+*****************************************************************************
+*                         INCLUDE FILES
+*****************************************************************************
+*/
+#include <stdlib.h>
+#include <stdio.h>
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "oper_32b.h"
+#include "cnst_vad.h"
+
+/*
+*****************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+*****************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         PRIVATE PROGRAM CODE
+********************************************************************************
+*/
+/****************************************************************************
+ *
+ *     Function     : first_filter_stage
+ *     Purpose      : Scale input down by one bit. Calculate 5th order
+ *                    half-band lowpass/highpass filter pair with
+ *                    decimation.
+ *
+ ***************************************************************************/
+static void first_filter_stage(Word16 in[],  /* i   : input signal                  */
+                               Word16 out[], /* o   : output values, every other    */
+                                             /*       output is low-pass part and   */
+                                             /*       other is high-pass part every */
+                               Word16 data[] /* i/o : filter memory                 */
+                               )
+{
+  Word16 temp0, temp1, temp2, temp3, i;
+  Word16 data0, data1;
+
+  data0 = data[0];                                          move16 ();
+  data1 = data[1];                                          move16 ();
+ 
+  for (i = 0; i < FRAME_LEN/4; i++)
+  {
+     temp0 = sub(shr(in[4*i+0], 2), mult(COEFF5_1, data0));
+     temp1 = add(data0, mult(COEFF5_1, temp0));
+     
+     temp3 = sub(shr(in[4*i+1], 2), mult(COEFF5_2, data1));
+     temp2 = add(data1, mult(COEFF5_2, temp3));
+     
+     out[4*i+0] = add(temp1, temp2);                        move16 ();
+     out[4*i+1] = sub(temp1, temp2);                        move16 ();
+     
+     data0 = sub(shr(in[4*i+2], 2), mult(COEFF5_1, temp0));
+     temp1 = add(temp0, mult(COEFF5_1, data0));
+     
+     data1 = sub(shr(in[4*i+3], 2), mult(COEFF5_2, temp3));
+     temp2 = add(temp3, mult(COEFF5_2, data1));
+     
+     out[4*i+2] = add(temp1, temp2);                       move16 ();
+     out[4*i+3] = sub(temp1, temp2);                       move16 ();
+  } 
+  
+  data[0] = data0;                                         move16 ();
+  data[1] = data1;                                         move16 ();
+}
+
+/****************************************************************************
+ *
+ *     Function     : filter5
+ *     Purpose      : Fifth-order half-band lowpass/highpass filter pair with
+ *                    decimation.
+ *
+ ***************************************************************************/
+static void filter5(Word16 *in0,    /* i/o : input values; output low-pass part  */
+                    Word16 *in1,    /* i/o : input values; output high-pass part */
+                    Word16 data[]   /* i/o : updated filter memory               */
+                    )
+{
+  Word16 temp0, temp1, temp2;
+
+  temp0 = sub(*in0, mult(COEFF5_1, data[0]));
+  temp1 = add(data[0], mult(COEFF5_1, temp0));
+  data[0] = temp0;                                move16 ();
+
+  temp0 = sub(*in1, mult(COEFF5_2, data[1]));
+  temp2 = add(data[1], mult(COEFF5_2, temp0));
+  data[1] = temp0;                                move16 ();
+
+  *in0 = shr(add(temp1, temp2), 1);               move16 ();
+  *in1 = shr(sub(temp1, temp2), 1);               move16 ();
+}
+
+/****************************************************************************
+ *
+ *     Function     : filter3
+ *     Purpose      : Third-order half-band lowpass/highpass filter pair with
+ *                    decimation.
+ *     Return value : 
+ *
+ ***************************************************************************/
+static void filter3(Word16 *in0,   /* i/o : input values; output low-pass part  */ 
+                    Word16 *in1,   /* i/o : input values; output high-pass part */
+                    Word16 *data   /* i/o : updated filter memory               */
+                    )
+{
+  Word16 temp1, temp2;
+
+  temp1 = sub(*in1, mult(COEFF3, *data));
+  temp2 = add(*data, mult(COEFF3, temp1));
+  *data = temp1;                              move16 ();
+
+  *in1 = shr(sub(*in0, temp2), 1);            move16 ();
+  *in0 = shr(add(*in0, temp2), 1);            move16 ();
+}
+
+/****************************************************************************
+ *
+ *     Function     : level_calculation
+ *     Purpose      : Calculate signal level in a sub-band. Level is calculated
+ *                    by summing absolute values of the input data.
+ *     Return value : signal level
+ *
+ ***************************************************************************/
+static Word16 level_calculation(
+    Word16 data[],     /* i   : signal buffer                                    */
+    Word16 *sub_level, /* i   : level calculate at the end of the previous frame */
+                       /* o   : level of signal calculated from the last         */
+                       /*       (count2 - count1) samples                        */
+    Word16 count1,     /* i   : number of samples to be counted                  */
+    Word16 count2,     /* i   : number of samples to be counted                  */
+    Word16 ind_m,      /* i   : step size for the index of the data buffer       */
+    Word16 ind_a,      /* i   : starting index of the data buffer                */
+    Word16 scale       /* i   : scaling for the level calculation                */
+    )
+{
+  Word32 l_temp1, l_temp2;
+  Word16 level, i;
+
+  l_temp1 = 0L;                                           move32 ();
+  for (i = count1; i < count2; i++)
+  {
+     l_temp1 = L_mac(l_temp1, 1, abs_s(data[ind_m*i+ind_a]));
+  }
+  
+  l_temp2 = L_add(l_temp1, L_shl(*sub_level, sub(16, scale)));
+  *sub_level = extract_h(L_shl(l_temp1, scale));
+  
+  for (i = 0; i < count1; i++)
+  {
+     l_temp2 = L_mac(l_temp2, 1, abs_s(data[ind_m*i+ind_a]));
+  }
+  level = extract_h(L_shl(l_temp2, scale));
+  
+  return level;
+}
+
+/****************************************************************************
+ *
+ *     Function     : filter_bank
+ *     Purpose      : Divides input signal into 9-bands and calculas level of
+ *                    the signal in each band 
+ *
+ ***************************************************************************/
+static void filter_bank(vadState1 *st,  /* i/o : State struct               */
+                        Word16 in[],   /* i   : input frame                */
+                        Word16 level[] /* 0   : signal levels at each band */
+                        )
+{
+  Word16 i;
+  Word16 tmp_buf[FRAME_LEN];
+
+  /* calculate the filter bank */
+
+  first_filter_stage(in, tmp_buf, st->a_data5[0]);
+  
+  for (i = 0; i < FRAME_LEN/4; i++)
+  {
+     filter5(&tmp_buf[4*i], &tmp_buf[4*i+2], st->a_data5[1]);
+     filter5(&tmp_buf[4*i+1], &tmp_buf[4*i+3], st->a_data5[2]);
+  }
+  for (i = 0; i < FRAME_LEN/8; i++)
+  {
+     filter3(&tmp_buf[8*i+0], &tmp_buf[8*i+4], &st->a_data3[0]);
+     filter3(&tmp_buf[8*i+2], &tmp_buf[8*i+6], &st->a_data3[1]);
+     filter3(&tmp_buf[8*i+3], &tmp_buf[8*i+7], &st->a_data3[4]);
+  }
+  
+  for (i = 0; i < FRAME_LEN/16; i++)
+  {
+     filter3(&tmp_buf[16*i+0], &tmp_buf[16*i+8], &st->a_data3[2]);
+     filter3(&tmp_buf[16*i+4], &tmp_buf[16*i+12], &st->a_data3[3]);
+  }
+  
+  /* calculate levels in each frequency band */
+  
+  /* 3000 - 4000 Hz*/
+  level[8] = level_calculation(tmp_buf, &st->sub_level[8], FRAME_LEN/4-8,
+                               FRAME_LEN/4, 4, 1, 15);
+  move16 ();
+  /* 2500 - 3000 Hz*/  
+  level[7] = level_calculation(tmp_buf, &st->sub_level[7], FRAME_LEN/8-4,
+                               FRAME_LEN/8, 8, 7, 16);
+  move16 ();
+  /* 2000 - 2500 Hz*/
+  level[6] = level_calculation(tmp_buf, &st->sub_level[6], FRAME_LEN/8-4,
+                               FRAME_LEN/8, 8, 3, 16);
+  move16 ();
+  /* 1500 - 2000 Hz*/
+  level[5] = level_calculation(tmp_buf, &st->sub_level[5], FRAME_LEN/8-4,
+                               FRAME_LEN/8, 8, 2, 16);
+  move16 ();
+  /* 1000 - 1500 Hz*/
+  level[4] = level_calculation(tmp_buf, &st->sub_level[4], FRAME_LEN/8-4,
+                               FRAME_LEN/8, 8, 6, 16);
+  move16 ();
+  /* 750 - 1000 Hz*/
+  level[3] = level_calculation(tmp_buf, &st->sub_level[3], FRAME_LEN/16-2,
+                               FRAME_LEN/16, 16, 4, 16);
+  move16 ();
+  /* 500 - 750 Hz*/
+  level[2] = level_calculation(tmp_buf, &st->sub_level[2], FRAME_LEN/16-2,
+                               FRAME_LEN/16, 16, 12, 16);
+  move16 ();
+  /* 250 - 500 Hz*/
+  level[1] = level_calculation(tmp_buf, &st->sub_level[1], FRAME_LEN/16-2,
+                               FRAME_LEN/16, 16, 8, 16);
+  move16 ();
+  /* 0 - 250 Hz*/
+  level[0] = level_calculation(tmp_buf, &st->sub_level[0], FRAME_LEN/16-2,
+                               FRAME_LEN/16, 16, 0, 16);
+  move16 ();
+}
+
+/****************************************************************************
+ *
+ *     Function   : update_cntrl
+ *     Purpose    : Control update of the background noise estimate.
+ *     Inputs     : pitch:      flags for pitch detection
+ *                  stat_count: stationary counter
+ *                  tone:       flags indicating presence of a tone
+ *                  complex:      flags for complex  detection
+ *                  vadreg:     intermediate VAD flags
+ *     Output     : stat_count: stationary counter
+ *
+ ***************************************************************************/
+static void update_cntrl(vadState1 *st,  /* i/o : State struct                       */
+                         Word16 level[] /* i   : sub-band levels of the input frame */
+                         )
+{
+  Word16 i, temp, stat_rat, exp;
+  Word16 num, denom;
+  Word16 alpha; 
+
+  /* handle highband complex signal input  separately       */
+  /* if ther has been highband correlation for some time    */
+  /* make sure that the VAD update speed is low for a while */
+  test ();
+  if (st->complex_warning != 0)
+  {
+     test ();
+     if (sub(st->stat_count, CAD_MIN_STAT_COUNT) < 0)
+     {
+        st->stat_count = CAD_MIN_STAT_COUNT;              move16 ();    
+     }
+  }
+  /* NB stat_count is allowed to be decreased by one below again  */
+  /* deadlock in speech is not possible unless the signal is very */
+  /* complex and need a high rate                                 */
+
+  /* if fullband pitch or tone have been detected for a while, initialize stat_count */
+  logic16 (); test (); logic16 (); test ();
+  if ((sub((st->pitch & 0x6000), 0x6000) == 0) ||
+      (sub((st->tone & 0x7c00), 0x7c00) == 0))
+  {
+     st->stat_count = STAT_COUNT;                          move16 ();  
+  }
+  else
+  {
+     /* if 8 last vad-decisions have been "0", reinitialize stat_count */
+     logic16 (); test ();
+     if ((st->vadreg & 0x7f80) == 0) 
+     { 
+        st->stat_count = STAT_COUNT;                       move16 ();
+     }
+     else
+     {
+        stat_rat = 0;                                      move16 ();
+        for (i = 0; i < COMPLEN; i++)
+        {
+           test ();
+           if (sub(level[i], st->ave_level[i]) > 0)
+           {
+              num = level[i];                              move16 ();
+              denom = st->ave_level[i];                    move16 ();
+           }
+           else
+           {
+              num = st->ave_level[i];                      move16 ();
+              denom = level[i];                            move16 ();
+           }
+           /* Limit nimimum value of num and denom to STAT_THR_LEVEL */
+           test ();
+           if (sub(num, STAT_THR_LEVEL) < 0)
+           {
+              num = STAT_THR_LEVEL;                        move16 ();
+           }
+           test ();
+           if (sub(denom, STAT_THR_LEVEL) < 0)
+           {
+              denom = STAT_THR_LEVEL;                      move16 ();
+           }
+           
+           exp = norm_s(denom);
+           denom = shl(denom, exp);
+           
+           /* stat_rat = num/denom * 64 */
+           temp = div_s(shr(num, 1), denom);
+           stat_rat = add(stat_rat, shr(temp, sub(8, exp)));
+        }
+        
+        /* compare stat_rat with a threshold and update stat_count */
+        test ();
+        if (sub(stat_rat, STAT_THR) > 0)
+        {
+           st->stat_count = STAT_COUNT;                    move16 ();
+        }
+        else
+        {
+           logic16 ();test ();
+           if ((st->vadreg & 0x4000) != 0)
+           {
+              test ();
+              if (st->stat_count != 0)
+              {
+                 st->stat_count = sub(st->stat_count, 1);  move16 ();
+              }
+           }
+        }
+     }
+  }
+  
+  /* Update average amplitude estimate for stationarity estimation */
+  alpha = ALPHA4;                                          move16 ();
+  test ();
+  if (sub(st->stat_count, STAT_COUNT) == 0) 
+  {
+     alpha = 32767;                                        move16 ();
+  }
+  else if ((st->vadreg & 0x4000) == 0) 
+  {
+     logic16 (); test ();
+     alpha = ALPHA5;                                       move16 ();
+  }
+  
+  for (i = 0; i < COMPLEN; i++)
+  {
+     st->ave_level[i] = add(st->ave_level[i],
+                            mult_r(alpha, sub(level[i], st->ave_level[i])));
+     move16 ();
+  }  
+}
+
+/****************************************************************************
+ *
+ *     Function     : hangover_addition
+ *     Purpose      : Add hangover for complex signal or after speech bursts
+ *     Inputs       : burst_count:  counter for the length of speech bursts
+ *                    hang_count:   hangover counter
+ *                    vadreg:       intermediate VAD decision
+ *     Outputs      : burst_count:  counter for the length of speech bursts
+ *                    hang_count:   hangover counter
+ *     Return value : VAD_flag indicating final VAD decision
+ *
+ ***************************************************************************/
+static Word16 hangover_addition(
+              vadState1 *st,       /* i/o : State struct                     */
+              Word16 noise_level, /* i   : average level of the noise       */
+                                  /*       estimates                        */
+              Word16 low_power    /* i   : flag power of the input frame    */
+              )
+{
+   Word16 hang_len, burst_len;
+   
+   /* 
+      Calculate burst_len and hang_len
+      burst_len: number of consecutive intermediate vad flags with "1"-decision
+                 required for hangover addition
+      hang_len:  length of the hangover
+      */
+
+   test ();
+   if (sub(noise_level, HANG_NOISE_THR) > 0)
+   {
+      burst_len = BURST_LEN_HIGH_NOISE;                           move16 ();
+      hang_len = HANG_LEN_HIGH_NOISE;                             move16 ();
+   }
+   else
+   {
+      burst_len = BURST_LEN_LOW_NOISE;                            move16 ();
+      hang_len = HANG_LEN_LOW_NOISE;                              move16 ();
+   }
+   
+   /* if the input power (pow_sum) is lower than a threshold, clear
+      counters and set VAD_flag to "0"  "fast exit"                 */
+   test ();
+   if (low_power != 0)
+   {
+      st->burst_count = 0;                                        move16 ();
+      st->hang_count = 0;                                         move16 ();
+      st->complex_hang_count = 0;                                 move16 ();
+      st->complex_hang_timer = 0;                                 move16 ();
+      return 0;
+   }
+   
+   test ();
+   if (sub(st->complex_hang_timer, CVAD_HANG_LIMIT) > 0)
+   {
+      test ();
+      if (sub(st->complex_hang_count, CVAD_HANG_LENGTH) < 0)
+      {
+         st->complex_hang_count = CVAD_HANG_LENGTH;               move16 ();
+      }      
+   }
+   
+   /* long time very complex signal override VAD output function */
+   test ();
+   if (st->complex_hang_count != 0)
+   {
+      st->burst_count = BURST_LEN_HIGH_NOISE;                     move16 ();
+      st->complex_hang_count = sub(st->complex_hang_count, 1);    move16 ();
+      return 1; 
+   }
+   else
+   {
+      /* let hp_corr work in from a noise_period indicated by the VAD */
+      test (); test (); logic16 ();
+      if (((st->vadreg & 0x3ff0) == 0) &&
+          (sub(st->corr_hp_fast, CVAD_THRESH_IN_NOISE) > 0))
+      {
+         return 1;
+      }  
+   }
+
+   /* update the counters (hang_count, burst_count) */
+   logic16 (); test ();
+   if ((st->vadreg & 0x4000) != 0)
+   {
+      st->burst_count = add(st->burst_count, 1);                  move16 ();
+      test ();
+      if (sub(st->burst_count, burst_len) >= 0)
+      {
+         st->hang_count = hang_len;                               move16 ();
+      }
+      return 1;
+   }
+   else
+   {
+      st->burst_count = 0;                                        move16 ();
+      test ();
+      if (st->hang_count > 0)
+      {
+         st->hang_count = sub(st->hang_count, 1);                 move16 ();
+         return 1;
+      }
+   }
+   return 0;
+}
+
+/****************************************************************************
+ *
+ *     Function   : noise_estimate_update
+ *     Purpose    : Update of background noise estimate
+ *     Inputs     : bckr_est:   background noise estimate
+ *                  pitch:      flags for pitch detection
+ *                  stat_count: stationary counter
+ *     Outputs    : bckr_est:   background noise estimate
+ *
+ ***************************************************************************/
+static void noise_estimate_update(
+                  vadState1 *st,    /* i/o : State struct                       */
+                  Word16 level[]   /* i   : sub-band levels of the input frame */
+                  )
+{
+   Word16 i, alpha_up, alpha_down, bckr_add;
+   
+   /* Control update of bckr_est[] */
+   update_cntrl(st, level);
+   
+   /* Choose update speed */
+   bckr_add = 2;                                           move16 ();
+   
+   logic16 (); test (); logic16 (); test (); test ();
+   if (((0x7800 & st->vadreg) == 0) && 
+       ((st->pitch & 0x7800) == 0) 
+       &&  (st->complex_hang_count == 0))
+   {
+      alpha_up = ALPHA_UP1;                                move16 ();
+      alpha_down = ALPHA_DOWN1;                            move16 ();
+   }
+   else 
+   {
+      test (); test ();
+      if ((st->stat_count == 0) 
+          && (st->complex_hang_count == 0))
+      {
+         alpha_up = ALPHA_UP2;                             move16 ();
+         alpha_down = ALPHA_DOWN2;                         move16 ();
+      }
+      else
+      {
+         alpha_up = 0;                                     move16 ();
+         alpha_down = ALPHA3;                              move16 ();
+         bckr_add = 0;                                     move16 ();
+      }
+   }
+   
+   /* Update noise estimate (bckr_est) */
+   for (i = 0; i < COMPLEN; i++)
+   {
+      Word16 temp;
+      temp = sub(st->old_level[i], st->bckr_est[i]);
+      
+      test ();
+      if (temp < 0)
+      { /* update downwards*/
+         st->bckr_est[i] = add(-2, add(st->bckr_est[i], mult_r(alpha_down, temp)));
+         move16 ();
+         
+         /* limit minimum value of the noise estimate to NOISE_MIN */
+         test ();
+         if (sub(st->bckr_est[i], NOISE_MIN) < 0)
+         {
+            st->bckr_est[i] = NOISE_MIN;                  move16 ();
+         }
+      }
+      else
+      { /* update upwards */
+         st->bckr_est[i] = add(bckr_add, add(st->bckr_est[i], mult_r(alpha_up, temp)));
+         move16 ();
+         
+         /* limit maximum value of the noise estimate to NOISE_MAX */
+         test ();
+         if (sub(st->bckr_est[i], NOISE_MAX) > 0)
+         {
+            st->bckr_est[i] = NOISE_MAX;                  move16 ();
+         }
+      }
+   }
+   
+   /* Update signal levels of the previous frame (old_level) */
+   for(i = 0; i < COMPLEN; i++)
+   {
+      st->old_level[i] = level[i];                        move16 ();
+   }
+}
+
+/****************************************************************************
+ *
+ *     Function   : complex_estimate_adapt
+ *     Purpose    : Update/adapt of complex signal estimate
+ *     Inputs     : low_power:   low signal power flag 
+ *     Outputs    : st->corr_hp_fast:   long term complex signal estimate
+ *
+ ***************************************************************************/
+static void complex_estimate_adapt(
+         vadState1 *st,       /* i/o : VAD state struct                       */
+         Word16 low_power    /* i   : very low level flag of the input frame */
+         )
+{
+   Word16 alpha;            /* Q15 */
+   Word32 L_tmp;            /* Q31 */
+
+
+   /* adapt speed on own state */
+   test ();
+   if (sub(st->best_corr_hp, st->corr_hp_fast) < 0) /* decrease */
+   {
+      test ();
+      if (sub(st->corr_hp_fast, CVAD_THRESH_ADAPT_HIGH) < 0)
+      {  /* low state  */
+         alpha = CVAD_ADAPT_FAST;                          move16(); 
+      }  
+      else 
+      {  /* high state */
+         alpha = CVAD_ADAPT_REALLY_FAST;                   move16();   
+      }      
+   }
+   else  /* increase */ 
+   {
+      test ();
+      if (sub(st->corr_hp_fast, CVAD_THRESH_ADAPT_HIGH) < 0)
+      {  
+         alpha = CVAD_ADAPT_FAST;                          move16(); 
+      }  
+      else 
+      {  
+         alpha = CVAD_ADAPT_SLOW;                          move16();
+      }      
+   }
+
+   L_tmp = L_deposit_h(st->corr_hp_fast);
+   L_tmp = L_msu(L_tmp, alpha, st->corr_hp_fast);
+   L_tmp = L_mac(L_tmp, alpha, st->best_corr_hp);
+   st->corr_hp_fast = round(L_tmp);           /* Q15 */    move16();   
+
+   test ();
+   if (sub(st->corr_hp_fast, CVAD_MIN_CORR) <  0)
+   {
+      st->corr_hp_fast = CVAD_MIN_CORR;                    move16();
+   }
+
+   test ();
+   if (low_power != 0)
+   {
+      st->corr_hp_fast = CVAD_MIN_CORR;                    move16();
+   }   
+}
+
+/****************************************************************************
+ *
+ *     Function     : complex_vad
+ *     Purpose      : complex background decision
+ *     Return value : the complex background decision
+ *
+ ***************************************************************************/
+static Word16 complex_vad(vadState1 *st,    /* i/o : VAD state struct              */
+                          Word16 low_power /* i   : flag power of the input frame */
+                          )
+{
+   st->complex_high = shr(st->complex_high, 1);                      move16 ();
+   st->complex_low = shr(st->complex_low, 1);                        move16 ();
+
+   test ();
+   if (low_power == 0)
+   {
+      test ();
+      if (sub(st->corr_hp_fast, CVAD_THRESH_ADAPT_HIGH) > 0)
+      {
+         st->complex_high = st->complex_high | 0x4000;   logic16 (); move16 ();
+      }
+      
+      test ();
+      if (sub(st->corr_hp_fast, CVAD_THRESH_ADAPT_LOW) > 0 )
+      {
+         st->complex_low = st->complex_low | 0x4000;     logic16 (); move16 ();
+      }
+   }
+
+   test ();
+   if (sub(st->corr_hp_fast, CVAD_THRESH_HANG) > 0)
+   {
+      st->complex_hang_timer = add(st->complex_hang_timer, 1);       move16 ();
+   }
+   else
+   {
+      st->complex_hang_timer =  0;                                   move16 ();
+   }               
+   
+   test (); logic16 (); test (); logic16 ();
+   return ((sub((st->complex_high & 0x7f80), 0x7f80) == 0) ||
+           (sub((st->complex_low & 0x7fff), 0x7fff) == 0));
+}
+
+/****************************************************************************
+ *
+ *     Function     : vad_decision
+ *     Purpose      : Calculates VAD_flag
+ *     Inputs       : bckr_est:    background noise estimate
+ *                    vadreg:      intermediate VAD flags
+ *     Outputs      : noise_level: average level of the noise estimates
+ *                    vadreg:      intermediate VAD flags
+ *     Return value : VAD_flag
+ *
+ ***************************************************************************/
+static Word16 vad_decision(
+             vadState1 *st,          /* i/o : State struct                       */
+             Word16 level[COMPLEN], /* i   : sub-band levels of the input frame */
+             Word32 pow_sum         /* i   : power of the input frame           */
+             )
+{
+   Word16 i;
+   Word16 snr_sum;
+   Word32 L_temp;
+   Word16 vad_thr, temp, noise_level;
+   Word16 low_power_flag;
+   
+   /* 
+      Calculate squared sum of the input levels (level)
+      divided by the background noise components (bckr_est).
+      */
+   L_temp = 0;                                            move32();
+   for (i = 0; i < COMPLEN; i++)
+   {
+      Word16 exp;
+      
+      exp = norm_s(st->bckr_est[i]);
+      temp = shl(st->bckr_est[i], exp);
+      temp = div_s(shr(level[i], 1), temp);
+      temp = shl(temp, sub(exp, UNIRSHFT-1));
+      L_temp = L_mac(L_temp, temp, temp);
+   }
+   snr_sum = extract_h(L_shl(L_temp, 6));
+   snr_sum = mult(snr_sum, INV_COMPLEN);
+
+   /* Calculate average level of estimated background noise */
+   L_temp = 0;                                            move32();
+   for (i = 0; i < COMPLEN; i++)
+   {
+      L_temp = L_add(L_temp, st->bckr_est[i]);
+   }
+   
+   noise_level = extract_h(L_shl(L_temp, 13));
+   
+   /* Calculate VAD threshold */
+   vad_thr = add(mult(VAD_SLOPE, sub(noise_level, VAD_P1)), VAD_THR_HIGH);
+   
+   test ();
+   if (sub(vad_thr, VAD_THR_LOW) < 0)
+   {
+      vad_thr = VAD_THR_LOW;                              move16 ();
+   }
+   
+   /* Shift VAD decision register */
+   st->vadreg = shr(st->vadreg, 1);                       move16 ();
+   
+   /* Make intermediate VAD decision */
+   test ();
+   if (sub(snr_sum, vad_thr) > 0)
+   {
+      st->vadreg = st->vadreg | 0x4000;       logic16 (); move16 ();
+   }
+   /* primary vad decsion made */
+   
+   /* check if the input power (pow_sum) is lower than a threshold" */
+   test ();
+   if (L_sub(pow_sum, VAD_POW_LOW) < 0)
+   {
+      low_power_flag = 1;                                 move16 ();
+   }
+   else
+   {
+      low_power_flag = 0;                                 move16 ();
+   }
+   
+   /* update complex signal estimate st->corr_hp_fast and hangover reset timer using */
+   /* low_power_flag and corr_hp_fast  and various adaptation speeds                 */
+   complex_estimate_adapt(st, low_power_flag);
+
+   /* check multiple thresholds of the st->corr_hp_fast value */
+   st->complex_warning = complex_vad(st, low_power_flag); move16();    
+
+   /* Update speech subband vad background noise estimates */
+   noise_estimate_update(st, level);
+     
+   /*  Add speech and complex hangover and return speech VAD_flag */
+   /*  long term complex hangover may be added */
+   st->speech_vad_decision = hangover_addition(st, noise_level, low_power_flag);
+   move16 ();
+   
+   return (st->speech_vad_decision);
+}
+
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+/*************************************************************************
+*
+*  Function:   vad1_init
+*  Purpose:    Allocates state memory and initializes state memory
+*
+**************************************************************************
+*/
+int vad1_init (vadState1 **state)
+{
+    vadState1* s;
+    
+    if (state == (vadState1 **) NULL){
+        fprintf(stderr, "vad_init: invalid parameter\n");
+        return -1;
+    }
+    *state = NULL;
+    
+    /* allocate memory */
+    if ((s = (vadState1 *) malloc(sizeof(vadState1))) == NULL){
+        fprintf(stderr, "vad_init: can not malloc state structure\n");
+        return -1;
+    }
+    
+    vad1_reset(s);
+    
+    *state = s;
+    
+    return 0;
+}
+ 
+/*************************************************************************
+*
+*  Function:   vad1_reset
+*  Purpose:    Initializes state memory to zero
+*
+**************************************************************************
+*/
+int vad1_reset (vadState1 *state)
+{
+   Word16 i, j;
+   
+   if (state == (vadState1 *) NULL){
+      fprintf(stderr, "vad_reset: invalid parameter\n");
+      return -1;
+   }
+   
+   /* Initialize pitch detection variables */
+   state->oldlag_count = 0;
+   state->oldlag = 0;         
+   state->pitch = 0;
+   state->tone = 0;            
+
+   state->complex_high = 0;            
+   state->complex_low = 0;            
+   state->complex_hang_timer = 0;
+
+   state->vadreg = 0;         
+
+   state->stat_count = 0;    
+   state->burst_count = 0;    
+   state->hang_count = 0;     
+   state->complex_hang_count = 0;     
+   
+   /* initialize memory used by the filter bank */
+   for (i = 0; i < 3; i++)
+   {
+      for (j = 0; j < 2; j++) 
+      {
+         state->a_data5[i][j] = 0;  
+      }
+   }
+   
+   for (i = 0; i < 5; i++)
+   {
+      state->a_data3[i] = 0;        
+   }
+   
+   /* initialize the rest of the memory */
+   for (i = 0; i < COMPLEN; i++)
+   {
+      state->bckr_est[i] = NOISE_INIT;  
+      state->old_level[i] = NOISE_INIT; 
+      state->ave_level[i] = NOISE_INIT; 
+      state->sub_level[i] = 0;          
+   }
+   
+   state->best_corr_hp = CVAD_LOWPOW_RESET; 
+
+   state->speech_vad_decision = 0;
+   state->complex_warning = 0;
+   state->sp_burst_count = 0;        
+
+   state->corr_hp_fast = CVAD_LOWPOW_RESET;
+ 
+   return 0;
+}
+
+/*************************************************************************
+*
+*  Function:   vad1_exit
+*  Purpose:    The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void vad1_exit (vadState1 **state)
+{
+    if (state == NULL || *state == NULL)
+        return;
+    
+    /* deallocate memory */
+    free(*state);
+    *state = NULL;
+    
+    return;
+}
+
+/****************************************************************************
+ *
+ *     Function     : vad_complex_detection_update
+ *     Purpose      : update vad->bestCorr_hp  complex signal feature state 
+ *
+ ***************************************************************************/
+void vad_complex_detection_update (vadState1 *st,       /* i/o : State struct */
+                                   Word16 best_corr_hp /* i   : best Corr    */
+                                   )
+{
+   st->best_corr_hp = best_corr_hp;         move16();
+}
+
+/****************************************************************************
+ *
+ *     Function     : vad_tone_detection
+ *     Purpose      : Set tone flag if pitch gain is high. This is used to detect
+ *                    signaling tones and other signals with high pitch gain.
+ *     Inputs       : tone: flags indicating presence of a tone
+ *     Outputs      : tone: flags indicating presence of a tone
+ *
+ ***************************************************************************/
+void vad_tone_detection (vadState1 *st,  /* i/o : State struct            */
+                         Word32 t0,     /* i   : autocorrelation maxima  */
+                         Word32 t1      /* i   : energy                  */
+                         )
+{
+   Word16 temp;
+   /* 
+      if (t0 > TONE_THR * t1)
+      set tone flag
+      */
+   temp = round(t1);
+   
+   test (); test ();
+   if ((temp > 0) && (L_msu(t0, temp, TONE_THR) > 0))
+   {
+      st->tone = st->tone | 0x4000;              logic16 (); move16 ();
+   }
+}
+
+/****************************************************************************
+ *
+ *     Function     : vad_tone_detection_update
+ *     Purpose      : Update the tone flag register. Tone flags are shifted right
+ *                    by one bit. This function should be called from the speech
+ *                    encoder before call to Vad_tone_detection() function.
+ *
+ ***************************************************************************/
+void vad_tone_detection_update (
+                vadState1 *st,              /* i/o : State struct              */
+                Word16 one_lag_per_frame   /* i   : 1 if one open-loop lag is
+                                              calculated per each frame,
+                                              otherwise 0                     */
+                )
+{
+   /* Shift tone flags right by one bit */
+   st->tone = shr(st->tone, 1);                move16 ();
+   
+   /* If open-loop lag is calculated only once in each frame, do extra update
+      and assume that the other tone flag of the frame is one. */
+   if (one_lag_per_frame != 0)
+   {
+      st->tone = shr(st->tone, 1);            
+      st->tone = st->tone | 0x2000;            logic16 (); move16 ();
+   }
+}
+
+/****************************************************************************
+ *
+ *     Function     : vad_pitch_detection
+ *     Purpose      : Test whether signal contains pitch or other periodic
+ *                    component.
+ *     Return value : Boolean voiced / unvoiced decision in state variable 
+ *
+ ***************************************************************************/
+void vad_pitch_detection (vadState1 *st,   /* i/o : State struct                  */
+                          Word16 T_op[]   /* i   : speech encoder open loop lags */
+                          )
+{
+   Word16 lagcount, i;
+   
+   lagcount = 0;               move16 ();
+   
+   for (i = 0; i < 2; i++)
+   {
+      test ();
+      if (sub (abs_s (sub (st->oldlag, T_op[i])), LTHRESH) < 0)
+      {
+         lagcount = add (lagcount, 1);
+      }
+      
+      /* Save the current LTP lag */
+      st->oldlag = T_op[i];       move16 ();
+   }
+   
+   /* Make pitch decision.
+      Save flag of the pitch detection to the variable pitch.
+      */
+   st->pitch = shr(st->pitch, 1); move16();
+   
+   test ();
+   if (sub ( add (st->oldlag_count, lagcount), NTHRESH) >= 0)
+   {
+      st->pitch = st->pitch | 0x4000; logic16(); move16();
+   }
+   
+   /* Update oldlagcount */
+   st->oldlag_count = lagcount;     move16 ();
+}
+
+/****************************************************************************
+ *
+ *     Function     : vad
+ *     Purpose      : Main program for Voice Activity Detection (VAD) for AMR 
+ *     Return value : VAD Decision, 1 = speech, 0 = noise
+ *
+ ***************************************************************************/
+Word16 vad1(vadState1 *st,      /* i/o : State struct                 */
+           Word16 in_buf[]    /* i   : samples of the input frame   */
+           )
+{
+   Word16 level[COMPLEN];
+   Word32 pow_sum;
+   Word16 i;
+   
+   /* Calculate power of the input frame. */
+   pow_sum = 0L;                                     move32 ();
+
+   for (i = 0; i < FRAME_LEN; i++)
+   {  
+      pow_sum = L_mac(pow_sum, in_buf[i-LOOKAHEAD], in_buf[i-LOOKAHEAD]);
+   }
+
+   /*
+     If input power is very low, clear pitch flag of the current frame
+     */
+   test ();
+   if (L_sub(pow_sum, POW_PITCH_THR) < 0)
+   {
+      st->pitch = st->pitch & 0x3fff;                logic16 (); move16 ();
+   }
+
+   /*
+     If input power is very low, clear complex flag of the "current" frame
+     */
+   test ();
+   if (L_sub(pow_sum, POW_COMPLEX_THR) < 0)
+   {
+      st->complex_low = st->complex_low & 0x3fff;    logic16 (); move16 ();
+   }
+   
+   /*
+     Run the filter bank which calculates signal levels at each band
+     */
+   filter_bank(st, in_buf, level);
+   
+   return (vad_decision(st, level, pow_sum));
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/vad1.h FFMpeg-20050127-new/libavcodec/amr/vad1.h
--- FFMpeg-20050127/libavcodec/amr/vad1.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/vad1.h	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,127 @@
+/*
+********************************************************************************
+**-------------------------------------------------------------------------**
+**                                                                         **
+**     GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001       **
+**                               R99   Version 3.3.0                       **
+**                               REL-4 Version 4.1.0                       **
+**                                                                         **
+**-------------------------------------------------------------------------**
+********************************************************************************
+*
+*      File             : vad1.h
+*      Purpose          : Voice Activity Detection (VAD) for AMR (option 1)
+*
+********************************************************************************
+*/
+#ifndef vad1_h
+#define vad1_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "cnst_vad.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+
+/* state variable */
+typedef struct {
+   
+   Word16 bckr_est[COMPLEN];    /* background noise estimate                */
+   Word16 ave_level[COMPLEN];   /* averaged input components for stationary */
+                                /*    estimation                            */
+   Word16 old_level[COMPLEN];   /* input levels of the previous frame       */
+   Word16 sub_level[COMPLEN];   /* input levels calculated at the end of
+                                      a frame (lookahead)                   */
+   Word16 a_data5[3][2];        /* memory for the filter bank               */
+   Word16 a_data3[5];           /* memory for the filter bank               */
+
+   Word16 burst_count;          /* counts length of a speech burst          */
+   Word16 hang_count;           /* hangover counter                         */
+   Word16 stat_count;           /* stationary counter                       */
+
+   /* Note that each of the following three variables (vadreg, pitch and tone)
+      holds 15 flags. Each flag reserves 1 bit of the variable. The newest
+      flag is in the bit 15 (assuming that LSB is bit 1 and MSB is bit 16). */
+   Word16 vadreg;               /* flags for intermediate VAD decisions     */
+   Word16 pitch;                /* flags for pitch detection                */
+   Word16 tone;                 /* flags for tone detection                 */
+   Word16 complex_high;         /* flags for complex detection              */
+   Word16 complex_low;          /* flags for complex detection              */
+
+   Word16 oldlag_count, oldlag; /* variables for pitch detection            */
+ 
+   Word16 complex_hang_count;   /* complex hangover counter, used by VAD    */
+   Word16 complex_hang_timer;   /* hangover initiator, used by CAD          */
+    
+   Word16 best_corr_hp;         /* FIP filtered value Q15                   */ 
+
+   Word16 speech_vad_decision;  /* final decision                           */
+   Word16 complex_warning;      /* complex background warning               */
+
+   Word16 sp_burst_count;       /* counts length of a speech burst incl
+                                   HO addition                              */
+   Word16 corr_hp_fast;         /* filtered value                           */ 
+} vadState1;
+
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+int vad1_init (vadState1 **st);
+/* initialize one instance of the pre processing state.
+   Stores pointer to filter status struct in *st. This pointer has to
+   be passed to vad in each call.
+   returns 0 on success
+ */
+ 
+int vad1_reset (vadState1 *st);
+/* reset of pre processing state (i.e. set state memory to zero)
+   returns 0 on success
+ */
+
+void vad1_exit (vadState1 **st);
+/* de-initialize pre processing state (i.e. free status struct)
+   stores NULL in *st
+ */
+
+void vad_complex_detection_update (vadState1 *st,      /* i/o : State struct     */
+                                   Word16 best_corr_hp /* i   : best Corr Q15    */
+                                   );
+
+void vad_tone_detection (vadState1 *st, /* i/o : State struct            */
+                         Word32 t0,     /* i   : autocorrelation maxima  */
+                         Word32 t1      /* i   : energy                  */
+                         );
+
+void vad_tone_detection_update (
+                vadState1 *st,             /* i/o : State struct              */
+                Word16 one_lag_per_frame   /* i   : 1 if one open-loop lag is
+                                              calculated per each frame,
+                                              otherwise 0                     */
+                );
+
+void vad_pitch_detection (vadState1 *st,  /* i/o : State struct                  */
+                          Word16 lags[]   /* i   : speech encoder open loop lags */
+                          );
+
+Word16 vad1 (vadState1 *st,  /* i/o : State struct                      */
+            Word16 in_buf[]  /* i   : samples of the input frame 
+                                inbuf[159] is the very last sample,
+                                incl lookahead                          */
+            );
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/vad2.c FFMpeg-20050127-new/libavcodec/amr/vad2.c
--- FFMpeg-20050127/libavcodec/amr/vad2.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/vad2.c	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,914 @@
+/*
+*****************************************************************************
+*                                                                        
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : vad2.c
+*      Purpose          : Voice Activity Detection (VAD) for AMR (option 2)
+*
+*****************************************************************************
+*/
+
+/*
+*****************************************************************************
+*                         VERSION ID
+*****************************************************************************
+*/
+
+const char vad2_id[] = "@(#)$Id $";
+
+
+/***************************************************************************
+ *
+ *   FUNCTION NAME: vad2()
+ *
+ *   PURPOSE:
+ *     This function provides the Voice Activity Detection function option 2
+ *     for the Adaptive Multi-rate (AMR) codec.
+ *
+ *   INPUTS:
+ *
+ *     farray_ptr
+ *                     pointer to Word16[80] input array
+ *     vadState2
+ *                     pointer to vadState2 state structure
+ *
+ *   OUTPUTS:
+ *
+ *     state variables are updated
+ *
+ *   RETURN VALUE:
+ *
+ *     Word16
+ *                     VAD(m) - two successive calls to vad2() yield
+ *                     the VAD decision for the 20 ms frame:
+ *                     VAD_flag = VAD(m-1) || VAD(m)
+ *
+ *
+ *************************************************************************/
+
+/* Includes */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "typedef.h"
+#include "cnst.h"
+#include "basic_op.h"
+#include "oper_32b.h"
+#include "count.h"
+#include "log2.h"
+#include "pow2.h"
+
+#include "vad2.h"
+
+
+/* Local functions */
+
+/***************************************************************************
+ *
+ *   FUNCTION NAME: fn10Log10
+ *
+ *   PURPOSE:
+ *     The purpose of this function is to take the 10*log base 10 of input and
+ *     divide by 128 and return; i.e. output = 10*log10(input)/128 (scaled as 7,8)
+ *
+ *   INPUTS:
+ *
+ *     L_Input
+ *                     input (scaled as 31-fbits,fbits)
+ *     fbits
+ *                     number of fractional bits on input
+ *
+ *   OUTPUTS:
+ *
+ *     none
+ *
+ *   RETURN VALUE:
+ *
+ *     Word16
+ *                     output (scaled as 7,8)
+ *
+ *   DESCRIPTION:
+ *
+ *     10*log10(x)/128 = 10*(log10(2) * (log2(x<<fbits)-log2(1<<fbits)) >> 7
+ *                     = 3.0103 * (log2(x<<fbits) - fbits) >> 7
+ *                     = ((3.0103/4.0 * (log2(x<<fbits) - fbits) << 2) >> 7
+ *                     = (3.0103/4.0 * (log2(x<<fbits) - fbits) >> 5
+ *
+ *************************************************************************/
+
+Word16 fn10Log10 (Word32 L_Input, Word16 fbits)
+{
+
+	Word16 integer;		/* Integer part of Log2.   (range: 0<=val<=30) */
+	Word16 fraction;	/* Fractional part of Log2. (range: 0<=val<1) */
+
+	Word32 Ltmp;
+	Word16 tmp;
+
+        Log2(L_Input, &integer, &fraction);
+
+	integer = sub(integer, fbits);
+	Ltmp = Mpy_32_16 (integer, fraction, 24660);	/* 24660 = 10*log10(2)/4 scaled 0,15 */
+	Ltmp = L_shr_r(Ltmp, 5+1);			/* extra shift for 30,1 => 15,0 extract correction */
+        tmp = extract_l(Ltmp);
+
+        return (tmp);
+}
+
+
+/***************************************************************************
+ *
+ *   FUNCTION NAME: block_norm
+ *
+ *   PURPOSE:
+ *     The purpose of this function is block normalise the input data sequence
+ *
+ *   INPUTS:
+ *
+ *     &in[0]
+ *                     pointer to data sequence to be normalised
+ *     length
+ *                     number of elements in data sequence
+ *     headroom
+ *                     number of headroom bits (i.e., 
+ *
+ *   OUTPUTS:
+ *
+ *     &out[0]
+ *                     normalised output data sequence pointed to by &out[0]
+ *
+ *   RETURN VALUE:
+ *
+ *     Word16
+ *                     number of bits sequence was left shifted
+ *
+ *   DESCRIPTION:
+ *
+ *                     1) Search for maximum absolute valued data element
+ *                     2) Normalise the max element with "headroom"
+ *                     3) Transfer/shift the input sequence to the output buffer
+ *                     4) Return the number of left shifts
+ *
+ *   CAVEATS:
+ *                     An input sequence of all zeros will return the maximum
+ *                     number of left shifts allowed, NOT the value returned
+ *                     by a norm_s(0) call, since it desired to associate an
+ *                     all zeros sequence with low energy.
+ *
+ *************************************************************************/
+
+Word16 block_norm (Word16 * in, Word16 * out, Word16 length, Word16 headroom)
+{
+
+	Word16 i, max, scnt, adata;
+
+        max = abs_s(in[0]);
+	for (i = 1; i < length; i++)
+	{
+                adata = abs_s(in[i]);                           test();
+		if (sub(adata, max) > 0)
+		{
+			max = adata;				move16();
+		}
+	}
+	test();
+	if (max != 0)
+	{
+		scnt = sub(norm_s(max), headroom);
+		for (i = 0; i < length; i++)
+		{
+			out[i] = shl(in[i], scnt);	       	move16();
+		}
+	}
+	else
+	{
+		scnt = sub(16, headroom);
+		for (i = 0; i < length; i++)
+		{
+			out[i] = 0;                             move16();
+		}
+	}
+	return (scnt);
+}
+
+
+
+/********************************************* The VAD function ***************************************************/
+
+Word16 vad2 (Word16 * farray_ptr, vadState2 * st)
+{
+
+	/*
+	 * The channel table is defined below.  In this table, the
+	 * lower and higher frequency coefficients for each of the 16
+	 * channels are specified.  The table excludes the coefficients
+	 * with numbers 0 (DC), 1, and 64 (Foldover frequency).
+	 */
+
+	static Word16 ch_tbl[NUM_CHAN][2] =
+	{
+
+		{2, 3},
+		{4, 5},
+		{6, 7},
+		{8, 9},
+		{10, 11},
+		{12, 13},
+		{14, 16},
+		{17, 19},
+		{20, 22},
+		{23, 26},
+		{27, 30},
+		{31, 35},
+		{36, 41},
+		{42, 48},
+		{49, 55},
+		{56, 63}
+
+	};
+
+	/* channel energy scaling table - allows efficient division by number
+         * of DFT bins in the channel: 1/2, 1/3, 1/4, etc.
+	 */
+
+	static Word16 ch_tbl_sh[NUM_CHAN] =
+	{
+		16384, 16384, 16384, 16384, 16384, 16384, 10923, 10923,
+		10923, 8192, 8192, 6554, 5461, 4681, 4681, 4096
+	};
+
+	/*
+	 * The voice metric table is defined below.  It is a non-
+	 * linear table with a deadband near zero.  It maps the SNR
+	 * index (quantized SNR value) to a number that is a measure
+	 * of voice quality.
+	 */
+
+	static Word16 vm_tbl[90] =
+	{
+		2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+		3, 3, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 7, 7, 7,
+		8, 8, 9, 9, 10, 10, 11, 12, 12, 13, 13, 14, 15,
+		15, 16, 17, 17, 18, 19, 20, 20, 21, 22, 23, 24,
+		24, 25, 26, 27, 28, 28, 29, 30, 31, 32, 33, 34,
+		35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45,
+		46, 47, 48, 49, 50, 50, 50, 50, 50, 50, 50, 50,
+		50, 50
+	};
+
+	/* hangover as a function of peak SNR (3 dB steps) */
+	static Word16 hangover_table[20] =
+	{
+		30, 30, 30, 30, 30, 30, 28, 26, 24, 22, 20, 18, 16, 14, 12, 10, 8, 8, 8, 8
+	};
+
+	/* burst sensitivity as a function of peak SNR (3 dB steps) */
+	static Word16 burstcount_table[20] =
+	{
+		8, 8, 8, 8, 8, 8, 8, 8, 7, 6, 5, 4, 4, 4, 4, 4, 4, 4, 4, 4
+	};
+
+	/* voice metric sensitivity as a function of peak SNR (3 dB steps) */
+	static Word16 vm_threshold_table[20] =
+	{
+                34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 40, 51, 71, 100, 139, 191, 257, 337, 432
+	};
+
+
+	/* State tables that use 22,9 or 27,4 scaling for ch_enrg[] */
+
+	static Word16 noise_floor_chan[2] =	{NOISE_FLOOR_CHAN_0, NOISE_FLOOR_CHAN_1};
+	static Word16 min_chan_enrg[2] =	{MIN_CHAN_ENRG_0, MIN_CHAN_ENRG_1};
+	static Word16 ine_noise[2] = 		{INE_NOISE_0, INE_NOISE_1};
+	static Word16 fbits[2] = 		{FRACTIONAL_BITS_0, FRACTIONAL_BITS_1};
+	static Word16 state_change_shift_r[2] = {STATE_1_TO_0_SHIFT_R, STATE_0_TO_1_SHIFT_R};
+
+	/* Energy scale table given 30,1 input scaling (also account for -6 dB shift on input) */
+	static Word16 enrg_norm_shift[2] = 	{(FRACTIONAL_BITS_0-1+2), (FRACTIONAL_BITS_1-1+2)};
+
+
+	/* Automatic variables */
+
+	Word32 Lenrg;				/* scaled as 30,1 */
+	Word32 Ltne;				/* scaled as 22,9 */
+	Word32 Ltce;				/* scaled as 22,9 or 27,4 */
+
+	Word16 tne_db;				/* scaled as 7,8 */
+	Word16 tce_db;				/* scaled as 7,8 */
+
+	Word16 input_buffer[FRM_LEN];		/* used for block normalising input data */
+	Word16 data_buffer[FFT_LEN];		/* used for in-place FFT */
+
+	Word16 ch_snr[NUM_CHAN];		/* scaled as 7,8 */
+	Word16 ch_snrq;				/* scaled as 15,0 (in 0.375 dB steps) */
+	Word16 vm_sum;				/* scaled as 15,0 */
+	Word16 ch_enrg_dev;			/* scaled as 7,8 */
+
+	Word32 Lpeak;				/* maximum channel energy */
+	Word16 p2a_flag;			/* flag to indicate spectral peak-to-average ratio > 10 dB */
+
+	Word16 ch_enrg_db[NUM_CHAN];		/* scaled as 7,8 */
+	Word16 ch_noise_db;			/* scaled as 7,8 */
+
+	Word16 alpha;				/* scaled as 0,15 */
+	Word16 one_m_alpha;			/* scaled as 0,15 */
+	Word16 update_flag;			/* set to indicate a background noise estimate update */
+
+	Word16 i, j, j1, j2;			/* Scratch variables */
+	Word16 hi1, lo1;
+
+	Word32 Ltmp, Ltmp1, Ltmp2;
+	Word16 tmp;
+
+	Word16 normb_shift;		/* block norm shift count */
+
+	Word16 ivad;			/* intermediate VAD decision (return value) */
+	Word16 tsnrq;			/* total signal-to-noise ratio (quantized 3 dB steps) scaled as 15,0 */
+	Word16 xt;			/* instantaneous frame SNR in dB, scaled as 7,8 */
+
+	Word16 state_change;
+
+
+	/* Increment frame counter */
+	st->Lframe_cnt = L_add(st->Lframe_cnt, 1);
+
+	/* Block normalize the input */
+	normb_shift = block_norm(farray_ptr, input_buffer, FRM_LEN, FFT_HEADROOM);
+
+	/* Pre-emphasize the input data and store in the data buffer with the appropriate offset */
+	for (i = 0; i < DELAY; i++)
+	{
+		data_buffer[i] = 0;									move16();
+	}
+
+	st->pre_emp_mem = shr_r(st->pre_emp_mem, sub(st->last_normb_shift, normb_shift));
+	st->last_normb_shift = normb_shift;								move16();
+
+	data_buffer[DELAY] = add(input_buffer[0], mult(PRE_EMP_FAC, st->pre_emp_mem));			move16();
+
+	for (i = DELAY + 1, j = 1; i < DELAY + FRM_LEN; i++, j++)
+	{
+		data_buffer[i] = add(input_buffer[j], mult(PRE_EMP_FAC, input_buffer[j-1]));		move16();
+	}
+	st->pre_emp_mem = input_buffer[FRM_LEN-1];							move16();
+
+	for (i = DELAY + FRM_LEN; i < FFT_LEN; i++)
+	{
+		data_buffer[i] = 0;									move16();
+	}
+
+
+	/* Perform FFT on the data buffer */
+	r_fft(data_buffer);
+
+
+	/* Use normb_shift factor to determine the scaling of the energy estimates */
+	state_change = 0;										move16();
+													test();
+	if (st->shift_state == 0)
+	{												test();
+		if (sub(normb_shift, -FFT_HEADROOM+2) <= 0)
+		{
+			state_change = 1;								move16();
+			st->shift_state = 1;								move16();
+		}
+	}
+	else
+	{												test();
+		if (sub(normb_shift, -FFT_HEADROOM+5) >= 0)
+		{
+			state_change = 1;								move16();
+			st->shift_state = 0;								move16();
+		}
+	}
+
+	/* Scale channel energy estimate */								test();
+	if (state_change)
+	{
+		for (i = LO_CHAN; i <= HI_CHAN; i++)
+		{
+			st->Lch_enrg[i] = L_shr(st->Lch_enrg[i], state_change_shift_r[st->shift_state]);	move32();
+		}
+	}
+
+
+	/* Estimate the energy in each channel */
+													test();
+	if (L_sub(st->Lframe_cnt, 1) == 0)
+	{
+		alpha = 32767;										move16();
+		one_m_alpha = 0;									move16();
+	}
+	else
+	{
+		alpha = CEE_SM_FAC;									move16();
+		one_m_alpha = ONE_MINUS_CEE_SM_FAC;							move16();
+	}
+
+	for (i = LO_CHAN; i <= HI_CHAN; i++)
+	{
+		Lenrg = 0;										move16();
+		j1 = ch_tbl[i][0];									move16();
+		j2 = ch_tbl[i][1];									move16();
+
+		for (j = j1; j <= j2; j++)
+		{
+			Lenrg = L_mac(Lenrg, data_buffer[2 * j], data_buffer[2 * j]);
+			Lenrg = L_mac(Lenrg, data_buffer[2 * j + 1], data_buffer[2 * j + 1]);
+		}
+
+		/* Denorm energy & scale 30,1 according to the state */
+		Lenrg = L_shr_r(Lenrg, sub(shl(normb_shift, 1), enrg_norm_shift[st->shift_state]));
+
+		/* integrate over time: e[i] = (1-alpha)*e[i] + alpha*enrg/num_bins_in_chan */
+		tmp = mult(alpha, ch_tbl_sh[i]);
+		L_Extract (Lenrg, &hi1, &lo1);
+		Ltmp = Mpy_32_16(hi1, lo1, tmp);
+
+		L_Extract (st->Lch_enrg[i], &hi1, &lo1);
+		st->Lch_enrg[i] = L_add(Ltmp, Mpy_32_16(hi1, lo1, one_m_alpha));			move32();
+													test();
+		if (L_sub(st->Lch_enrg[i], min_chan_enrg[st->shift_state]) < 0)
+		{
+			st->Lch_enrg[i] = min_chan_enrg[st->shift_state];				move32();
+		}
+
+	}
+
+
+	/* Compute the total channel energy estimate (Ltce) */
+	Ltce = 0;											move16();
+	for (i = LO_CHAN; i <= HI_CHAN; i++)
+	{
+		Ltce = L_add(Ltce, st->Lch_enrg[i]);
+	}
+
+
+	/* Calculate spectral peak-to-average ratio, set flag if p2a > 10 dB */
+	Lpeak = 0;											move32();
+	for (i = LO_CHAN+2; i <= HI_CHAN; i++)	/* Sine waves not valid for low frequencies */
+	{												test();
+		if (L_sub(st->Lch_enrg [i], Lpeak) > 0)
+		{
+			Lpeak = st->Lch_enrg [i];							move32();
+		}
+	}
+
+	/* Set p2a_flag if peak (dB) > average channel energy (dB) + 10 dB */
+	/*   Lpeak > Ltce/num_channels * 10^(10/10)                        */
+	/*   Lpeak > (10/16)*Ltce                                          */
+
+	L_Extract (Ltce, &hi1, &lo1);
+	Ltmp = Mpy_32_16(hi1, lo1, 20480);
+													test();
+	if (L_sub(Lpeak, Ltmp) > 0)
+	{
+		p2a_flag = TRUE;									move16();
+	}
+	else
+	{
+		p2a_flag = FALSE;									move16();
+	}
+
+
+	/* Initialize channel noise estimate to either the channel energy or fixed level  */
+	/*   Scale the energy appropriately to yield state 0 (22,9) scaling for noise */
+													test();
+	if (L_sub(st->Lframe_cnt, 4) <= 0)
+	{												test();
+		if (p2a_flag == TRUE)
+		{
+			for (i = LO_CHAN; i <= HI_CHAN; i++)
+			{
+				st->Lch_noise[i] = INE_NOISE_0;						move32();
+			}
+		}
+		else
+		{
+			for (i = LO_CHAN; i <= HI_CHAN; i++)
+			{										test();
+				if (L_sub(st->Lch_enrg[i], ine_noise[st->shift_state]) < 0)
+				{
+					st->Lch_noise[i] = INE_NOISE_0;					move32();
+				}
+				else
+				{									test();
+					if (st->shift_state == 1)
+					{
+						st->Lch_noise[i] = L_shr(st->Lch_enrg[i], state_change_shift_r[0]);
+													move32();
+					}
+					else
+					{
+						st->Lch_noise[i] = st->Lch_enrg[i];			move32();
+					}
+				}
+			}
+		}
+	}
+
+
+	/* Compute the channel energy (in dB), the channel SNRs, and the sum of voice metrics */
+	vm_sum = 0;											move16();
+	for (i = LO_CHAN; i <= HI_CHAN; i++)
+	{
+		ch_enrg_db[i] = fn10Log10(st->Lch_enrg[i], fbits[st->shift_state]);			move16();
+		ch_noise_db = fn10Log10(st->Lch_noise[i], FRACTIONAL_BITS_0);
+
+		ch_snr[i] = sub(ch_enrg_db[i], ch_noise_db);						move16();
+
+		/* quantize channel SNR in 3/8 dB steps (scaled 7,8 => 15,0) */
+		/*   ch_snr = round((snr/(3/8))>>8)                          */
+		/*          = round(((0.6667*snr)<<2)>>8)                    */
+		/*          = round((0.6667*snr)>>6)                         */
+
+		ch_snrq = shr_r(mult(21845, ch_snr[i]), 6);
+
+		/* Accumulate the sum of voice metrics	*/						test();
+		if (sub(ch_snrq, 89) < 0)
+		{											test();
+			if (ch_snrq > 0)
+			{
+				j = ch_snrq;								move16();
+			}
+			else
+			{
+				j = 0;									move16();
+			}
+		}
+		else
+		{
+			j = 89;										move16();
+		}
+		vm_sum = add(vm_sum, vm_tbl[j]);
+	}
+
+
+	/* Initialize NOMINAL peak voice energy and average noise energy, calculate instantaneous SNR */ 
+												test(),test(),logic16();
+	if (L_sub(st->Lframe_cnt, 4) <= 0 || st->fupdate_flag == TRUE)
+	{
+		/* tce_db = (96 - 22 - 10*log10(64) (due to FFT)) scaled as 7,8 */
+		tce_db = 14320;										move16();
+		st->negSNRvar = 0;									move16();
+		st->negSNRbias = 0;									move16();
+
+		/* Compute the total noise estimate (Ltne) */
+		Ltne = 0;										move32();
+		for (i = LO_CHAN; i <= HI_CHAN; i++)
+		{
+			Ltne = L_add(Ltne, st->Lch_noise[i]);
+		}
+
+		/* Get total noise in dB */
+		tne_db = fn10Log10(Ltne, FRACTIONAL_BITS_0);
+
+		/* Initialise instantaneous and long-term peak signal-to-noise ratios */
+		xt = sub(tce_db, tne_db);
+		st->tsnr = xt;										move16();
+	}
+	else
+	{
+		/* Calculate instantaneous frame signal-to-noise ratio */
+		/* xt = 10*log10( sum(2.^(ch_snr*0.1*log2(10)))/length(ch_snr) ) */
+		Ltmp1 = 0;										move32();
+		for (i=LO_CHAN; i<=HI_CHAN; i++) {
+			/* Ltmp2 = ch_snr[i] * 0.1 * log2(10); (ch_snr scaled as 7,8) */
+			Ltmp2 = L_shr(L_mult(ch_snr[i], 10885), 8);
+			L_Extract(Ltmp2, &hi1, &lo1);
+			hi1 = add(hi1, 3);			/* 2^3 to compensate for negative SNR */
+			Ltmp1 = L_add(Ltmp1, Pow2(hi1, lo1));
+		}
+		xt = fn10Log10(Ltmp1, 4+3);			/* average by 16, inverse compensation 2^3 */
+
+		/* Estimate long-term "peak" SNR */							test(),test();
+		if (sub(xt, st->tsnr) > 0)
+		{
+			/* tsnr = 0.9*tsnr + 0.1*xt; */
+			st->tsnr = round(L_add(L_mult(29491, st->tsnr), L_mult(3277, xt)));
+		}
+		/* else if (xt > 0.625*tsnr) */	
+		else if (sub(xt, mult(20480, st->tsnr)) > 0)
+		{
+			/* tsnr = 0.998*tsnr + 0.002*xt; */
+			st->tsnr = round(L_add(L_mult(32702, st->tsnr), L_mult(66, xt)));
+		}
+	}
+
+	/* Quantize the long-term SNR in 3 dB steps, limit to 0 <= tsnrq <= 19 */
+	tsnrq = shr(mult(st->tsnr, 10923), 8);
+
+	/* tsnrq = min(19, max(0, tsnrq)); */								test(),test();
+	if (sub(tsnrq, 19) > 0)
+	{
+		tsnrq = 19;										move16();
+	}
+	else if (tsnrq < 0)
+	{
+		tsnrq = 0;										move16();
+	}
+
+	/* Calculate the negative SNR sensitivity bias */
+													test();
+	if (xt < 0)
+	{
+		/* negSNRvar = 0.99*negSNRvar + 0.01*xt*xt; */
+		/*   xt scaled as 7,8 => xt*xt scaled as 14,17, shift to 7,8 and round */
+		tmp = round(L_shl(L_mult(xt, xt), 7));
+		st->negSNRvar = round(L_add(L_mult(32440, st->negSNRvar), L_mult(328, tmp)));
+
+		/* if (negSNRvar > 4.0) negSNRvar = 4.0;  */						test();
+		if (sub(st->negSNRvar, 1024) > 0)
+		{
+			st->negSNRvar = 1024;								move16();
+		}
+
+		/* negSNRbias = max(12.0*(negSNRvar - 0.65), 0.0); */
+		tmp = mult_r(shl(sub(st->negSNRvar, 166), 4), 24576);					test();
+
+		if (tmp < 0)
+		{
+			st->negSNRbias = 0;								move16();
+		}
+		else
+		{
+			st->negSNRbias = shr(tmp, 8);
+		}
+	}
+
+
+	/* Determine VAD as a function of the voice metric sum and quantized SNR */
+
+	tmp = add(vm_threshold_table[tsnrq], st->negSNRbias);						test();
+	if (sub(vm_sum, tmp) > 0)
+	{
+		ivad = 1;										move16();
+		st->burstcount = add(st->burstcount, 1);						test();
+		if (sub(st->burstcount, burstcount_table[tsnrq]) > 0)
+		{
+			st->hangover = hangover_table[tsnrq];						move16();
+		}
+	}
+	else
+	{
+		st->burstcount = 0;									move16();
+		st->hangover = sub(st->hangover, 1);							test();
+		if (st->hangover <= 0)
+		{
+			ivad = 0;									move16();
+			st->hangover = 0;								move16();
+		}
+		else
+		{
+			ivad = 1;									move16();
+		}
+	}
+
+
+	/* Calculate log spectral deviation */
+	ch_enrg_dev = 0;										move16();
+													test();
+	if (L_sub(st->Lframe_cnt, 1) == 0)
+	{
+		for (i = LO_CHAN; i <= HI_CHAN; i++)
+		{
+			st->ch_enrg_long_db[i] = ch_enrg_db[i];						move16();
+		}
+	}
+	else
+	{
+		for (i = LO_CHAN; i <= HI_CHAN; i++)
+		{
+			tmp = abs_s(sub(st->ch_enrg_long_db[i], ch_enrg_db[i]));
+			ch_enrg_dev = add(ch_enrg_dev, tmp);
+		}
+	}
+
+	/*
+	 * Calculate long term integration constant as a function of instantaneous SNR
+	 * (i.e., high SNR (tsnr dB) -> slower integration (alpha = HIGH_ALPHA),
+	 *         low SNR (0 dB) -> faster integration (alpha = LOW_ALPHA)
+	 */
+
+	/* alpha = HIGH_ALPHA - ALPHA_RANGE * (tsnr - xt) / tsnr, low <= alpha <= high */
+	tmp = sub(st->tsnr, xt);						test(),logic16(),test(),test();
+	if (tmp <= 0 || st->tsnr <= 0)
+	{
+		alpha = HIGH_ALPHA;								move16();
+		one_m_alpha = 32768L-HIGH_ALPHA;						move16();
+	}
+	else if (sub(tmp, st->tsnr) > 0)
+	{
+		alpha = LOW_ALPHA;								move16();
+		one_m_alpha = 32768L-LOW_ALPHA;							move16();
+	}
+	else
+	{
+		tmp = div_s(tmp, st->tsnr);
+		alpha = sub(HIGH_ALPHA, mult(ALPHA_RANGE, tmp));
+		one_m_alpha = sub(32767, alpha);
+	}
+
+	/* Calc long term log spectral energy */
+	for (i = LO_CHAN; i <= HI_CHAN; i++)
+	{
+		Ltmp1 = L_mult(one_m_alpha, ch_enrg_db[i]);
+		Ltmp2 = L_mult(alpha, st->ch_enrg_long_db[i]);
+		st->ch_enrg_long_db[i] = round(L_add(Ltmp1, Ltmp2));
+	}
+
+
+	/* Set or clear the noise update flags */
+	update_flag = FALSE;										move16();
+	st->fupdate_flag = FALSE;									move16();
+													test(),test();
+	if (sub(vm_sum, UPDATE_THLD) <= 0)
+	{												test();
+		if (st->burstcount == 0)
+		{
+			update_flag = TRUE;								move16();
+			st->update_cnt = 0;								move16();
+		}
+	}
+	else if (L_sub(Ltce, noise_floor_chan[st->shift_state]) > 0)
+	{												test();
+		if (sub(ch_enrg_dev, DEV_THLD) < 0)
+		{											test();
+			if (p2a_flag == FALSE)
+			{										test();
+				if (st->LTP_flag == FALSE)
+				{
+					st->update_cnt = add(st->update_cnt, 1);			test();
+					if (sub(st->update_cnt, UPDATE_CNT_THLD) >= 0)
+					{
+						update_flag = TRUE;					move16();
+						st->fupdate_flag = TRUE;				move16();
+					}
+				}
+			}
+		}
+	}
+													test();
+	if (sub(st->update_cnt, st->last_update_cnt) == 0)
+	{
+		st->hyster_cnt = add(st->hyster_cnt, 1);
+	}
+	else
+	{
+		st->hyster_cnt = 0;									move16();
+	}
+
+	st->last_update_cnt = st->update_cnt;								move16();
+													test();
+	if (sub(st->hyster_cnt, HYSTER_CNT_THLD) > 0)
+	{
+		st->update_cnt = 0;									move16();
+	}
+
+
+	/* Conditionally update the channel noise estimates */
+													test();
+	if (update_flag == TRUE)
+	{
+		/* Check shift state */									test();
+		if (st->shift_state == 1)
+		{
+			/* get factor to shift ch_enrg[] from state 1 to 0 (noise always state 0) */
+			tmp = state_change_shift_r[0];							move16();
+		}
+		else
+		{
+			/* No shift if already state 0 */
+			tmp = 0;									move16();
+		}
+
+		/* Update noise energy estimate */
+		for (i = LO_CHAN; i <= HI_CHAN; i++)
+		{											test();
+			/* integrate over time: en[i] = (1-alpha)*en[i] + alpha*e[n] */
+			/* (extract with shift compensation for state 1) */
+			L_Extract (L_shr(st->Lch_enrg[i], tmp), &hi1, &lo1);
+			Ltmp = Mpy_32_16(hi1, lo1, CNE_SM_FAC);
+
+			L_Extract (st->Lch_noise[i], &hi1, &lo1);
+			st->Lch_noise[i] = L_add(Ltmp, Mpy_32_16(hi1, lo1, ONE_MINUS_CNE_SM_FAC));	move32();
+
+			/* Limit low level noise */							test();
+			if (L_sub(st->Lch_noise[i], MIN_NOISE_ENRG_0) < 0)
+			{
+				st->Lch_noise[i] = MIN_NOISE_ENRG_0;					move32();
+			}
+		}
+	}
+
+	return(ivad);
+}								/* end of vad2 () */
+
+
+/**** Other related functions *****/
+
+/*************************************************************************
+*
+*  Function:   vad2_init
+*  Purpose:    Allocates state memory and initializes state memory
+*
+**************************************************************************
+*/
+int vad2_init (vadState2 **state)
+{
+    vadState2* s;
+    
+    if (state == (vadState2 **) NULL){
+        fprintf(stderr, "vad2_init: invalid parameter\n");
+        return -1;
+    }
+    *state = NULL;
+    
+    /* allocate memory */
+    if ((s = (vadState2 *) malloc(sizeof(vadState2))) == NULL){
+        fprintf(stderr, "vad2_init: can not malloc state structure\n");
+        return -1;
+    }
+    
+    vad2_reset(s);
+    
+    *state = s;
+    
+    return 0;
+}
+
+/***************************************************************************
+ *
+ *   FUNCTION NAME: vad2_reset()
+ *
+ *   PURPOSE:
+ *     The purpose of this function is to initialise the vad2() state
+ *     variables.
+ *
+ *   INPUTS:
+ *
+ *     &st
+ *                     pointer to data structure of vad2 state variables
+ *
+ *   OUTPUTS:
+ *
+ *     none
+ *
+ *   RETURN VALUE:
+ *
+ *     none
+ *
+ *   DESCRIPTION:
+ *
+ *                     Set all values in vad2 state to zero.  Since it is
+ *                     known that all elements in the structure contain
+ *                     16 and 32 bit fixed point elements, the initialisation
+ *                     is performed by zeroing out the number of bytes in the
+ *                     structure divided by two.
+ *
+ *************************************************************************/
+
+int vad2_reset (vadState2 * st)
+{
+	Word16	i;
+	Word16	*ptr;
+
+	if (st == (vadState2 *) NULL){
+		fprintf(stderr, "vad2_reset: invalid parameter\n");
+		return -1;
+	}
+	ptr = (Word16 *)st;				move16();
+
+	for (i = 0; i < sizeof(vadState2)/2; i++)
+	{
+		*ptr++ = 0;				move16();
+	}
+
+	return 0;
+}						/* end of vad2_reset () */
+
+/*************************************************************************
+*
+*  Function:   vad2_exit
+*  Purpose:    The memory used for state memory is freed
+*
+**************************************************************************
+*/
+void vad2_exit (vadState2 **state)
+{
+    if (state == NULL || *state == NULL)
+        return;
+    
+    /* deallocate memory */
+    free(*state);
+    *state = NULL;
+    
+    return;
+}
+
diff -Nur FFMpeg-20050127/libavcodec/amr/vad2.h FFMpeg-20050127-new/libavcodec/amr/vad2.h
--- FFMpeg-20050127/libavcodec/amr/vad2.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/vad2.h	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,116 @@
+/*
+********************************************************************************
+*                                                                        
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : vad2.h
+*      Purpose          : Voice Activity Detection (VAD) for AMR (option 2)
+*
+********************************************************************************
+*/
+
+#ifndef vad2_h
+#define vad2_h "$Id $"
+
+#include "typedef.h"
+
+/***** Defines ****/
+
+#define		YES		1
+#define		NO		0
+#define		ON		1
+#define		OFF		0
+#define		TRUE		1
+#define		FALSE		0
+
+#define         FRM_LEN                 80
+#define         DELAY                   24
+#define         FFT_LEN                 128
+
+#define         NUM_CHAN                16
+#define         LO_CHAN                 0
+#define         HI_CHAN                 15
+
+#define         UPDATE_THLD             35
+#define         HYSTER_CNT_THLD         6
+#define         UPDATE_CNT_THLD         50
+
+#define		SHIFT_STATE_0		0		/* channel energy scaled as 22,9 */
+#define		SHIFT_STATE_1		1		/* channel energy scaled as 27,4 */
+
+#define		NOISE_FLOOR_CHAN_0	512		/* 1.0    scaled as 22,9 */
+#define		MIN_CHAN_ENRG_0		32		/* 0.0625 scaled as 22,9 */
+#define		MIN_NOISE_ENRG_0	32		/* 0.0625 scaled as 22,9 */
+#define		INE_NOISE_0		8192		/* 16.0   scaled as 22,9 */
+#define		FRACTIONAL_BITS_0	9		/* used as input to fn10Log10() */
+
+#define		NOISE_FLOOR_CHAN_1	16		/* 1.0    scaled as 27,4 */
+#define		MIN_CHAN_ENRG_1		1		/* 0.0625 scaled as 27,4 */
+#define		MIN_NOISE_ENRG_1	1		/* 0.0625 scaled as 27,4 */
+#define		INE_NOISE_1		256		/* 16.0   scaled as 27,4 */
+#define		FRACTIONAL_BITS_1	4		/* used as input to fn10Log10() */
+
+#define		STATE_1_TO_0_SHIFT_R	(FRACTIONAL_BITS_1-FRACTIONAL_BITS_0)	/* state correction factor */
+#define		STATE_0_TO_1_SHIFT_R	(FRACTIONAL_BITS_0-FRACTIONAL_BITS_1)	/* state correction factor */
+
+#define         HIGH_ALPHA              29491		/* 0.9 scaled as 0,15 */
+#define         LOW_ALPHA               22938		/* 0.7 scaled as 0,15 */
+#define         ALPHA_RANGE             (HIGH_ALPHA - LOW_ALPHA)
+#define         DEV_THLD                7168		/* 28.0 scaled as 7,8 */
+
+#define         PRE_EMP_FAC             (-26214)	/* -0.8 scaled as 0,15 */
+
+#define         CEE_SM_FAC              18022		/* 0.55 scaled as 0,15 */
+#define         ONE_MINUS_CEE_SM_FAC    14746		/* 0.45 scaled as 0,15 */
+
+#define         CNE_SM_FAC              3277		/* 0.1 scaled as 0,15 */
+#define         ONE_MINUS_CNE_SM_FAC    29491		/* 0.9 scaled as 0,15 */
+
+#define         FFT_HEADROOM            2
+
+
+typedef struct
+{
+	Word16 pre_emp_mem;
+	Word16 update_cnt;
+	Word16 hyster_cnt;
+	Word16 last_update_cnt;
+	Word16 ch_enrg_long_db[NUM_CHAN];	/* scaled as 7,8  */
+
+	Word32 Lframe_cnt;
+	Word32 Lch_enrg[NUM_CHAN];	/* scaled as 22,9 or 27,4 */
+	Word32 Lch_noise[NUM_CHAN];	/* scaled as 22,9 */
+
+	Word16 last_normb_shift;	/* last block norm shift count */
+
+	Word16 tsnr;			/* total signal-to-noise ratio in dB (scaled as 7,8) */
+	Word16 hangover;
+	Word16 burstcount;
+	Word16 fupdate_flag;		/* forced update flag from previous frame */
+	Word16 negSNRvar;		/* Negative SNR variance (scaled as 7,8) */
+	Word16 negSNRbias;		/* sensitivity bias from negative SNR variance (scaled as 15,0) */
+
+	Word16 shift_state;		/* use 22,9 or 27,4 scaling for ch_enrg[] */
+
+	Word32 L_R0;
+	Word32 L_Rmax;
+	Flag   LTP_flag;		/* Use to indicate the the LTP gain is > LTP_THRESH */
+
+} vadState2;
+
+/**** Prototypes ****/
+
+Word16	vad2 (Word16 *farray_ptr, vadState2 *st);
+int	vad2_init (vadState2 **st);
+int	vad2_reset (vadState2 *st);
+void	vad2_exit (vadState2 **state);
+
+void	r_fft (Word16 *farray_ptr);
+void	LTP_flag_update (vadState2 *st, Word16 mode);
+
+#endif
+
diff -Nur FFMpeg-20050127/libavcodec/amr/vadname.c FFMpeg-20050127-new/libavcodec/amr/vadname.c
--- FFMpeg-20050127/libavcodec/amr/vadname.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/vadname.c	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,50 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : vadname.c
+*      Purpose          : check VAD option
+*
+*****************************************************************************
+*/
+ 
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#include "vadname.h"
+const char vadname_id[] = "@(#)$Id $" vadname_h;
+ 
+/*
+*****************************************************************************
+*                         PUBLIC PROGRAM CODE
+*****************************************************************************
+*/
+ 
+/*************************************************************************
+*
+*  Function:   get_vadname
+*  Purpose:    return pointer to string with name of VAD option
+*              ("VAD1" or "VAD2")
+*
+**************************************************************************
+*/
+const char *get_vadname(void)
+{
+    static const char name[] = 
+#if defined(VAD1)
+        "VAD1 (ENS)";
+#elif defined(VAD2)
+        "VAD2 (Motorola)";
+#else
+        "unknown";
+#endif
+    
+    return name;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/vadname.h FFMpeg-20050127-new/libavcodec/amr/vadname.h
--- FFMpeg-20050127/libavcodec/amr/vadname.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/vadname.h	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,31 @@
+/*
+*****************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+*****************************************************************************
+*
+*      File             : vadname.c
+*      Purpose          : check VAD option
+*
+*****************************************************************************
+*/
+ 
+/*
+*****************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+*****************************************************************************
+*/
+#ifndef vadname_h
+#define vadname_h "$Id $"
+
+/*
+*****************************************************************************
+*                         ENCLARATION OF PROTOTYPES
+*****************************************************************************
+*/
+const char *get_vadname(void);
+
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/weight_a.c FFMpeg-20050127-new/libavcodec/amr/weight_a.c
--- FFMpeg-20050127/libavcodec/amr/weight_a.c	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/weight_a.c	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,67 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : weight_a.c
+*      Purpose          : Spectral expansion of LP coefficients.  (order==10)
+*      Description      : a_exp[i] = a[i] * fac[i-1]    ,i=1,10
+*
+********************************************************************************
+*/
+/*
+********************************************************************************
+*                         MODULE INCLUDE FILE AND VERSION ID
+********************************************************************************
+*/
+#include "weight_a.h"
+const char weight_a_id[] = "@(#)$Id $" weight_a_h;
+
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+#include "basic_op.h"
+#include "count.h"
+#include "cnst.h"
+
+/*
+********************************************************************************
+*                         LOCAL VARIABLES AND TABLES
+********************************************************************************
+*/
+/*
+*--------------------------------------*
+* Constants (defined in cnst.h         *
+*--------------------------------------*
+*  M         : LPC order               *
+*--------------------------------------*
+*/
+
+/*
+********************************************************************************
+*                         PUBLIC PROGRAM CODE
+********************************************************************************
+*/
+void Weight_Ai (
+    Word16 a[],         /* (i)     : a[M+1]  LPC coefficients   (M=10)    */
+    const Word16 fac[], /* (i)     : Spectral expansion factors.          */
+    Word16 a_exp[]      /* (o)     : Spectral expanded LPC coefficients   */
+)
+{
+    Word16 i;
+
+    a_exp[0] = a[0];                                    move16 (); 
+    for (i = 1; i <= M; i++)
+    {
+        a_exp[i] = round (L_mult (a[i], fac[i - 1]));   move16 (); 
+    }
+
+    return;
+}
diff -Nur FFMpeg-20050127/libavcodec/amr/weight_a.h FFMpeg-20050127-new/libavcodec/amr/weight_a.h
--- FFMpeg-20050127/libavcodec/amr/weight_a.h	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/weight_a.h	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,45 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : weight_a.h
+*      Purpose          : Spectral expansion of LP coefficients.  (order==10)
+*      Description      : a_exp[i] = a[i] * fac[i-1]    ,i=1,10
+*
+*
+********************************************************************************
+*/
+#ifndef weight_a_h
+#define weight_a_h "$Id $"
+ 
+/*
+********************************************************************************
+*                         INCLUDE FILES
+********************************************************************************
+*/
+#include "typedef.h"
+ 
+/*
+********************************************************************************
+*                         DEFINITION OF DATA TYPES
+********************************************************************************
+*/
+ 
+/*
+********************************************************************************
+*                         DECLARATION OF PROTOTYPES
+********************************************************************************
+*/
+ 
+void Weight_Ai (
+    Word16 a[],        /* (i)  : a[m+1]  LPC coefficients   (m=10)          */
+    const Word16 fac[],/* (i)  : Spectral expansion factors.                */
+    Word16 a_exp[]     /* (o)  : Spectral expanded LPC coefficients         */
+);
+ 
+#endif
diff -Nur FFMpeg-20050127/libavcodec/amr/window.tab FFMpeg-20050127-new/libavcodec/amr/window.tab
--- FFMpeg-20050127/libavcodec/amr/window.tab	1970-01-01 00:00:00.000000000 +0000
+++ FFMpeg-20050127-new/libavcodec/amr/window.tab	2001-12-12 20:10:00.000000000 +0000
@@ -0,0 +1,111 @@
+/*
+********************************************************************************
+*
+*      GSM AMR-NB speech codec   R98   Version 7.6.0   December 12, 2001
+*                                R99   Version 3.3.0                
+*                                REL-4 Version 4.1.0                
+*
+********************************************************************************
+*
+*      File             : window.tab
+*      Purpose          : Hamming_cos window for LPC analysis.
+*      $Id $
+*
+********************************************************************************
+*/
+
+/*************************************************************************
+ *
+ * Hamming_cos windows for LPC analysis.
+ *
+ *************************************************************************/
+
+/* window for non-EFR modesm; uses 40 samples lookahead */
+
+static Word16 window_200_40[L_WINDOW] = {
+  2621,  2623,  2629,  2638,  2651,  2668,  2689,  2713,  2741,  2772,
+  2808,  2847,  2890,  2936,  2986,  3040,  3097,  3158,  3223,  3291,
+  3363,  3438,  3517,  3599,  3685,  3774,  3867,  3963,  4063,  4166,
+  4272,  4382,  4495,  4611,  4731,  4853,  4979,  5108,  5240,  5376,
+  5514,  5655,  5800,  5947,  6097,  6250,  6406,  6565,  6726,  6890,
+  7057,  7227,  7399,  7573,  7750,  7930,  8112,  8296,  8483,  8672,
+  8863,  9057,  9252,  9450,  9650,  9852, 10055, 10261, 10468, 10677,
+ 10888, 11101, 11315, 11531, 11748, 11967, 12187, 12409, 12632, 12856,
+ 13082, 13308, 13536, 13764, 13994, 14225, 14456, 14688, 14921, 15155,
+ 15389, 15624, 15859, 16095, 16331, 16568, 16805, 17042, 17279, 17516,
+ 17754, 17991, 18228, 18465, 18702, 18939, 19175, 19411, 19647, 19882,
+ 20117, 20350, 20584, 20816, 21048, 21279, 21509, 21738, 21967, 22194,
+ 22420, 22644, 22868, 23090, 23311, 23531, 23749, 23965, 24181, 24394,
+ 24606, 24816, 25024, 25231, 25435, 25638, 25839, 26037, 26234, 26428,
+ 26621, 26811, 26999, 27184, 27368, 27548, 27727, 27903, 28076, 28247,
+ 28415, 28581, 28743, 28903, 29061, 29215, 29367, 29515, 29661, 29804,
+ 29944, 30081, 30214, 30345, 30472, 30597, 30718, 30836, 30950, 31062,
+ 31170, 31274, 31376, 31474, 31568, 31659, 31747, 31831, 31911, 31988,
+ 32062, 32132, 32198, 32261, 32320, 32376, 32428, 32476, 32521, 32561,
+ 32599, 32632, 32662, 32688, 32711, 32729, 32744, 32755, 32763, 32767,
+ 32767, 32741, 32665, 32537, 32359, 32129, 31850, 31521, 31143, 30716,
+ 30242, 29720, 29151, 28538, 27879, 27177, 26433, 25647, 24821, 23957,
+ 23055, 22117, 21145, 20139, 19102, 18036, 16941, 15820, 14674, 13505,
+ 12315, 11106,  9879,  8637,  7381,  6114,  4838,  3554,  2264,   971};
+
+
+/* window for EFR, first two subframes, no lookahead */
+
+static const Word16 window_160_80[L_WINDOW] =
+{
+    2621, 2624, 2633, 2648, 2668, 2695, 2727, 2765, 2809, 2859,
+    2915, 2976, 3043, 3116, 3194, 3279, 3368, 3464, 3565, 3671,
+    3783, 3900, 4023, 4151, 4285, 4423, 4567, 4716, 4870, 5029,
+    5193, 5362, 5535, 5714, 5897, 6084, 6277, 6473, 6674, 6880,
+    7089, 7303, 7521, 7742, 7968, 8197, 8430, 8667, 8907, 9151,
+    9398, 9648, 9902, 10158, 10417, 10680, 10945, 11212, 11482, 11755,
+    12030, 12307, 12586, 12867, 13150, 13435, 13722, 14010, 14299, 14590,
+    14882, 15175, 15469, 15764, 16060, 16356, 16653, 16950, 17248, 17546,
+    17844, 18141, 18439, 18736, 19033, 19330, 19625, 19920, 20214, 20507,
+    20799, 21090, 21380, 21668, 21954, 22239, 22522, 22803, 23083, 23360,
+    23635, 23907, 24177, 24445, 24710, 24972, 25231, 25488, 25741, 25991,
+    26238, 26482, 26722, 26959, 27192, 27422, 27647, 27869, 28087, 28300,
+    28510, 28715, 28916, 29113, 29305, 29493, 29676, 29854, 30028, 30197,
+    30361, 30519, 30673, 30822, 30966, 31105, 31238, 31366, 31489, 31606,
+    31718, 31825, 31926, 32021, 32111, 32195, 32273, 32346, 32413, 32475,
+    32530, 32580, 32624, 32662, 32695, 32721, 32742, 32756, 32765, 32767,
+    32767, 32756, 32720, 32661, 32578, 32471, 32341, 32188, 32012, 31813,
+    31592, 31349, 31084, 30798, 30492, 30165, 29818, 29453, 29068, 28666,
+    28247, 27810, 27358, 26891, 26408, 25913, 25404, 24883, 24350, 23807,
+    23255, 22693, 22124, 21548, 20965, 20378, 19786, 19191, 18593, 17994,
+    17395, 16796, 16199, 15604, 15012, 14424, 13842, 13265, 12696, 12135,
+    11582, 11039, 10507, 9986, 9477, 8981, 8499, 8031, 7579, 7143,
+    6723, 6321, 5937, 5571, 5225, 4898, 4591, 4305, 4041, 3798,
+    3577, 3378, 3202, 3048, 2918, 2812, 2729, 2669, 2633, 2621
+};
+
+/* window for EFR, last two subframes, no lookahead */
+
+static const Word16 window_232_8[L_WINDOW] =
+{
+    2621, 2623, 2627, 2634, 2644, 2656, 2671, 2689, 2710, 2734,
+    2760, 2789, 2821, 2855, 2893, 2933, 2975, 3021, 3069, 3120,
+    3173, 3229, 3288, 3350, 3414, 3481, 3550, 3622, 3697, 3774,
+    3853, 3936, 4021, 4108, 4198, 4290, 4385, 4482, 4582, 4684,
+    4788, 4895, 5004, 5116, 5230, 5346, 5464, 5585, 5708, 5833,
+    5960, 6090, 6221, 6355, 6491, 6629, 6769, 6910, 7054, 7200,
+    7348, 7498, 7649, 7803, 7958, 8115, 8274, 8434, 8597, 8761,
+    8926, 9093, 9262, 9432, 9604, 9778, 9952, 10129, 10306, 10485,
+    10665, 10847, 11030, 11214, 11399, 11586, 11773, 11962, 12152, 12342,
+    12534, 12727, 12920, 13115, 13310, 13506, 13703, 13901, 14099, 14298,
+    14497, 14698, 14898, 15100, 15301, 15504, 15706, 15909, 16112, 16316,
+    16520, 16724, 16928, 17132, 17337, 17541, 17746, 17950, 18155, 18359,
+    18564, 18768, 18972, 19175, 19379, 19582, 19785, 19987, 20189, 20390,
+    20591, 20792, 20992, 21191, 21390, 21588, 21785, 21981, 22177, 22372,
+    22566, 22759, 22951, 23143, 23333, 23522, 23710, 23897, 24083, 24268,
+    24451, 24633, 24814, 24994, 25172, 25349, 25525, 25699, 25871, 26042,
+    26212, 26380, 26546, 26711, 26874, 27035, 27195, 27353, 27509, 27664,
+    27816, 27967, 28115, 28262, 28407, 28550, 28691, 28830, 28967, 29102,
+    29234, 29365, 29493, 29619, 29743, 29865, 29985, 30102, 30217, 30330,
+    30440, 30548, 30654, 30757, 30858, 30956, 31052, 31146, 31237, 31326,
+    31412, 31495, 31576, 31655, 31730, 31804, 31874, 31942, 32008, 32071,
+    32131, 32188, 32243, 32295, 32345, 32392, 32436, 32477, 32516, 32552,
+    32585, 32615, 32643, 32668, 32690, 32709, 32726, 32740, 32751, 32759,
+    32765, 32767, 32767, 32097, 30112, 26895, 22576, 17333, 11380, 4962
+};
+
