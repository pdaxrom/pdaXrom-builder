diff -Nur dillo-0.8.0/ABOUT-NLS dillo-0.8.0.new/ABOUT-NLS
--- dillo-0.8.0/ABOUT-NLS	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/ABOUT-NLS	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,432 @@
+Notes on the Free Translation Project
+*************************************
+
+   Free software is going international!  The Free Translation Project
+is a way to get maintainers of free software, translators, and users all
+together, so that will gradually become able to speak many languages.
+A few packages already provide translations for their messages.
+
+   If you found this `ABOUT-NLS' file inside a distribution, you may
+assume that the distributed package does use GNU `gettext' internally,
+itself available at your nearest GNU archive site.  But you do _not_
+need to install GNU `gettext' prior to configuring, installing or using
+this package with messages translated.
+
+   Installers will find here some useful hints.  These notes also
+explain how users should proceed for getting the programs to use the
+available translations.  They tell how people wanting to contribute and
+work at translations should contact the appropriate team.
+
+   When reporting bugs in the `intl/' directory or bugs which may be
+related to internationalization, you should tell about the version of
+`gettext' which is used.  The information can be found in the
+`intl/VERSION' file, in internationalized packages.
+
+Quick configuration advice
+==========================
+
+   If you want to exploit the full power of internationalization, you
+should configure it using
+
+     ./configure --with-included-gettext
+
+to force usage of internationalizing routines provided within this
+package, despite the existence of internationalizing capabilities in the
+operating system where this package is being installed.  So far, only
+the `gettext' implementation in the GNU C library version 2 provides as
+many features (such as locale alias, message inheritance, automatic
+charset conversion or plural form handling) as the implementation here.
+It is also not possible to offer this additional functionality on top
+of a `catgets' implementation.  Future versions of GNU `gettext' will
+very likely convey even more functionality.  So it might be a good idea
+to change to GNU `gettext' as soon as possible.
+
+   So you need _not_ provide this option if you are using GNU libc 2 or
+you have installed a recent copy of the GNU gettext package with the
+included `libintl'.
+
+INSTALL Matters
+===============
+
+   Some packages are "localizable" when properly installed; the
+programs they contain can be made to speak your own native language.
+Most such packages use GNU `gettext'.  Other packages have their own
+ways to internationalization, predating GNU `gettext'.
+
+   By default, this package will be installed to allow translation of
+messages.  It will automatically detect whether the system already
+provides the GNU `gettext' functions.  If not, the GNU `gettext' own
+library will be used.  This library is wholly contained within this
+package, usually in the `intl/' subdirectory, so prior installation of
+the GNU `gettext' package is _not_ required.  Installers may use
+special options at configuration time for changing the default
+behaviour.  The commands:
+
+     ./configure --with-included-gettext
+     ./configure --disable-nls
+
+will respectively bypass any pre-existing `gettext' to use the
+internationalizing routines provided within this package, or else,
+_totally_ disable translation of messages.
+
+   When you already have GNU `gettext' installed on your system and run
+configure without an option for your new package, `configure' will
+probably detect the previously built and installed `libintl.a' file and
+will decide to use this.  This might be not what is desirable.  You
+should use the more recent version of the GNU `gettext' library.  I.e.
+if the file `intl/VERSION' shows that the library which comes with this
+package is more recent, you should use
+
+     ./configure --with-included-gettext
+
+to prevent auto-detection.
+
+   The configuration process will not test for the `catgets' function
+and therefore it will not be used.  The reason is that even an
+emulation of `gettext' on top of `catgets' could not provide all the
+extensions of the GNU `gettext' library.
+
+   Internationalized packages have usually many `po/LL.po' files, where
+LL gives an ISO 639 two-letter code identifying the language.  Unless
+translations have been forbidden at `configure' time by using the
+`--disable-nls' switch, all available translations are installed
+together with the package.  However, the environment variable `LINGUAS'
+may be set, prior to configuration, to limit the installed set.
+`LINGUAS' should then contain a space separated list of two-letter
+codes, stating which languages are allowed.
+
+Using This Package
+==================
+
+   As a user, if your language has been installed for this package, you
+only have to set the `LANG' environment variable to the appropriate
+`LL_CC' combination.  Here `LL' is an ISO 639 two-letter language code,
+and `CC' is an ISO 3166 two-letter country code.  For example, let's
+suppose that you speak German and live in Germany.  At the shell
+prompt, merely execute `setenv LANG de_DE' (in `csh'),
+`export LANG; LANG=de_DE' (in `sh') or `export LANG=de_DE' (in `bash').
+This can be done from your `.login' or `.profile' file, once and for
+all.
+
+   You might think that the country code specification is redundant.
+But in fact, some languages have dialects in different countries.  For
+example, `de_AT' is used for Austria, and `pt_BR' for Brazil.  The
+country code serves to distinguish the dialects.
+
+   The locale naming convention of `LL_CC', with `LL' denoting the
+language and `CC' denoting the country, is the one use on systems based
+on GNU libc.  On other systems, some variations of this scheme are
+used, such as `LL' or `LL_CC.ENCODING'.  You can get the list of
+locales supported by your system for your country by running the command
+`locale -a | grep '^LL''.
+
+   Not all programs have translations for all languages.  By default, an
+English message is shown in place of a nonexistent translation.  If you
+understand other languages, you can set up a priority list of languages.
+This is done through a different environment variable, called
+`LANGUAGE'.  GNU `gettext' gives preference to `LANGUAGE' over `LANG'
+for the purpose of message handling, but you still need to have `LANG'
+set to the primary language; this is required by other parts of the
+system libraries.  For example, some Swedish users who would rather
+read translations in German than English for when Swedish is not
+available, set `LANGUAGE' to `sv:de' while leaving `LANG' to `sv_SE'.
+
+   In the `LANGUAGE' environment variable, but not in the `LANG'
+environment variable, `LL_CC' combinations can be abbreviated as `LL'
+to denote the language's main dialect.  For example, `de' is equivalent
+to `de_DE' (German as spoken in Germany), and `pt' to `pt_PT'
+(Portuguese as spoken in Portugal) in this context.
+
+Translating Teams
+=================
+
+   For the Free Translation Project to be a success, we need interested
+people who like their own language and write it well, and who are also
+able to synergize with other translators speaking the same language.
+Each translation team has its own mailing list.  The up-to-date list of
+teams can be found at the Free Translation Project's homepage,
+`http://www.iro.umontreal.ca/contrib/po/HTML/', in the "National teams"
+area.
+
+   If you'd like to volunteer to _work_ at translating messages, you
+should become a member of the translating team for your own language.
+The subscribing address is _not_ the same as the list itself, it has
+`-request' appended.  For example, speakers of Swedish can send a
+message to `sv-request@li.org', having this message body:
+
+     subscribe
+
+   Keep in mind that team members are expected to participate
+_actively_ in translations, or at solving translational difficulties,
+rather than merely lurking around.  If your team does not exist yet and
+you want to start one, or if you are unsure about what to do or how to
+get started, please write to `translation@iro.umontreal.ca' to reach the
+coordinator for all translator teams.
+
+   The English team is special.  It works at improving and uniformizing
+the terminology in use.  Proven linguistic skill are praised more than
+programming skill, here.
+
+Available Packages
+==================
+
+   Languages are not equally supported in all packages.  The following
+matrix shows the current state of internationalization, as of July
+2002.  The matrix shows, in regard of each package, for which languages
+PO files have been submitted to translation coordination, with a
+translation percentage of at least 50%.
+
+     Ready PO files    be bg ca cs da de el en eo es et fi fr
+                     +----------------------------------------+
+     a2ps            |             [] []             []    [] |
+     bash            |                []       [] []       [] |
+     bfd             |                            []       [] |
+     binutils        |                            []       [] |
+     bison           |                []          [] []    [] |
+     clisp           |                []    []    []       [] |
+     clisp           |                                        |
+     clisplow        |                                        |
+     cpio            |             [] []          []       [] |
+     darkstat        |             ()                         |
+     diffutils       |          [] [] []       [] []       [] |
+     enscript        |                []                   [] |
+     error           |                []          []       [] |
+     fetchmail       |       [] () [] []          []       () |
+     fileutils       |             [] []          [] []    [] |
+     findutils       |             [] []       [] [] []    [] |
+     flex            |       []    [] []          []       [] |
+     gas             |                            []       [] |
+     gawk            |                []          []       [] |
+     gcal            |       []                            [] |
+     gcc             |                            []       [] |
+     gettext         |       []    [] []          []       [] |
+     gnupg           |       []       [] []    [] [] []    [] |
+     gprof           |                            []       [] |
+     gpsdrive        |             () ()    ()    ()       () |
+     grep            |    [] []       [] []       [] []    [] |
+     gretl           |                            []          |
+     gthumb          |                ()          ()       () |
+     hello           |       []    [] [] []    [] [] [] [] [] |
+     id-utils        |             [] []                   [] |
+     indent          |       []       []       []    []    [] |
+     jpilot          |          () [] []                   [] |
+     jwhois          |                            []       [] |
+     kbd             |                []          []       [] |
+     ld              |                            []       [] |
+     libc            |       [] [] [] [] []       []       [] |
+     libiconv        |       []       []       [] []          |
+     lifelines       |                ()                   () |
+     lilypond        |             []             []       [] |
+     lingoteach      |                         []          [] |
+     lingoteach_lessons|                ()          ()          |
+     lynx            |       [] [] [] []             []       |
+     m4              |          [] [] [] []                [] |
+     make            |             [] []          []       [] |
+     man-db          |       [] () () []          ()       () |
+     mysecretdiary   |                []          []       [] |
+     nano            |       [] () [] []          []       [] |
+     nano_1_0        |       [] () [] []          []       [] |
+     opcodes         |             []             []       [] |
+     parted          |       []    [] []          []       [] |
+     ptx             |             [] []       [] [] [] [] [] |
+     python          |                                        |
+     recode          |             [] [] []    [] []       [] |
+     sed             |       [] [] [] [] []    [] [] []    [] |
+     sh-utils        |                []          [] []    [] |
+     sharutils       |          [] [] [] []       []       [] |
+     sketch          |                ()          []       () |
+     soundtracker    |                []          []       [] |
+     sp              |                []                      |
+     tar             |          [] [] []          [] []    [] |
+     texinfo         |          [] [] []       []          [] |
+     textutils       |       []    [] []          []       [] |
+     util-linux      |          [] [] []          [] []    [] |
+     vorbis-tools    |                                     [] |
+     wastesedge      |                                        |
+     wdiff           |       []    [] []          [] []    [] |
+     wget            |    [] [] [] [] [] []       [] [] [] [] |
+                     +----------------------------------------+
+                       be bg ca cs da de el en eo es et fi fr
+                        0  2 19 10 30 44  9  1 12 45 16  3 53
+     
+                       gl he hr hu id it ja ko lv nb nl nn
+                     +-------------------------------------+
+     a2ps            |                ()    ()       []    |
+     bash            |          []                         |
+     bfd             |                   []                |
+     binutils        |                   []                |
+     bison           |       []       [] []          []    |
+     clisp           |                               []    |
+     clisp           |                                     |
+     clisplow        |                                     |
+     cpio            | []       []          []       []    |
+     darkstat        |       ()                            |
+     diffutils       | [] []    [] []    []                |
+     enscript        |       []                      []    |
+     error           |          []                         |
+     fetchmail       |                   []                |
+     fileutils       |          []    [] []                |
+     findutils       | []    [] [] [] [] [] []       []    |
+     flex            |                      []             |
+     gas             |                                     |
+     gawk            |    []                               |
+     gcal            |                                     |
+     gcc             |                   []                |
+     gettext         |                   [] []             |
+     gnupg           | []          [] [] []                |
+     gprof           |                                     |
+     gpsdrive        |          []    ()             ()    |
+     grep            | [] [] [] [] [] [] []                |
+     gretl           |                                     |
+     gthumb          |                () ()                |
+     hello           | [] [] [] [] [] [] [] [] [] [] [] [] |
+     id-utils        |          []                   []    |
+     indent          | []       []       []          []    |
+     jpilot          |                   ()          ()    |
+     jwhois          |          [] []                      |
+     kbd             |                                     |
+     ld              |                                     |
+     libc            | []                [] []    []       |
+     libiconv        | []    [] []                         |
+     lifelines       |                                     |
+     lilypond        |                   []          []    |
+     lingoteach      |          []                         |
+     lingoteach_lessons|                                     |
+     lynx            |          []    [] []          []    |
+     m4              | []          []    []          []    |
+     make            | [] [] []          [] []       []    |
+     man-db          |                () ()                |
+     mysecretdiary   |             []                      |
+     nano            | []          [] []          [] [] [] |
+     nano_1_0        | []          [] []          []    [] |
+     opcodes         |             []                []    |
+     parted          | []                []             [] |
+     ptx             | []       [] []             [] []    |
+     python          |                                     |
+     recode          | [] []          []                   |
+     sed             | [] [] []    [] [] [] []       []    |
+     sh-utils        |                [] []       []       |
+     sharutils       | []                []          []    |
+     sketch          |                ()                   |
+     soundtracker    | []    []                            |
+     sp              |                                     |
+     tar             | []    []       [] []       []       |
+     texinfo         |    [] []          []                |
+     textutils       | []                   []    []       |
+     util-linux      |                () []                |
+     vorbis-tools    |                                     |
+     wastesedge      |                                     |
+     wdiff           | []       [] []                      |
+     wget            | [] [] [] []       []          []    |
+                     +-------------------------------------+
+                       gl he hr hu id it ja ko lv nb nl nn
+                       23  9 12 18 14 13 26  9  1  8 19  4
+     
+                       no pl pt pt_BR ru sk sl sv tr uk zh_TW
+                     +----------------------------------------+
+     a2ps            | () () ()  []   []    [] [] []          | 10
+     bash            |           []                           |  6
+     bfd             |                         [] []          |  5
+     binutils        |                         [] []          |  5
+     bison           |                []       [] []          | 11
+     clisp           |                                        |  5
+     clisp           |                                        |  0
+     clisplow        |                                        |  0
+     cpio            |    []     []   []       []             | 12
+     darkstat        |           []                      ()   |  1
+     diffutils       |    []     []   []       [] []     []   | 17
+     enscript        |           []   []       [] []          |  8
+     error           |                   []       []     []   |  7
+     fetchmail       |    ()     ()               []          |  6
+     fileutils       |                []    [] [] []     []   | 13
+     findutils       |    []     []   [] [] [] [] []          | 21
+     flex            |                []       [] []          |  9
+     gas             |                            []          |  3
+     gawk            |                         [] []          |  6
+     gcal            |                         [] []          |  4
+     gcc             |                            []          |  4
+     gettext         |                [] [] [] [] []     []   | 13
+     gnupg           |    []                   [] []          | 14
+     gprof           |                         [] []          |  4
+     gpsdrive        |                   []    [] ()          |  3
+     grep            |    []          []    []    []          | 18
+     gretl           |                                        |  1
+     gthumb          |           ()   ()       []             |  1
+     hello           | [] []          [] []    [] [] []       | 28
+     id-utils        |           []   []       [] []          |  9
+     indent          |           []   [] []    [] []          | 14
+     jpilot          | ()                      () []          |  4
+     jwhois          |           []   ()       () []     []   |  7
+     kbd             |                         [] []          |  5
+     ld              |                         [] []          |  4
+     libc            | [] []     []      []    [] []          | 17
+     libiconv        |           []      []    [] []          | 11
+     lifelines       |                         []             |  1
+     lilypond        |                         []             |  6
+     lingoteach      |           []            []             |  5
+     lingoteach_lessons|                                        |  0
+     lynx            |           []   []       [] []          | 13
+     m4              |    []          []       []             | 12
+     make            |    []     []   []          []          | 14
+     man-db          |                                        |  3
+     mysecretdiary   |           []            [] []          |  7
+     nano            |    []          []       []    []       | 15
+     nano_1_0        |    []          []       []    []       | 14
+     opcodes         |                         [] []          |  7
+     parted          |       []  []            []             | 11
+     ptx             | [] [] []  []   []       [] []          | 19
+     python          |                                        |  0
+     recode          |    []     []   []    [] [] []          | 15
+     sed             |           []   [] [] [] [] []          | 23
+     sh-utils        |                            []          |  8
+     sharutils       |                []       [] []     []   | 13
+     sketch          |           []   ()       []             |  4
+     soundtracker    |                         []             |  6
+     sp              |                                        |  1
+     tar             | [] []     []      [] [] [] []          | 18
+     texinfo         |                []       []             | 10
+     textutils       |                []    [] [] []     []   | 13
+     util-linux      |           []            [] []          | 10
+     vorbis-tools    |                         []             |  2
+     wastesedge      |                                        |  0
+     wdiff           |           []   [] []    [] []          | 14
+     wget            |    []          [] [] [] [] [] []  []   | 24
+                     +----------------------------------------+
+       36 teams        no pl pt pt_BR ru sk sl sv tr uk zh_TW
+       67 domains       4 15  2  24   26 12 10 47 42  4   8    594
+
+   Some counters in the preceding matrix are higher than the number of
+visible blocks let us expect.  This is because a few extra PO files are
+used for implementing regional variants of languages, or language
+dialects.
+
+   For a PO file in the matrix above to be effective, the package to
+which it applies should also have been internationalized and
+distributed as such by its maintainer.  There might be an observable
+lag between the mere existence a PO file and its wide availability in a
+distribution.
+
+   If July 2002 seems to be old, you may fetch a more recent copy of
+this `ABOUT-NLS' file on most GNU archive sites.  The most up-to-date
+matrix with full percentage details can be found at
+`http://www.iro.umontreal.ca/contrib/po/HTML/matrix.html'.
+
+Using `gettext' in new packages
+===============================
+
+   If you are writing a freely available program and want to
+internationalize it you are welcome to use GNU `gettext' in your
+package.  Of course you have to respect the GNU Library General Public
+License which covers the use of the GNU `gettext' library.  This means
+in particular that even non-free programs can use `libintl' as a shared
+library, whereas only free software can use `libintl' as a static
+library or use modified versions of `libintl'.
+
+   Once the sources are changed appropriately and the setup can handle
+to use of `gettext' the only thing missing are the translations.  The
+Free Translation Project is also available for packages which are not
+developed inside the GNU project.  Therefore the information given above
+applies also for every other Free Software Project.  Contact
+`translation@iro.umontreal.ca' to make the `.pot' files available to
+the translation teams.
+
diff -Nur dillo-0.8.0/aclocal.m4 dillo-0.8.0.new/aclocal.m4
--- dillo-0.8.0/aclocal.m4	2004-02-08 12:55:49.000000000 +0000
+++ dillo-0.8.0.new/aclocal.m4	2004-10-13 01:19:58.000000000 +0000
@@ -1,4 +1,4 @@
-# generated automatically by aclocal 1.7.7 -*- Autoconf -*-
+# generated automatically by aclocal 1.7.3 -*- Autoconf -*-
 
 # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002
 # Free Software Foundation, Inc.
@@ -16,7 +16,7 @@
 # This macro actually does too much some checks are only needed if
 # your package does certain things.  But this isn't really a big deal.
 
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
 # Free Software Foundation, Inc.
 
 # This program is free software; you can redistribute it and/or modify
@@ -34,7 +34,14 @@
 # Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
 # 02111-1307, USA.
 
-# serial 10
+# serial 9
+
+# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
+# written in clear, in which case automake, when reading aclocal.m4,
+# will think it sees a *use*, and therefore will trigger all it's
+# C support machinery.  Also note that it means that autoscan, seeing
+# CC etc. in the Makefile, will ask for an AC_PROG_CC use...
+
 
 AC_PREREQ([2.54])
 
@@ -163,7 +170,7 @@
 # Call AM_AUTOMAKE_VERSION so it can be traced.
 # This function is AC_REQUIREd by AC_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-	 [AM_AUTOMAKE_VERSION([1.7.7])])
+	 [AM_AUTOMAKE_VERSION([1.7.3])])
 
 # Helper functions for option handling.                    -*- Autoconf -*-
 
@@ -545,32 +552,18 @@
   # using a relative directory.
   cp "$am_depcomp" conftest.dir
   cd conftest.dir
-  # We will build objects and dependencies in a subdirectory because
-  # it helps to detect inapplicable dependency modes.  For instance
-  # both Tru64's cc and ICC support -MD to output dependencies as a
-  # side effect of compilation, but ICC will put the dependencies in
-  # the current directory while Tru64 will put them in the object
-  # directory.
-  mkdir sub
 
   am_cv_$1_dependencies_compiler_type=none
   if test "$am_compiler_list" = ""; then
      am_compiler_list=`sed -n ['s/^#*\([a-zA-Z0-9]*\))$/\1/p'] < ./depcomp`
   fi
   for depmode in $am_compiler_list; do
-    # Setup a source with many dependencies, because some compilers
-    # like to wrap large dependency lists on column 80 (with \), and
-    # we should not choose a depcomp mode which is confused by this.
-    #
     # We need to recreate these files for each test, as the compiler may
     # overwrite some of them when testing with obscure command lines.
     # This happens at least with the AIX C compiler.
-    : > sub/conftest.c
-    for i in 1 2 3 4 5 6; do
-      echo '#include "conftst'$i'.h"' >> sub/conftest.c
-      : > sub/conftst$i.h
-    done
-    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+    echo '#include "conftest.h"' > conftest.c
+    echo 'int i;' > conftest.h
+    echo "${am__include} ${am__quote}conftest.Po${am__quote}" > confmf
 
     case $depmode in
     nosideeffect)
@@ -588,12 +581,11 @@
     # mode.  It turns out that the SunPro C++ compiler does not properly
     # handle `-M -o', and we need to detect this.
     if depmode=$depmode \
-       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \
-       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
-       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
+       source=conftest.c object=conftest.o \
+       depfile=conftest.Po tmpdepfile=conftest.TPo \
+       $SHELL ./depcomp $depcc -c -o conftest.o conftest.c \
          >/dev/null 2>conftest.err &&
-       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
-       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
+       grep conftest.h conftest.Po > /dev/null 2>&1 &&
        ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
       # icc doesn't choke on unknown options, it will just issue warnings
       # (even with -Werror).  So we grep stderr for any message
@@ -728,7 +720,7 @@
 
 # Check to see how 'make' treats includes.	-*- Autoconf -*-
 
-# Copyright (C) 2001, 2002, 2003 Free Software Foundation, Inc.
+# Copyright (C) 2001, 2002 Free Software Foundation, Inc.
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -753,9 +745,8 @@
 AC_DEFUN([AM_MAKE_INCLUDE],
 [am_make=${MAKE-make}
 cat > confinc << 'END'
-am__doit:
+doit:
 	@echo done
-.PHONY: am__doit
 END
 # If we don't find an include directive, just comment out the code.
 AC_MSG_CHECKING([for style of include used by $am_make])
@@ -783,9 +774,9 @@
       _am_result=BSD
    fi
 fi
-AC_SUBST([am__include])
-AC_SUBST([am__quote])
-AC_MSG_RESULT([$_am_result])
+AC_SUBST(am__include)
+AC_SUBST(am__quote)
+AC_MSG_RESULT($_am_result)
 rm -f confinc confmf
 ])
 
@@ -967,6 +958,1923 @@
 
 AU_DEFUN([fp_PROG_CC_STDC], [AM_PROG_CC_STDC])
 
+# gettext.m4 serial 17 (gettext-0.11.5)
+dnl Copyright (C) 1995-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+dnl
+dnl This file can can be used in projects which are not available under
+dnl the GNU General Public License or the GNU Library General Public
+dnl License but which still want to provide support for the GNU gettext
+dnl functionality.
+dnl Please note that the actual code of the GNU gettext library is covered
+dnl by the GNU Library General Public License, and the rest of the GNU
+dnl gettext package package is covered by the GNU General Public License.
+dnl They are *not* in the public domain.
+
+dnl Authors:
+dnl   Ulrich Drepper <drepper@cygnus.com>, 1995-2000.
+dnl   Bruno Haible <haible@clisp.cons.org>, 2000-2002.
+
+dnl Macro to add for using GNU gettext.
+
+dnl Usage: AM_GNU_GETTEXT([INTLSYMBOL], [NEEDSYMBOL], [INTLDIR]).
+dnl INTLSYMBOL can be one of 'external', 'no-libtool', 'use-libtool'. The
+dnl    default (if it is not specified or empty) is 'no-libtool'.
+dnl    INTLSYMBOL should be 'external' for packages with no intl directory,
+dnl    and 'no-libtool' or 'use-libtool' for packages with an intl directory.
+dnl    If INTLSYMBOL is 'use-libtool', then a libtool library
+dnl    $(top_builddir)/intl/libintl.la will be created (shared and/or static,
+dnl    depending on --{enable,disable}-{shared,static} and on the presence of
+dnl    AM-DISABLE-SHARED). If INTLSYMBOL is 'no-libtool', a static library
+dnl    $(top_builddir)/intl/libintl.a will be created.
+dnl If NEEDSYMBOL is specified and is 'need-ngettext', then GNU gettext
+dnl    implementations (in libc or libintl) without the ngettext() function
+dnl    will be ignored.  If NEEDSYMBOL is specified and is
+dnl    'need-formatstring-macros', then GNU gettext implementations that don't
+dnl    support the ISO C 99 <inttypes.h> formatstring macros will be ignored.
+dnl INTLDIR is used to find the intl libraries.  If empty,
+dnl    the value `$(top_builddir)/intl/' is used.
+dnl
+dnl The result of the configuration is one of three cases:
+dnl 1) GNU gettext, as included in the intl subdirectory, will be compiled
+dnl    and used.
+dnl    Catalog format: GNU --> install in $(datadir)
+dnl    Catalog extension: .mo after installation, .gmo in source tree
+dnl 2) GNU gettext has been found in the system's C library.
+dnl    Catalog format: GNU --> install in $(datadir)
+dnl    Catalog extension: .mo after installation, .gmo in source tree
+dnl 3) No internationalization, always use English msgid.
+dnl    Catalog format: none
+dnl    Catalog extension: none
+dnl If INTLSYMBOL is 'external', only cases 2 and 3 can occur.
+dnl The use of .gmo is historical (it was needed to avoid overwriting the
+dnl GNU format catalogs when building on a platform with an X/Open gettext),
+dnl but we keep it in order not to force irrelevant filename changes on the
+dnl maintainers.
+dnl
+AC_DEFUN([AM_GNU_GETTEXT],
+[
+  dnl Argument checking.
+  ifelse([$1], [], , [ifelse([$1], [external], , [ifelse([$1], [no-libtool], , [ifelse([$1], [use-libtool], ,
+    [errprint([ERROR: invalid first argument to AM_GNU_GETTEXT
+])])])])])
+  ifelse([$2], [], , [ifelse([$2], [need-ngettext], , [ifelse([$2], [need-formatstring-macros], ,
+    [errprint([ERROR: invalid second argument to AM_GNU_GETTEXT
+])])])])
+  define(gt_included_intl, ifelse([$1], [external], [no], [yes]))
+  define(gt_libtool_suffix_prefix, ifelse([$1], [use-libtool], [l], []))
+
+  AC_REQUIRE([AM_PO_SUBDIRS])dnl
+  ifelse(gt_included_intl, yes, [
+    AC_REQUIRE([AM_INTL_SUBDIR])dnl
+  ])
+
+  dnl Prerequisites of AC_LIB_LINKFLAGS_BODY.
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+
+  dnl Sometimes libintl requires libiconv, so first search for libiconv.
+  dnl Ideally we would do this search only after the
+  dnl      if test "$USE_NLS" = "yes"; then
+  dnl        if test "$gt_cv_func_gnugettext_libc" != "yes"; then
+  dnl tests. But if configure.in invokes AM_ICONV after AM_GNU_GETTEXT
+  dnl the configure script would need to contain the same shell code
+  dnl again, outside any 'if'. There are two solutions:
+  dnl - Invoke AM_ICONV_LINKFLAGS_BODY here, outside any 'if'.
+  dnl - Control the expansions in more detail using AC_PROVIDE_IFELSE.
+  dnl Since AC_PROVIDE_IFELSE is only in autoconf >= 2.52 and not
+  dnl documented, we avoid it.
+  ifelse(gt_included_intl, yes, , [
+    AC_REQUIRE([AM_ICONV_LINKFLAGS_BODY])
+  ])
+
+  AC_MSG_CHECKING([whether NLS is requested])
+  dnl Default is enabled NLS
+  AC_ARG_ENABLE(nls,
+    [  --disable-nls           do not use Native Language Support],
+    USE_NLS=$enableval, USE_NLS=yes)
+  AC_MSG_RESULT($USE_NLS)
+  AC_SUBST(USE_NLS)
+
+  ifelse(gt_included_intl, yes, [
+    BUILD_INCLUDED_LIBINTL=no
+    USE_INCLUDED_LIBINTL=no
+  ])
+  LIBINTL=
+  LTLIBINTL=
+  POSUB=
+
+  dnl If we use NLS figure out what method
+  if test "$USE_NLS" = "yes"; then
+    gt_use_preinstalled_gnugettext=no
+    ifelse(gt_included_intl, yes, [
+      AC_MSG_CHECKING([whether included gettext is requested])
+      AC_ARG_WITH(included-gettext,
+        [  --with-included-gettext use the GNU gettext library included here],
+        nls_cv_force_use_gnu_gettext=$withval,
+        nls_cv_force_use_gnu_gettext=no)
+      AC_MSG_RESULT($nls_cv_force_use_gnu_gettext)
+
+      nls_cv_use_gnu_gettext="$nls_cv_force_use_gnu_gettext"
+      if test "$nls_cv_force_use_gnu_gettext" != "yes"; then
+    ])
+        dnl User does not insist on using GNU NLS library.  Figure out what
+        dnl to use.  If GNU gettext is available we use this.  Else we have
+        dnl to fall back to GNU NLS library.
+
+        dnl Add a version number to the cache macros.
+        define([gt_api_version], ifelse([$2], [need-formatstring-macros], 3, ifelse([$2], [need-ngettext], 2, 1)))
+        define([gt_cv_func_gnugettext_libc], [gt_cv_func_gnugettext]gt_api_version[_libc])
+        define([gt_cv_func_gnugettext_libintl], [gt_cv_func_gnugettext]gt_api_version[_libintl])
+
+        AC_CACHE_CHECK([for GNU gettext in libc], gt_cv_func_gnugettext_libc,
+         [AC_TRY_LINK([#include <libintl.h>
+]ifelse([$2], [need-formatstring-macros],
+[#ifndef __GNU_GETTEXT_SUPPORTED_REVISION
+#define __GNU_GETTEXT_SUPPORTED_REVISION(major) ((major) == 0 ? 0 : -1)
+#endif
+changequote(,)dnl
+typedef int array [2 * (__GNU_GETTEXT_SUPPORTED_REVISION(0) >= 1) - 1];
+changequote([,])dnl
+], [])[extern int _nl_msg_cat_cntr;
+extern int *_nl_domain_bindings;],
+            [bindtextdomain ("", "");
+return (int) gettext ("")]ifelse([$2], [need-ngettext], [ + (int) ngettext ("", "", 0)], [])[ + _nl_msg_cat_cntr + *_nl_domain_bindings],
+            gt_cv_func_gnugettext_libc=yes,
+            gt_cv_func_gnugettext_libc=no)])
+
+        if test "$gt_cv_func_gnugettext_libc" != "yes"; then
+          dnl Sometimes libintl requires libiconv, so first search for libiconv.
+          ifelse(gt_included_intl, yes, , [
+            AM_ICONV_LINK
+          ])
+          dnl Search for libintl and define LIBINTL, LTLIBINTL and INCINTL
+          dnl accordingly. Don't use AC_LIB_LINKFLAGS_BODY([intl],[iconv])
+          dnl because that would add "-liconv" to LIBINTL and LTLIBINTL
+          dnl even if libiconv doesn't exist.
+          AC_LIB_LINKFLAGS_BODY([intl])
+          AC_CACHE_CHECK([for GNU gettext in libintl],
+            gt_cv_func_gnugettext_libintl,
+           [gt_save_CPPFLAGS="$CPPFLAGS"
+            CPPFLAGS="$CPPFLAGS $INCINTL"
+            gt_save_LIBS="$LIBS"
+            LIBS="$LIBS $LIBINTL"
+            dnl Now see whether libintl exists and does not depend on libiconv.
+            AC_TRY_LINK([#include <libintl.h>
+]ifelse([$2], [need-formatstring-macros],
+[#ifndef __GNU_GETTEXT_SUPPORTED_REVISION
+#define __GNU_GETTEXT_SUPPORTED_REVISION(major) ((major) == 0 ? 0 : -1)
+#endif
+changequote(,)dnl
+typedef int array [2 * (__GNU_GETTEXT_SUPPORTED_REVISION(0) >= 1) - 1];
+changequote([,])dnl
+], [])[extern int _nl_msg_cat_cntr;
+extern
+#ifdef __cplusplus
+"C"
+#endif
+const char *_nl_expand_alias ();],
+              [bindtextdomain ("", "");
+return (int) gettext ("")]ifelse([$2], [need-ngettext], [ + (int) ngettext ("", "", 0)], [])[ + _nl_msg_cat_cntr + *_nl_expand_alias (0)],
+              gt_cv_func_gnugettext_libintl=yes,
+              gt_cv_func_gnugettext_libintl=no)
+            dnl Now see whether libintl exists and depends on libiconv.
+            if test "$gt_cv_func_gnugettext_libintl" != yes && test -n "$LIBICONV"; then
+              LIBS="$LIBS $LIBICONV"
+              AC_TRY_LINK([#include <libintl.h>
+]ifelse([$2], [need-formatstring-macros],
+[#ifndef __GNU_GETTEXT_SUPPORTED_REVISION
+#define __GNU_GETTEXT_SUPPORTED_REVISION(major) ((major) == 0 ? 0 : -1)
+#endif
+changequote(,)dnl
+typedef int array [2 * (__GNU_GETTEXT_SUPPORTED_REVISION(0) >= 1) - 1];
+changequote([,])dnl
+], [])[extern int _nl_msg_cat_cntr;
+extern
+#ifdef __cplusplus
+"C"
+#endif
+const char *_nl_expand_alias ();],
+                [bindtextdomain ("", "");
+return (int) gettext ("")]ifelse([$2], [need-ngettext], [ + (int) ngettext ("", "", 0)], [])[ + _nl_msg_cat_cntr + *_nl_expand_alias (0)],
+               [LIBINTL="$LIBINTL $LIBICONV"
+                LTLIBINTL="$LTLIBINTL $LTLIBICONV"
+                gt_cv_func_gnugettext_libintl=yes
+               ])
+            fi
+            CPPFLAGS="$gt_save_CPPFLAGS"
+            LIBS="$gt_save_LIBS"])
+        fi
+
+        dnl If an already present or preinstalled GNU gettext() is found,
+        dnl use it.  But if this macro is used in GNU gettext, and GNU
+        dnl gettext is already preinstalled in libintl, we update this
+        dnl libintl.  (Cf. the install rule in intl/Makefile.in.)
+        if test "$gt_cv_func_gnugettext_libc" = "yes" \
+           || { test "$gt_cv_func_gnugettext_libintl" = "yes" \
+                && test "$PACKAGE" != gettext; }; then
+          gt_use_preinstalled_gnugettext=yes
+        else
+          dnl Reset the values set by searching for libintl.
+          LIBINTL=
+          LTLIBINTL=
+          INCINTL=
+        fi
+
+    ifelse(gt_included_intl, yes, [
+        if test "$gt_use_preinstalled_gnugettext" != "yes"; then
+          dnl GNU gettext is not found in the C library.
+          dnl Fall back on included GNU gettext library.
+          nls_cv_use_gnu_gettext=yes
+        fi
+      fi
+
+      if test "$nls_cv_use_gnu_gettext" = "yes"; then
+        dnl Mark actions used to generate GNU NLS library.
+        INTLOBJS="\$(GETTOBJS)"
+        BUILD_INCLUDED_LIBINTL=yes
+        USE_INCLUDED_LIBINTL=yes
+        LIBINTL="ifelse([$3],[],\${top_builddir}/intl,[$3])/libintl.[]gt_libtool_suffix_prefix[]a $LIBICONV"
+        LTLIBINTL="ifelse([$3],[],\${top_builddir}/intl,[$3])/libintl.[]gt_libtool_suffix_prefix[]a $LTLIBICONV"
+        LIBS=`echo " $LIBS " | sed -e 's/ -lintl / /' -e 's/^ //' -e 's/ $//'`
+      fi
+
+      if test "$gt_use_preinstalled_gnugettext" = "yes" \
+         || test "$nls_cv_use_gnu_gettext" = "yes"; then
+        dnl Mark actions to use GNU gettext tools.
+        CATOBJEXT=.gmo
+      fi
+    ])
+
+    if test "$gt_use_preinstalled_gnugettext" = "yes" \
+       || test "$nls_cv_use_gnu_gettext" = "yes"; then
+      AC_DEFINE(ENABLE_NLS, 1,
+        [Define to 1 if translation of program messages to the user's native language
+   is requested.])
+    else
+      USE_NLS=no
+    fi
+  fi
+
+  if test "$USE_NLS" = "yes"; then
+
+    if test "$gt_use_preinstalled_gnugettext" = "yes"; then
+      if test "$gt_cv_func_gnugettext_libintl" = "yes"; then
+        AC_MSG_CHECKING([how to link with libintl])
+        AC_MSG_RESULT([$LIBINTL])
+        AC_LIB_APPENDTOVAR([CPPFLAGS], [$INCINTL])
+      fi
+
+      dnl For backward compatibility. Some packages may be using this.
+      AC_DEFINE(HAVE_GETTEXT, 1,
+       [Define if the GNU gettext() function is already present or preinstalled.])
+      AC_DEFINE(HAVE_DCGETTEXT, 1,
+       [Define if the GNU dcgettext() function is already present or preinstalled.])
+    fi
+
+    dnl We need to process the po/ directory.
+    POSUB=po
+  fi
+
+  ifelse(gt_included_intl, yes, [
+    dnl If this is used in GNU gettext we have to set BUILD_INCLUDED_LIBINTL
+    dnl to 'yes' because some of the testsuite requires it.
+    if test "$PACKAGE" = gettext; then
+      BUILD_INCLUDED_LIBINTL=yes
+    fi
+
+    dnl Make all variables we use known to autoconf.
+    AC_SUBST(BUILD_INCLUDED_LIBINTL)
+    AC_SUBST(USE_INCLUDED_LIBINTL)
+    AC_SUBST(CATOBJEXT)
+    AC_SUBST(INTLOBJS)
+
+    dnl For backward compatibility. Some configure.ins may be using this.
+    nls_cv_header_intl=
+    nls_cv_header_libgt=
+
+    dnl For backward compatibility. Some Makefiles may be using this.
+    DATADIRNAME=share
+    AC_SUBST(DATADIRNAME)
+
+    dnl For backward compatibility. Some Makefiles may be using this.
+    INSTOBJEXT=.mo
+    AC_SUBST(INSTOBJEXT)
+
+    dnl For backward compatibility. Some Makefiles may be using this.
+    GENCAT=gencat
+    AC_SUBST(GENCAT)
+
+    dnl Enable libtool support if the surrounding package wishes it.
+    INTL_LIBTOOL_SUFFIX_PREFIX=gt_libtool_suffix_prefix
+    AC_SUBST(INTL_LIBTOOL_SUFFIX_PREFIX)
+  ])
+
+  dnl For backward compatibility. Some Makefiles may be using this.
+  INTLLIBS="$LIBINTL"
+  AC_SUBST(INTLLIBS)
+
+  dnl Make all documented variables known to autoconf.
+  AC_SUBST(LIBINTL)
+  AC_SUBST(LTLIBINTL)
+  AC_SUBST(POSUB)
+])
+
+
+dnl Checks for all prerequisites of the po subdirectory,
+dnl except for USE_NLS.
+AC_DEFUN([AM_PO_SUBDIRS],
+[
+  AC_REQUIRE([AC_PROG_MAKE_SET])dnl
+  AC_REQUIRE([AC_PROG_INSTALL])dnl
+  AC_REQUIRE([AM_MKINSTALLDIRS])dnl
+
+  dnl Perform the following tests also if --disable-nls has been given,
+  dnl because they are needed for "make dist" to work.
+
+  dnl Search for GNU msgfmt in the PATH.
+  dnl The first test excludes Solaris msgfmt and early GNU msgfmt versions.
+  dnl The second test excludes FreeBSD msgfmt.
+  AM_PATH_PROG_WITH_TEST(MSGFMT, msgfmt,
+    [$ac_dir/$ac_word --statistics /dev/null >/dev/null 2>&1 &&
+     (if $ac_dir/$ac_word --statistics /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi)],
+    :)
+  AC_PATH_PROG(GMSGFMT, gmsgfmt, $MSGFMT)
+
+  dnl Search for GNU xgettext 0.11 or newer in the PATH.
+  dnl The first test excludes Solaris xgettext and early GNU xgettext versions.
+  dnl The second test excludes FreeBSD xgettext.
+  AM_PATH_PROG_WITH_TEST(XGETTEXT, xgettext,
+    [$ac_dir/$ac_word --omit-header --copyright-holder= /dev/null >/dev/null 2>&1 &&
+     (if $ac_dir/$ac_word --omit-header --copyright-holder= /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi)],
+    :)
+  dnl Remove leftover from FreeBSD xgettext call.
+  rm -f messages.po
+
+  dnl Search for GNU msgmerge 0.11 or newer in the PATH.
+  AM_PATH_PROG_WITH_TEST(MSGMERGE, msgmerge,
+    [$ac_dir/$ac_word --update -q /dev/null /dev/null >/dev/null 2>&1], :)
+
+  dnl This could go away some day; the PATH_PROG_WITH_TEST already does it.
+  dnl Test whether we really found GNU msgfmt.
+  if test "$GMSGFMT" != ":"; then
+    dnl If it is no GNU msgfmt we define it as : so that the
+    dnl Makefiles still can work.
+    if $GMSGFMT --statistics /dev/null >/dev/null 2>&1 &&
+       (if $GMSGFMT --statistics /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi); then
+      : ;
+    else
+      GMSGFMT=`echo "$GMSGFMT" | sed -e 's,^.*/,,'`
+      AC_MSG_RESULT(
+        [found $GMSGFMT program is not GNU msgfmt; ignore it])
+      GMSGFMT=":"
+    fi
+  fi
+
+  dnl This could go away some day; the PATH_PROG_WITH_TEST already does it.
+  dnl Test whether we really found GNU xgettext.
+  if test "$XGETTEXT" != ":"; then
+    dnl If it is no GNU xgettext we define it as : so that the
+    dnl Makefiles still can work.
+    if $XGETTEXT --omit-header --copyright-holder= /dev/null >/dev/null 2>&1 &&
+       (if $XGETTEXT --omit-header --copyright-holder= /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi); then
+      : ;
+    else
+      AC_MSG_RESULT(
+        [found xgettext program is not GNU xgettext; ignore it])
+      XGETTEXT=":"
+    fi
+    dnl Remove leftover from FreeBSD xgettext call.
+    rm -f messages.po
+  fi
+
+  AC_OUTPUT_COMMANDS([
+    for ac_file in $CONFIG_FILES; do
+      # Support "outfile[:infile[:infile...]]"
+      case "$ac_file" in
+        *:*) ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+      esac
+      # PO directories have a Makefile.in generated from Makefile.in.in.
+      case "$ac_file" in */Makefile.in)
+        # Adjust a relative srcdir.
+        ac_dir=`echo "$ac_file"|sed 's%/[^/][^/]*$%%'`
+        ac_dir_suffix="/`echo "$ac_dir"|sed 's%^\./%%'`"
+        ac_dots=`echo "$ac_dir_suffix"|sed 's%/[^/]*%../%g'`
+        # In autoconf-2.13 it is called $ac_given_srcdir.
+        # In autoconf-2.50 it is called $srcdir.
+        test -n "$ac_given_srcdir" || ac_given_srcdir="$srcdir"
+        case "$ac_given_srcdir" in
+          .)  top_srcdir=`echo $ac_dots|sed 's%/$%%'` ;;
+          /*) top_srcdir="$ac_given_srcdir" ;;
+          *)  top_srcdir="$ac_dots$ac_given_srcdir" ;;
+        esac
+        if test -f "$ac_given_srcdir/$ac_dir/POTFILES.in"; then
+          rm -f "$ac_dir/POTFILES"
+          test -n "$as_me" && echo "$as_me: creating $ac_dir/POTFILES" || echo "creating $ac_dir/POTFILES"
+          cat "$ac_given_srcdir/$ac_dir/POTFILES.in" | sed -e "/^#/d" -e "/^[ 	]*\$/d" -e "s,.*,     $top_srcdir/& \\\\," | sed -e "\$s/\(.*\) \\\\/\1/" > "$ac_dir/POTFILES"
+          # ALL_LINGUAS, POFILES, GMOFILES, UPDATEPOFILES, DUMMYPOFILES depend
+          # on $ac_dir but don't depend on user-specified configuration
+          # parameters.
+          if test -f "$ac_given_srcdir/$ac_dir/LINGUAS"; then
+            # The LINGUAS file contains the set of available languages.
+            if test -n "$ALL_LINGUAS"; then
+              test -n "$as_me" && echo "$as_me: setting ALL_LINGUAS in configure.in is obsolete" || echo "setting ALL_LINGUAS in configure.in is obsolete"
+            fi
+            ALL_LINGUAS_=`sed -e "/^#/d" "$ac_given_srcdir/$ac_dir/LINGUAS"`
+            # Hide the ALL_LINGUAS assigment from automake.
+            eval 'ALL_LINGUAS''=$ALL_LINGUAS_'
+          fi
+          case "$ac_given_srcdir" in
+            .) srcdirpre= ;;
+            *) srcdirpre='$(srcdir)/' ;;
+          esac
+          POFILES=
+          GMOFILES=
+          UPDATEPOFILES=
+          DUMMYPOFILES=
+          for lang in $ALL_LINGUAS; do
+            POFILES="$POFILES $srcdirpre$lang.po"
+            GMOFILES="$GMOFILES $srcdirpre$lang.gmo"
+            UPDATEPOFILES="$UPDATEPOFILES $lang.po-update"
+            DUMMYPOFILES="$DUMMYPOFILES $lang.nop"
+          done
+          # CATALOGS depends on both $ac_dir and the user's LINGUAS
+          # environment variable.
+          INST_LINGUAS=
+          if test -n "$ALL_LINGUAS"; then
+            for presentlang in $ALL_LINGUAS; do
+              useit=no
+              if test "%UNSET%" != "$LINGUAS"; then
+                desiredlanguages="$LINGUAS"
+              else
+                desiredlanguages="$ALL_LINGUAS"
+              fi
+              for desiredlang in $desiredlanguages; do
+                # Use the presentlang catalog if desiredlang is
+                #   a. equal to presentlang, or
+                #   b. a variant of presentlang (because in this case,
+                #      presentlang can be used as a fallback for messages
+                #      which are not translated in the desiredlang catalog).
+                case "$desiredlang" in
+                  "$presentlang"*) useit=yes;;
+                esac
+              done
+              if test $useit = yes; then
+                INST_LINGUAS="$INST_LINGUAS $presentlang"
+              fi
+            done
+          fi
+          CATALOGS=
+          if test -n "$INST_LINGUAS"; then
+            for lang in $INST_LINGUAS; do
+              CATALOGS="$CATALOGS $lang.gmo"
+            done
+          fi
+          test -n "$as_me" && echo "$as_me: creating $ac_dir/Makefile" || echo "creating $ac_dir/Makefile"
+          sed -e "/^POTFILES =/r $ac_dir/POTFILES" -e "/^# Makevars/r $ac_given_srcdir/$ac_dir/Makevars" -e "s|@POFILES@|$POFILES|g" -e "s|@GMOFILES@|$GMOFILES|g" -e "s|@UPDATEPOFILES@|$UPDATEPOFILES|g" -e "s|@DUMMYPOFILES@|$DUMMYPOFILES|g" -e "s|@CATALOGS@|$CATALOGS|g" "$ac_dir/Makefile.in" > "$ac_dir/Makefile"
+          for f in "$ac_given_srcdir/$ac_dir"/Rules-*; do
+            if test -f "$f"; then
+              case "$f" in
+                *.orig | *.bak | *~) ;;
+                *) cat "$f" >> "$ac_dir/Makefile" ;;
+              esac
+            fi
+          done
+        fi
+        ;;
+      esac
+    done],
+   [# Capture the value of obsolete ALL_LINGUAS because we need it to compute
+    # POFILES, GMOFILES, UPDATEPOFILES, DUMMYPOFILES, CATALOGS. But hide it
+    # from automake.
+    eval 'ALL_LINGUAS''="$ALL_LINGUAS"'
+    # Capture the value of LINGUAS because we need it to compute CATALOGS.
+    LINGUAS="${LINGUAS-%UNSET%}"
+   ])
+])
+
+
+dnl Checks for all prerequisites of the intl subdirectory,
+dnl except for INTL_LIBTOOL_SUFFIX_PREFIX (and possibly LIBTOOL), INTLOBJS,
+dnl            USE_INCLUDED_LIBINTL, BUILD_INCLUDED_LIBINTL.
+AC_DEFUN([AM_INTL_SUBDIR],
+[
+  AC_REQUIRE([AC_PROG_INSTALL])dnl
+  AC_REQUIRE([AM_MKINSTALLDIRS])dnl
+  AC_REQUIRE([AC_PROG_CC])dnl
+  AC_REQUIRE([AC_CANONICAL_HOST])dnl
+  AC_REQUIRE([AC_PROG_RANLIB])dnl
+  AC_REQUIRE([AC_ISC_POSIX])dnl
+  AC_REQUIRE([AC_HEADER_STDC])dnl
+  AC_REQUIRE([AC_C_CONST])dnl
+  AC_REQUIRE([AC_C_INLINE])dnl
+  AC_REQUIRE([AC_TYPE_OFF_T])dnl
+  AC_REQUIRE([AC_TYPE_SIZE_T])dnl
+  AC_REQUIRE([AC_FUNC_ALLOCA])dnl
+  AC_REQUIRE([AC_FUNC_MMAP])dnl
+  AC_REQUIRE([jm_GLIBC21])dnl
+  AC_REQUIRE([gt_INTDIV0])dnl
+  AC_REQUIRE([jm_AC_TYPE_UINTMAX_T])dnl
+  AC_REQUIRE([gt_HEADER_INTTYPES_H])dnl
+  AC_REQUIRE([gt_INTTYPES_PRI])dnl
+
+  AC_CHECK_HEADERS([argz.h limits.h locale.h nl_types.h malloc.h stddef.h \
+stdlib.h string.h unistd.h sys/param.h])
+  AC_CHECK_FUNCS([feof_unlocked fgets_unlocked getc_unlocked getcwd getegid \
+geteuid getgid getuid mempcpy munmap putenv setenv setlocale stpcpy \
+strcasecmp strdup strtoul tsearch __argz_count __argz_stringify __argz_next])
+
+  AM_ICONV
+  AM_LANGINFO_CODESET
+  if test $ac_cv_header_locale_h = yes; then
+    AM_LC_MESSAGES
+  fi
+
+  dnl intl/plural.c is generated from intl/plural.y. It requires bison,
+  dnl because plural.y uses bison specific features. It requires at least
+  dnl bison-1.26 because earlier versions generate a plural.c that doesn't
+  dnl compile.
+  dnl bison is only needed for the maintainer (who touches plural.y). But in
+  dnl order to avoid separate Makefiles or --enable-maintainer-mode, we put
+  dnl the rule in general Makefile. Now, some people carelessly touch the
+  dnl files or have a broken "make" program, hence the plural.c rule will
+  dnl sometimes fire. To avoid an error, defines BISON to ":" if it is not
+  dnl present or too old.
+  AC_CHECK_PROGS([INTLBISON], [bison])
+  if test -z "$INTLBISON"; then
+    ac_verc_fail=yes
+  else
+    dnl Found it, now check the version.
+    AC_MSG_CHECKING([version of bison])
+changequote(<<,>>)dnl
+    ac_prog_version=`$INTLBISON --version 2>&1 | sed -n 's/^.*GNU Bison.* \([0-9]*\.[0-9.]*\).*$/\1/p'`
+    case $ac_prog_version in
+      '') ac_prog_version="v. ?.??, bad"; ac_verc_fail=yes;;
+      1.2[6-9]* | 1.[3-9][0-9]* | [2-9].*)
+changequote([,])dnl
+         ac_prog_version="$ac_prog_version, ok"; ac_verc_fail=no;;
+      *) ac_prog_version="$ac_prog_version, bad"; ac_verc_fail=yes;;
+    esac
+    AC_MSG_RESULT([$ac_prog_version])
+  fi
+  if test $ac_verc_fail = yes; then
+    INTLBISON=:
+  fi
+])
+
+
+AC_DEFUN([AM_MKINSTALLDIRS],
+[
+  dnl If the AC_CONFIG_AUX_DIR macro for autoconf is used we possibly
+  dnl find the mkinstalldirs script in another subdir but $(top_srcdir).
+  dnl Try to locate is.
+  MKINSTALLDIRS=
+  if test -n "$ac_aux_dir"; then
+    MKINSTALLDIRS="$ac_aux_dir/mkinstalldirs"
+  fi
+  if test -z "$MKINSTALLDIRS"; then
+    MKINSTALLDIRS="\$(top_srcdir)/mkinstalldirs"
+  fi
+  AC_SUBST(MKINSTALLDIRS)
+])
+
+
+dnl Usage: AM_GNU_GETTEXT_VERSION([gettext-version])
+AC_DEFUN([AM_GNU_GETTEXT_VERSION], [])
+
+# lib-prefix.m4 serial 1 (gettext-0.11)
+dnl Copyright (C) 2001-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Bruno Haible.
+
+dnl AC_LIB_PREFIX adds to the CPPFLAGS and LDFLAGS the flags that are needed
+dnl to access previously installed libraries. The basic assumption is that
+dnl a user will want packages to use other packages he previously installed
+dnl with the same --prefix option.
+dnl This macro is not needed if only AC_LIB_LINKFLAGS is used to locate
+dnl libraries, but is otherwise very convenient.
+AC_DEFUN([AC_LIB_PREFIX],
+[
+  AC_BEFORE([$0], [AC_LIB_LINKFLAGS])
+  AC_REQUIRE([AC_PROG_CC])
+  AC_REQUIRE([AC_CANONICAL_HOST])
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  dnl By default, look in $includedir and $libdir.
+  use_additional=yes
+  AC_LIB_WITH_FINAL_PREFIX([
+    eval additional_includedir=\"$includedir\"
+    eval additional_libdir=\"$libdir\"
+  ])
+  AC_ARG_WITH([lib-prefix],
+[  --with-lib-prefix[=DIR] search for libraries in DIR/include and DIR/lib
+  --without-lib-prefix    don't search for libraries in includedir and libdir],
+[
+    if test "X$withval" = "Xno"; then
+      use_additional=no
+    else
+      if test "X$withval" = "X"; then
+        AC_LIB_WITH_FINAL_PREFIX([
+          eval additional_includedir=\"$includedir\"
+          eval additional_libdir=\"$libdir\"
+        ])
+      else
+        additional_includedir="$withval/include"
+        additional_libdir="$withval/lib"
+      fi
+    fi
+])
+  if test $use_additional = yes; then
+    dnl Potentially add $additional_includedir to $CPPFLAGS.
+    dnl But don't add it
+    dnl   1. if it's the standard /usr/include,
+    dnl   2. if it's already present in $CPPFLAGS,
+    dnl   3. if it's /usr/local/include and we are using GCC on Linux,
+    dnl   4. if it doesn't exist as a directory.
+    if test "X$additional_includedir" != "X/usr/include"; then
+      haveit=
+      for x in $CPPFLAGS; do
+        AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+        if test "X$x" = "X-I$additional_includedir"; then
+          haveit=yes
+          break
+        fi
+      done
+      if test -z "$haveit"; then
+        if test "X$additional_includedir" = "X/usr/local/include"; then
+          if test -n "$GCC"; then
+            case $host_os in
+              linux*) haveit=yes;;
+            esac
+          fi
+        fi
+        if test -z "$haveit"; then
+          if test -d "$additional_includedir"; then
+            dnl Really add $additional_includedir to $CPPFLAGS.
+            CPPFLAGS="${CPPFLAGS}${CPPFLAGS:+ }-I$additional_includedir"
+          fi
+        fi
+      fi
+    fi
+    dnl Potentially add $additional_libdir to $LDFLAGS.
+    dnl But don't add it
+    dnl   1. if it's the standard /usr/lib,
+    dnl   2. if it's already present in $LDFLAGS,
+    dnl   3. if it's /usr/local/lib and we are using GCC on Linux,
+    dnl   4. if it doesn't exist as a directory.
+    if test "X$additional_libdir" != "X/usr/lib"; then
+      haveit=
+      for x in $LDFLAGS; do
+        AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+        if test "X$x" = "X-L$additional_libdir"; then
+          haveit=yes
+          break
+        fi
+      done
+      if test -z "$haveit"; then
+        if test "X$additional_libdir" = "X/usr/local/lib"; then
+          if test -n "$GCC"; then
+            case $host_os in
+              linux*) haveit=yes;;
+            esac
+          fi
+        fi
+        if test -z "$haveit"; then
+          if test -d "$additional_libdir"; then
+            dnl Really add $additional_libdir to $LDFLAGS.
+            LDFLAGS="${LDFLAGS}${LDFLAGS:+ }-L$additional_libdir"
+          fi
+        fi
+      fi
+    fi
+  fi
+])
+
+dnl AC_LIB_PREPARE_PREFIX creates variables acl_final_prefix,
+dnl acl_final_exec_prefix, containing the values to which $prefix and
+dnl $exec_prefix will expand at the end of the configure script.
+AC_DEFUN([AC_LIB_PREPARE_PREFIX],
+[
+  dnl Unfortunately, prefix and exec_prefix get only finally determined
+  dnl at the end of configure.
+  if test "X$prefix" = "XNONE"; then
+    acl_final_prefix="$ac_default_prefix"
+  else
+    acl_final_prefix="$prefix"
+  fi
+  if test "X$exec_prefix" = "XNONE"; then
+    acl_final_exec_prefix='${prefix}'
+  else
+    acl_final_exec_prefix="$exec_prefix"
+  fi
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  eval acl_final_exec_prefix=\"$acl_final_exec_prefix\"
+  prefix="$acl_save_prefix"
+])
+
+dnl AC_LIB_WITH_FINAL_PREFIX([statement]) evaluates statement, with the
+dnl variables prefix and exec_prefix bound to the values they will have
+dnl at the end of the configure script.
+AC_DEFUN([AC_LIB_WITH_FINAL_PREFIX],
+[
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  $1
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+])
+
+# lib-link.m4 serial 3 (gettext-0.11.3)
+dnl Copyright (C) 2001-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Bruno Haible.
+
+dnl AC_LIB_LINKFLAGS(name [, dependencies]) searches for libname and
+dnl the libraries corresponding to explicit and implicit dependencies.
+dnl Sets and AC_SUBSTs the LIB${NAME} and LTLIB${NAME} variables and
+dnl augments the CPPFLAGS variable.
+AC_DEFUN([AC_LIB_LINKFLAGS],
+[
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+  define([Name],[translit([$1],[./-], [___])])
+  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],
+                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])
+  AC_CACHE_CHECK([how to link with lib[]$1], [ac_cv_lib[]Name[]_libs], [
+    AC_LIB_LINKFLAGS_BODY([$1], [$2])
+    ac_cv_lib[]Name[]_libs="$LIB[]NAME"
+    ac_cv_lib[]Name[]_ltlibs="$LTLIB[]NAME"
+    ac_cv_lib[]Name[]_cppflags="$INC[]NAME"
+  ])
+  LIB[]NAME="$ac_cv_lib[]Name[]_libs"
+  LTLIB[]NAME="$ac_cv_lib[]Name[]_ltlibs"
+  INC[]NAME="$ac_cv_lib[]Name[]_cppflags"
+  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)
+  AC_SUBST([LIB]NAME)
+  AC_SUBST([LTLIB]NAME)
+  dnl Also set HAVE_LIB[]NAME so that AC_LIB_HAVE_LINKFLAGS can reuse the
+  dnl results of this search when this library appears as a dependency.
+  HAVE_LIB[]NAME=yes
+  undefine([Name])
+  undefine([NAME])
+])
+
+dnl AC_LIB_HAVE_LINKFLAGS(name, dependencies, includes, testcode)
+dnl searches for libname and the libraries corresponding to explicit and
+dnl implicit dependencies, together with the specified include files and
+dnl the ability to compile and link the specified testcode. If found, it
+dnl sets and AC_SUBSTs HAVE_LIB${NAME}=yes and the LIB${NAME} and
+dnl LTLIB${NAME} variables and augments the CPPFLAGS variable, and
+dnl #defines HAVE_LIB${NAME} to 1. Otherwise, it sets and AC_SUBSTs
+dnl HAVE_LIB${NAME}=no and LIB${NAME} and LTLIB${NAME} to empty.
+AC_DEFUN([AC_LIB_HAVE_LINKFLAGS],
+[
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+  define([Name],[translit([$1],[./-], [___])])
+  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],
+                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])
+
+  dnl Search for lib[]Name and define LIB[]NAME, LTLIB[]NAME and INC[]NAME
+  dnl accordingly.
+  AC_LIB_LINKFLAGS_BODY([$1], [$2])
+
+  dnl Add $INC[]NAME to CPPFLAGS before performing the following checks,
+  dnl because if the user has installed lib[]Name and not disabled its use
+  dnl via --without-lib[]Name-prefix, he wants to use it.
+  ac_save_CPPFLAGS="$CPPFLAGS"
+  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)
+
+  AC_CACHE_CHECK([for lib[]$1], [ac_cv_lib[]Name], [
+    ac_save_LIBS="$LIBS"
+    LIBS="$LIBS $LIB[]NAME"
+    AC_TRY_LINK([$3], [$4], [ac_cv_lib[]Name=yes], [ac_cv_lib[]Name=no])
+    LIBS="$ac_save_LIBS"
+  ])
+  if test "$ac_cv_lib[]Name" = yes; then
+    HAVE_LIB[]NAME=yes
+    AC_DEFINE([HAVE_LIB]NAME, 1, [Define if you have the $1 library.])
+    AC_MSG_CHECKING([how to link with lib[]$1])
+    AC_MSG_RESULT([$LIB[]NAME])
+  else
+    HAVE_LIB[]NAME=no
+    dnl If $LIB[]NAME didn't lead to a usable library, we don't need
+    dnl $INC[]NAME either.
+    CPPFLAGS="$ac_save_CPPFLAGS"
+    LIB[]NAME=
+    LTLIB[]NAME=
+  fi
+  AC_SUBST([HAVE_LIB]NAME)
+  AC_SUBST([LIB]NAME)
+  AC_SUBST([LTLIB]NAME)
+  undefine([Name])
+  undefine([NAME])
+])
+
+dnl Determine the platform dependent parameters needed to use rpath:
+dnl libext, shlibext, hardcode_libdir_flag_spec, hardcode_libdir_separator,
+dnl hardcode_direct, hardcode_minus_L,
+dnl sys_lib_search_path_spec, sys_lib_dlsearch_path_spec.
+AC_DEFUN([AC_LIB_RPATH],
+[
+  AC_REQUIRE([AC_PROG_CC])                dnl we use $CC, $GCC, $LDFLAGS
+  AC_REQUIRE([AC_LIB_PROG_LD])            dnl we use $LD, $with_gnu_ld
+  AC_REQUIRE([AC_CANONICAL_HOST])         dnl we use $host
+  AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT]) dnl we use $ac_aux_dir
+  AC_CACHE_CHECK([for shared library run path origin], acl_cv_rpath, [
+    CC="$CC" GCC="$GCC" LDFLAGS="$LDFLAGS" LD="$LD" with_gnu_ld="$with_gnu_ld" \
+    ${CONFIG_SHELL-/bin/sh} "$ac_aux_dir/config.rpath" "$host" > conftest.sh
+    . ./conftest.sh
+    rm -f ./conftest.sh
+    acl_cv_rpath=done
+  ])
+  wl="$acl_cv_wl"
+  libext="$acl_cv_libext"
+  shlibext="$acl_cv_shlibext"
+  hardcode_libdir_flag_spec="$acl_cv_hardcode_libdir_flag_spec"
+  hardcode_libdir_separator="$acl_cv_hardcode_libdir_separator"
+  hardcode_direct="$acl_cv_hardcode_direct"
+  hardcode_minus_L="$acl_cv_hardcode_minus_L"
+  sys_lib_search_path_spec="$acl_cv_sys_lib_search_path_spec"
+  sys_lib_dlsearch_path_spec="$acl_cv_sys_lib_dlsearch_path_spec"
+  dnl Determine whether the user wants rpath handling at all.
+  AC_ARG_ENABLE(rpath,
+    [  --disable-rpath         do not hardcode runtime library paths],
+    :, enable_rpath=yes)
+])
+
+dnl AC_LIB_LINKFLAGS_BODY(name [, dependencies]) searches for libname and
+dnl the libraries corresponding to explicit and implicit dependencies.
+dnl Sets the LIB${NAME}, LTLIB${NAME} and INC${NAME} variables.
+AC_DEFUN([AC_LIB_LINKFLAGS_BODY],
+[
+  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],
+                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])
+  dnl By default, look in $includedir and $libdir.
+  use_additional=yes
+  AC_LIB_WITH_FINAL_PREFIX([
+    eval additional_includedir=\"$includedir\"
+    eval additional_libdir=\"$libdir\"
+  ])
+  AC_ARG_WITH([lib$1-prefix],
+[  --with-lib$1-prefix[=DIR]  search for lib$1 in DIR/include and DIR/lib
+  --without-lib$1-prefix     don't search for lib$1 in includedir and libdir],
+[
+    if test "X$withval" = "Xno"; then
+      use_additional=no
+    else
+      if test "X$withval" = "X"; then
+        AC_LIB_WITH_FINAL_PREFIX([
+          eval additional_includedir=\"$includedir\"
+          eval additional_libdir=\"$libdir\"
+        ])
+      else
+        additional_includedir="$withval/include"
+        additional_libdir="$withval/lib"
+      fi
+    fi
+])
+  dnl Search the library and its dependencies in $additional_libdir and
+  dnl $LDFLAGS. Using breadth-first-seach.
+  LIB[]NAME=
+  LTLIB[]NAME=
+  INC[]NAME=
+  rpathdirs=
+  ltrpathdirs=
+  names_already_handled=
+  names_next_round='$1 $2'
+  while test -n "$names_next_round"; do
+    names_this_round="$names_next_round"
+    names_next_round=
+    for name in $names_this_round; do
+      already_handled=
+      for n in $names_already_handled; do
+        if test "$n" = "$name"; then
+          already_handled=yes
+          break
+        fi
+      done
+      if test -z "$already_handled"; then
+        names_already_handled="$names_already_handled $name"
+        dnl See if it was already located by an earlier AC_LIB_LINKFLAGS
+        dnl or AC_LIB_HAVE_LINKFLAGS call.
+        uppername=`echo "$name" | sed -e 'y|abcdefghijklmnopqrstuvwxyz./-|ABCDEFGHIJKLMNOPQRSTUVWXYZ___|'`
+        eval value=\"\$HAVE_LIB$uppername\"
+        if test -n "$value"; then
+          if test "$value" = yes; then
+            eval value=\"\$LIB$uppername\"
+            test -z "$value" || LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$value"
+            eval value=\"\$LTLIB$uppername\"
+            test -z "$value" || LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }$value"
+          else
+            dnl An earlier call to AC_LIB_HAVE_LINKFLAGS has determined
+            dnl that this library doesn't exist. So just drop it.
+            :
+          fi
+        else
+          dnl Search the library lib$name in $additional_libdir and $LDFLAGS
+          dnl and the already constructed $LIBNAME/$LTLIBNAME.
+          found_dir=
+          found_la=
+          found_so=
+          found_a=
+          if test $use_additional = yes; then
+            if test -n "$shlibext" && test -f "$additional_libdir/lib$name.$shlibext"; then
+              found_dir="$additional_libdir"
+              found_so="$additional_libdir/lib$name.$shlibext"
+              if test -f "$additional_libdir/lib$name.la"; then
+                found_la="$additional_libdir/lib$name.la"
+              fi
+            else
+              if test -f "$additional_libdir/lib$name.$libext"; then
+                found_dir="$additional_libdir"
+                found_a="$additional_libdir/lib$name.$libext"
+                if test -f "$additional_libdir/lib$name.la"; then
+                  found_la="$additional_libdir/lib$name.la"
+                fi
+              fi
+            fi
+          fi
+          if test "X$found_dir" = "X"; then
+            for x in $LDFLAGS $LTLIB[]NAME; do
+              AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+              case "$x" in
+                -L*)
+                  dir=`echo "X$x" | sed -e 's/^X-L//'`
+                  if test -n "$shlibext" && test -f "$dir/lib$name.$shlibext"; then
+                    found_dir="$dir"
+                    found_so="$dir/lib$name.$shlibext"
+                    if test -f "$dir/lib$name.la"; then
+                      found_la="$dir/lib$name.la"
+                    fi
+                  else
+                    if test -f "$dir/lib$name.$libext"; then
+                      found_dir="$dir"
+                      found_a="$dir/lib$name.$libext"
+                      if test -f "$dir/lib$name.la"; then
+                        found_la="$dir/lib$name.la"
+                      fi
+                    fi
+                  fi
+                  ;;
+              esac
+              if test "X$found_dir" != "X"; then
+                break
+              fi
+            done
+          fi
+          if test "X$found_dir" != "X"; then
+            dnl Found the library.
+            LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$found_dir -l$name"
+            if test "X$found_so" != "X"; then
+              dnl Linking with a shared library. We attempt to hardcode its
+              dnl directory into the executable's runpath, unless it's the
+              dnl standard /usr/lib.
+              if test "$enable_rpath" = no || test "X$found_dir" = "X/usr/lib"; then
+                dnl No hardcoding is needed.
+                LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+              else
+                dnl Use an explicit option to hardcode DIR into the resulting
+                dnl binary.
+                dnl Potentially add DIR to ltrpathdirs.
+                dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.
+                haveit=
+                for x in $ltrpathdirs; do
+                  if test "X$x" = "X$found_dir"; then
+                    haveit=yes
+                    break
+                  fi
+                done
+                if test -z "$haveit"; then
+                  ltrpathdirs="$ltrpathdirs $found_dir"
+                fi
+                dnl The hardcoding into $LIBNAME is system dependent.
+                if test "$hardcode_direct" = yes; then
+                  dnl Using DIR/libNAME.so during linking hardcodes DIR into the
+                  dnl resulting binary.
+                  LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+                else
+                  if test -n "$hardcode_libdir_flag_spec" && test "$hardcode_minus_L" = no; then
+                    dnl Use an explicit option to hardcode DIR into the resulting
+                    dnl binary.
+                    LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+                    dnl Potentially add DIR to rpathdirs.
+                    dnl The rpathdirs will be appended to $LIBNAME at the end.
+                    haveit=
+                    for x in $rpathdirs; do
+                      if test "X$x" = "X$found_dir"; then
+                        haveit=yes
+                        break
+                      fi
+                    done
+                    if test -z "$haveit"; then
+                      rpathdirs="$rpathdirs $found_dir"
+                    fi
+                  else
+                    dnl Rely on "-L$found_dir".
+                    dnl But don't add it if it's already contained in the LDFLAGS
+                    dnl or the already constructed $LIBNAME
+                    haveit=
+                    for x in $LDFLAGS $LIB[]NAME; do
+                      AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                      if test "X$x" = "X-L$found_dir"; then
+                        haveit=yes
+                        break
+                      fi
+                    done
+                    if test -z "$haveit"; then
+                      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir"
+                    fi
+                    if test "$hardcode_minus_L" != no; then
+                      dnl FIXME: Not sure whether we should use
+                      dnl "-L$found_dir -l$name" or "-L$found_dir $found_so"
+                      dnl here.
+                      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+                    else
+                      dnl We cannot use $hardcode_runpath_var and LD_RUN_PATH
+                      dnl here, because this doesn't fit in flags passed to the
+                      dnl compiler. So give up. No hardcoding. This affects only
+                      dnl very old systems.
+                      dnl FIXME: Not sure whether we should use
+                      dnl "-L$found_dir -l$name" or "-L$found_dir $found_so"
+                      dnl here.
+                      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-l$name"
+                    fi
+                  fi
+                fi
+              fi
+            else
+              if test "X$found_a" != "X"; then
+                dnl Linking with a static library.
+                LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_a"
+              else
+                dnl We shouldn't come here, but anyway it's good to have a
+                dnl fallback.
+                LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir -l$name"
+              fi
+            fi
+            dnl Assume the include files are nearby.
+            additional_includedir=
+            case "$found_dir" in
+              */lib | */lib/)
+                basedir=`echo "X$found_dir" | sed -e 's,^X,,' -e 's,/lib/*$,,'`
+                additional_includedir="$basedir/include"
+                ;;
+            esac
+            if test "X$additional_includedir" != "X"; then
+              dnl Potentially add $additional_includedir to $INCNAME.
+              dnl But don't add it
+              dnl   1. if it's the standard /usr/include,
+              dnl   2. if it's /usr/local/include and we are using GCC on Linux,
+              dnl   3. if it's already present in $CPPFLAGS or the already
+              dnl      constructed $INCNAME,
+              dnl   4. if it doesn't exist as a directory.
+              if test "X$additional_includedir" != "X/usr/include"; then
+                haveit=
+                if test "X$additional_includedir" = "X/usr/local/include"; then
+                  if test -n "$GCC"; then
+                    case $host_os in
+                      linux*) haveit=yes;;
+                    esac
+                  fi
+                fi
+                if test -z "$haveit"; then
+                  for x in $CPPFLAGS $INC[]NAME; do
+                    AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                    if test "X$x" = "X-I$additional_includedir"; then
+                      haveit=yes
+                      break
+                    fi
+                  done
+                  if test -z "$haveit"; then
+                    if test -d "$additional_includedir"; then
+                      dnl Really add $additional_includedir to $INCNAME.
+                      INC[]NAME="${INC[]NAME}${INC[]NAME:+ }-I$additional_includedir"
+                    fi
+                  fi
+                fi
+              fi
+            fi
+            dnl Look for dependencies.
+            if test -n "$found_la"; then
+              dnl Read the .la file. It defines the variables
+              dnl dlname, library_names, old_library, dependency_libs, current,
+              dnl age, revision, installed, dlopen, dlpreopen, libdir.
+              save_libdir="$libdir"
+              case "$found_la" in
+                */* | *\\*) . "$found_la" ;;
+                *) . "./$found_la" ;;
+              esac
+              libdir="$save_libdir"
+              dnl We use only dependency_libs.
+              for dep in $dependency_libs; do
+                case "$dep" in
+                  -L*)
+                    additional_libdir=`echo "X$dep" | sed -e 's/^X-L//'`
+                    dnl Potentially add $additional_libdir to $LIBNAME and $LTLIBNAME.
+                    dnl But don't add it
+                    dnl   1. if it's the standard /usr/lib,
+                    dnl   2. if it's /usr/local/lib and we are using GCC on Linux,
+                    dnl   3. if it's already present in $LDFLAGS or the already
+                    dnl      constructed $LIBNAME,
+                    dnl   4. if it doesn't exist as a directory.
+                    if test "X$additional_libdir" != "X/usr/lib"; then
+                      haveit=
+                      if test "X$additional_libdir" = "X/usr/local/lib"; then
+                        if test -n "$GCC"; then
+                          case $host_os in
+                            linux*) haveit=yes;;
+                          esac
+                        fi
+                      fi
+                      if test -z "$haveit"; then
+                        haveit=
+                        for x in $LDFLAGS $LIB[]NAME; do
+                          AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                          if test "X$x" = "X-L$additional_libdir"; then
+                            haveit=yes
+                            break
+                          fi
+                        done
+                        if test -z "$haveit"; then
+                          if test -d "$additional_libdir"; then
+                            dnl Really add $additional_libdir to $LIBNAME.
+                            LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-L$additional_libdir"
+                          fi
+                        fi
+                        haveit=
+                        for x in $LDFLAGS $LTLIB[]NAME; do
+                          AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                          if test "X$x" = "X-L$additional_libdir"; then
+                            haveit=yes
+                            break
+                          fi
+                        done
+                        if test -z "$haveit"; then
+                          if test -d "$additional_libdir"; then
+                            dnl Really add $additional_libdir to $LTLIBNAME.
+                            LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$additional_libdir"
+                          fi
+                        fi
+                      fi
+                    fi
+                    ;;
+                  -R*)
+                    dir=`echo "X$dep" | sed -e 's/^X-R//'`
+                    if test "$enable_rpath" != no; then
+                      dnl Potentially add DIR to rpathdirs.
+                      dnl The rpathdirs will be appended to $LIBNAME at the end.
+                      haveit=
+                      for x in $rpathdirs; do
+                        if test "X$x" = "X$dir"; then
+                          haveit=yes
+                          break
+                        fi
+                      done
+                      if test -z "$haveit"; then
+                        rpathdirs="$rpathdirs $dir"
+                      fi
+                      dnl Potentially add DIR to ltrpathdirs.
+                      dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.
+                      haveit=
+                      for x in $ltrpathdirs; do
+                        if test "X$x" = "X$dir"; then
+                          haveit=yes
+                          break
+                        fi
+                      done
+                      if test -z "$haveit"; then
+                        ltrpathdirs="$ltrpathdirs $dir"
+                      fi
+                    fi
+                    ;;
+                  -l*)
+                    dnl Handle this in the next round.
+                    names_next_round="$names_next_round "`echo "X$dep" | sed -e 's/^X-l//'`
+                    ;;
+                  *.la)
+                    dnl Handle this in the next round. Throw away the .la's
+                    dnl directory; it is already contained in a preceding -L
+                    dnl option.
+                    names_next_round="$names_next_round "`echo "X$dep" | sed -e 's,^X.*/,,' -e 's,^lib,,' -e 's,\.la$,,'`
+                    ;;
+                  *)
+                    dnl Most likely an immediate library name.
+                    LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$dep"
+                    LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }$dep"
+                    ;;
+                esac
+              done
+            fi
+          else
+            dnl Didn't find the library; assume it is in the system directories
+            dnl known to the linker and runtime loader. (All the system
+            dnl directories known to the linker should also be known to the
+            dnl runtime loader, otherwise the system is severely misconfigured.)
+            LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-l$name"
+            LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-l$name"
+          fi
+        fi
+      fi
+    done
+  done
+  if test "X$rpathdirs" != "X"; then
+    if test -n "$hardcode_libdir_separator"; then
+      dnl Weird platform: only the last -rpath option counts, the user must
+      dnl pass all path elements in one option. We can arrange that for a
+      dnl single library, but not when more than one $LIBNAMEs are used.
+      alldirs=
+      for found_dir in $rpathdirs; do
+        alldirs="${alldirs}${alldirs:+$hardcode_libdir_separator}$found_dir"
+      done
+      dnl Note: hardcode_libdir_flag_spec uses $libdir and $wl.
+      acl_save_libdir="$libdir"
+      libdir="$alldirs"
+      eval flag=\"$hardcode_libdir_flag_spec\"
+      libdir="$acl_save_libdir"
+      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$flag"
+    else
+      dnl The -rpath options are cumulative.
+      for found_dir in $rpathdirs; do
+        acl_save_libdir="$libdir"
+        libdir="$found_dir"
+        eval flag=\"$hardcode_libdir_flag_spec\"
+        libdir="$acl_save_libdir"
+        LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$flag"
+      done
+    fi
+  fi
+  if test "X$ltrpathdirs" != "X"; then
+    dnl When using libtool, the option that works for both libraries and
+    dnl executables is -R. The -R options are cumulative.
+    for found_dir in $ltrpathdirs; do
+      LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-R$found_dir"
+    done
+  fi
+])
+
+dnl AC_LIB_APPENDTOVAR(VAR, CONTENTS) appends the elements of CONTENTS to VAR,
+dnl unless already present in VAR.
+dnl Works only for CPPFLAGS, not for LIB* variables because that sometimes
+dnl contains two or three consecutive elements that belong together.
+AC_DEFUN([AC_LIB_APPENDTOVAR],
+[
+  for element in [$2]; do
+    haveit=
+    for x in $[$1]; do
+      AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+      if test "X$x" = "X$element"; then
+        haveit=yes
+        break
+      fi
+    done
+    if test -z "$haveit"; then
+      [$1]="${[$1]}${[$1]:+ }$element"
+    fi
+  done
+])
+
+# lib-ld.m4 serial 1 (gettext-0.11)
+dnl Copyright (C) 1996-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl Subroutines of libtool.m4,
+dnl with replacements s/AC_/AC_LIB/ and s/lt_cv/acl_cv/ to avoid collision
+dnl with libtool.m4.
+
+dnl From libtool-1.4. Sets the variable with_gnu_ld to yes or no.
+AC_DEFUN([AC_LIB_PROG_LD_GNU],
+[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], acl_cv_prog_gnu_ld,
+[# I'd rather use --version here, but apparently some GNU ld's only accept -v.
+if $LD -v 2>&1 </dev/null | egrep '(GNU|with BFD)' 1>&5; then
+  acl_cv_prog_gnu_ld=yes
+else
+  acl_cv_prog_gnu_ld=no
+fi])
+with_gnu_ld=$acl_cv_prog_gnu_ld
+])
+
+dnl From libtool-1.4. Sets the variable LD.
+AC_DEFUN([AC_LIB_PROG_LD],
+[AC_ARG_WITH(gnu-ld,
+[  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]],
+test "$withval" = no || with_gnu_ld=yes, with_gnu_ld=no)
+AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([AC_CANONICAL_HOST])dnl
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  AC_MSG_CHECKING([for ld used by GCC])
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [[\\/]* | [A-Za-z]:[\\/]*)]
+      [re_direlt='/[^/][^/]*/\.\./']
+      # Canonicalize the path of ld
+      ac_prog=`echo $ac_prog| sed 's%\\\\%/%g'`
+      while echo $ac_prog | grep "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`echo $ac_prog| sed "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  AC_MSG_CHECKING([for GNU ld])
+else
+  AC_MSG_CHECKING([for non-GNU ld])
+fi
+AC_CACHE_VAL(acl_cv_path_LD,
+[if test -z "$LD"; then
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}${PATH_SEPARATOR-:}"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      acl_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some GNU ld's only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      if "$acl_cv_path_LD" -v 2>&1 < /dev/null | egrep '(GNU|with BFD)' > /dev/null; then
+	test "$with_gnu_ld" != no && break
+      else
+	test "$with_gnu_ld" != yes && break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+else
+  acl_cv_path_LD="$LD" # Let the user override the test with a path.
+fi])
+LD="$acl_cv_path_LD"
+if test -n "$LD"; then
+  AC_MSG_RESULT($LD)
+else
+  AC_MSG_RESULT(no)
+fi
+test -z "$LD" && AC_MSG_ERROR([no acceptable ld found in \$PATH])
+AC_LIB_PROG_LD_GNU
+])
+
+# iconv.m4 serial AM4 (gettext-0.11.3)
+dnl Copyright (C) 2000-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Bruno Haible.
+
+AC_DEFUN([AM_ICONV_LINKFLAGS_BODY],
+[
+  dnl Prerequisites of AC_LIB_LINKFLAGS_BODY.
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+
+  dnl Search for libiconv and define LIBICONV, LTLIBICONV and INCICONV
+  dnl accordingly.
+  AC_LIB_LINKFLAGS_BODY([iconv])
+])
+
+AC_DEFUN([AM_ICONV_LINK],
+[
+  dnl Some systems have iconv in libc, some have it in libiconv (OSF/1 and
+  dnl those with the standalone portable GNU libiconv installed).
+
+  dnl Search for libiconv and define LIBICONV, LTLIBICONV and INCICONV
+  dnl accordingly.
+  AC_REQUIRE([AM_ICONV_LINKFLAGS_BODY])
+
+  dnl Add $INCICONV to CPPFLAGS before performing the following checks,
+  dnl because if the user has installed libiconv and not disabled its use
+  dnl via --without-libiconv-prefix, he wants to use it. The first
+  dnl AC_TRY_LINK will then fail, the second AC_TRY_LINK will succeed.
+  am_save_CPPFLAGS="$CPPFLAGS"
+  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INCICONV])
+
+  AC_CACHE_CHECK(for iconv, am_cv_func_iconv, [
+    am_cv_func_iconv="no, consider installing GNU libiconv"
+    am_cv_lib_iconv=no
+    AC_TRY_LINK([#include <stdlib.h>
+#include <iconv.h>],
+      [iconv_t cd = iconv_open("","");
+       iconv(cd,NULL,NULL,NULL,NULL);
+       iconv_close(cd);],
+      am_cv_func_iconv=yes)
+    if test "$am_cv_func_iconv" != yes; then
+      am_save_LIBS="$LIBS"
+      LIBS="$LIBS $LIBICONV"
+      AC_TRY_LINK([#include <stdlib.h>
+#include <iconv.h>],
+        [iconv_t cd = iconv_open("","");
+         iconv(cd,NULL,NULL,NULL,NULL);
+         iconv_close(cd);],
+        am_cv_lib_iconv=yes
+        am_cv_func_iconv=yes)
+      LIBS="$am_save_LIBS"
+    fi
+  ])
+  if test "$am_cv_func_iconv" = yes; then
+    AC_DEFINE(HAVE_ICONV, 1, [Define if you have the iconv() function.])
+  fi
+  if test "$am_cv_lib_iconv" = yes; then
+    AC_MSG_CHECKING([how to link with libiconv])
+    AC_MSG_RESULT([$LIBICONV])
+  else
+    dnl If $LIBICONV didn't lead to a usable library, we don't need $INCICONV
+    dnl either.
+    CPPFLAGS="$am_save_CPPFLAGS"
+    LIBICONV=
+    LTLIBICONV=
+  fi
+  AC_SUBST(LIBICONV)
+  AC_SUBST(LTLIBICONV)
+])
+
+AC_DEFUN([AM_ICONV],
+[
+  AM_ICONV_LINK
+  if test "$am_cv_func_iconv" = yes; then
+    AC_MSG_CHECKING([for iconv declaration])
+    AC_CACHE_VAL(am_cv_proto_iconv, [
+      AC_TRY_COMPILE([
+#include <stdlib.h>
+#include <iconv.h>
+extern
+#ifdef __cplusplus
+"C"
+#endif
+#if defined(__STDC__) || defined(__cplusplus)
+size_t iconv (iconv_t cd, char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);
+#else
+size_t iconv();
+#endif
+], [], am_cv_proto_iconv_arg1="", am_cv_proto_iconv_arg1="const")
+      am_cv_proto_iconv="extern size_t iconv (iconv_t cd, $am_cv_proto_iconv_arg1 char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);"])
+    am_cv_proto_iconv=`echo "[$]am_cv_proto_iconv" | tr -s ' ' | sed -e 's/( /(/'`
+    AC_MSG_RESULT([$]{ac_t:-
+         }[$]am_cv_proto_iconv)
+    AC_DEFINE_UNQUOTED(ICONV_CONST, $am_cv_proto_iconv_arg1,
+      [Define as const if the declaration of iconv() needs const.])
+  fi
+])
+
+# progtest.m4 serial 2 (gettext-0.10.40)
+dnl Copyright (C) 1996-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+dnl
+dnl This file can can be used in projects which are not available under
+dnl the GNU General Public License or the GNU Library General Public
+dnl License but which still want to provide support for the GNU gettext
+dnl functionality.
+dnl Please note that the actual code of the GNU gettext library is covered
+dnl by the GNU Library General Public License, and the rest of the GNU
+dnl gettext package package is covered by the GNU General Public License.
+dnl They are *not* in the public domain.
+
+dnl Authors:
+dnl   Ulrich Drepper <drepper@cygnus.com>, 1996.
+
+# Search path for a program which passes the given test.
+
+dnl AM_PATH_PROG_WITH_TEST(VARIABLE, PROG-TO-CHECK-FOR,
+dnl   TEST-PERFORMED-ON-FOUND_PROGRAM [, VALUE-IF-NOT-FOUND [, PATH]])
+AC_DEFUN([AM_PATH_PROG_WITH_TEST],
+[# Extract the first word of "$2", so it can be a program name with args.
+set dummy $2; ac_word=[$]2
+AC_MSG_CHECKING([for $ac_word])
+AC_CACHE_VAL(ac_cv_path_$1,
+[case "[$]$1" in
+  /*)
+  ac_cv_path_$1="[$]$1" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in ifelse([$5], , $PATH, [$5]); do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if [$3]; then
+	ac_cv_path_$1="$ac_dir/$ac_word"
+	break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+dnl If no 4th arg is given, leave the cache variable unset,
+dnl so AC_PATH_PROGS will keep looking.
+ifelse([$4], , , [  test -z "[$]ac_cv_path_$1" && ac_cv_path_$1="$4"
+])dnl
+  ;;
+esac])dnl
+$1="$ac_cv_path_$1"
+if test ifelse([$4], , [-n "[$]$1"], ["[$]$1" != "$4"]); then
+  AC_MSG_RESULT([$]$1)
+else
+  AC_MSG_RESULT(no)
+fi
+AC_SUBST($1)dnl
+])
+
+# isc-posix.m4 serial 2 (gettext-0.11.2)
+dnl Copyright (C) 1995-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+# This file is not needed with autoconf-2.53 and newer.  Remove it in 2005.
+
+# This test replaces the one in autoconf.
+# Currently this macro should have the same name as the autoconf macro
+# because gettext's gettext.m4 (distributed in the automake package)
+# still uses it.  Otherwise, the use in gettext.m4 makes autoheader
+# give these diagnostics:
+#   configure.in:556: AC_TRY_COMPILE was called before AC_ISC_POSIX
+#   configure.in:556: AC_TRY_RUN was called before AC_ISC_POSIX
+
+undefine([AC_ISC_POSIX])
+
+AC_DEFUN([AC_ISC_POSIX],
+  [
+    dnl This test replaces the obsolescent AC_ISC_POSIX kludge.
+    AC_CHECK_LIB(cposix, strerror, [LIBS="$LIBS -lcposix"])
+  ]
+)
+
+# glibc21.m4 serial 2 (fileutils-4.1.3, gettext-0.10.40)
+dnl Copyright (C) 2000-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+# Test for the GNU C Library, version 2.1 or newer.
+# From Bruno Haible.
+
+AC_DEFUN([jm_GLIBC21],
+  [
+    AC_CACHE_CHECK(whether we are using the GNU C Library 2.1 or newer,
+      ac_cv_gnu_library_2_1,
+      [AC_EGREP_CPP([Lucky GNU user],
+	[
+#include <features.h>
+#ifdef __GNU_LIBRARY__
+ #if (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 1) || (__GLIBC__ > 2)
+  Lucky GNU user
+ #endif
+#endif
+	],
+	ac_cv_gnu_library_2_1=yes,
+	ac_cv_gnu_library_2_1=no)
+      ]
+    )
+    AC_SUBST(GLIBC21)
+    GLIBC21="$ac_cv_gnu_library_2_1"
+  ]
+)
+
+# intdiv0.m4 serial 1 (gettext-0.11.3)
+dnl Copyright (C) 2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Bruno Haible.
+
+AC_DEFUN([gt_INTDIV0],
+[
+  AC_REQUIRE([AC_PROG_CC])dnl
+  AC_REQUIRE([AC_CANONICAL_HOST])dnl
+
+  AC_CACHE_CHECK([whether integer division by zero raises SIGFPE],
+    gt_cv_int_divbyzero_sigfpe,
+    [
+      AC_TRY_RUN([
+#include <stdlib.h>
+#include <signal.h>
+
+static void
+#ifdef __cplusplus
+sigfpe_handler (int sig)
+#else
+sigfpe_handler (sig) int sig;
+#endif
+{
+  /* Exit with code 0 if SIGFPE, with code 1 if any other signal.  */
+  exit (sig != SIGFPE);
+}
+
+int x = 1;
+int y = 0;
+int z;
+int nan;
+
+int main ()
+{
+  signal (SIGFPE, sigfpe_handler);
+/* IRIX and AIX (when "xlc -qcheck" is used) yield signal SIGTRAP.  */
+#if (defined (__sgi) || defined (_AIX)) && defined (SIGTRAP)
+  signal (SIGTRAP, sigfpe_handler);
+#endif
+/* Linux/SPARC yields signal SIGILL.  */
+#if defined (__sparc__) && defined (__linux__)
+  signal (SIGILL, sigfpe_handler);
+#endif
+
+  z = x / y;
+  nan = y / y;
+  exit (1);
+}
+], gt_cv_int_divbyzero_sigfpe=yes, gt_cv_int_divbyzero_sigfpe=no,
+        [
+          # Guess based on the CPU.
+          case "$host_cpu" in
+            alpha* | i[34567]86 | m68k | s390*)
+              gt_cv_int_divbyzero_sigfpe="guessing yes";;
+            *)
+              gt_cv_int_divbyzero_sigfpe="guessing no";;
+          esac
+        ])
+    ])
+  case "$gt_cv_int_divbyzero_sigfpe" in
+    *yes) value=1;;
+    *) value=0;;
+  esac
+  AC_DEFINE_UNQUOTED(INTDIV0_RAISES_SIGFPE, $value,
+    [Define if integer division by zero raises signal SIGFPE.])
+])
+
+# uintmax_t.m4 serial 6 (gettext-0.11)
+dnl Copyright (C) 1997-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Paul Eggert.
+
+AC_PREREQ(2.13)
+
+# Define uintmax_t to `unsigned long' or `unsigned long long'
+# if <inttypes.h> does not exist.
+
+AC_DEFUN([jm_AC_TYPE_UINTMAX_T],
+[
+  AC_REQUIRE([jm_AC_HEADER_INTTYPES_H])
+  AC_REQUIRE([jm_AC_HEADER_STDINT_H])
+  if test $jm_ac_cv_header_inttypes_h = no && test $jm_ac_cv_header_stdint_h = no; then
+    AC_REQUIRE([jm_AC_TYPE_UNSIGNED_LONG_LONG])
+    test $ac_cv_type_unsigned_long_long = yes \
+      && ac_type='unsigned long long' \
+      || ac_type='unsigned long'
+    AC_DEFINE_UNQUOTED(uintmax_t, $ac_type,
+  [Define to unsigned long or unsigned long long
+   if <inttypes.h> and <stdint.h> don't define.])
+  fi
+])
+
+# inttypes_h.m4 serial 4 (gettext-0.11.4)
+dnl Copyright (C) 1997-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Paul Eggert.
+
+# Define HAVE_INTTYPES_H_WITH_UINTMAX if <inttypes.h> exists,
+# doesn't clash with <sys/types.h>, and declares uintmax_t.
+
+AC_DEFUN([jm_AC_HEADER_INTTYPES_H],
+[
+  AC_CACHE_CHECK([for inttypes.h], jm_ac_cv_header_inttypes_h,
+  [AC_TRY_COMPILE(
+    [#include <sys/types.h>
+#include <inttypes.h>],
+    [uintmax_t i = (uintmax_t) -1;],
+    jm_ac_cv_header_inttypes_h=yes,
+    jm_ac_cv_header_inttypes_h=no)])
+  if test $jm_ac_cv_header_inttypes_h = yes; then
+    AC_DEFINE_UNQUOTED(HAVE_INTTYPES_H_WITH_UINTMAX, 1,
+[Define if <inttypes.h> exists, doesn't clash with <sys/types.h>,
+   and declares uintmax_t. ])
+  fi
+])
+
+# stdint_h.m4 serial 2 (gettext-0.11.4)
+dnl Copyright (C) 1997-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Paul Eggert.
+
+# Define HAVE_STDINT_H_WITH_UINTMAX if <stdint.h> exists,
+# doesn't clash with <sys/types.h>, and declares uintmax_t.
+
+AC_DEFUN([jm_AC_HEADER_STDINT_H],
+[
+  AC_CACHE_CHECK([for stdint.h], jm_ac_cv_header_stdint_h,
+  [AC_TRY_COMPILE(
+    [#include <sys/types.h>
+#include <stdint.h>],
+    [uintmax_t i = (uintmax_t) -1;],
+    jm_ac_cv_header_stdint_h=yes,
+    jm_ac_cv_header_stdint_h=no)])
+  if test $jm_ac_cv_header_stdint_h = yes; then
+    AC_DEFINE_UNQUOTED(HAVE_STDINT_H_WITH_UINTMAX, 1,
+[Define if <stdint.h> exists, doesn't clash with <sys/types.h>,
+   and declares uintmax_t. ])
+  fi
+])
+
+# ulonglong.m4 serial 2 (fileutils-4.0.32, gettext-0.10.40)
+dnl Copyright (C) 1999-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Paul Eggert.
+
+AC_DEFUN([jm_AC_TYPE_UNSIGNED_LONG_LONG],
+[
+  AC_CACHE_CHECK([for unsigned long long], ac_cv_type_unsigned_long_long,
+  [AC_TRY_LINK([unsigned long long ull = 1; int i = 63;],
+    [unsigned long long ullmax = (unsigned long long) -1;
+     return ull << i | ull >> i | ullmax / ull | ullmax % ull;],
+    ac_cv_type_unsigned_long_long=yes,
+    ac_cv_type_unsigned_long_long=no)])
+  if test $ac_cv_type_unsigned_long_long = yes; then
+    AC_DEFINE(HAVE_UNSIGNED_LONG_LONG, 1,
+      [Define if you have the unsigned long long type.])
+  fi
+])
+
+# inttypes.m4 serial 1 (gettext-0.11.4)
+dnl Copyright (C) 1997-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Paul Eggert.
+
+# Define HAVE_INTTYPES_H if <inttypes.h> exists and doesn't clash with
+# <sys/types.h>.
+
+AC_DEFUN([gt_HEADER_INTTYPES_H],
+[
+  AC_CACHE_CHECK([for inttypes.h], gt_cv_header_inttypes_h,
+  [
+    AC_TRY_COMPILE(
+      [#include <sys/types.h>
+#include <inttypes.h>],
+      [], gt_cv_header_inttypes_h=yes, gt_cv_header_inttypes_h=no)
+  ])
+  if test $gt_cv_header_inttypes_h = yes; then
+    AC_DEFINE_UNQUOTED(HAVE_INTTYPES_H, 1,
+      [Define if <inttypes.h> exists and doesn't clash with <sys/types.h>.])
+  fi
+])
+
+# inttypes-pri.m4 serial 1 (gettext-0.11.4)
+dnl Copyright (C) 1997-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Bruno Haible.
+
+# Define PRI_MACROS_BROKEN if <inttypes.h> exists and defines the PRI*
+# macros to non-string values.  This is the case on AIX 4.3.3.
+
+AC_DEFUN([gt_INTTYPES_PRI],
+[
+  AC_REQUIRE([gt_HEADER_INTTYPES_H])
+  if test $gt_cv_header_inttypes_h = yes; then
+    AC_CACHE_CHECK([whether the inttypes.h PRIxNN macros are broken],
+      gt_cv_inttypes_pri_broken,
+      [
+        AC_TRY_COMPILE([#include <inttypes.h>
+#ifdef PRId32
+char *p = PRId32;
+#endif
+], [], gt_cv_inttypes_pri_broken=no, gt_cv_inttypes_pri_broken=yes)
+      ])
+  fi
+  if test "$gt_cv_inttypes_pri_broken" = yes; then
+    AC_DEFINE_UNQUOTED(PRI_MACROS_BROKEN, 1,
+      [Define if <inttypes.h> exists and defines unusable PRI* macros.])
+  fi
+])
+
+# codeset.m4 serial AM1 (gettext-0.10.40)
+dnl Copyright (C) 2000-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Bruno Haible.
+
+AC_DEFUN([AM_LANGINFO_CODESET],
+[
+  AC_CACHE_CHECK([for nl_langinfo and CODESET], am_cv_langinfo_codeset,
+    [AC_TRY_LINK([#include <langinfo.h>],
+      [char* cs = nl_langinfo(CODESET);],
+      am_cv_langinfo_codeset=yes,
+      am_cv_langinfo_codeset=no)
+    ])
+  if test $am_cv_langinfo_codeset = yes; then
+    AC_DEFINE(HAVE_LANGINFO_CODESET, 1,
+      [Define if you have <langinfo.h> and nl_langinfo(CODESET).])
+  fi
+])
+
+# lcmessage.m4 serial 3 (gettext-0.11.3)
+dnl Copyright (C) 1995-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+dnl
+dnl This file can can be used in projects which are not available under
+dnl the GNU General Public License or the GNU Library General Public
+dnl License but which still want to provide support for the GNU gettext
+dnl functionality.
+dnl Please note that the actual code of the GNU gettext library is covered
+dnl by the GNU Library General Public License, and the rest of the GNU
+dnl gettext package package is covered by the GNU General Public License.
+dnl They are *not* in the public domain.
+
+dnl Authors:
+dnl   Ulrich Drepper <drepper@cygnus.com>, 1995.
+
+# Check whether LC_MESSAGES is available in <locale.h>.
+
+AC_DEFUN([AM_LC_MESSAGES],
+[
+  AC_CACHE_CHECK([for LC_MESSAGES], am_cv_val_LC_MESSAGES,
+    [AC_TRY_LINK([#include <locale.h>], [return LC_MESSAGES],
+       am_cv_val_LC_MESSAGES=yes, am_cv_val_LC_MESSAGES=no)])
+  if test $am_cv_val_LC_MESSAGES = yes; then
+    AC_DEFINE(HAVE_LC_MESSAGES, 1,
+      [Define if your <locale.h> file defines LC_MESSAGES.])
+  fi
+])
+
 # Configure paths for GLIB
 # Owen Taylor     97-11-3
 
diff -Nur dillo-0.8.0/AUTHORS dillo-0.8.0.new/AUTHORS
--- dillo-0.8.0/AUTHORS	2003-02-16 18:36:39.000000000 +0000
+++ dillo-0.8.0.new/AUTHORS	2004-10-13 01:13:29.000000000 +0000
@@ -35,6 +35,7 @@
           * Adam Sampson
           * Andreas Schweitzer
           * Dominic Wong 
+          * Kiyo
      _________________________________________________________________
    
    Web site logo:
diff -Nur dillo-0.8.0/autogen.sh dillo-0.8.0.new/autogen.sh
--- dillo-0.8.0/autogen.sh	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/autogen.sh	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,58 @@
+#!/bin/sh
+#
+# Script to generate configure&make stuff
+#
+
+#-----------------------------------------------------
+# If defined, get these programs from the environment
+#
+: ${ACLOCAL:=aclocal}
+: ${AUTOHEADER:=autoheader}
+: ${AUTOCONF:=autoconf}
+: ${AUTOMAKE:=automake}
+
+#-------------------------
+# Required binaries check
+#          
+check_bin_file(){
+   which $1 > /dev/null 2>&1
+   if [ $? = 0 ]; then
+      return 0
+   else
+      return 1
+   fi
+}
+
+#------
+# Main
+#
+clear
+ERR="no"
+for cmd in "$ACLOCAL" "$AUTOHEADER" "$AUTOCONF" "$AUTOMAKE"
+do
+   if check_bin_file "$cmd"
+   then
+      echo -e "$cmd   \tfound"
+   else
+      echo -e "$cmd   \tNOT found"
+      ERR="yes"
+   fi
+done
+
+if test $ERR = "yes"
+then
+   echo
+   echo "ERROR: to run this program you need the following installed"
+   echo "       $ACLOCAL $AUTOHEADER $AUTOCONF $AUTOMAKE"
+   echo
+   exit 1
+fi
+
+echo "[Checks passed]"
+echo "Generating..."
+
+"$ACLOCAL"
+"$AUTOHEADER"
+"$AUTOCONF"
+"$AUTOMAKE" -a -c
+
diff -Nur dillo-0.8.0/ChangeLog dillo-0.8.0.new/ChangeLog
--- dillo-0.8.0/ChangeLog	2004-02-03 19:21:18.000000000 +0000
+++ dillo-0.8.0.new/ChangeLog	2004-10-13 01:13:29.000000000 +0000
@@ -2,8 +2,10 @@
 Dillo project
 =============================================================================
 
-dillo-0.8.0 [??, 2003]
+dillo-0.8.0-i18n-misc [??, 2004]
 
+ - * Apply 0.8.0 Changes to dillo-0.7.3-i18n-misc
+   Patch: Kiyo
  - * Added a right-mouse-button popup for images!
    Patch: Frank de Lange, Eric Gaudet, Jorge Arellano
  - * Made main document window grab focus on startup, fullwindow,
@@ -135,9 +137,46 @@
  - * Added the "-geometry" switch to the CLI.
    Patch: Jorge Arellano, Jan Dittmer
 
+dillo-0.7.3-i18n-misc [Oct ??, 2003]
+
+ - * Xft support
+   * changed internal code that is processed by UTF-8
+   * charset automatic recognition support
+   * GUI setting tool
+   * Start-up URL specification support
+   * gzip compression transmission support
+   * SSL support
+   * BASIC authorization support
+   * Referer support
+   * User-Agent change support
+   * meta-refresh support(optional)
+   * "Character entity references" (like &#xnnnn;) support
+   * Gettextize
+   * multi byte char selection support
+   * Fixed scroll quantity
+   * Fixed tab, frame patch
+   * Change font setting code for i18n
+   * Add Search box
+   Patches: Kiyo(http://teki.jpn.ph/)
+   (These patches referred to --
+    Robert Thomson, Tor Andersson, Frank de lange, madis, Geoff Lane,
+    Lars Clausen, Jim Huang, Takubo, LJ)
 
 dillo-0.7.3 [Aug 03, 2003]
 
+ - * Implemented tabbed browsing, separated 'document' from 'interface' code
+     - Moved all document-specific code into DilloDoc (src/doc.c/h and
+       src/browser.h for definition of DilloDoc)
+     - Added tab browsing as an option (enabled by default, disable
+       with --disable-tabs configure option)
+   * Focus is on location bar on new empty window/tab
+   * Open new window on link-shift-click1, new tab on link-control-click1
+     - optionally open tab on link-click2 (pref tab_on_middle_click=YES)
+   * Implemented experimental frame and iframe support
+     - Added frame and iframe support as an option (enabled by default,
+       disable with --disable-frames configure option)
+     - Added support for named windows/frames (target= and name= parameters)
+   Patch: Frank de Lange
  - * Some more selection goodies:
      - Redesign of the selection state model, now the selection is preserved
        as long as possible.
diff -Nur dillo-0.8.0/config/dillocfg.c dillo-0.8.0.new/config/dillocfg.c
--- dillo-0.8.0/config/dillocfg.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/config/dillocfg.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,470 @@
+/*
+ * File: dillocfg-gtk.c
+ *
+ * Copyright (C) 2003 Kiyo <kiyo@teki.jpn.ph>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <locale.h>
+#include <gdk/gdkx.h>
+#include <gtk/gtk.h>
+
+#include "../config.h"
+#include "../src/intl.h"
+#include "dillocfg.h"
+#include "dillocfg_option.h"
+#include "dillocfg_token.h"
+
+static gboolean modified_ = FALSE;
+
+#define IS_LINE_END(c) (c  == '\0' || c == '#')
+#define SKIPSPACE(buf, i) while (!IS_LINE_END(buf[i]) && isspace(buf[i])) i++
+
+DillocfgWin *DillocfgWin_new();
+void DillocfgWin_init(DillocfgWin *d, gboolean use_default);
+void DillocfgWin_free(GtkWidget *widget, DillocfgWin *d);
+void DillocfgWin_callback_reset(GtkButton *button, gpointer user_data);
+void DillocfgWin_callback_reload(GtkButton *button, gpointer user_data);
+void DillocfgWin_callback_save(GtkButton *button, gpointer user_data);
+DillocfgInterface *DillocfgInterface_new(DillocfgWin *w, const gchar *label);
+DillocfgFont *DillocfgFont_new(DillocfgWin *w, const gchar *label);
+DillocfgColor *DillocfgColor_new(DillocfgWin *w, const gchar *label);
+DillocfgNetwork *DillocfgNetwork_new(DillocfgWin *w, const gchar *label);
+#ifndef DISABLE_TABS
+DillocfgTab *DillocfgTab_new(DillocfgWin *w, const gchar *label);
+#endif
+DillocfgOther *DillocfgOther_new(DillocfgWin *w, const gchar *label);
+DillocfgCookie *DillocfgCookie_new(DillocfgWin *w, const gchar *label);
+void ReadUserconfig(DillocfgWin *d);
+void WriteUserconfig(DillocfgWin *d);
+
+/****************************** M A I N ********************************/
+int main(int argc, char **argv) {
+   DillocfgWin *dialog;
+
+   /* set locale */
+   gtk_set_locale();
+   /* Initialize Gettext */
+   bindtextdomain (PACKAGE, LOCALEDIR);
+   textdomain (PACKAGE);
+   /* Initialize GUI and parse GTK related args */
+   gtk_init(&argc, &argv);
+   gdk_rgb_init();
+
+   dialog = DillocfgWin_new();
+   ReadUserconfig(dialog);
+
+   /* Start the GTK+ cycle */
+   gtk_main();
+
+   g_print("Dillocfg:normal exit\n");
+   gtk_exit (0);
+   return 0;
+}
+
+DillocfgWin *DillocfgWin_new() {
+   DillocfgWin *d           = g_new(DillocfgWin, 1);
+   GtkWidget *dialog_main   = gtk_window_new(GTK_WINDOW_TOPLEVEL);//DIALOG);
+   GtkWidget *vbox          = gtk_vbox_new(FALSE, 0);
+   GtkWidget *button_hbox   = gtk_hbox_new(FALSE, 0);
+   GtkWidget *button_reset  = gtk_button_new_with_label(_("Reset"));
+   GtkWidget *button_reload = gtk_button_new_with_label(_("Reload"));
+   GtkWidget *button_save   = gtk_button_new_with_label(_("Save"));
+   GtkWidget *button_quit   = gtk_button_new_with_label(_("Quit"));
+
+   gtk_window_set_title(GTK_WINDOW(dialog_main), _("Dillo Preferences"));
+   gtk_window_set_policy(GTK_WINDOW(dialog_main), TRUE, TRUE, FALSE);
+   gtk_signal_connect(GTK_OBJECT(dialog_main), "delete_event",
+         GTK_SIGNAL_FUNC(gtk_widget_destroy), d);
+   gtk_signal_connect(GTK_OBJECT(dialog_main), "destroy",
+         GTK_SIGNAL_FUNC(DillocfgWin_free), d);
+   gtk_window_set_wmclass(GTK_WINDOW(dialog_main), "dillocfg", _("Dillo Preferences"));
+   gtk_widget_set_usize(dialog_main, WIDTH, HEIGHT);
+
+   d->notebook              = gtk_notebook_new();
+   gtk_notebook_set_homogeneous_tabs(GTK_NOTEBOOK(d->notebook), FALSE);
+   gtk_container_add(GTK_CONTAINER(dialog_main), vbox);
+   gtk_container_add(GTK_CONTAINER(vbox), d->notebook);
+   gtk_signal_connect(GTK_OBJECT(button_reset), "clicked",
+         GTK_SIGNAL_FUNC(DillocfgWin_callback_reset), d);
+   gtk_signal_connect(GTK_OBJECT(button_reload), "clicked",
+         GTK_SIGNAL_FUNC(DillocfgWin_callback_reload), d);
+   gtk_signal_connect(GTK_OBJECT(button_save), "clicked",
+         GTK_SIGNAL_FUNC(DillocfgWin_callback_save), d);
+   gtk_signal_connect(GTK_OBJECT(button_quit), "clicked",
+         GTK_SIGNAL_FUNC(DillocfgWin_free), d);
+   gtk_box_set_spacing(GTK_BOX(button_hbox), 5);
+   gtk_container_add(GTK_CONTAINER(button_hbox), button_reset);
+   gtk_container_add(GTK_CONTAINER(button_hbox), button_reload);
+   gtk_container_add(GTK_CONTAINER(button_hbox), button_save);
+   gtk_container_add(GTK_CONTAINER(button_hbox), button_quit);
+   gtk_box_pack_end(GTK_BOX(vbox), button_hbox, FALSE, FALSE, 5);
+
+   d->list      = NULL;
+   d->interface = DillocfgInterface_new(d, _("Interface"));
+   d->font      = DillocfgFont_new(d, _("  Font  "));
+   d->color     = DillocfgColor_new(d, _("  Color "));
+   d->network   = DillocfgNetwork_new(d, _(" Network "));
+#ifndef DISABLE_TABS
+   d->tab       = DillocfgTab_new(d, _("   Tab   "));
+#endif
+   d->cookie    = NULL;//DillocfgCookie_new(d, _(" Cookie "));
+   d->other     = DillocfgOther_new(d, _("  Other  "));
+
+   gtk_widget_show_all(dialog_main);
+   return d;
+}
+
+void DillocfgWin_init(DillocfgWin *d, gboolean use_default) {
+   g_list_foreach(d->list, (GFunc)Option_init, (gpointer)use_default);
+}
+
+void DillocfgWin_free(GtkWidget *widget, DillocfgWin *d) {
+   g_list_foreach(d->list, (GFunc)Option_free, (gpointer)&d->list);
+   g_free(d->interface);
+   g_free(d->font);
+   g_free(d->color);
+   g_free(d->network);
+#ifndef DISABLE_TABS
+   g_free(d->tab);
+#endif
+   g_free(d->cookie);
+   g_free(d->other);
+   g_list_free(d->list);
+   g_free(d);
+   gtk_main_quit();
+}
+
+#ifndef DISABLE_TABS
+DillocfgTab *DillocfgTab_new(DillocfgWin *w, const gchar *label) {
+   DillocfgTab *t              = g_new(DillocfgTab, 1);
+   gint x, y;
+   GtkWidget *vbox             = gtk_vbox_new(FALSE, 0);
+   GtkWidget *table            = gtk_table_new(3, 2, FALSE);
+   GtkWidget *table2           = gtk_table_new(3, 1, FALSE);
+
+   gtk_table_set_homogeneous(GTK_TABLE(table), TRUE);
+   gtk_table_set_homogeneous(GTK_TABLE(table2), TRUE);
+   gtk_container_add(GTK_CONTAINER(vbox), table);
+   gtk_container_add(GTK_CONTAINER(vbox), table2);
+   x = 0; y = 0;
+   t->tab_bar_homogeneous      = Option_new(TOKEN_TAB_BAR_HOMOGENEOUS, &w->list, table, x, y++);
+   t->tab_bar_scroller         = Option_new(TOKEN_TAB_BAR_SCROLLER, &w->list, table, x, y++);
+   t->tab_bar_show_fullscreen  = Option_new(TOKEN_TAB_BAR_SHOW_FULLSCREEN, &w->list, table, x, y++);
+   t->tab_close_middle_click   = Option_new(TOKEN_TAB_CLOSE_MIDDLE_CLICK, &w->list, table, x, y++);
+   x++; y = 0;
+   t->tab_bar_show_single_tab  = Option_new(TOKEN_TAB_BAR_SHOW_SINGLE_TAB, &w->list, table, x, y++);
+   t->tab_instead_of_window    = Option_new(TOKEN_TAB_INSTEAD_OF_WINDOW, &w->list, table, x, y++);
+   t->tab_load_in_background   = Option_new(TOKEN_TAB_LOAD_IN_BACKGROUND, &w->list, table, x, y++);
+   x = 0; y = 0;
+   t->tab_title_compress
+      = Option_new(TOKEN_TAB_TITLE_COMPRESS, &w->list, table2, x, y++);
+   t->compress_vowels          = Option_new(TOKEN_COMPRESS_VOWELS, &w->list, table2, x, y++);
+   t->compress_common_prefixes = Option_new(TOKEN_COMPRESS_COMMON_PREFIXES, &w->list, table2, x, y++);
+   gtk_notebook_append_page(GTK_NOTEBOOK(w->notebook), vbox, gtk_label_new(label));
+   return t;
+}
+
+#endif
+
+DillocfgOther *DillocfgOther_new(DillocfgWin *w, const gchar *label) {
+   DillocfgOther *g    = g_new(DillocfgOther, 1);
+   gint x, y;
+   GtkWidget *vbox     = gtk_vbox_new(FALSE, 0);
+   GtkWidget *table    = gtk_table_new(9, 1, FALSE);
+
+   gtk_table_set_homogeneous(GTK_TABLE(table), TRUE);
+   gtk_container_add(GTK_CONTAINER(vbox), table);
+   x = 0; y = 0;
+   g->use_dicache      = Option_new(TOKEN_USE_DICACHE, &w->list, table, x, y++);
+   g->focus_location_on_new
+      = Option_new(TOKEN_FOCUS_LOCATION_ON_NEW, &w->list, table, x, y++);
+   g->enterpress_forces_submit
+      = Option_new(TOKEN_ENTERPRESS_FORCES_SUBMIT, &w->list, table, x, y++);
+   g->generate_submit  = Option_new(TOKEN_GENERATE_SUBMIT, &w->list, table, x, y++);
+   g->limit_text_width = Option_new(TOKEN_LIMIT_TEXT_WIDTH, &w->list, table, x, y++);
+   g->search_url       = Option_new(TOKEN_SEARCH_URL, &w->list, table, x, y++);
+   g->search_charset   = Option_new(TOKEN_SEARCH_CHARSET, &w->list, table, x, y++);
+   g->accept_language  = Option_new(TOKEN_ACCEPT_LANGUAGE, &w->list, table, x, y++);
+   g->show_msg   = Option_new(TOKEN_SHOW_MSG, &w->list, table, x, y++);
+   g->use_old_parser   = Option_new(TOKEN_USE_OLD_PARSER, &w->list, table, x, y++);
+   gtk_notebook_append_page(GTK_NOTEBOOK(w->notebook), vbox, gtk_label_new(label));
+   return g;
+}
+
+DillocfgInterface *DillocfgInterface_new(DillocfgWin *w, const gchar *label) {
+   DillocfgInterface *di     = g_new(DillocfgInterface, 1);
+   gint x, y;
+   GtkWidget *vbox           = gtk_vbox_new(FALSE, 0);
+   GtkWidget *table          = gtk_table_new(10, 2, FALSE);
+
+   gtk_table_set_homogeneous (GTK_TABLE(table), FALSE);
+   gtk_container_add(GTK_CONTAINER(vbox), table);
+   x = 0; y = 0;
+   di->geometry              = Option_new(TOKEN_GEOMETRY, &w->list, table, x, y++);
+   di->panel_size            = Option_new(TOKEN_PANEL_SIZE, &w->list, table, x, y++);
+   di->show_back             = Option_new(TOKEN_SHOW_BACK, &w->list, table, x, y++);
+   di->show_forw             = Option_new(TOKEN_SHOW_FORW, &w->list, table, x, y++);
+   di->show_bookmarks        = Option_new(TOKEN_SHOW_BOOKMARKS, &w->list, table, x, y++);
+   di->show_clear_url        = Option_new(TOKEN_SHOW_CLEAR_URL, &w->list, table, x, y++);
+   di->show_home             = Option_new(TOKEN_SHOW_HOME, &w->list, table, x, y++);
+   di->show_menubar          = Option_new(TOKEN_SHOW_MENUBAR, &w->list, table, x, y++);
+   di->show_progress_box     = Option_new(TOKEN_SHOW_PROGRESS_BOX, &w->list, table, x, y++);
+   di->show_reload           = Option_new(TOKEN_SHOW_RELOAD, &w->list, table, x, y++);
+   x++; y = 0;
+   di->show_save             = Option_new(TOKEN_SHOW_SAVE, &w->list, table, x, y++);
+   di->show_stop             = Option_new(TOKEN_SHOW_STOP, &w->list, table, x, y++);
+   di->show_tooltip          = Option_new(TOKEN_SHOW_TOOLTIP, &w->list, table, x, y++);
+   di->show_url              = Option_new(TOKEN_SHOW_URL, &w->list, table, x, y++);
+   di->show_search           = Option_new(TOKEN_SHOW_SEARCH, &w->list, table, x, y++);
+   di->small_icons           = Option_new(TOKEN_SMALL_ICONS, &w->list, table, x, y++);
+   di->fullwindow_start      = Option_new(TOKEN_FULLWINDOW_START, &w->list, table, x, y++);
+   di->transient_dialogs     = Option_new(TOKEN_TRANSIENT_DIALOGS, &w->list, table, x, y++);
+   di->show_popup_navigation = Option_new(TOKEN_SHOW_POPUP_NAVIGATION, &w->list, table, x, y++);
+   di->show_user_agent       = Option_new(TOKEN_SHOW_USER_AGENT, &w->list, table, x, y++);
+   gtk_notebook_append_page(GTK_NOTEBOOK(w->notebook), vbox, gtk_label_new(label));
+   return di;
+}
+
+DillocfgFont *DillocfgFont_new(DillocfgWin *w, const gchar *label) {
+   DillocfgFont *r          = g_new(DillocfgFont, 1);
+   gint x, y;
+   GtkWidget *vbox          = gtk_vbox_new(FALSE, 5);
+   GtkWidget *table         = gtk_table_new(4, 1, FALSE);
+   GtkWidget *table2        = gtk_table_new(2, 2, FALSE);
+
+   gtk_table_set_homogeneous (GTK_TABLE(table), TRUE);
+   gtk_table_set_row_spacings(GTK_TABLE(table), 5);
+   gtk_table_set_homogeneous (GTK_TABLE(table2), TRUE);
+   //gtk_box_pack_start(GTK_BOX(vbox), table, TRUE, FALSE, 5);
+   //gtk_box_pack_start(GTK_BOX(vbox), table2, TRUE, FALSE, 5);
+   gtk_container_add(GTK_CONTAINER(vbox), table);
+   gtk_container_add(GTK_CONTAINER(vbox), table2);
+   x=0; y=0;
+   r->vw_fontname           = Option_new(TOKEN_VW_FONT, &w->list, table, x, y++);
+   r->vw_aafontname         = Option_new(TOKEN_VW_AAFONT, &w->list, table, x, y++);
+   r->fw_fontname           = Option_new(TOKEN_FW_FONT, &w->list, table, x, y++);
+   r->fw_aafontname         = Option_new(TOKEN_FW_AAFONT, &w->list, table, x, y++);
+   x=0; y=0;
+   r->font_sizes            = Option_new(TOKEN_FONT_SIZES, &w->list, table2, x, y++);
+   r->use_oblique           = Option_new(TOKEN_USE_OBLIQUE, &w->list, table2, x, y++);
+   x++; y=0;
+   r->font_factor           = Option_new(TOKEN_FONT_FACTOR, &w->list, table2, x, y++);
+   r->limit_font_decoration = Option_new(TOKEN_LIMIT_FONT_DECORATION, &w->list, table2, x, y++);
+
+   gtk_notebook_append_page(GTK_NOTEBOOK(w->notebook), vbox, gtk_label_new(label));
+   return r;
+}
+
+DillocfgColor *DillocfgColor_new(DillocfgWin *w, const gchar *label) {
+   DillocfgColor *c       = g_new(DillocfgColor, 1);
+   gint x, y;
+   GtkWidget *vbox        = gtk_vbox_new(FALSE, 0);
+   GtkWidget *table       = gtk_table_new(3, 1, FALSE);
+   GtkWidget *table2      = gtk_table_new(2, 2, TRUE);
+
+   gtk_table_set_homogeneous (GTK_TABLE(table), TRUE);
+   gtk_table_set_homogeneous (GTK_TABLE(table2), FALSE);
+   gtk_box_pack_start(GTK_BOX(vbox), table,  FALSE, FALSE, 5);
+   gtk_box_pack_start(GTK_BOX(vbox), table2, FALSE, FALSE, 5);
+   x = 0; y = 0;
+   c->force_my_colors     = Option_new(TOKEN_FORCE_MY_COLORS, &w->list, table, x, y++);
+   c->force_visited_color = Option_new(TOKEN_FORCE_VISITED_COLOR, &w->list, table, x, y++);
+   c->allow_white_bg      = Option_new(TOKEN_ALLOW_WHITE_BG, &w->list, table, x, y++);
+   x = 0; y = 0;
+   c->link_color          = Option_new(TOKEN_LINK_COLOR, &w->list, table2, x, y++);
+   c->bg_color            = Option_new(TOKEN_BG_COLOR, &w->list, table2, x, y++);
+   x++; y = 0;
+   c->visited_color       = Option_new(TOKEN_VISITED_COLOR, &w->list, table2, x, y++);
+   c->text_color          = Option_new(TOKEN_TEXT_COLOR, &w->list, table2, x, y++);
+
+   gtk_notebook_append_page(GTK_NOTEBOOK(w->notebook), vbox, gtk_label_new(label));
+   return c;
+}
+
+DillocfgNetwork *DillocfgNetwork_new(DillocfgWin *w, const gchar *label) {
+   DillocfgNetwork *n = g_new(DillocfgNetwork, 1);
+   gint x, y;
+   GtkWidget *vbox    = gtk_vbox_new(FALSE, 0);
+   GtkWidget *table   = gtk_table_new(10, 2, FALSE);
+
+   gtk_container_add(GTK_CONTAINER(vbox), table);
+   x = 0; y = 0;
+   n->user_agent      = Option_new(TOKEN_USER_AGENT, &w->list, table, x, y++);
+   n->home            = Option_new(TOKEN_HOME, &w->list, table, x, y++);
+   n->startup         = Option_new(TOKEN_STARTUP, &w->list, table, x, y++);;
+   n->http_proxy      = Option_new(TOKEN_PROXY, &w->list, table, x, y++);;
+   n->no_proxy        = Option_new(TOKEN_NOPROXY, &w->list, table, x, y++);;
+   gtk_notebook_append_page(GTK_NOTEBOOK(w->notebook), vbox, gtk_label_new(label));
+   return n;
+}
+
+DillocfgCookie *DillocfgCookie_new(DillocfgWin *w, const gchar *label) {
+   DillocfgCookie *c = g_new(DillocfgCookie, 1);
+   gint x, y;
+   GtkWidget *vbox   = gtk_vbox_new(FALSE, 0);
+   GtkWidget *hbox   = gtk_hbox_new(FALSE, 0);
+   GtkWidget *table  = gtk_table_new(1, 1, TRUE);
+   GtkWidget *clist  = gtk_clist_new(2);
+   GtkWidget *add_btn= gtk_button_new_with_label(_("Add"));
+   GtkWidget *del_btn= gtk_button_new_with_label(_("Delete"));
+   gtk_table_set_homogeneous(GTK_TABLE(table), TRUE);
+   gtk_container_add(GTK_CONTAINER(hbox), add_btn);
+   gtk_container_add(GTK_CONTAINER(hbox), del_btn);
+   x = 0; y = 0;
+   c->cookie_default = Option_new(TOKEN_COOKIE_DEFAULT, &w->list, table, x, y++);
+   gtk_clist_set_column_title(GTK_CLIST(clist), 0, _("Address"));
+   gtk_clist_set_column_title(GTK_CLIST(clist), 1, _("Rule"));
+   gtk_clist_column_titles_show(GTK_CLIST(clist));
+   gtk_clist_set_column_width(GTK_CLIST(clist), 0, 200);
+   /*
+   gtk_clist_insert(GTK_CLIST(clist), 1, NULL);
+   gtk_clist_set_text(GTK_CLIST(clist), 0, 0, "DEFAULT");
+   gtk_clist_set_text(GTK_CLIST(clist), 0, 1, "ACCEPT");
+   */
+   gtk_widget_set_usize(table, 320, 32);
+   gtk_box_pack_start(GTK_BOX(vbox), clist, TRUE, TRUE, 10);
+   gtk_box_pack_start(GTK_BOX(vbox), table, FALSE, FALSE, 10);
+   gtk_box_pack_start(GTK_BOX(vbox), hbox, FALSE, FALSE, 10);
+   //gtk_table_attach_defaults(GTK_TABLE(table), clist, x, x + 1, y, y + 1);
+   gtk_notebook_append_page(GTK_NOTEBOOK(w->notebook), vbox, gtk_label_new(label));
+   return c;
+}
+
+#define BUFSIZE 4096
+void ReadUserconfig(DillocfgWin *d) {
+   FILE *usercfg, *usercookiecfg;
+   gchar *filepass = g_strconcat(g_get_home_dir(), "/", USER_CFG, NULL);
+   char buf[BUFSIZE], name[BUFSIZE], value[BUFSIZE];
+   gchar *locale = g_strdup (setlocale (LC_NUMERIC, NULL));;
+
+   setlocale (LC_NUMERIC, "C");
+   if (!(usercfg = fopen(filepass, "r"))) {
+      g_print(_("Read failed <%s>\n"), filepass);
+      return;
+   }
+   g_free(filepass);
+   filepass = g_strconcat(g_get_home_dir(), "/", USER_COOKIE_CFG, NULL);
+   if (!(usercookiecfg = fopen(filepass, "r"))) {
+      g_print(_("Read failed <%s>\n"), filepass);
+      return;
+   }
+   g_free(filepass);
+
+   /* First, set default data. */
+   DillocfgWin_init(d, TRUE);
+
+   /* Read dillorc. */
+   while (fgets(buf, BUFSIZE, usercfg)) {
+      /* Parse name and value. */
+      int i = 0, j = 0, k = 0;
+      guint token;
+      SKIPSPACE(buf, i);
+      if (buf[i] == '#') continue;
+      SKIPSPACE(buf, i);
+      while (!IS_LINE_END(buf[i]) && buf[i] != '=' && !isspace(buf[i]))
+         name[j++] = buf[i++];
+      name[j] = '\0';
+      SKIPSPACE(buf, i);
+      if (buf[i++] != '=') continue;
+      SKIPSPACE(buf, i);
+      if (buf[i] == '"') {
+         i++;
+         while (!IS_LINE_END(buf[i]) && buf[i] != '"') value[k++] = buf[i++];
+      } else
+         while (!IS_LINE_END(buf[i]) && !isspace(buf[i])) value[k++] = buf[i++];
+      value[k] = '\0';
+      if (strlen(value) == 0) continue;
+      token = name2token(name);
+      /* Set value */
+      Option_set(get_token_object(token), value);
+   }
+
+   /* Read cookiesrc */
+   while (fgets(buf, BUFSIZE, usercookiecfg)) {
+      /* Parse name and value. */
+      int i = 0, j = 0, k = 0;
+      guint token;
+      SKIPSPACE(buf, i);
+      if (buf[i] == '#') continue;
+      SKIPSPACE(buf, i);
+      while (!IS_LINE_END(buf[i]) && !isspace(buf[i])) name[j++] = buf[i++];
+      name[j] = '\0';
+      SKIPSPACE(buf, i);
+      while (!IS_LINE_END(buf[i]) && !isspace(buf[i])) value[k++] = buf[i++];
+      value[k] = '\0';
+      if (strlen(value) == 0) continue;
+      if (strcmp(name, "DEFAULT") == 0)
+         token = TOKEN_COOKIE_DEFAULT;
+      else
+         token = TOKEN_COOKIE;
+      /* Set value */
+      Option_set(get_token_object(token), value);
+   }
+   fclose(usercfg);
+   fclose(usercookiecfg);
+   setlocale(LC_NUMERIC, locale);
+   DillocfgWin_init(d, FALSE);
+   g_free (locale);
+}
+
+void DillocfgWin_callback_reset(GtkButton *button, gpointer user_data) {
+   DillocfgWin *d = (DillocfgWin *)user_data;
+   DillocfgWin_init(d, TRUE);
+   modified_ = TRUE;
+}
+
+void DillocfgWin_callback_reload(GtkButton *button, gpointer user_data) {
+   DillocfgWin *d = (DillocfgWin *)user_data;
+   ReadUserconfig(d);
+   modified_ = FALSE;
+}
+
+void WriteUserconfig(DillocfgWin *d) {
+   FILE *usercfg;
+   //FILE *usercookiecfg;
+   GList *list;
+   gchar *filepass = g_strconcat(g_get_home_dir(), "/", USER_CFG, NULL);
+
+   if (!(usercfg = fopen(filepass, "w"))) {
+      g_print(_("can't write <%s>\n"), filepass);
+      return;
+   }
+   g_free(filepass);
+   fprintf(usercfg, "#This file is written by Dillocfg\n");
+#if 0
+   filepass = g_strconcat(g_get_home_dir(), "/", USER_COOKIE_CFG, NULL);
+   if (!(usercookiecfg = fopen(filepass, "w"))) {
+      g_print(_("can't write <%s>\n"), filepass);
+      fclose(usercfg);
+      return;
+   }
+   g_free(filepass);
+   fprintf(usercookiecfg, "#This file is written by Dillocfg\n");
+#endif
+   for (list = g_list_first(d->list); list; list = g_list_next(list)) {
+      Option *o = (Option *)list->data;
+      if (get_token_type(o->base.token) == COOKIE)
+         ;//Option_get(o, usercookiecfg);
+      else
+         Option_get(o, usercfg);
+   }
+   fclose(usercfg);
+   //fclose(usercookiecfg);
+}
+
+void DillocfgWin_callback_save(GtkButton *button, gpointer user_data) {
+   DillocfgWin *d = (DillocfgWin *)user_data;
+   WriteUserconfig(d);
+   modified_ = FALSE;
+}
+
+/* vim: set ts=3 sw=3 sts=3 expandtab:*/
diff -Nur dillo-0.8.0/config/dillocfg.h dillo-0.8.0.new/config/dillocfg.h
--- dillo-0.8.0/config/dillocfg.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/config/dillocfg.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,124 @@
+#ifndef __DILLOCFG_GTK_H__
+#define __DILLOCFG_GTK_H__
+
+#include <gdk/gdkx.h>
+#include <gtk/gtk.h>
+
+#include "../config.h"
+#include "dillocfg_option.h"
+
+#define WIDTH  740
+#define HEIGHT 370
+#define USER_CFG ".dillo/dillorc"
+#define USER_COOKIE_CFG ".dillo/cookiesrc"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#ifndef DISABLE_TABS
+   typedef struct {
+      Option *tab_bar_homogeneous;
+      Option *tab_bar_scroller;
+      Option *tab_bar_show_fullscreen;
+      Option *tab_bar_show_single_tab;
+      Option *tab_instead_of_window;
+      Option *tab_load_in_background;
+      Option *tab_close_middle_click;
+      Option *compress_vowels;
+      Option *compress_common_prefixes;
+      Option *tab_title_compress;
+   } DillocfgTab;
+#endif
+
+   typedef struct {
+      Option *use_dicache;
+      Option *focus_location_on_new;
+      Option *enterpress_forces_submit;
+      Option *limit_text_width;
+      Option *generate_submit;
+      Option *search_url;
+      Option *search_charset;
+      Option *accept_language;
+      Option *show_msg;
+      Option *use_old_parser;
+   } DillocfgOther;
+
+   typedef struct {
+      Option *geometry;
+      Option *panel_size;
+      Option *show_back;
+      Option *show_bookmarks;
+      Option *show_clear_url;
+      Option *show_forw;
+      Option *show_home;
+      Option *show_menubar;
+      Option *show_popup_navigation;
+      Option *show_progress_box;
+      Option *show_reload;
+      Option *show_save;
+      Option *show_stop;
+      Option *show_tooltip;
+      Option *show_url;
+      Option *show_search;
+      Option *show_user_agent;
+      Option *small_icons;
+      Option *fullwindow_start;
+      Option *transient_dialogs;
+   } DillocfgInterface;
+
+   typedef struct {
+      Option *font_sizes;
+      Option *font_factor;
+      Option *vw_fontname;
+      Option *fw_fontname;
+      Option *vw_aafontname;
+      Option *fw_aafontname;
+      Option *use_oblique;
+      Option *limit_font_decoration;
+   } DillocfgFont;
+
+   typedef struct {
+      Option *force_my_colors;
+      Option *force_visited_color;
+      Option *allow_white_bg;
+      Option *link_color;
+      Option *bg_color;
+      Option *visited_color;
+      Option *text_color;
+   } DillocfgColor;
+
+   typedef struct {
+      Option *user_agent;
+      Option *home;
+      Option *startup;
+      Option *http_proxy;
+      Option *no_proxy;
+   } DillocfgNetwork;
+
+   typedef struct {
+      Option    *cookie_default;
+   } DillocfgCookie;
+
+   typedef struct {
+      GtkWidget         *notebook;
+      GList             *list;
+      DillocfgInterface *interface;
+      DillocfgFont      *font;
+      DillocfgColor     *color;
+      DillocfgNetwork   *network;
+#ifndef DISABLE_TABS
+      DillocfgTab       *tab;
+#endif
+      DillocfgCookie    *cookie;
+      DillocfgOther     *other;
+   } DillocfgWin;
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#endif /* __DILLOCFG_GTK_H__ */
+
+/* vim: set ts=3 sw=3 sts=3 expandtab:*/
diff -Nur dillo-0.8.0/config/dillocfg_option.c dillo-0.8.0.new/config/dillocfg_option.c
--- dillo-0.8.0/config/dillocfg_option.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/config/dillocfg_option.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,565 @@
+/*
+ * File: dillocfg-gtk_option.c
+ *
+ * Copyright (C) 2003 Kiyo <kiyo@teki.jpn.ph>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <ctype.h>
+#include <string.h>
+#include <gdk/gdkx.h>
+#include <gtk/gtk.h>
+
+#include "../config.h"
+#include "../src/intl.h"
+#include "dillocfg_option.h"
+#include "dillocfg_token.h"
+
+/* Private class. */
+typedef struct {
+   OptionBase base;
+   GtkWidget *button;
+   gboolean   value;
+   gboolean   default_value;
+} CheckOption;
+
+typedef struct {
+   OptionBase base;
+   GtkWidget *hbox;
+   GtkWidget *entry;
+   gchar     *value;
+   gchar     *default_value;
+   gboolean  allow_space;
+} EntryOption;
+
+typedef struct {
+   OptionBase base;
+   GtkWidget *hbox;
+   GtkWidget *option_menu;
+   gchar    **items;
+   gint       value;
+   gint       default_value;
+} SelectOption;
+
+typedef struct {
+   OptionBase base;
+   GtkWidget *hbox;
+   GtkWidget *label;
+   GdkImage  *image;
+   GtkWidget *button_image;
+   GtkWidget *dialog;
+   GdkColor  *value;
+   GdkColor  *default_value;
+} ColorOption;
+
+typedef struct {
+   OptionBase base;
+   GtkWidget *hbox;
+   GtkWidget *button;
+   double     value;
+   double     default_value;
+   gboolean is_integer;
+} SpinOption;
+
+typedef struct {
+   gint x;
+   gint y;
+} Geometry;
+
+typedef struct {
+   OptionBase base;
+   GtkWidget *hbox;
+   GtkWidget *button;
+   GtkWidget *button2;
+   Geometry   value;
+   Geometry   default_value;
+} GeometryOption;
+
+CheckOption *CheckOption_new(guint token,
+      GtkWidget *table, gint x, gint y);
+void   CheckOption_init(CheckOption *o, gboolean use_default);
+void   CheckOption_set(CheckOption *o, gchar *value);
+gchar *CheckOption_get(CheckOption *o);
+void   CheckOption_free(CheckOption *o);
+
+EntryOption *EntryOption_new(guint token,
+      GtkWidget *table, gint x, gint y);
+void   EntryOption_init(EntryOption *o, gboolean use_default);
+void   EntryOption_set(EntryOption *o, gchar *value);
+gchar *EntryOption_get(EntryOption *o);
+void   EntryOption_free(EntryOption *o);
+
+SelectOption *SelectOption_new(guint token,
+      GtkWidget *table, gint x, gint y);
+void   SelectOption_init(SelectOption *o, gboolean use_default);
+void   SelectOption_set(SelectOption *o, gchar *value);
+gchar *SelectOption_get(SelectOption *o);
+void   SelectOption_free(SelectOption *o);
+
+ColorOption *ColorOption_new(guint token,
+      GtkWidget *table, gint x, gint y);
+void   ColorOption_init(ColorOption *o, gboolean use_default);
+void   ColorOption_set(ColorOption *o, gchar *value);
+gchar *ColorOption_get(ColorOption *o);
+void   ColorOption_free(ColorOption *o);
+
+SpinOption *SpinOption_new(guint token,
+      GtkWidget *table, gint x, gint y);
+void   SpinOption_init(SpinOption *o, gboolean use_default);
+void   SpinOption_set(SpinOption *o, gchar *value);
+gchar *SpinOption_get(SpinOption *o);
+void   SpinOption_free(SpinOption *o);
+
+GeometryOption *GeometryOption_new(guint token,
+      GtkWidget *table, gint x, gint y);
+void   GeometryOption_init(GeometryOption *o, gboolean use_default);
+void   GeometryOption_set(GeometryOption *o, gchar *value);
+gchar *GeometryOption_get(GeometryOption *o);
+void   GeometryOption_free(SpinOption *o);
+
+
+Option *Option_new(guint token, GList **list,
+      GtkWidget *table, gint x, gint y) {
+   guint type = get_token_type(token);
+   Option *o;
+   switch (type) {
+      case CHECK_OPTION:
+         o = (Option *)CheckOption_new(token, table, x, y);
+         break;
+      case ENTRY_OPTION:
+         o = (Option *)EntryOption_new(token, table, x, y);
+         break;
+      case SELECT_OPTION:
+      case COOKIE:
+         o = (Option *)SelectOption_new(token, table, x, y);
+         break;
+      case COLOR_OPTION:
+         o = (Option *)ColorOption_new(token, table, x, y);
+         break;
+      case SPIN_OPTION:
+         o = (Option *)SpinOption_new (token, table, x, y);
+         break;
+      case GEOMETRY_OPTION:
+         o = (Option *)GeometryOption_new(token, table, x, y);
+         break;
+      default:
+         o = (Option *)NULL;
+   }
+   set_token_object(token, o);
+   *list = g_list_append(*list, o);
+   return o;
+}
+
+void Option_init(Option *o, gboolean use_default) {
+   return ((o) ? o->base.init(o, use_default) : NULL);
+}
+
+void Option_set(Option *o, gchar *value) {
+   return ((o) ? o->base.set(o, value)        : NULL);
+}
+
+gchar *Option_get(Option *o, FILE *fp) {
+   if (!o) return NULL;
+   if (fp && o->base.get(o)) fprintf(fp, "%s\n", o->base.get(o));
+   return ((o) ? o->base.get(o)               : NULL);
+}
+
+void Option_free(Option *o, GList **list) {
+   return ((o) ? o->base.free(o)              : NULL);
+}
+
+CheckOption *CheckOption_new(guint token, GtkWidget *table, gint x, gint y) {
+   CheckOption *o   = g_new(CheckOption, 1);
+
+   o->base.token    = token;
+   o->base.init     = CheckOption_init;
+   o->base.set      = CheckOption_set;
+   o->base.get      = CheckOption_get;
+   o->base.free     = CheckOption_free;
+   o->button        = gtk_check_button_new_with_label(_(get_token_label(token)));
+   o->base.set(o, (gchar *)get_token_value(token));
+   o->default_value = o->value;
+   gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(o->button), o->value);
+   gtk_table_attach_defaults(GTK_TABLE(table), o->button, x, x + 1, y, y + 1);
+   return o;
+}
+
+void CheckOption_init(CheckOption *o, gboolean use_default) {
+   if (use_default) o->value = o->default_value;
+   gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(o->button), o->value);
+}
+
+void CheckOption_set(CheckOption *o, gchar *value) {
+   if (value)
+      o->value = (strcmp(value, "YES") == 0);
+}
+
+gchar *CheckOption_get(CheckOption *o) {
+   return g_strdup_printf("%s=%s", get_token_name(o->base.token),
+         (gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(o->button)))
+         ? "YES" : "NO");
+}
+
+void CheckOption_free(CheckOption *o) {
+   g_free(o);
+}
+
+EntryOption *EntryOption_new(guint token,
+      GtkWidget *table, gint x, gint y) {
+   EntryOption *o    = g_new(EntryOption, 1);
+   GtkWidget *label  = gtk_label_new(_(get_token_label(token)));
+
+   o->base.token     = token;
+   o->base.init      = EntryOption_init;
+   o->base.set       = EntryOption_set;
+   o->base.get       = EntryOption_get;
+   o->base.free      = EntryOption_free;
+   o->hbox           = gtk_hbox_new(FALSE, 0);
+   o->entry          = gtk_entry_new();
+   o->value          = NULL;
+   o->base.set(o, (gchar *)get_token_value(token));
+   o->default_value  = g_strdup(o->value);
+   o->allow_space    = (gboolean)get_token_option(token);
+   //gtk_box_set_homogeneous(GTK_BOX(o->hbox), TRUE);
+   gtk_label_set_justify(GTK_LABEL(label), GTK_JUSTIFY_LEFT);
+   if (o->value) gtk_entry_set_text(GTK_ENTRY(o->entry), o->value);
+   gtk_box_pack_start(GTK_BOX(o->hbox), label, FALSE, FALSE, 10);
+   gtk_box_pack_end(GTK_BOX(o->hbox), o->entry, TRUE, TRUE, 5);
+   gtk_table_attach_defaults(GTK_TABLE(table), o->hbox, x, x + 1, y, y + 1);
+   return o;
+}
+
+void EntryOption_init(EntryOption *o, gboolean use_default) {
+   if (use_default) {
+      g_free(o->value);
+      o->value = g_strdup(o->default_value);
+   }
+   if (o->value) gtk_entry_set_text(GTK_ENTRY(o->entry), o->value);
+}
+
+void EntryOption_set(EntryOption *o, gchar *value) {
+   g_free(o->value);
+   o->value = g_strdup(value);
+}
+
+gchar *EntryOption_get(EntryOption *o) {
+   gchar *format;
+   gchar *value = gtk_entry_get_text(GTK_ENTRY(o->entry));
+
+   if (!value) return NULL;
+   if (strcmp(value, "") == 0) return NULL;
+   if (o->allow_space) format = "%s=\"%s\"";
+   else format = "%s=%s";
+   return g_strdup_printf(format, get_token_name(o->base.token),
+         value);
+}
+
+void EntryOption_free(EntryOption *o) {
+   g_free(o);
+}
+
+SelectOption *SelectOption_new(guint token, GtkWidget *table, gint x, gint y) {
+   SelectOption *o  = g_new(SelectOption, 1);
+   GtkWidget *menu  = gtk_menu_new ();
+   gint i;
+
+   o->base.token    = token;
+   o->base.init     = SelectOption_init;
+   o->base.set      = SelectOption_set;
+   o->base.get      = SelectOption_get;
+   o->base.free     = SelectOption_free;
+   o->hbox          = gtk_hbox_new(FALSE, 0);
+   o->option_menu   = gtk_option_menu_new();
+   o->items         = (gchar **)get_token_option(token);
+   for (i = 0; o->items[i]; i++)
+      gtk_menu_append(GTK_MENU(menu), 
+            gtk_menu_item_new_with_label(o->items[i]));
+   gtk_option_menu_set_menu (GTK_OPTION_MENU(o->option_menu), menu);
+   o->base.set(o, (gchar *)get_token_value(token));
+   o->default_value = o->value;
+   gtk_option_menu_set_history(GTK_OPTION_MENU(o->option_menu), o->value);
+   gtk_box_pack_start(GTK_BOX(o->hbox),
+         gtk_label_new(_(get_token_label(token))), FALSE, FALSE, 5);
+   gtk_box_pack_start(GTK_BOX(o->hbox), o->option_menu, TRUE, TRUE, 5);
+   gtk_table_attach_defaults(GTK_TABLE(table), o->hbox, x, x + 1, y, y + 1);
+   return o;
+}
+
+void SelectOption_init(SelectOption *o, gboolean use_default) {
+   if (use_default) o->value = o->default_value;
+   gtk_option_menu_set_history (GTK_OPTION_MENU(o->option_menu), o->value);
+}
+
+void SelectOption_set(SelectOption *o, gchar *value) {
+   gint i;
+   for (i = 0; o->items[i]; i++)
+      if (!g_strcasecmp(value, o->items[i]))
+         o->value = i;
+}
+
+gchar *SelectOption_get(SelectOption *o) {
+   GtkWidget *menu = gtk_option_menu_get_menu(GTK_OPTION_MENU(o->option_menu));
+   /* always null...
+      gchar *str = NULL;
+      GtkWidget *item = gtk_menu_get_active(GTK_MENU(menu));
+      GtkWidget *label = GTK_BIN(GTK_MENU_ITEM(item))->child;
+      if(!label) str = g_strdup("");
+      else gtk_label_get(GTK_LABEL(label), &str);
+      */
+   gint i = g_list_index(GTK_MENU_SHELL(menu)->children,
+         GTK_OPTION_MENU(o->option_menu)->menu_item);
+   gchar *format = (get_token_type(o->base.token) == COOKIE) ? "%s %s" : "%s=\"%s\"";
+   return g_strdup_printf(format, get_token_name(o->base.token), o->items[i]);
+}
+
+void SelectOption_free(SelectOption *o) {
+   g_free(o);
+}
+
+void change_color_GdkColor(const double *color, GdkColor* o) {
+   o->red   = color[0] * 65535;
+   o->green = color[1] * 65535;
+   o->blue  = color[2] * 65535;
+}
+
+void change_color_double(const GdkColor* o, double *color) {
+   color[0] = o->red   / (double)65535;
+   color[1] = o->green / (double)65535;
+   color[2] = o->blue  / (double)65535;
+}
+
+void ColorDialog_ok(GtkButton *button, gpointer user_data) {
+   ColorOption *o = (ColorOption *)user_data;
+   double color[4];
+   gtk_color_selection_get_color(
+         GTK_COLOR_SELECTION(GTK_COLOR_SELECTION_DIALOG(o->dialog)->colorsel),
+         color);
+   change_color_GdkColor(color, o->value);
+   ColorOption_init(o, FALSE);
+   gtk_widget_destroy(o->dialog);
+}
+
+void ColorDialog_cancel(GtkButton *button, gpointer user_data) {
+   ColorOption *o = (ColorOption *)user_data;
+   gtk_widget_destroy(o->dialog);
+}
+
+void ColorOption_clicked(GtkButton *button, gpointer user_data) {
+   ColorOption *o = (ColorOption *)user_data;
+   gchar *title;
+   double color[4];
+   gtk_label_get(GTK_LABEL(o->label), &title);
+   change_color_double(o->value, color);
+   o->dialog = gtk_color_selection_dialog_new(title);
+   gtk_color_selection_set_color(
+         GTK_COLOR_SELECTION(GTK_COLOR_SELECTION_DIALOG(o->dialog)->colorsel),
+         color);
+   gtk_signal_connect(
+         GTK_OBJECT(GTK_COLOR_SELECTION_DIALOG(o->dialog)->ok_button),
+         "clicked", GTK_SIGNAL_FUNC(ColorDialog_ok), o);
+   gtk_signal_connect(
+         GTK_OBJECT(GTK_COLOR_SELECTION_DIALOG(o->dialog)->cancel_button),
+         "clicked", GTK_SIGNAL_FUNC(ColorDialog_cancel), o);
+   gtk_widget_hide(GTK_COLOR_SELECTION_DIALOG(o->dialog)->help_button);
+   gtk_widget_show(o->dialog);
+}
+
+#define PREVIEW_SIZE 48
+ColorOption *ColorOption_new(guint token,
+      GtkWidget *table, gint x, gint y) {
+   ColorOption *o    = g_new(ColorOption, 1);
+   GtkWidget *button = gtk_button_new();
+
+   o->base.token     = token;
+   o->base.init      = ColorOption_init;
+   o->base.set       = ColorOption_set;
+   o->base.get       = ColorOption_get;
+   o->base.free      = ColorOption_free;
+   o->hbox           = gtk_hbox_new(FALSE, 0);
+   o->label          = gtk_label_new(_(get_token_label(token)));
+   o->image          = gdk_image_new(GDK_IMAGE_NORMAL,
+         gdk_visual_get_system(), PREVIEW_SIZE, PREVIEW_SIZE);
+   o->button_image   = gtk_image_new(o->image, NULL);
+   o->value          = g_new(GdkColor, 1);
+   o->base.set(o, (gchar *)get_token_value(token));
+   o->default_value  = g_new(GdkColor, 1);
+   o->default_value  = gdk_color_copy(o->value);
+   gtk_signal_connect(GTK_OBJECT(button), "clicked",
+         GTK_SIGNAL_FUNC(ColorOption_clicked), o);
+   gtk_container_add(GTK_CONTAINER(button), o->button_image);
+   //gtk_box_set_homogeneous(GTK_BOX(o->hbox), TRUE);
+   gtk_label_set_justify (GTK_LABEL(o->label), GTK_JUSTIFY_LEFT);
+   gtk_box_pack_start(GTK_BOX(o->hbox), button, FALSE, FALSE, 10);
+   gtk_box_pack_start(GTK_BOX(o->hbox), o->label, FALSE, FALSE, 10);
+   gtk_table_attach_defaults(GTK_TABLE(table), o->hbox, x, x + 1, y, y + 1);
+   return o;
+}
+
+guint32 change_color(GdkColor *o) {
+   gdk_colormap_alloc_color(gdk_colormap_get_system(),
+         o, TRUE, TRUE);
+   return o->pixel;
+}
+
+void ColorOption_init(ColorOption *o, gboolean use_default) {
+   int i, j;
+   if (use_default) o->value = gdk_color_copy(o->default_value);
+   for (i = 0; i < PREVIEW_SIZE; i++)
+      for (j = 0; j < PREVIEW_SIZE; j++)
+         gdk_image_put_pixel(o->image, i, j, change_color(o->value));
+   gtk_image_set(GTK_IMAGE(o->button_image), o->image, NULL);
+}
+
+void ColorOption_set(ColorOption *o, gchar *value) {
+   guint32 i;
+   if (strlen(value) != 8) return;
+   if (value[0] != '0' || value[1] != 'x') return;
+   sscanf(value, "0x%x", &i);
+   o->value->red   = (i&0x00FF0000) >> 8;
+   o->value->green = (i&0x0000FF00);
+   o->value->blue  = (i&0x000000FF) << 8;
+}
+
+gchar *ColorOption_get(ColorOption *o) {
+   return g_strdup_printf("%s=0x%.2x%.2x%.2x",
+         get_token_name(o->base.token),
+         o->value->red   >> 8,
+         o->value->green >> 8,
+         o->value->blue  >> 8);
+}
+
+void ColorOption_free(ColorOption *o) {
+   gdk_image_destroy (o->image);
+   g_free(o);
+}
+
+SpinOption *SpinOption_new(guint token,
+      GtkWidget *table, gint x, gint y) {
+   SpinOption *o      = g_new(SpinOption, 1);
+   OptionAdjustment_t *opt  = (OptionAdjustment_t *)get_token_option(token);
+
+   o->base.token      = token;
+   o->base.init       = SpinOption_init;
+   o->base.set        = SpinOption_set;
+   o->base.get        = SpinOption_get;
+   o->base.free       = SpinOption_free;
+   o->hbox            = gtk_hbox_new(FALSE, 0);
+   o->button          = gtk_spin_button_new(
+         (GtkAdjustment *)gtk_adjustment_new(0,
+                                             opt->lower,
+                                             opt->upper,
+                                             opt->increment,
+                                             opt->increment,
+                                             opt->increment),
+         opt->increment, opt->digits);
+   o->base.set(o, (gchar *)get_token_value(token));
+   o->default_value   = o->value;
+   o->is_integer      = (opt->digits == 0);
+   gtk_box_pack_start(GTK_BOX(o->hbox),
+         gtk_label_new(_(get_token_label(token))), FALSE, FALSE, 10);
+   gtk_box_pack_start(GTK_BOX(o->hbox), o->button, FALSE, FALSE, 10);
+   gtk_table_attach_defaults(GTK_TABLE(table), o->hbox, x, x + 1, y, y + 1);
+   return o;
+}
+
+void SpinOption_init(SpinOption *o, gboolean use_default) {
+   if (use_default) o->value = o->default_value;
+   gtk_spin_button_set_value(GTK_SPIN_BUTTON(o->button), o->value);
+}
+
+void SpinOption_set(SpinOption *o, gchar *value) {
+   if (o->is_integer)
+      o->value = strtol(value, NULL, 0);
+   else
+      o->value = strtod(value, NULL);
+}
+
+   gchar *SpinOption_get(SpinOption *o) {
+      if (o->is_integer)
+         return g_strdup_printf("%s=%d", get_token_name(o->base.token),
+               gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(o->button)));
+      else {
+         gchar *float_str = g_strdup_printf("%s=%f",
+               get_token_name(o->base.token),
+               gtk_spin_button_get_value_as_float(GTK_SPIN_BUTTON(o->button)));
+         if (strchr(float_str, ','))
+            strchr(float_str, ',')[0] = '.';
+         return float_str;
+      }
+   }
+
+void SpinOption_free(SpinOption *o) {
+   g_free(o);
+}
+
+GeometryOption *GeometryOption_new(guint token,
+      GtkWidget *table, gint x, gint y) {
+   GeometryOption *o     = g_new(GeometryOption, 1);
+   OptionAdjustment_t *opt     = (OptionAdjustment_t *)get_token_option(token);
+
+   o->base.token         = token;
+   o->base.init          = GeometryOption_init;
+   o->base.set           = GeometryOption_set;
+   o->base.get           = GeometryOption_get;
+   o->base.free          = GeometryOption_free;
+   o->hbox               = gtk_hbox_new(FALSE, 0);
+   o->button             = gtk_spin_button_new(
+         (GtkAdjustment *)gtk_adjustment_new(0,
+                                             opt->lower,
+                                             opt->upper,
+                                             opt->increment,
+                                             opt->increment,
+                                             opt->increment),
+         opt->increment, 0);
+   o->button2            = gtk_spin_button_new(
+         (GtkAdjustment *)gtk_adjustment_new(0,
+                                             opt->lower,
+                                             opt->upper,
+                                             opt->increment,
+                                             opt->increment,
+                                             opt->increment),
+         opt->increment, 0);
+   o->base.set(o, (gchar *)get_token_value(token));
+   o->default_value      = o->value;
+   gtk_box_pack_start(GTK_BOX(o->hbox),
+         gtk_label_new(_(get_token_label(token))), FALSE, FALSE, 10);
+   gtk_box_pack_start(GTK_BOX(o->hbox), o->button, FALSE, FALSE, 10);
+   gtk_box_pack_start(GTK_BOX(o->hbox), gtk_label_new("X"), FALSE, FALSE, 0);
+   gtk_box_pack_start(GTK_BOX(o->hbox), o->button2, FALSE, FALSE, 10);
+   gtk_table_attach_defaults(GTK_TABLE(table), o->hbox, x, x + 1, y, y + 1);
+   return o;
+}
+
+void GeometryOption_init(GeometryOption *o, gboolean use_default) {
+   if(use_default) o->value = o->default_value;
+   gtk_spin_button_set_value(GTK_SPIN_BUTTON(o->button),  o->value.x);
+   gtk_spin_button_set_value(GTK_SPIN_BUTTON(o->button2), o->value.y);
+}
+
+void GeometryOption_set(GeometryOption *o, gchar *value) {
+   gchar *ptr;
+
+   if ((ptr = strchr(value, 'x'))) {
+      o->value.x = atoi(value);
+      o->value.y = atoi(++ptr);
+   }
+}
+
+gchar *GeometryOption_get(GeometryOption *o) {
+   return g_strdup_printf("%s=%dx%d", get_token_name(o->base.token),
+         gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(o->button)),
+         gtk_spin_button_get_value_as_int(GTK_SPIN_BUTTON(o->button2)));
+}
+
+void GeometryOption_free(SpinOption *o) {
+   g_free(o);
+}
+
+
+/* vim: set ts=3 sw=3 sts=3 expandtab:*/
diff -Nur dillo-0.8.0/config/dillocfg_option.h dillo-0.8.0.new/config/dillocfg_option.h
--- dillo-0.8.0/config/dillocfg_option.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/config/dillocfg_option.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,55 @@
+#ifndef __DILLOCFG_GTK_OPTION_H__
+#define __DILLOCFG_GTK_OPTION_H__
+
+#include <stdio.h>
+#include <gtk/gtk.h>
+
+#include "../config.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+   typedef enum {
+      CHECK_OPTION = 0,
+      ENTRY_OPTION,
+      SELECT_OPTION,
+      COLOR_OPTION,
+      SPIN_OPTION,
+      GEOMETRY_OPTION,
+      COOKIE
+   } OptionType;
+
+   typedef struct {
+      guint     token;
+      void  (*init)();
+      void   (*set)();
+      gchar *(*get)();
+      void  (*free)();
+   } OptionBase;
+
+   typedef struct {
+      OptionBase base;
+   } Option;
+
+   typedef struct {
+      gfloat lower;
+      gfloat upper;
+      gfloat increment;
+      guint  digits;
+   } OptionAdjustment_t;
+
+   Option *Option_new(guint token, GList **list, GtkWidget *table, gint x, gint y);
+   void    Option_init(Option *o, gboolean use_default);
+   void    Option_set(Option *o, gchar *value);
+   gchar  *Option_get(Option *o, FILE *fp);
+   void    Option_free(Option *o, GList **list);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#endif /* __DILLOCFG_GTK_OPTION_H__ */
+
+/* vim: set ts=3 sw=3 sts=3 expandtab:*/
diff -Nur dillo-0.8.0/config/dillocfg_token.c dillo-0.8.0.new/config/dillocfg_token.c
--- dillo-0.8.0/config/dillocfg_token.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/config/dillocfg_token.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,604 @@
+/*
+ * File: dillocfg-gtk_token.c
+ *
+ * Copyright (C) 2003 Kiyo <kiyo@teki.jpn.ph>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include <string.h>
+#include <gdk/gdkx.h>
+#include <gtk/gtk.h>
+
+#include "../config.h"
+#include "../src/intl.h"
+#include "dillocfg_token.h"
+#include "dillocfg_option.h"
+
+static const OptionAdjustment_t font_factor_option = {0.1, 20, 0.1, 1};
+static const OptionAdjustment_t geometry_option = {1, 65535, 1, 0};
+static const gchar *panel_sizes[] = {"tiny", "medium", "large", NULL};
+static const gchar *user_agents[] = {
+   "Dillo/%v",
+   "Mozilla/3.0 (compatible;) Dillo/%v",
+   "Mozilla/4.0 (compatible; MSIE 4.0;) Dillo/%v",
+   "Mozilla/4.0 (Macintosh; U; PPC Mac OS X; ja-jp) Dillo/%v",
+   "DoCoMo/1.0/x505i (Dillo/%v)",
+   "J-PHONE/4.2/J-x53 (Dillo/%v)",
+   "KDDI-x24 UP.Browser/6.0.x.x (GUI) MMP/1.1 (Dillo/%v)",
+   NULL
+};
+static const gchar *cookie_rules[] = {
+   "ACCEPT_SESSION",
+   "DENY",
+   "ACCEPT",
+   NULL
+};
+
+/* symbol array */
+static struct {
+   const gchar   *name;
+   const gchar   *label;
+   const guint    token;
+   const guint    type;
+   const gchar   *value;
+   const gpointer option;
+   Option        *object;
+
+} symbols[] = {
+   { "null",
+      "null",
+      0,
+      -1,
+      NULL,
+      (const gpointer)NULL,
+      NULL 
+   },
+   { "geometry",
+      N_("Window Size"),
+      TOKEN_GEOMETRY,
+      GEOMETRY_OPTION,
+      "640x550",
+      (const gpointer)&geometry_option,
+      NULL 
+   },
+   { "http_proxy",
+      N_("HTTP Proxy"),
+      TOKEN_PROXY,
+      ENTRY_OPTION,
+      "",
+      (const gpointer)FALSE,
+      NULL 
+   },
+   { "no_proxy",
+      N_("NO Proxy"),
+      TOKEN_NOPROXY,
+      ENTRY_OPTION,
+      "",
+      (const gpointer)TRUE,
+      NULL 
+   },
+   { "user_agent",
+      N_("User-Agent"),
+      TOKEN_USER_AGENT,
+      SELECT_OPTION,
+      "Dillo/%v",
+      (const gpointer)&user_agents,
+      NULL 
+   },
+   { "link_color",
+      N_("Link color"),
+      TOKEN_LINK_COLOR,
+      COLOR_OPTION,
+      "0x0000ff",
+      NULL,
+      NULL 
+   },
+   { "visited_color",
+      N_("Visited color"),
+      TOKEN_VISITED_COLOR,
+      COLOR_OPTION,
+      "0xa020f0",
+      NULL,
+      NULL 
+   },
+   { "bg_color",
+      N_("BackGround color"),
+      TOKEN_BG_COLOR,
+      COLOR_OPTION,
+      "0xffffff",
+      NULL,
+      NULL 
+   },
+   { "allow_white_bg",
+      N_("Allow white bg"),
+      TOKEN_ALLOW_WHITE_BG,
+      CHECK_OPTION,
+      "NO",
+      NULL,
+      NULL 
+   },
+   { "force_my_colors",
+      N_("Force my colors"),
+      TOKEN_FORCE_MY_COLORS,
+      CHECK_OPTION,
+      "NO",
+      NULL,
+      NULL 
+   },
+   { "force_visited_color",
+      N_("Force visited color"),
+      TOKEN_FORCE_VISITED_COLOR,
+      CHECK_OPTION,
+      "NO",
+      NULL,
+      NULL 
+   },
+   { "text_color",
+      N_("Text color"),
+      TOKEN_TEXT_COLOR,
+      COLOR_OPTION,
+      "0x000000",
+      NULL,
+      NULL 
+   },
+   { "use_oblique",
+      N_("Use oblique"),
+      TOKEN_USE_OBLIQUE,
+      CHECK_OPTION,
+      "NO",
+      NULL,
+      NULL 
+   },
+   { "startup",
+      N_("STARTUP"),
+      TOKEN_STARTUP,
+      ENTRY_OPTION,
+      "about:splash",
+      (const gpointer)FALSE,
+      NULL 
+   },
+   { "home",
+      N_("HOMEPAGE"),
+      TOKEN_HOME,
+      ENTRY_OPTION,
+      "http://www.google.com/",
+      (const gpointer)FALSE,
+      NULL 
+   },
+   { "search_url",
+      N_("Search-engine's URL"),
+      TOKEN_SEARCH_URL,
+      ENTRY_OPTION,
+      "http://www.google.com/search?ie=UTF-8&oe=UTF-8&q=%s",
+      (const gpointer)TRUE,
+      NULL 
+   },
+   { "search_charset",
+      N_("Search-engine's charset"),
+      TOKEN_SEARCH_CHARSET,
+      ENTRY_OPTION,
+      "UTF-8",
+      (const gpointer)FALSE,
+      NULL 
+   },
+   { "show_tooltip",
+      N_("Show Tooltip"),
+      TOKEN_SHOW_TOOLTIP,
+      CHECK_OPTION,
+      "YES",
+      NULL,
+      NULL 
+   },
+   { "panel_size",
+      N_("Panel Size"),
+      TOKEN_PANEL_SIZE,
+      SELECT_OPTION,
+      "tiny",
+      (const gpointer)&panel_sizes,
+      NULL 
+   },
+   { "small_icons",
+      N_("Small icons"),
+      TOKEN_SMALL_ICONS,
+      CHECK_OPTION,
+      "YES",
+      NULL,
+      NULL 
+   },
+   { "limit_text_width",
+      N_("Limit text width"),
+      TOKEN_LIMIT_TEXT_WIDTH,
+      CHECK_OPTION,
+      "NO",
+      NULL,
+      NULL 
+   },
+   { "limit_font_decoration",
+      N_("Limit font decoration"),
+      TOKEN_LIMIT_FONT_DECORATION,
+      CHECK_OPTION,
+      "NO",
+      NULL,
+      NULL 
+   },
+   { "font_factor",
+      N_("Font factor"),
+      TOKEN_FONT_FACTOR,
+      SPIN_OPTION,
+      "1.0",
+      (const gpointer)&font_factor_option,
+      NULL 
+   },
+   { "font_sizes",
+      N_("Font Sizes"),
+      TOKEN_FONT_SIZES,
+      ENTRY_OPTION,
+      "10 12 14 16 18 20",
+      (const gpointer)TRUE,
+      NULL 
+   },
+   { "use_dicache",
+      N_("Use dicache"),
+      TOKEN_USE_DICACHE,
+      CHECK_OPTION,
+      FALSE,
+      NULL,
+      NULL 
+   },
+   { "show_back",
+      N_("Show Back"),
+      TOKEN_SHOW_BACK,
+      CHECK_OPTION,
+      "YES",
+      NULL,
+      NULL 
+   },
+   { "show_forw",
+      N_("Show Forw"),
+      TOKEN_SHOW_FORW,
+      CHECK_OPTION,
+      "YES",
+      NULL,
+      NULL 
+   },
+   { "show_home",
+      N_("Show Home"),
+      TOKEN_SHOW_HOME,
+      CHECK_OPTION,
+      "YES",
+      NULL,
+      NULL 
+   },
+   { "show_reload",
+      N_("Show Reload"),
+      TOKEN_SHOW_RELOAD,
+      CHECK_OPTION,
+      "YES",
+      NULL,
+      NULL 
+   },
+   { "show_save",
+      N_("Show Save"),
+      TOKEN_SHOW_SAVE,
+      CHECK_OPTION,
+      "NO",
+      NULL,
+      NULL 
+   },
+   { "show_stop",
+      N_("Show Stop"),
+      TOKEN_SHOW_STOP,
+      CHECK_OPTION,
+      "YES",
+      NULL,
+      NULL 
+   },
+   { "show_bookmarks",
+      N_("Show Bookmarks"),
+      TOKEN_SHOW_BOOKMARKS,
+      CHECK_OPTION,
+      "YES",
+      NULL,
+      NULL 
+   },
+   { "show_menubar",
+      N_("Show Menubar"),
+      TOKEN_SHOW_MENUBAR,
+      CHECK_OPTION,
+      "YES",
+      NULL,
+      NULL 
+   },
+   { "show_clear_url",
+      N_("Show ClearURL"),
+      TOKEN_SHOW_CLEAR_URL,
+      CHECK_OPTION,
+      "YES",
+      NULL,
+      NULL 
+   },
+   { "show_url",
+      N_("Show URL box"),
+      TOKEN_SHOW_URL,
+      CHECK_OPTION,
+      "YES",
+      NULL,
+      NULL 
+   },
+   { "show_search",
+      N_("Show Search box"),
+      TOKEN_SHOW_SEARCH,
+      CHECK_OPTION,
+      "YES",
+      NULL,
+      NULL 
+   },
+   { "show_progress_box",
+      N_("Show Progress box"),
+      TOKEN_SHOW_PROGRESS_BOX,
+      CHECK_OPTION,
+      "NO",
+      NULL,
+      NULL 
+   },
+   { "show_popup_navigation",
+      N_("Show Popup navigation"),
+      TOKEN_SHOW_POPUP_NAVIGATION,
+      CHECK_OPTION,
+      "YES",
+      NULL,
+      NULL 
+   },
+   { "show_user_agent",
+      N_("Show User-Agent"),
+      TOKEN_SHOW_USER_AGENT,
+      CHECK_OPTION,
+      "NO",
+      NULL,
+      NULL 
+   },
+   { "fullwindow_start",
+      N_("Fullwindow start"),
+      TOKEN_FULLWINDOW_START,
+      CHECK_OPTION,
+      "NO",
+      NULL,
+      NULL 
+   },
+   { "transient_dialogs",
+      N_("Transient dialogs"),
+      TOKEN_TRANSIENT_DIALOGS,
+      CHECK_OPTION,
+      "NO",
+      NULL,
+      NULL 
+   },
+   { "vw_aafontname",
+      N_("vw_aafontname"),
+      TOKEN_VW_AAFONT,
+      ENTRY_OPTION,
+      "*",
+      (const gpointer)TRUE,
+      NULL 
+   },
+   { "fw_aafontname",
+      N_("fw_aafontname"),
+      TOKEN_FW_AAFONT,
+      ENTRY_OPTION,
+      "*",
+      (const gpointer)TRUE,
+      NULL 
+   },
+   { "vw_fontname",
+      N_("vw_fontname"),
+      TOKEN_VW_FONT,
+      ENTRY_OPTION,
+      "*-*",
+      (const gpointer)TRUE,
+      NULL 
+   },
+   { "fw_fontname",
+      N_("fw_fontname"),
+      TOKEN_FW_FONT,
+      ENTRY_OPTION,
+      "*-*",
+      (const gpointer)TRUE,
+      NULL 
+   },
+   { "generate_submit",
+      N_("Generate submit"),
+      TOKEN_GENERATE_SUBMIT,
+      CHECK_OPTION,
+      "YES",
+      NULL,
+      NULL 
+   },
+   { "enterpress_forces_submit",
+      N_("Enterpress forces submit"),
+      TOKEN_ENTERPRESS_FORCES_SUBMIT,
+      CHECK_OPTION,
+      "NO",
+      NULL,
+      NULL 
+   },
+   { "show_msg",
+      N_("Show debugging messsages"),
+      TOKEN_SHOW_MSG,
+      CHECK_OPTION,
+      "NO",
+      NULL,
+      NULL 
+   },
+   { "use_old_parser",
+      N_("Use old parser"),
+      TOKEN_USE_OLD_PARSER,
+      CHECK_OPTION,
+      "NO",
+      NULL,
+      NULL 
+   },
+   { "focus_location_on_new",
+      N_("Focus location on new"),
+      TOKEN_FOCUS_LOCATION_ON_NEW,
+      CHECK_OPTION,
+      "YES",
+      NULL,
+      NULL 
+   },
+   { "accept_language",
+      N_("Accept Language"),
+      TOKEN_ACCEPT_LANGUAGE,
+      ENTRY_OPTION,
+      "en-us, ja",
+      (const gpointer)TRUE,
+      NULL
+   },
+#ifndef DISABLE_TABS
+   { "tab_load_in_background",
+      N_("Tab load in background"),
+      TOKEN_TAB_LOAD_IN_BACKGROUND,
+      CHECK_OPTION,
+      "YES",
+      NULL,
+      NULL 
+   },
+   { "tab_close_middle_click",
+      N_("Tab close middle click"),
+      TOKEN_TAB_CLOSE_MIDDLE_CLICK,
+      CHECK_OPTION,
+      "YES",
+      NULL,
+      NULL 
+   },
+   { "tab_instead_of_window",
+      N_("Tab instead of window"),
+      TOKEN_TAB_INSTEAD_OF_WINDOW,
+      CHECK_OPTION,
+      "YES",
+      FALSE,
+      NULL 
+   },
+   { "tab_bar_show_fullscreen",
+      N_("Tab bar show fullscreen"),
+      TOKEN_TAB_BAR_SHOW_FULLSCREEN,
+      CHECK_OPTION,
+      "NO",
+      NULL,
+      NULL 
+   },
+   { "tab_bar_show_single_tab",
+      N_("Tab bar show single tab"),
+      TOKEN_TAB_BAR_SHOW_SINGLE_TAB,
+      CHECK_OPTION,
+      "NO",
+      NULL,
+      NULL 
+   },
+   { "tab_bar_scroller",
+      N_("Tab bar scroller"),
+      TOKEN_TAB_BAR_SCROLLER,
+      CHECK_OPTION,
+      "NO",
+      NULL,
+      NULL 
+   },
+   { "tab_bar_homogeneous",
+      N_("Tab bar homogeneous"),
+      TOKEN_TAB_BAR_HOMOGENEOUS,
+      CHECK_OPTION,
+      "YES",
+      NULL,
+      NULL 
+   },
+   { "tab_title_compress",
+      N_("Tab title compress"),
+      TOKEN_TAB_TITLE_COMPRESS,
+      CHECK_OPTION,
+      "NO",
+      NULL,
+      NULL 
+   },
+   { "compress_vowels",
+      N_("Compress vowels"),
+      TOKEN_COMPRESS_VOWELS,
+      ENTRY_OPTION,
+      "aeiouyAEIOUY",
+      (const gpointer)TRUE,
+      NULL 
+   },
+   { "compress_common_prefixes",
+      N_("Compress_common_prefixes"),
+      TOKEN_COMPRESS_COMMON_PREFIXES,
+      ENTRY_OPTION,
+      "index of ;re: ;fwd: ;www.;welcome to ;the ",
+      (const gpointer)TRUE,
+      NULL 
+   },
+#endif /* !DISABLE_TABS */
+   { "DEFAULT",
+      N_("Default"),
+      TOKEN_COOKIE_DEFAULT,
+      COOKIE,
+      "ACCEPT_SESSION",
+      (const gpointer)&cookie_rules,
+      NULL 
+   },
+   { NULL,
+      NULL,
+      TOKEN_COOKIE,
+      COOKIE,
+      "ACCEPT_SESSION",
+      (const gpointer)&cookie_rules,
+      NULL 
+   },
+
+};
+
+
+static guint token2num(guint tkn) {
+   gint i;
+   for (i = 0; i < N_TOKENS && symbols[i].token != tkn; i++);
+   return i;
+}
+
+guint name2token(const gchar *name) {
+   gint i;
+   for (i = 0; i < N_TOKENS; i++)
+      if (symbols[i].name && strcmp(symbols[i].name, name) == 0)
+         return (const guint)symbols[i].token;
+   return 0;
+}
+
+const gchar *get_token_name(guint tkn) {
+   return symbols[token2num(tkn)].name;
+}
+
+const gchar *get_token_label(guint tkn) {
+   return symbols[token2num(tkn)].label;
+}
+
+guint get_token_type(guint tkn) {
+   return symbols[token2num(tkn)].type;
+}
+
+gpointer get_token_value(guint tkn) {
+   return (const gpointer)symbols[token2num(tkn)].value;
+}
+
+gpointer get_token_option(guint tkn) {
+   return symbols[token2num(tkn)].option;
+}
+
+void set_token_object(guint tkn, Option *obj) {
+   symbols[token2num(tkn)].object = obj;
+}
+
+Option *get_token_object(guint tkn) {
+   return symbols[token2num(tkn)].object;
+}
+
+/* vim: set ts=3 sw=3 sts=3 expandtab:*/
diff -Nur dillo-0.8.0/config/dillocfg_token.h dillo-0.8.0.new/config/dillocfg_token.h
--- dillo-0.8.0/config/dillocfg_token.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/config/dillocfg_token.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,101 @@
+#ifndef __DILLOCFG_GTK_TOKEN_H__
+#define __DILLOCFG_GTK_TOKEN_H__
+
+#include <gdk/gdkx.h>
+#include <gtk/gtk.h>
+
+#include "../config.h"
+#include "dillocfg_option.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+   /* define enumeration values to be returned for specific symbols */
+   typedef enum {
+      TOKEN_NULL = 0,
+      TOKEN_GEOMETRY,
+      TOKEN_PROXY,
+      TOKEN_NOPROXY,
+      TOKEN_USER_AGENT,
+      TOKEN_LINK_COLOR,
+      TOKEN_VISITED_COLOR,
+      TOKEN_BG_COLOR,
+      TOKEN_ALLOW_WHITE_BG,
+      TOKEN_FORCE_MY_COLORS,
+      TOKEN_FORCE_VISITED_COLOR,
+      TOKEN_TEXT_COLOR,
+      TOKEN_USE_OBLIQUE,
+      TOKEN_STARTUP,
+      TOKEN_HOME,
+      TOKEN_SEARCH_URL,
+      TOKEN_SEARCH_CHARSET,
+      TOKEN_PANEL_SIZE,
+      TOKEN_SMALL_ICONS,
+      TOKEN_FONT_FACTOR,
+      TOKEN_FONT_SIZES,
+      TOKEN_SHOW_TOOLTIP,
+      TOKEN_LIMIT_TEXT_WIDTH,
+      TOKEN_LIMIT_FONT_DECORATION,
+      TOKEN_USE_DICACHE,
+      TOKEN_SHOW_BACK,
+      TOKEN_SHOW_FORW,
+      TOKEN_SHOW_HOME,
+      TOKEN_SHOW_RELOAD,
+      TOKEN_SHOW_SAVE,
+      TOKEN_SHOW_STOP,
+      TOKEN_SHOW_BOOKMARKS,
+      TOKEN_SHOW_MENUBAR,
+      TOKEN_SHOW_CLEAR_URL,
+      TOKEN_SHOW_URL,
+      TOKEN_SHOW_SEARCH,
+      TOKEN_SHOW_PROGRESS_BOX,
+      TOKEN_SHOW_POPUP_NAVIGATION,
+      TOKEN_SHOW_USER_AGENT,
+      TOKEN_FULLWINDOW_START,
+      TOKEN_TRANSIENT_DIALOGS,
+      TOKEN_FW_FONT,
+      TOKEN_VW_FONT,
+      TOKEN_FW_AAFONT,
+      TOKEN_VW_AAFONT,
+      TOKEN_GENERATE_SUBMIT,
+      TOKEN_ENTERPRESS_FORCES_SUBMIT,
+      TOKEN_SHOW_MSG,
+      TOKEN_USE_OLD_PARSER,
+      TOKEN_FOCUS_LOCATION_ON_NEW,
+      TOKEN_ACCEPT_LANGUAGE,
+#ifndef DISABLE_TABS
+      TOKEN_TAB_LOAD_IN_BACKGROUND,
+      TOKEN_TAB_INSTEAD_OF_WINDOW,
+      TOKEN_TAB_BAR_SHOW_FULLSCREEN,
+      TOKEN_TAB_BAR_SHOW_SINGLE_TAB,
+      TOKEN_TAB_BAR_SCROLLER,
+      TOKEN_TAB_BAR_HOMOGENEOUS,
+      TOKEN_TAB_TITLE_COMPRESS,
+      TOKEN_TAB_CLOSE_MIDDLE_CLICK,
+      TOKEN_COMPRESS_VOWELS,
+      TOKEN_COMPRESS_COMMON_PREFIXES,
+#endif /* !DISABLE_TABS */
+      TOKEN_COOKIE_DEFAULT,
+      TOKEN_COOKIE,
+
+      TOKEN_LAST
+   } TokenType;
+#define N_TOKENS TOKEN_LAST
+
+   guint    name2token(const gchar *name);
+   const gchar   *get_token_name(guint tkn);
+   const gchar   *get_token_label(guint tkn);
+   guint    get_token_type(guint tkn);
+   gpointer get_token_value(guint tkn);
+   gpointer get_token_option(guint tkn);
+   Option        *get_token_object(guint tkn);
+   void           set_token_object(guint tkn, Option *obj);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#endif /* __DILLOCFG_GTK_TOKEN_H__ */
+
+/* vim: set ts=3 sw=3 sts=3 expandtab:*/
diff -Nur dillo-0.8.0/config/Makefile.am dillo-0.8.0.new/config/Makefile.am
--- dillo-0.8.0/config/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/config/Makefile.am	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,13 @@
+AM_CPPFLAGS=-DDILLORC_SYS='"$(sysconfdir)/dillorc"' @GTK_CFLAGS@ -DLOCALEDIR='"$(localedir)"'
+
+bin_PROGRAMS = dillocfg
+
+dillocfg_LDADD = @GTK_LIBS@
+dillocfg_SOURCES = dillocfg.c \
+				   dillocfg.h \
+				   dillocfg_option.c \
+				   dillocfg_option.h \
+				   dillocfg_token.h \
+				   dillocfg_token.c
+
+#EXTRA_DIST = dillocfg.tcl
diff -Nur dillo-0.8.0/config/Makefile.in dillo-0.8.0.new/config/Makefile.in
--- dillo-0.8.0/config/Makefile.in	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/config/Makefile.in	2004-10-13 01:20:00.000000000 +0000
@@ -0,0 +1,451 @@
+# Makefile.in generated by automake 1.7.3 from Makefile.am.
+# @configure_input@
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+ACLOCAL = @ACLOCAL@
+ALLOCA = @ALLOCA@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+BUILD_INCLUDED_LIBINTL = @BUILD_INCLUDED_LIBINTL@
+CATOBJEXT = @CATOBJEXT@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DATADIRNAME = @DATADIRNAME@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+GENCAT = @GENCAT@
+GLIBC21 = @GLIBC21@
+GLIB_CFLAGS = @GLIB_CFLAGS@
+GLIB_CONFIG = @GLIB_CONFIG@
+GLIB_LIBS = @GLIB_LIBS@
+GMSGFMT = @GMSGFMT@
+GTK_CFLAGS = @GTK_CFLAGS@
+GTK_CONFIG = @GTK_CONFIG@
+GTK_LIBS = @GTK_LIBS@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+INSTOBJEXT = @INSTOBJEXT@
+INTLBISON = @INTLBISON@
+INTLLIBS = @INTLLIBS@
+INTLOBJS = @INTLOBJS@
+INTL_LIBTOOL_SUFFIX_PREFIX = @INTL_LIBTOOL_SUFFIX_PREFIX@
+KRB5_CONFIG = @KRB5_CONFIG@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBICONV_CFLAGS = @LIBICONV_CFLAGS@
+LIBICONV_LIBS = @LIBICONV_LIBS@
+LIBINTL = @LIBINTL@
+LIBJPEG_CPPFLAGS = @LIBJPEG_CPPFLAGS@
+LIBJPEG_LDFLAGS = @LIBJPEG_LDFLAGS@
+LIBJPEG_LIBS = @LIBJPEG_LIBS@
+LIBOBJS = @LIBOBJS@
+LIBPNG_CFLAGS = @LIBPNG_CFLAGS@
+LIBPNG_LIBS = @LIBPNG_LIBS@
+LIBS = @LIBS@
+LIBZ_LIBS = @LIBZ_LIBS@
+LTLIBICONV = @LTLIBICONV@
+LTLIBINTL = @LTLIBINTL@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+MKINSTALLDIRS = @MKINSTALLDIRS@
+MSGFMT = @MSGFMT@
+MSGMERGE = @MSGMERGE@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+POSUB = @POSUB@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+USE_INCLUDED_LIBINTL = @USE_INCLUDED_LIBINTL@
+USE_NLS = @USE_NLS@
+VERSION = @VERSION@
+XFT_CONFIG = @XFT_CONFIG@
+XGETTEXT = @XGETTEXT@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+AM_CPPFLAGS = -DDILLORC_SYS='"$(sysconfdir)/dillorc"' @GTK_CFLAGS@ -DLOCALEDIR='"$(localedir)"'
+
+bin_PROGRAMS = dillocfg
+
+dillocfg_LDADD = @GTK_LIBS@
+dillocfg_SOURCES = dillocfg.c \
+				   dillocfg.h \
+				   dillocfg_option.c \
+				   dillocfg_option.h \
+				   dillocfg_token.h \
+				   dillocfg_token.c
+
+subdir = config
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+bin_PROGRAMS = dillocfg$(EXEEXT)
+PROGRAMS = $(bin_PROGRAMS)
+
+am_dillocfg_OBJECTS = dillocfg.$(OBJEXT) dillocfg_option.$(OBJEXT) \
+	dillocfg_token.$(OBJEXT)
+dillocfg_OBJECTS = $(am_dillocfg_OBJECTS)
+dillocfg_DEPENDENCIES =
+dillocfg_LDFLAGS =
+
+DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+@AMDEP_TRUE@DEP_FILES = ./$(DEPDIR)/dillocfg.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/dillocfg_option.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/dillocfg_token.Po
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
+DIST_SOURCES = $(dillocfg_SOURCES)
+DIST_COMMON = Makefile.am Makefile.in
+SOURCES = $(dillocfg_SOURCES)
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .o .obj
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  config/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+binPROGRAMS_INSTALL = $(INSTALL_PROGRAM)
+install-binPROGRAMS: $(bin_PROGRAMS)
+	@$(NORMAL_INSTALL)
+	$(mkinstalldirs) $(DESTDIR)$(bindir)
+	@list='$(bin_PROGRAMS)'; for p in $$list; do \
+	  p1=`echo $$p|sed 's/$(EXEEXT)$$//'`; \
+	  if test -f $$p \
+	  ; then \
+	    f=`echo "$$p1" | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'`; \
+	   echo " $(INSTALL_PROGRAM_ENV) $(binPROGRAMS_INSTALL) $$p $(DESTDIR)$(bindir)/$$f"; \
+	   $(INSTALL_PROGRAM_ENV) $(binPROGRAMS_INSTALL) $$p $(DESTDIR)$(bindir)/$$f || exit 1; \
+	  else :; fi; \
+	done
+
+uninstall-binPROGRAMS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(bin_PROGRAMS)'; for p in $$list; do \
+	  f=`echo "$$p" | sed 's,^.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/'`; \
+	  echo " rm -f $(DESTDIR)$(bindir)/$$f"; \
+	  rm -f $(DESTDIR)$(bindir)/$$f; \
+	done
+
+clean-binPROGRAMS:
+	-test -z "$(bin_PROGRAMS)" || rm -f $(bin_PROGRAMS)
+dillocfg$(EXEEXT): $(dillocfg_OBJECTS) $(dillocfg_DEPENDENCIES) 
+	@rm -f dillocfg$(EXEEXT)
+	$(LINK) $(dillocfg_LDFLAGS) $(dillocfg_OBJECTS) $(dillocfg_LDADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT) core *.core
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dillocfg.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dillocfg_option.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dillocfg_token.Po@am__quote@
+
+distclean-depend:
+	-rm -rf ./$(DEPDIR)
+
+.c.o:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
+@am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
+@am__fastdepCC_TRUE@	then mv "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
+@am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; \
+@am__fastdepCC_TRUE@	fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `test -f '$<' || echo '$(srcdir)/'`$<
+
+.c.obj:
+@am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
+@am__fastdepCC_TRUE@	  -c -o $@ `if test -f '$<'; then $(CYGPATH_W) '$<'; else $(CYGPATH_W) '$(srcdir)/$<'; fi`; \
+@am__fastdepCC_TRUE@	then mv "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
+@am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; \
+@am__fastdepCC_TRUE@	fi
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	depfile='$(DEPDIR)/$*.Po' tmpdepfile='$(DEPDIR)/$*.TPo' @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `if test -f '$<'; then $(CYGPATH_W) '$<'; else $(CYGPATH_W) '$(srcdir)/$<'; fi`
+uninstall-info-am:
+
+ETAGS = etags
+ETAGSFLAGS =
+
+CTAGS = ctags
+CTAGSFLAGS =
+
+tags: TAGS
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	mkid -fID $$unique
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(ETAGS_ARGS)$$tags$$unique" \
+	  || $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	     $$tags $$unique
+
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '    { files[$$0] = 1; } \
+	       END { for (i in files) print i; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(PROGRAMS)
+
+installdirs:
+	$(mkinstalldirs) $(DESTDIR)$(bindir)
+
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-binPROGRAMS clean-generic mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-compile distclean-depend \
+	distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am: install-binPROGRAMS
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-binPROGRAMS uninstall-info-am
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-binPROGRAMS \
+	clean-generic ctags distclean distclean-compile \
+	distclean-depend distclean-generic distclean-tags distdir dvi \
+	dvi-am info info-am install install-am install-binPROGRAMS \
+	install-data install-data-am install-exec install-exec-am \
+	install-info install-info-am install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-binPROGRAMS uninstall-info-am
+
+
+#EXTRA_DIST = dillocfg.tcl
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -Nur dillo-0.8.0/config.guess dillo-0.8.0.new/config.guess
--- dillo-0.8.0/config.guess	2003-09-21 23:02:39.000000000 +0000
+++ dillo-0.8.0.new/config.guess	2004-10-13 01:13:29.000000000 +0000
@@ -3,7 +3,7 @@
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 #   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
 
-timestamp='2003-08-18'
+timestamp='2003-01-30'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -106,7 +106,6 @@
 : ${TMPDIR=/tmp} ;
  { tmp=`(umask 077 && mktemp -d -q "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
  { test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir $tmp) ; } ||
- { tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir $tmp) && echo "Warning: creating insecure temp directory" >&2 ; } ||
  { echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; } ;
 dummy=$tmp/dummy ;
 tmpfiles="$dummy.c $dummy.o $dummy.rel $dummy" ;
@@ -236,6 +235,9 @@
     *:OpenBSD:*:*)
 	echo ${UNAME_MACHINE}-unknown-openbsd${UNAME_RELEASE}
 	exit 0 ;;
+    *:MicroBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-microbsd${UNAME_RELEASE}
+	exit 0 ;;
     alpha:OSF1:*:*)
 	if test $UNAME_RELEASE = "V4.0"; then
 		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
@@ -283,9 +285,6 @@
 	# 1.2 uses "1.2" for uname -r.
 	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[VTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
 	exit 0 ;;
-    Alpha*:OpenVMS:*:*)
-	echo alpha-hp-vms
-	exit 0 ;;
     Alpha\ *:Windows_NT*:*)
 	# How do we know it's Interix rather than the generic POSIX subsystem?
 	# Should we change UNAME_MACHINE based on the output of uname instead
@@ -324,9 +323,6 @@
     NILE*:*:*:dcosx)
 	echo pyramid-pyramid-svr4
 	exit 0 ;;
-    DRS?6000:unix:4.0:6*)
-	echo sparc-icl-nx6
-	exit 0 ;;
     DRS?6000:UNIX_SV:4.2*:7*)
 	case `/usr/bin/uname -p` in
 	    sparc) echo sparc-icl-nx7 && exit 0 ;;
@@ -734,7 +730,7 @@
 	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
 	exit 0 ;;
     *:UNICOS/mp:*:*)
-	echo nv1-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	echo nv1-cray-unicosmp${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/' 
 	exit 0 ;;
     F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
 	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
@@ -751,7 +747,7 @@
     *:BSD/OS:*:*)
 	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
 	exit 0 ;;
-    *:FreeBSD:*:*|*:GNU/FreeBSD:*:*)
+    *:FreeBSD:*:*)
 	# Determine whether the default compiler uses glibc.
 	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
@@ -763,10 +759,7 @@
 	#endif
 EOF
 	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
-	# GNU/FreeBSD systems have a "k" prefix to indicate we are using
-	# FreeBSD's kernel, but not the complete OS.
-	case ${LIBC} in gnu) kernel_only='k' ;; esac
-	echo ${UNAME_MACHINE}-unknown-${kernel_only}freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`${LIBC:+-$LIBC}
+	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`${LIBC:+-$LIBC}
 	exit 0 ;;
     i*:CYGWIN*:*)
 	echo ${UNAME_MACHINE}-pc-cygwin
@@ -777,8 +770,8 @@
     i*:PW*:*)
 	echo ${UNAME_MACHINE}-pc-pw32
 	exit 0 ;;
-    x86:Interix*:[34]*)
-	echo i586-pc-interix${UNAME_RELEASE}|sed -e 's/\..*//'
+    x86:Interix*:3*)
+	echo i586-pc-interix3
 	exit 0 ;;
     [345]86:Windows_95:* | [345]86:Windows_98:* | [345]86:Windows_NT:*)
 	echo i${UNAME_MACHINE}-pc-mks
@@ -807,9 +800,6 @@
     arm*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
 	exit 0 ;;
-    cris:Linux:*:*)
-	echo cris-axis-linux-gnu
-	exit 0 ;;
     ia64:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
 	exit 0 ;;
@@ -888,9 +878,6 @@
     s390:Linux:*:* | s390x:Linux:*:*)
 	echo ${UNAME_MACHINE}-ibm-linux
 	exit 0 ;;
-    sh64*:Linux:*:*)
-    	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
     sh*:Linux:*:*)
 	echo ${UNAME_MACHINE}-unknown-linux-gnu
 	exit 0 ;;
@@ -948,9 +935,6 @@
 	LIBC=gnuaout
 	#endif
 	#endif
-	#ifdef __dietlibc__
-	LIBC=dietlibc
-	#endif
 EOF
 	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
 	test x"${LIBC}" != x && echo "${UNAME_MACHINE}-pc-linux-${LIBC}" && exit 0
@@ -1052,7 +1036,7 @@
 	exit 0 ;;
     M68*:*:R3V[567]*:*)
 	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
-    3[34]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0)
+    3[34]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0)
 	OS_REL=''
 	test -r /etc/.relid \
 	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
@@ -1208,9 +1192,6 @@
     *:ITS:*:*)
 	echo pdp10-unknown-its
 	exit 0 ;;
-    SEI:*:*:SEIUX)
-        echo mips-sei-seiux${UNAME_RELEASE}
-	exit 0 ;;
 esac
 
 #echo '(No uname command or uname output not recognized.)' 1>&2
diff -Nur dillo-0.8.0/config.h.in dillo-0.8.0.new/config.h.in
--- dillo-0.8.0/config.h.in	2004-02-08 12:57:04.000000000 +0000
+++ dillo-0.8.0.new/config.h.in	2004-10-13 01:20:12.000000000 +0000
@@ -1,23 +1,97 @@
 /* config.h.in.  Generated from configure.in by autoheader.  */
 
+/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
+   systems. This function is required for `alloca.c' support on those systems.
+   */
+#undef CRAY_STACKSEG_END
+
+/* Define to 1 if using `alloca.c'. */
+#undef C_ALLOCA
+
+/* Enable SSL Processing */
+#undef DILLO_SSL
+
 /* Enable GIF images */
 #undef ENABLE_GIF
 
 /* Enable JPEG images */
 #undef ENABLE_JPEG
 
+/* Define as 1 if you want to use NLS. */
+#undef ENABLE_NLS
+
 /* Enable PNG images */
 #undef ENABLE_PNG
 
+/* Define to 1 if you have `alloca', as a function or macro. */
+#undef HAVE_ALLOCA
+
+/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
+   */
+#undef HAVE_ALLOCA_H
+
+/* Define to 1 if you have the <argz.h> header file. */
+#undef HAVE_ARGZ_H
+
+/* Define as 1 if you have catgets and don't want to use GNU gettext. */
+#undef HAVE_CATGETS
+
+/* Define if the GNU dcgettext() function is already present or preinstalled.
+   */
+#undef HAVE_DCGETTEXT
+
 /* Define to 1 if you have the <fcntl.h> header file. */
 #undef HAVE_FCNTL_H
 
+/* Define to 1 if you have the `feof_unlocked' function. */
+#undef HAVE_FEOF_UNLOCKED
+
+/* Define to 1 if you have the `fgets_unlocked' function. */
+#undef HAVE_FGETS_UNLOCKED
+
+/* Define to 1 if you have the `getcwd' function. */
+#undef HAVE_GETCWD
+
+/* Define to 1 if you have the `getc_unlocked' function. */
+#undef HAVE_GETC_UNLOCKED
+
+/* Define to 1 if you have the `getegid' function. */
+#undef HAVE_GETEGID
+
+/* Define to 1 if you have the `geteuid' function. */
+#undef HAVE_GETEUID
+
+/* Define to 1 if you have the `getgid' function. */
+#undef HAVE_GETGID
+
 /* Define to 1 if you have the `gethostbyname' function. */
 #undef HAVE_GETHOSTBYNAME
 
-/* Define to 1 if you have the <inttypes.h> header file. */
+/* Define to 1 if you have the `getpagesize' function. */
+#undef HAVE_GETPAGESIZE
+
+/* Define as 1 if you have GNU gettext. */
+#undef HAVE_GETTEXT
+
+/* Define to 1 if you have the `getuid' function. */
+#undef HAVE_GETUID
+
+/* Define if you have the iconv() function. */
+#undef HAVE_ICONV
+
+/* Define if <inttypes.h> exists and doesn't clash with <sys/types.h>. */
 #undef HAVE_INTTYPES_H
 
+/* Define if <inttypes.h> exists, doesn't clash with <sys/types.h>, and
+   declares uintmax_t. */
+#undef HAVE_INTTYPES_H_WITH_UINTMAX
+
+/* Define if you have <langinfo.h> and nl_langinfo(CODESET). */
+#undef HAVE_LANGINFO_CODESET
+
+/* Define as 1 if you have LC_MESSAGES. */
+#undef HAVE_LC_MESSAGES
+
 /* Define to 1 if you have the `nsl' library (-lnsl). */
 #undef HAVE_LIBNSL
 
@@ -30,27 +104,88 @@
 /* Define to 1 if you have the `socket' library (-lsocket). */
 #undef HAVE_LIBSOCKET
 
+/* Define to 1 if you have the `ssl' library (-lssl). */
+#undef HAVE_LIBSSL
+
+/* Define to 1 if you have the <limits.h> header file. */
+#undef HAVE_LIMITS_H
+
+/* Define to 1 if you have the <locale.h> header file. */
+#undef HAVE_LOCALE_H
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#undef HAVE_MALLOC_H
+
 /* Define to 1 if you have the <memory.h> header file. */
 #undef HAVE_MEMORY_H
 
+/* Define to 1 if you have the `mempcpy' function. */
+#undef HAVE_MEMPCPY
+
+/* Define to 1 if you have a working `mmap' system call. */
+#undef HAVE_MMAP
+
+/* Define to 1 if you have the `munmap' function. */
+#undef HAVE_MUNMAP
+
+/* Define to 1 if you have the <nl_types.h> header file. */
+#undef HAVE_NL_TYPES_H
+
+/* Define to 1 if you have the <openssl/err.h> header file. */
+#undef HAVE_OPENSSL_ERR_H
+
+/* Define to 1 if you have the <openssl/ssl.h> header file. */
+#undef HAVE_OPENSSL_SSL_H
+
 /* Define to 1 if you have the <png.h> header file. */
 #undef HAVE_PNG_H
 
+/* Define to 1 if you have the `putenv' function. */
+#undef HAVE_PUTENV
+
+/* Define to 1 if you have the `setenv' function. */
+#undef HAVE_SETENV
+
+/* Define to 1 if you have the `setlocale' function. */
+#undef HAVE_SETLOCALE
+
 /* Define to 1 if you have the `setsockopt' function. */
 #undef HAVE_SETSOCKOPT
 
+/* Define to 1 if you have the <stddef.h> header file. */
+#undef HAVE_STDDEF_H
+
 /* Define to 1 if you have the <stdint.h> header file. */
 #undef HAVE_STDINT_H
 
+/* Define if <stdint.h> exists, doesn't clash with <sys/types.h>, and declares
+   uintmax_t. */
+#undef HAVE_STDINT_H_WITH_UINTMAX
+
 /* Define to 1 if you have the <stdlib.h> header file. */
 #undef HAVE_STDLIB_H
 
+/* Define as 1 if you have stpcpy() function. */
+#undef HAVE_STPCPY
+
+/* Define to 1 if you have the `strcasecmp' function. */
+#undef HAVE_STRCASECMP
+
+/* Define to 1 if you have the `strdup' function. */
+#undef HAVE_STRDUP
+
 /* Define to 1 if you have the <strings.h> header file. */
 #undef HAVE_STRINGS_H
 
 /* Define to 1 if you have the <string.h> header file. */
 #undef HAVE_STRING_H
 
+/* Define to 1 if you have the `strtoul' function. */
+#undef HAVE_STRTOUL
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#undef HAVE_SYS_PARAM_H
+
 /* Define to 1 if you have the <sys/stat.h> header file. */
 #undef HAVE_SYS_STAT_H
 
@@ -60,9 +195,30 @@
 /* Define to 1 if you have the <sys/uio.h> header file. */
 #undef HAVE_SYS_UIO_H
 
+/* Define to 1 if you have the `tsearch' function. */
+#undef HAVE_TSEARCH
+
 /* Define to 1 if you have the <unistd.h> header file. */
 #undef HAVE_UNISTD_H
 
+/* Define if you have the unsigned long long type. */
+#undef HAVE_UNSIGNED_LONG_LONG
+
+/* Define to 1 if you have the `__argz_count' function. */
+#undef HAVE___ARGZ_COUNT
+
+/* Define to 1 if you have the `__argz_next' function. */
+#undef HAVE___ARGZ_NEXT
+
+/* Define to 1 if you have the `__argz_stringify' function. */
+#undef HAVE___ARGZ_STRINGIFY
+
+/* Define as const if the declaration of iconv() needs const. */
+#undef ICONV_CONST
+
+/* Define if integer division by zero raises signal SIGFPE. */
+#undef INTDIV0_RAISES_SIGFPE
+
 /* Name of package */
 #undef PACKAGE
 
@@ -81,8 +237,36 @@
 /* Define to the version of this package. */
 #undef PACKAGE_VERSION
 
+/* Define if <inttypes.h> exists and defines unusable PRI* macros. */
+#undef PRI_MACROS_BROKEN
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at run-time.
+        STACK_DIRECTION > 0 => grows toward higher addresses
+        STACK_DIRECTION < 0 => grows toward lower addresses
+        STACK_DIRECTION = 0 => direction of growth unknown */
+#undef STACK_DIRECTION
+
 /* Define to 1 if you have the ANSI C header files. */
 #undef STDC_HEADERS
 
 /* Version number of package */
 #undef VERSION
+
+/* Define to empty if `const' does not conform to ANSI C. */
+#undef const
+
+/* Define as `__inline' if that's what the C compiler calls it, or to nothing
+   if it is not supported. */
+#undef inline
+
+/* Define to `long' if <sys/types.h> does not define. */
+#undef off_t
+
+/* Define to `unsigned' if <sys/types.h> does not define. */
+#undef size_t
+
+/* Define to unsigned long or unsigned long long if <inttypes.h> and
+   <stdint.h> don't define. */
+#undef uintmax_t
diff -Nur dillo-0.8.0/config.rpath dillo-0.8.0.new/config.rpath
--- dillo-0.8.0/config.rpath	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/config.rpath	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,513 @@
+#! /bin/sh
+# Output a system dependent set of variables, describing how to set the
+# run time search path of shared libraries in an executable.
+#
+#   Copyright 1996-2002 Free Software Foundation, Inc.
+#   Taken from GNU libtool, 2001
+#   Originally by Gordon Matzigkeit <gord@gnu.ai.mit.edu>, 1996
+#
+#   This program is free software; you can redistribute it and/or modify
+#   it under the terms of the GNU General Public License as published by
+#   the Free Software Foundation; either version 2 of the License, or
+#   (at your option) any later version.
+#
+#   This program is distributed in the hope that it will be useful, but
+#   WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   General Public License for more details.
+#
+#   You should have received a copy of the GNU General Public License
+#   along with this program; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+#
+#   As a special exception to the GNU General Public License, if you
+#   distribute this file as part of a program that contains a
+#   configuration script generated by Autoconf, you may include it under
+#   the same distribution terms that you use for the rest of that program.
+#
+# The first argument passed to this file is the canonical host specification,
+#    CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or
+#    CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# The environment variables CC, GCC, LDFLAGS, LD, with_gnu_ld
+# should be set by the caller.
+#
+# The set of defined variables is at the end of this script.
+
+# All known linkers require a `.a' archive for static linking (except M$VC,
+# which needs '.lib').
+libext=a
+shlibext=
+
+host="$1"
+host_cpu=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\1/'`
+host_vendor=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\2/'`
+host_os=`echo "$host" | sed 's/^\([^-]*\)-\([^-]*\)-\(.*\)$/\3/'`
+
+wl=
+if test "$GCC" = yes; then
+  wl='-Wl,'
+else
+  case "$host_os" in
+    aix3* | aix4* | aix5*)
+      wl='-Wl,'
+      ;;
+    hpux9* | hpux10* | hpux11*)
+      wl='-Wl,'
+      ;;
+    irix5* | irix6*)
+      wl='-Wl,'
+      ;;
+    linux*)
+      echo '__INTEL_COMPILER' > conftest.$ac_ext
+      if $CC -E conftest.$ac_ext >/dev/null | grep __INTEL_COMPILER >/dev/null
+      then
+        :
+      else
+        # Intel icc
+        wl='-Qoption,ld,'
+      fi
+      ;;
+    osf3* | osf4* | osf5*)
+      wl='-Wl,'
+      ;;
+    solaris*)
+      wl='-Wl,'
+      ;;
+    sunos4*)
+      wl='-Qoption ld '
+      ;;
+    sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+      if test "x$host_vendor" = xsni; then
+        wl='-LD'
+      else
+        wl='-Wl,'
+      fi
+      ;;
+  esac
+fi
+
+hardcode_libdir_flag_spec=
+hardcode_libdir_separator=
+hardcode_direct=no
+hardcode_minus_L=no
+
+case "$host_os" in
+  cygwin* | mingw* | pw32*)
+    # FIXME: the MSVC++ port hasn't been tested in a loooong time
+    # When not using gcc, we currently assume that we are using
+    # Microsoft Visual C++.
+    if test "$GCC" != yes; then
+      with_gnu_ld=no
+    fi
+    ;;
+  openbsd*)
+    with_gnu_ld=no
+    ;;
+esac
+
+ld_shlibs=yes
+if test "$with_gnu_ld" = yes; then
+  case "$host_os" in
+    aix3* | aix4* | aix5*)
+      # On AIX, the GNU linker is very broken
+      ld_shlibs=no
+      ;;
+    amigaos*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      # Samuel A. Falvo II <kc5tja@dolphin.openprojects.net> reports
+      # that the semantics of dynamic libraries on AmigaOS, at least up
+      # to version 4, is to share data among multiple programs linked
+      # with the same dynamic library.  Since this doesn't match the
+      # behavior of shared libraries on other platforms, we can use
+      # them.
+      ld_shlibs=no
+      ;;
+    beos*)
+      if $LD --help 2>&1 | egrep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    cygwin* | mingw* | pw32*)
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec='-L$libdir'
+      ;;
+    solaris* | sysv5*)
+      if $LD -v 2>&1 | egrep 'BFD 2\.8' > /dev/null; then
+        ld_shlibs=no
+      elif $LD --help 2>&1 | egrep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+    sunos4*)
+      hardcode_direct=yes
+      ;;
+    *)
+      if $LD --help 2>&1 | egrep ': supported targets:.* elf' > /dev/null; then
+        :
+      else
+        ld_shlibs=no
+      fi
+      ;;
+  esac
+  if test "$ld_shlibs" = yes; then
+    hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+  fi
+else
+  case "$host_os" in
+    aix3*)
+      # Note: this linker hardcodes the directories in LIBPATH if there
+      # are no directories specified by -L.
+      hardcode_minus_L=yes
+      if test "$GCC" = yes; then
+        # Neither direct hardcoding nor static linking is supported with a
+        # broken collect2.
+        hardcode_direct=unsupported
+      fi
+      ;;
+    aix4* | aix5*)
+      if test "$host_cpu" = ia64; then
+        # On IA64, the linker does run time linking by default, so we don't
+        # have to do anything special.
+        aix_use_runtimelinking=no
+      else
+        aix_use_runtimelinking=no
+        # Test if we are trying to use run time linking or normal
+        # AIX style linking. If -brtl is somewhere in LDFLAGS, we
+        # need to do runtime linking.
+        case $host_os in aix4.[23]|aix4.[23].*|aix5*)
+          for ld_flag in $LDFLAGS; do
+            if (test $ld_flag = "-brtl" || test $ld_flag = "-Wl,-brtl"); then
+              aix_use_runtimelinking=yes
+              break
+            fi
+          done
+        esac
+      fi
+      hardcode_direct=yes
+      hardcode_libdir_separator=':'
+      if test "$GCC" = yes; then
+        case $host_os in aix4.[012]|aix4.[012].*)
+          collect2name=`${CC} -print-prog-name=collect2`
+          if test -f "$collect2name" && \
+            strings "$collect2name" | grep resolve_lib_name >/dev/null
+          then
+            # We have reworked collect2
+            hardcode_direct=yes
+          else
+            # We have old collect2
+            hardcode_direct=unsupported
+            hardcode_minus_L=yes
+            hardcode_libdir_flag_spec='-L$libdir'
+            hardcode_libdir_separator=
+          fi
+        esac
+      fi
+      if test "$aix_use_runtimelinking" = yes; then
+        hardcode_libdir_flag_spec='${wl}-blibpath:$libdir:/usr/lib:/lib'
+      else
+        if test "$host_cpu" = ia64; then
+          hardcode_libdir_flag_spec='${wl}-R $libdir:/usr/lib:/lib'
+        else
+          hardcode_libdir_flag_spec='${wl}-bnolibpath ${wl}-blibpath:$libdir:/usr/lib:/lib'
+        fi
+      fi
+      ;;
+    amigaos*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      # see comment about different semantics on the GNU ld section
+      ld_shlibs=no
+      ;;
+    cygwin* | mingw* | pw32*)
+      # When not using gcc, we currently assume that we are using
+      # Microsoft Visual C++.
+      # hardcode_libdir_flag_spec is actually meaningless, as there is
+      # no search path for DLLs.
+      hardcode_libdir_flag_spec=' '
+      libext=lib
+      ;;
+    darwin* | rhapsody*)
+      hardcode_direct=yes
+      ;;
+    freebsd1*)
+      ld_shlibs=no
+      ;;
+    freebsd2.2*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    freebsd2*)
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      ;;
+    freebsd*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    hpux9* | hpux10* | hpux11*)
+      hardcode_libdir_flag_spec='${wl}+b ${wl}$libdir'
+      hardcode_libdir_separator=:
+      hardcode_direct=yes
+      hardcode_minus_L=yes # Not in the search PATH, but as the default
+                           # location of the library.
+      ;;
+    irix5* | irix6*)
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    netbsd*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      hardcode_direct=yes
+      ;;
+    newsos6)
+      hardcode_direct=yes
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    openbsd*)
+      hardcode_direct=yes
+      if test -z "`echo __ELF__ | $CC -E - | grep __ELF__`" || test "$host_os-$host_cpu" = "openbsd2.8-powerpc"; then
+        hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+      else
+        case "$host_os" in
+          openbsd[01].* | openbsd2.[0-7] | openbsd2.[0-7].*)
+            hardcode_libdir_flag_spec='-R$libdir'
+            ;;
+          *)
+            hardcode_libdir_flag_spec='${wl}-rpath,$libdir'
+            ;;
+        esac
+      fi
+      ;;
+    os2*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_minus_L=yes
+      ;;
+    osf3*)
+      hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      hardcode_libdir_separator=:
+      ;;
+    osf4* | osf5*)
+      if test "$GCC" = yes; then
+        hardcode_libdir_flag_spec='${wl}-rpath ${wl}$libdir'
+      else
+        # Both cc and cxx compiler support -rpath directly
+        hardcode_libdir_flag_spec='-rpath $libdir'
+      fi
+      hardcode_libdir_separator=:
+      ;;
+    sco3.2v5*)
+      ;;
+    solaris*)
+      hardcode_libdir_flag_spec='-R$libdir'
+      ;;
+    sunos4*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      hardcode_direct=yes
+      hardcode_minus_L=yes
+      ;;
+    sysv4)
+      if test "x$host_vendor" = xsno; then
+        hardcode_direct=yes # is this really true???
+      else
+        hardcode_direct=no # Motorola manual says yes, but my tests say they lie
+      fi
+      ;;
+    sysv4.3*)
+      ;;
+    sysv5*)
+      hardcode_libdir_flag_spec=
+      ;;
+    uts4*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      ;;
+    dgux*)
+      hardcode_libdir_flag_spec='-L$libdir'
+      ;;
+    sysv4*MP*)
+      if test -d /usr/nec; then
+        ld_shlibs=yes
+      fi
+      ;;
+    sysv4.2uw2*)
+      hardcode_direct=yes
+      hardcode_minus_L=no
+      ;;
+    sysv5uw7* | unixware7*)
+      ;;
+    *)
+      ld_shlibs=no
+      ;;
+  esac
+fi
+
+# Check dynamic linker characteristics
+libname_spec='lib$name'
+sys_lib_dlsearch_path_spec="/lib /usr/lib"
+sys_lib_search_path_spec="/lib /usr/lib /usr/local/lib"
+case "$host_os" in
+  aix3*)
+    shlibext=so
+    ;;
+  aix4* | aix5*)
+    shlibext=so
+    ;;
+  amigaos*)
+    shlibext=ixlibrary
+    ;;
+  beos*)
+    shlibext=so
+    ;;
+  bsdi4*)
+    shlibext=so
+    sys_lib_search_path_spec="/shlib /usr/lib /usr/X11/lib /usr/contrib/lib /lib /usr/local/lib"
+    sys_lib_dlsearch_path_spec="/shlib /usr/lib /usr/local/lib"
+    ;;
+  cygwin* | mingw* | pw32*)
+    case $GCC,$host_os in
+      yes,cygwin*)
+        shlibext=dll.a
+        ;;
+      yes,mingw*)
+        shlibext=dll
+        sys_lib_search_path_spec=`$CC -print-search-dirs | grep "^libraries:" | sed -e "s/^libraries://" -e "s/;/ /g"`
+        ;;
+      yes,pw32*)
+        shlibext=dll
+        ;;
+      *)
+        shlibext=dll
+        ;;
+    esac
+    ;;
+  darwin* | rhapsody*)
+    shlibext=dylib
+    ;;
+  freebsd1*)
+    ;;
+  freebsd*)
+    shlibext=so
+    ;;
+  gnu*)
+    shlibext=so
+    ;;
+  hpux9* | hpux10* | hpux11*)
+    shlibext=sl
+    ;;
+  irix5* | irix6*)
+    shlibext=so
+    case "$host_os" in
+      irix5*)
+        libsuff= shlibsuff=
+        ;;
+      *)
+        case $LD in
+          *-32|*"-32 ") libsuff= shlibsuff= ;;
+          *-n32|*"-n32 ") libsuff=32 shlibsuff=N32 ;;
+          *-64|*"-64 ") libsuff=64 shlibsuff=64 ;;
+          *) libsuff= shlibsuff= ;;
+        esac
+        ;;
+    esac
+    sys_lib_search_path_spec="/usr/lib${libsuff} /lib${libsuff} /usr/local/lib${libsuff}"
+    sys_lib_dlsearch_path_spec="/usr/lib${libsuff} /lib${libsuff}"
+    ;;
+  linux-gnuoldld* | linux-gnuaout* | linux-gnucoff*)
+    ;;
+  linux-gnu*)
+    shlibext=so
+    ;;
+  netbsd*)
+    shlibext=so
+    ;;
+  newsos6)
+    shlibext=so
+    ;;
+  openbsd*)
+    shlibext=so
+    ;;
+  os2*)
+    libname_spec='$name'
+    shlibext=dll
+    ;;
+  osf3* | osf4* | osf5*)
+    shlibext=so
+    sys_lib_search_path_spec="/usr/shlib /usr/ccs/lib /usr/lib/cmplrs/cc /usr/lib /usr/local/lib /var/shlib"
+    sys_lib_dlsearch_path_spec="$sys_lib_search_path_spec"
+    ;;
+  sco3.2v5*)
+    shlibext=so
+    ;;
+  solaris*)
+    shlibext=so
+    ;;
+  sunos4*)
+    shlibext=so
+    ;;
+  sysv4 | sysv4.2uw2* | sysv4.3* | sysv5*)
+    shlibext=so
+    case "$host_vendor" in
+      motorola)
+        sys_lib_search_path_spec='/lib /usr/lib /usr/ccs/lib'
+        ;;
+    esac
+    ;;
+  uts4*)
+    shlibext=so
+    ;;
+  dgux*)
+    shlibext=so
+    ;;
+  sysv4*MP*)
+    if test -d /usr/nec; then
+      shlibext=so
+    fi
+    ;;
+esac
+
+sed_quote_subst='s/\(["`$\\]\)/\\\1/g'
+escaped_wl=`echo "X$wl" | sed -e 's/^X//' -e "$sed_quote_subst"`
+escaped_hardcode_libdir_flag_spec=`echo "X$hardcode_libdir_flag_spec" | sed -e 's/^X//' -e "$sed_quote_subst"`
+escaped_sys_lib_search_path_spec=`echo "X$sys_lib_search_path_spec" | sed -e 's/^X//' -e "$sed_quote_subst"`
+escaped_sys_lib_dlsearch_path_spec=`echo "X$sys_lib_dlsearch_path_spec" | sed -e 's/^X//' -e "$sed_quote_subst"`
+
+sed -e 's/^\([a-zA-Z0-9_]*\)=/acl_cv_\1=/' <<EOF
+
+# How to pass a linker flag through the compiler.
+wl="$escaped_wl"
+
+# Static library suffix (normally "a").
+libext="$libext"
+
+# Shared library suffix (normally "so").
+shlibext="$shlibext"
+
+# Flag to hardcode \$libdir into a binary during linking.
+# This must work even if \$libdir does not exist.
+hardcode_libdir_flag_spec="$escaped_hardcode_libdir_flag_spec"
+
+# Whether we need a single -rpath flag with a separated argument.
+hardcode_libdir_separator="$hardcode_libdir_separator"
+
+# Set to yes if using DIR/libNAME.so during linking hardcodes DIR into the
+# resulting binary.
+hardcode_direct="$hardcode_direct"
+
+# Set to yes if using the -LDIR flag during linking hardcodes DIR into the
+# resulting binary.
+hardcode_minus_L="$hardcode_minus_L"
+
+# Compile-time system search path for libraries
+sys_lib_search_path_spec="$escaped_sys_lib_search_path_spec"
+
+# Run-time system search path for libraries
+sys_lib_dlsearch_path_spec="$escaped_sys_lib_dlsearch_path_spec"
+
+EOF
diff -Nur dillo-0.8.0/config.sub dillo-0.8.0.new/config.sub
--- dillo-0.8.0/config.sub	2003-09-21 23:02:39.000000000 +0000
+++ dillo-0.8.0.new/config.sub	2004-10-13 01:13:29.000000000 +0000
@@ -3,7 +3,7 @@
 #   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
 #   2000, 2001, 2002, 2003 Free Software Foundation, Inc.
 
-timestamp='2003-08-18'
+timestamp='2003-02-03'
 
 # This file is (in principle) common to ALL GNU software.
 # The presence of a machine in this file suggests that SOME GNU software
@@ -118,7 +118,7 @@
 # Here we must recognize all the valid KERNEL-OS combinations.
 maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
 case $maybe_os in
-  nto-qnx* | linux-gnu* | linux-dietlibc | kfreebsd*-gnu* | netbsd*-gnu* | storm-chaos* | os2-emx* | rtmk-nova*)
+  nto-qnx* | linux-gnu* | freebsd*-gnu* | netbsd*-gnu* | storm-chaos* | os2-emx* | rtmk-nova*)
     os=-$maybe_os
     basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
     ;;
@@ -228,14 +228,13 @@
 	| a29k \
 	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
 	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
-	| am33_2.0 \
 	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr \
-	| c4x | clipper \
+	| clipper \
 	| d10v | d30v | dlx | dsp16xx \
 	| fr30 | frv \
 	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
 	| i370 | i860 | i960 | ia64 \
-	| ip2k | iq2000 \
+	| ip2k \
 	| m32r | m68000 | m68k | m88k | mcore \
 	| mips | mipsbe | mipseb | mipsel | mipsle \
 	| mips16 \
@@ -262,7 +261,7 @@
 	| sh64 | sh64le \
 	| sparc | sparc64 | sparc86x | sparclet | sparclite | sparcv9 | sparcv9b \
 	| strongarm \
-	| tahoe | thumb | tic4x | tic80 | tron \
+	| tahoe | thumb | tic80 | tron \
 	| v850 | v850e \
 	| we32k \
 	| x86 | xscale | xstormy16 | xtensa \
@@ -305,7 +304,7 @@
 	| h8300-* | h8500-* \
 	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
 	| i*86-* | i860-* | i960-* | ia64-* \
-	| ip2k-* | iq2000-* \
+	| ip2k-* \
 	| m32r-* \
 	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
 	| m88110-* | m88k-* | mcore-* \
@@ -374,9 +373,6 @@
 		basic_machine=a29k-none
 		os=-bsd
 		;;
-	amd64)
-		basic_machine=x86_64-pc
-		;;
 	amdahl)
 		basic_machine=580-amdahl
 		os=-sysv
@@ -772,24 +768,18 @@
 	pentiumpro | p6 | 6x86 | athlon | athlon_*)
 		basic_machine=i686-pc
 		;;
-	pentiumii | pentium2 | pentiumiii | pentium3)
+	pentiumii | pentium2)
 		basic_machine=i686-pc
 		;;
-	pentium4)
-		basic_machine=i786-pc
-		;;
 	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
 		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	pentiumpro-* | p6-* | 6x86-* | athlon-*)
 		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
-	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
+	pentiumii-* | pentium2-*)
 		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
-	pentium4-*)
-		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
 	pn)
 		basic_machine=pn-gould
 		;;
@@ -848,10 +838,6 @@
 	sb1el)
 		basic_machine=mipsisa64sb1el-unknown
 		;;
-	sei)
-		basic_machine=mips-sei
-		os=-seiux
-		;;
 	sequent)
 		basic_machine=i386-sequent
 		;;
@@ -859,9 +845,6 @@
 		basic_machine=sh-hitachi
 		os=-hms
 		;;
-	sh64)
-		basic_machine=sh64-unknown
-		;;
 	sparclite-wrs | simso-wrs)
 		basic_machine=sparclite-wrs
 		os=-vxworks
@@ -936,6 +919,10 @@
 		basic_machine=t90-cray
 		os=-unicos
 		;;
+        tic4x | c4x*)
+		basic_machine=tic4x-unknown
+		os=-coff
+		;;
 	tic54x | c54x*)
 		basic_machine=tic54x-unknown
 		os=-coff
@@ -1129,7 +1116,7 @@
 	      | -aos* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
-	      | -hiux* | -386bsd* | -netbsd* | -openbsd* | -kfreebsd* | -freebsd* | -riscix* \
+	      | -hiux* | -386bsd* | -netbsd* | -openbsd* | -freebsd* | -riscix* \
 	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
 	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
@@ -1141,7 +1128,7 @@
 	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
 	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
 	      | -morphos* | -superux* | -rtmk* | -rtmk-nova* | -windiss* \
-	      | -powermax* | -dnix* | -nx6 | -nx7 | -sei*)
+	      | -powermax* | -dnix* | -microbsd*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
 	-qnx*)
@@ -1165,9 +1152,6 @@
 	-mac*)
 		os=`echo $os | sed -e 's|mac|macos|'`
 		;;
-	-linux-dietlibc)
-		os=-linux-dietlibc
-		;;
 	-linux*)
 		os=`echo $os | sed -e 's|linux|linux-gnu|'`
 		;;
@@ -1290,9 +1274,6 @@
 	arm*-semi)
 		os=-aout
 		;;
-    c4x-* | tic4x-*)
-        os=-coff
-        ;;
 	# This must come before the *-dec entry.
 	pdp10-*)
 		os=-tops20
diff -Nur dillo-0.8.0/configure dillo-0.8.0.new/configure
--- dillo-0.8.0/configure	2004-02-08 12:56:17.000000000 +0000
+++ dillo-0.8.0.new/configure	2004-10-13 01:20:02.000000000 +0000
@@ -308,7 +308,7 @@
 # include <unistd.h>
 #endif"
 
-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO AMTAR install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM AWK SET_MAKE am__leading_dot CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE RANLIB ac_ct_RANLIB CPP GLIB_CONFIG GLIB_CFLAGS GLIB_LIBS GTK_CONFIG GTK_CFLAGS GTK_LIBS EGREP LIBJPEG_LIBS LIBJPEG_LDFLAGS LIBJPEG_CPPFLAGS LIBPNG_LIBS LIBPNG_CFLAGS LIBZ_LIBS src doc bin util lib LIBOBJS LTLIBOBJS'
+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os INSTALL_PROGRAM INSTALL_SCRIPT INSTALL_DATA CYGPATH_W PACKAGE VERSION ACLOCAL AUTOCONF AUTOMAKE AUTOHEADER MAKEINFO AMTAR install_sh STRIP ac_ct_STRIP INSTALL_STRIP_PROGRAM AWK SET_MAKE am__leading_dot CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT DEPDIR am__include am__quote AMDEP_TRUE AMDEP_FALSE AMDEPBACKSLASH CCDEPMODE am__fastdepCC_TRUE am__fastdepCC_FALSE RANLIB ac_ct_RANLIB CPP MKINSTALLDIRS MSGFMT GMSGFMT XGETTEXT MSGMERGE EGREP ALLOCA GLIBC21 LIBICONV LTLIBICONV INTLBISON USE_NLS BUILD_INCLUDED_LIBINTL USE_INCLUDED_LIBINTL CATOBJEXT INTLOBJS DATADIRNAME INSTOBJEXT GENCAT INTL_LIBTOOL_SUFFIX_PREFIX INTLLIBS LIBINTL LTLIBINTL POSUB localedir GLIB_CONFIG GLIB_CFLAGS GLIB_LIBS GTK_CONFIG GTK_CFLAGS GTK_LIBS KRB5_CONFIG XFT_CONFIG LIBJPEG_LIBS LIBJPEG_LDFLAGS LIBJPEG_CPPFLAGS LIBPNG_LIBS LIBPNG_CFLAGS LIBZ_LIBS LIBICONV_CFLAGS LIBICONV_LIBS src doc bin util lib LIBOBJS LTLIBOBJS'
 ac_subst_files=''
 
 # Initialize some variables set by options.
@@ -853,14 +853,21 @@
   --enable-gprof          Try to compile and run with profiling enabled
   --enable-insure         Try to compile and run with Insure++
   --enable-ansi           Try to compile and run with ANSI flags
+  --disable-tabs          Don't compile support for tabs
+  --disable-anti-alias    Don't compile support for anti-alias
   --enable-ipv6           Build with support for IPv6
   --enable-rtfl           Build with rtfl messages
   --disable-cookies       Don't compile support for cookies
   --disable-png           Disable support for PNG images
   --disable-jpeg          Disable support for JPEG images
   --disable-gif           Disable support for GIF images
+  --disable-ssl           Don't compile support for SSL
+  --enable-meta-refresh   Allow meta refresh
+  --enable-user-agent           Build with UserAgentBox.
   --disable-dependency-tracking Speeds up one-time builds
   --enable-dependency-tracking  Do not reject slow dependency extractors
+  --disable-rpath         do not hardcode runtime library paths
+  --disable-nls           do not use Native Language Support
   --disable-glibtest       Do not try to compile and run a test GLIB program
   --disable-gtktest       Do not try to compile and run a test GTK program
 
@@ -869,6 +876,13 @@
   --without-PACKAGE       do not use PACKAGE (same as --with-PACKAGE=no)
   --with-jpeg-lib=DIR     Specify where to find libjpeg
   --with-jpeg-inc=DIR     Specify where to find libjpeg's headers
+  --with-krb5-inc=DIR     Specify where to find Kerberos V's headers
+  --with-gnu-ld           assume the C compiler uses GNU ld default=no
+  --with-libiconv-prefix=DIR  search for libiconv in DIR/include and DIR/lib
+  --without-libiconv-prefix     don't search for libiconv in includedir and libdir
+  --with-included-gettext use the GNU gettext library included here
+  --with-libintl-prefix=DIR  search for libintl in DIR/include and DIR/lib
+  --without-libintl-prefix     don't search for libintl in includedir and libdir
   --with-glib-prefix=PFX   Prefix where GLIB is installed (optional)
   --with-glib-exec-prefix=PFX Exec prefix where GLIB is installed (optional)
   --with-gtk-prefix=PFX   Prefix where GTK is installed (optional)
@@ -1646,7 +1660,7 @@
 
 # Define the identity of the package.
  PACKAGE=dillo
- VERSION=0.8.0
+ VERSION=0.8.0-i18n-misc-20040613
 
 
 cat >>confdefs.h <<_ACEOF
@@ -1789,12 +1803,18 @@
   LIBJPEG_INCDIR=$withval
 fi;
 
+# Check whether --with-krb5-inc or --without-krb5-inc was given.
+if test "${with_krb5_inc+set}" = set; then
+  withval="$with_krb5_inc"
+  KRB5_INCDIR=$withval
+fi;
+
 # Check whether --enable-efence or --disable-efence was given.
 if test "${enable_efence+set}" = set; then
   enableval="$enable_efence"
 
 else
-  enable_fence=no
+  enable_efence=no
 fi;
 # Check whether --enable-gprof or --disable-gprof was given.
 if test "${enable_gprof+set}" = set; then
@@ -1817,6 +1837,20 @@
 else
   enable_ansi=no
 fi;
+# Check whether --enable-tabs or --disable-tabs was given.
+if test "${enable_tabs+set}" = set; then
+  enableval="$enable_tabs"
+
+else
+  enable_tabs=yes
+fi;
+# Check whether --enable-anti_alias or --disable-anti_alias was given.
+if test "${enable_anti_alias+set}" = set; then
+  enableval="$enable_anti_alias"
+
+else
+  enable_anti_alias=yes
+fi;
 # Check whether --enable-ipv6 or --disable-ipv6 was given.
 if test "${enable_ipv6+set}" = set; then
   enableval="$enable_ipv6"
@@ -1855,6 +1889,27 @@
 else
   enable_gif=yes
 fi;
+# Check whether --enable-ssl or --disable-ssl was given.
+if test "${enable_ssl+set}" = set; then
+  enableval="$enable_ssl"
+
+else
+  enable_ssl=yes
+fi;
+# Check whether --enable-meta_refresh or --disable-meta_refresh was given.
+if test "${enable_meta_refresh+set}" = set; then
+  enableval="$enable_meta_refresh"
+
+else
+  enable_meta_refresh=no
+fi;
+# Check whether --enable-user_agent or --disable-user_agent was given.
+if test "${enable_user_agent+set}" = set; then
+  enableval="$enable_user_agent"
+
+else
+  use_useragent=no
+fi;
 
 ac_ext=c
 ac_cpp='$CPP $CPPFLAGS'
@@ -2730,9 +2785,8 @@
 
 am_make=${MAKE-make}
 cat > confinc << 'END'
-am__doit:
+doit:
 	@echo done
-.PHONY: am__doit
 END
 # If we don't find an include directive, just comment out the code.
 echo "$as_me:$LINENO: checking for style of include used by $am_make" >&5
@@ -2807,32 +2861,18 @@
   # using a relative directory.
   cp "$am_depcomp" conftest.dir
   cd conftest.dir
-  # We will build objects and dependencies in a subdirectory because
-  # it helps to detect inapplicable dependency modes.  For instance
-  # both Tru64's cc and ICC support -MD to output dependencies as a
-  # side effect of compilation, but ICC will put the dependencies in
-  # the current directory while Tru64 will put them in the object
-  # directory.
-  mkdir sub
 
   am_cv_CC_dependencies_compiler_type=none
   if test "$am_compiler_list" = ""; then
      am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
   fi
   for depmode in $am_compiler_list; do
-    # Setup a source with many dependencies, because some compilers
-    # like to wrap large dependency lists on column 80 (with \), and
-    # we should not choose a depcomp mode which is confused by this.
-    #
     # We need to recreate these files for each test, as the compiler may
     # overwrite some of them when testing with obscure command lines.
     # This happens at least with the AIX C compiler.
-    : > sub/conftest.c
-    for i in 1 2 3 4 5 6; do
-      echo '#include "conftst'$i'.h"' >> sub/conftest.c
-      : > sub/conftst$i.h
-    done
-    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+    echo '#include "conftest.h"' > conftest.c
+    echo 'int i;' > conftest.h
+    echo "${am__include} ${am__quote}conftest.Po${am__quote}" > confmf
 
     case $depmode in
     nosideeffect)
@@ -2850,12 +2890,11 @@
     # mode.  It turns out that the SunPro C++ compiler does not properly
     # handle `-M -o', and we need to detect this.
     if depmode=$depmode \
-       source=sub/conftest.c object=sub/conftest.${OBJEXT-o} \
-       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
-       $SHELL ./depcomp $depcc -c -o sub/conftest.${OBJEXT-o} sub/conftest.c \
+       source=conftest.c object=conftest.o \
+       depfile=conftest.Po tmpdepfile=conftest.TPo \
+       $SHELL ./depcomp $depcc -c -o conftest.o conftest.c \
          >/dev/null 2>conftest.err &&
-       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
-       grep sub/conftest.${OBJEXT-o} sub/conftest.Po > /dev/null 2>&1 &&
+       grep conftest.h conftest.Po > /dev/null 2>&1 &&
        ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
       # icc doesn't choke on unknown options, it will just issue warnings
       # (even with -Werror).  So we grep stderr for any message
@@ -3309,101 +3348,209 @@
 ac_compiler_gnu=$ac_cv_c_compiler_gnu
 
 
-if test "`$CPP -v < /dev/null 2>&1 | grep '/usr/local/include' 2>&1`" = ""; then
-  CPPFLAGS="$CPPFLAGS -I/usr/local/include"
-  LDFLAGS="$LDFLAGS -L/usr/local/lib"
-fi
+ALL_LINGUAS="ja"
 
+        MKINSTALLDIRS=
+  if test -n "$ac_aux_dir"; then
+    MKINSTALLDIRS="$ac_aux_dir/mkinstalldirs"
+  fi
+  if test -z "$MKINSTALLDIRS"; then
+    MKINSTALLDIRS="\$(top_srcdir)/mkinstalldirs"
+  fi
 
-for ac_func in gethostbyname
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-echo "$as_me:$LINENO: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
-if eval "test \"\${$as_ac_var+set}\" = set"; then
+
+
+
+
+        # Extract the first word of "msgfmt", so it can be a program name with args.
+set dummy msgfmt; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_MSGFMT+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
-#line $LINENO "configure"
-/* confdefs.h.  */
-_ACEOF
-cat confdefs.h >>conftest.$ac_ext
-cat >>conftest.$ac_ext <<_ACEOF
-/* end confdefs.h.  */
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-/* Override any gcc2 internal prototype to avoid an error.  */
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-/* We use char because int might match the return type of a gcc2
-   builtin and then its argument prototype would still apply.  */
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
-choke me
-#else
-char (*f) () = $ac_func;
-#endif
-#ifdef __cplusplus
-}
-#endif
+  case "$MSGFMT" in
+  /*)
+  ac_cv_path_MSGFMT="$MSGFMT" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if $ac_dir/$ac_word --statistics /dev/null >/dev/null 2>&1 &&
+     (if $ac_dir/$ac_word --statistics /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi); then
+	ac_cv_path_MSGFMT="$ac_dir/$ac_word"
+	break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_MSGFMT" && ac_cv_path_MSGFMT=":"
+  ;;
+esac
+fi
+MSGFMT="$ac_cv_path_MSGFMT"
+if test "$MSGFMT" != ":"; then
+  echo "$as_me:$LINENO: result: $MSGFMT" >&5
+echo "${ECHO_T}$MSGFMT" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
 
-int
-main ()
-{
-return f != $ac_func;
-  ;
-  return 0;
-}
-_ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-         { ac_try='test -s conftest$ac_exeext'
-  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
-  (eval $ac_try) 2>&5
-  ac_status=$?
-  echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); }; }; then
-  eval "$as_ac_var=yes"
+  # Extract the first word of "gmsgfmt", so it can be a program name with args.
+set dummy gmsgfmt; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_GMSGFMT+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  echo "$as_me: failed program was:" >&5
-sed 's/^/| /' conftest.$ac_ext >&5
+  case $GMSGFMT in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_GMSGFMT="$GMSGFMT" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_GMSGFMT="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
 
-eval "$as_ac_var=no"
+  test -z "$ac_cv_path_GMSGFMT" && ac_cv_path_GMSGFMT="$MSGFMT"
+  ;;
+esac
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+GMSGFMT=$ac_cv_path_GMSGFMT
+
+if test -n "$GMSGFMT"; then
+  echo "$as_me:$LINENO: result: $GMSGFMT" >&5
+echo "${ECHO_T}$GMSGFMT" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
 fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
-_ACEOF
 
+
+        # Extract the first word of "xgettext", so it can be a program name with args.
+set dummy xgettext; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_XGETTEXT+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case "$XGETTEXT" in
+  /*)
+  ac_cv_path_XGETTEXT="$XGETTEXT" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if $ac_dir/$ac_word --omit-header --copyright-holder= /dev/null >/dev/null 2>&1 &&
+     (if $ac_dir/$ac_word --omit-header --copyright-holder= /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi); then
+	ac_cv_path_XGETTEXT="$ac_dir/$ac_word"
+	break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_XGETTEXT" && ac_cv_path_XGETTEXT=":"
+  ;;
+esac
+fi
+XGETTEXT="$ac_cv_path_XGETTEXT"
+if test "$XGETTEXT" != ":"; then
+  echo "$as_me:$LINENO: result: $XGETTEXT" >&5
+echo "${ECHO_T}$XGETTEXT" >&6
 else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
 
-echo "$as_me:$LINENO: checking for gethostbyname in -lnsl" >&5
-echo $ECHO_N "checking for gethostbyname in -lnsl... $ECHO_C" >&6
-if test "${ac_cv_lib_nsl_gethostbyname+set}" = set; then
+    rm -f messages.po
+
+    # Extract the first word of "msgmerge", so it can be a program name with args.
+set dummy msgmerge; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_MSGMERGE+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case "$MSGMERGE" in
+  /*)
+  ac_cv_path_MSGMERGE="$MSGMERGE" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if $ac_dir/$ac_word --update -q /dev/null /dev/null >/dev/null 2>&1; then
+	ac_cv_path_MSGMERGE="$ac_dir/$ac_word"
+	break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+  test -z "$ac_cv_path_MSGMERGE" && ac_cv_path_MSGMERGE=":"
+  ;;
+esac
+fi
+MSGMERGE="$ac_cv_path_MSGMERGE"
+if test "$MSGMERGE" != ":"; then
+  echo "$as_me:$LINENO: result: $MSGMERGE" >&5
+echo "${ECHO_T}$MSGMERGE" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+
+      if test "$GMSGFMT" != ":"; then
+            if $GMSGFMT --statistics /dev/null >/dev/null 2>&1 &&
+       (if $GMSGFMT --statistics /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi); then
+      : ;
+    else
+      GMSGFMT=`echo "$GMSGFMT" | sed -e 's,^.*/,,'`
+      echo "$as_me:$LINENO: result: found $GMSGFMT program is not GNU msgfmt; ignore it" >&5
+echo "${ECHO_T}found $GMSGFMT program is not GNU msgfmt; ignore it" >&6
+      GMSGFMT=":"
+    fi
+  fi
+
+      if test "$XGETTEXT" != ":"; then
+            if $XGETTEXT --omit-header --copyright-holder= /dev/null >/dev/null 2>&1 &&
+       (if $XGETTEXT --omit-header --copyright-holder= /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi); then
+      : ;
+    else
+      echo "$as_me:$LINENO: result: found xgettext program is not GNU xgettext; ignore it" >&5
+echo "${ECHO_T}found xgettext program is not GNU xgettext; ignore it" >&6
+      XGETTEXT=":"
+    fi
+        rm -f messages.po
+  fi
+
+            ac_config_commands="$ac_config_commands default-1"
+
+
+
+        echo "$as_me:$LINENO: checking for strerror in -lcposix" >&5
+echo $ECHO_N "checking for strerror in -lcposix... $ECHO_C" >&6
+if test "${ac_cv_lib_cposix_strerror+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lnsl  $LIBS"
+LIBS="-lcposix  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
 /* confdefs.h.  */
@@ -3418,11 +3565,11 @@
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
-char gethostbyname ();
+char strerror ();
 int
 main ()
 {
-gethostbyname ();
+strerror ();
   ;
   return 0;
 }
@@ -3439,103 +3586,134 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_nsl_gethostbyname=yes
+  ac_cv_lib_cposix_strerror=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-ac_cv_lib_nsl_gethostbyname=no
+ac_cv_lib_cposix_strerror=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
-echo "${ECHO_T}$ac_cv_lib_nsl_gethostbyname" >&6
-if test $ac_cv_lib_nsl_gethostbyname = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBNSL 1
-_ACEOF
+echo "$as_me:$LINENO: result: $ac_cv_lib_cposix_strerror" >&5
+echo "${ECHO_T}$ac_cv_lib_cposix_strerror" >&6
+if test $ac_cv_lib_cposix_strerror = yes; then
+  LIBS="$LIBS -lcposix"
+fi
 
-  LIBS="-lnsl $LIBS"
 
+
+
+echo "$as_me:$LINENO: checking for egrep" >&5
+echo $ECHO_N "checking for egrep... $ECHO_C" >&6
+if test "${ac_cv_prog_egrep+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
 else
+  if echo a | (grep -E '(a|b)') >/dev/null 2>&1
+    then ac_cv_prog_egrep='grep -E'
+    else ac_cv_prog_egrep='egrep'
+    fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_prog_egrep" >&5
+echo "${ECHO_T}$ac_cv_prog_egrep" >&6
+ EGREP=$ac_cv_prog_egrep
 
-echo "$as_me:$LINENO: checking for gethostbyname in -lsocket" >&5
-echo $ECHO_N "checking for gethostbyname in -lsocket... $ECHO_C" >&6
-if test "${ac_cv_lib_socket_gethostbyname+set}" = set; then
+
+echo "$as_me:$LINENO: checking for ANSI C header files" >&5
+echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6
+if test "${ac_cv_header_stdc+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lsocket  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
+  cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <float.h>
 
-/* Override any gcc2 internal prototype to avoid an error.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-/* We use char because int might match the return type of a gcc2
-   builtin and then its argument prototype would still apply.  */
-char gethostbyname ();
 int
 main ()
 {
-gethostbyname ();
+
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest$ac_exeext'
+         { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_socket_gethostbyname=yes
+  ac_cv_header_stdc=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-ac_cv_lib_socket_gethostbyname=no
-fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
+ac_cv_header_stdc=no
 fi
-echo "$as_me:$LINENO: result: $ac_cv_lib_socket_gethostbyname" >&5
-echo "${ECHO_T}$ac_cv_lib_socket_gethostbyname" >&6
-if test $ac_cv_lib_socket_gethostbyname = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBSOCKET 1
-_ACEOF
+rm -f conftest.$ac_objext conftest.$ac_ext
 
-  LIBS="-lsocket $LIBS"
+if test $ac_cv_header_stdc = yes; then
+  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <string.h>
 
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "memchr" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
 fi
+rm -f conftest*
 
 fi
 
+if test $ac_cv_header_stdc = yes; then
+  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "free" >/dev/null 2>&1; then
+  :
+else
+  ac_cv_header_stdc=no
 fi
-done
+rm -f conftest*
 
+fi
 
-for ac_func in setsockopt
-do
-as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
-echo "$as_me:$LINENO: checking for $ac_func" >&5
-echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
-if eval "test \"\${$as_ac_var+set}\" = set"; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
+if test $ac_cv_header_stdc = yes; then
+  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
+  if test "$cross_compiling" = yes; then
+  :
 else
   cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
@@ -3544,81 +3722,70 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-/* System header to define __stub macros and hopefully few prototypes,
-    which can conflict with char $ac_func (); below.
-    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
-    <limits.h> exists even on freestanding compilers.  */
-#ifdef __STDC__
-# include <limits.h>
-#else
-# include <assert.h>
-#endif
-/* Override any gcc2 internal prototype to avoid an error.  */
-#ifdef __cplusplus
-extern "C"
-{
-#endif
-/* We use char because int might match the return type of a gcc2
-   builtin and then its argument prototype would still apply.  */
-char $ac_func ();
-/* The GNU C library defines this for functions which it implements
-    to always fail with ENOSYS.  Some functions are actually named
-    something starting with __ and the normal name is an alias.  */
-#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
-choke me
+#include <ctype.h>
+#if ((' ' & 0x0FF) == 0x020)
+# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
+# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
 #else
-char (*f) () = $ac_func;
-#endif
-#ifdef __cplusplus
-}
+# define ISLOWER(c) \
+                   (('a' <= (c) && (c) <= 'i') \
+                     || ('j' <= (c) && (c) <= 'r') \
+                     || ('s' <= (c) && (c) <= 'z'))
+# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
 #endif
 
+#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
 int
 main ()
 {
-return f != $ac_func;
-  ;
-  return 0;
+  int i;
+  for (i = 0; i < 256; i++)
+    if (XOR (islower (i), ISLOWER (i))
+        || toupper (i) != TOUPPER (i))
+      exit(2);
+  exit (0);
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
+rm -f conftest$ac_exeext
 if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
   (eval $ac_link) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } &&
-         { ac_try='test -s conftest$ac_exeext'
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  eval "$as_ac_var=yes"
+  :
 else
-  echo "$as_me: failed program was:" >&5
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-eval "$as_ac_var=no"
+( exit $ac_status )
+ac_cv_header_stdc=no
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
 fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
-if test `eval echo '${'$as_ac_var'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
+echo "${ECHO_T}$ac_cv_header_stdc" >&6
+if test $ac_cv_header_stdc = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define STDC_HEADERS 1
 _ACEOF
 
-else
+fi
 
-echo "$as_me:$LINENO: checking for setsockopt in -lsocket" >&5
-echo $ECHO_N "checking for setsockopt in -lsocket... $ECHO_C" >&6
-if test "${ac_cv_lib_socket_setsockopt+set}" = set; then
+echo "$as_me:$LINENO: checking for an ANSI C-conforming const" >&5
+echo $ECHO_N "checking for an ANSI C-conforming const... $ECHO_C" >&6
+if test "${ac_cv_c_const+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  ac_check_lib_save_LIBS=$LIBS
-LIBS="-lsocket  $LIBS"
-cat >conftest.$ac_ext <<_ACEOF
+  cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
@@ -3626,114 +3793,3838 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 
-/* Override any gcc2 internal prototype to avoid an error.  */
-#ifdef __cplusplus
-extern "C"
-#endif
-/* We use char because int might match the return type of a gcc2
-   builtin and then its argument prototype would still apply.  */
-char setsockopt ();
 int
 main ()
 {
-setsockopt ();
+/* FIXME: Include the comments suggested by Paul. */
+#ifndef __cplusplus
+  /* Ultrix mips cc rejects this.  */
+  typedef int charset[2];
+  const charset x;
+  /* SunOS 4.1.1 cc rejects this.  */
+  char const *const *ccp;
+  char **p;
+  /* NEC SVR4.0.2 mips cc rejects this.  */
+  struct point {int x, y;};
+  static struct point const zero = {0,0};
+  /* AIX XL C 1.02.0.0 rejects this.
+     It does not let you subtract one const X* pointer from another in
+     an arm of an if-expression whose if-part is not a constant
+     expression */
+  const char *g = "string";
+  ccp = &g + (g ? g-g : 0);
+  /* HPUX 7.0 cc rejects these. */
+  ++ccp;
+  p = (char**) ccp;
+  ccp = (char const *const *) p;
+  { /* SCO 3.2v4 cc rejects this.  */
+    char *t;
+    char const *s = 0 ? (char *) 0 : (char const *) 0;
+
+    *t++ = 0;
+  }
+  { /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
+    int x[] = {25, 17};
+    const int *foo = &x[0];
+    ++foo;
+  }
+  { /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
+    typedef const int *iptr;
+    iptr p = 0;
+    ++p;
+  }
+  { /* AIX XL C 1.02.0.0 rejects this saying
+       "k.c", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
+    struct s { int j; const int *ap[3]; };
+    struct s *b; b->j = 5;
+  }
+  { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
+    const int foo = 10;
+  }
+#endif
+
   ;
   return 0;
 }
 _ACEOF
-rm -f conftest.$ac_objext conftest$ac_exeext
-if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest$ac_exeext'
+         { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_socket_setsockopt=yes
+  ac_cv_c_const=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-ac_cv_lib_socket_setsockopt=no
+ac_cv_c_const=no
 fi
-rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
-LIBS=$ac_check_lib_save_LIBS
+rm -f conftest.$ac_objext conftest.$ac_ext
 fi
-echo "$as_me:$LINENO: result: $ac_cv_lib_socket_setsockopt" >&5
-echo "${ECHO_T}$ac_cv_lib_socket_setsockopt" >&6
-if test $ac_cv_lib_socket_setsockopt = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define HAVE_LIBSOCKET 1
-_ACEOF
+echo "$as_me:$LINENO: result: $ac_cv_c_const" >&5
+echo "${ECHO_T}$ac_cv_c_const" >&6
+if test $ac_cv_c_const = no; then
 
-  LIBS="-lsocket $LIBS"
+cat >>confdefs.h <<\_ACEOF
+#define const
+_ACEOF
 
 fi
 
+echo "$as_me:$LINENO: checking for inline" >&5
+echo $ECHO_N "checking for inline... $ECHO_C" >&6
+if test "${ac_cv_c_inline+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_c_inline=no
+for ac_kw in inline __inline__ __inline; do
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifndef __cplusplus
+typedef int foo_t;
+static $ac_kw foo_t static_foo () {return 0; }
+$ac_kw foo_t foo () {return 0; }
+#endif
+
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_inline=$ac_kw; break
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
 fi
+rm -f conftest.$ac_objext conftest.$ac_ext
 done
 
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_inline" >&5
+echo "${ECHO_T}$ac_cv_c_inline" >&6
+case $ac_cv_c_inline in
+  inline | yes) ;;
+  no)
+cat >>confdefs.h <<\_ACEOF
+#define inline
+_ACEOF
+ ;;
+  *)  cat >>confdefs.h <<_ACEOF
+#define inline $ac_cv_c_inline
+_ACEOF
+ ;;
+esac
 
+# On IRIX 5.3, sys/types and inttypes.h are conflicting.
 
-# Check whether --with-glib-prefix or --without-glib-prefix was given.
-if test "${with_glib_prefix+set}" = set; then
-  withval="$with_glib_prefix"
-  glib_config_prefix="$withval"
-else
-  glib_config_prefix=""
-fi;
 
-# Check whether --with-glib-exec-prefix or --without-glib-exec-prefix was given.
-if test "${with_glib_exec_prefix+set}" = set; then
-  withval="$with_glib_exec_prefix"
-  glib_config_exec_prefix="$withval"
-else
-  glib_config_exec_prefix=""
-fi;
-# Check whether --enable-glibtest or --disable-glibtest was given.
-if test "${enable_glibtest+set}" = set; then
-  enableval="$enable_glibtest"
 
-else
-  enable_glibtest=yes
-fi;
 
-  if test x$glib_config_exec_prefix != x ; then
-     glib_config_args="$glib_config_args --exec-prefix=$glib_config_exec_prefix"
-     if test x${GLIB_CONFIG+set} != xset ; then
-        GLIB_CONFIG=$glib_config_exec_prefix/bin/glib-config
-     fi
-  fi
-  if test x$glib_config_prefix != x ; then
-     glib_config_args="$glib_config_args --prefix=$glib_config_prefix"
-     if test x${GLIB_CONFIG+set} != xset ; then
-        GLIB_CONFIG=$glib_config_prefix/bin/glib-config
-     fi
-  fi
 
-  for module in .
-  do
-      case "$module" in
-         gmodule)
-             glib_config_args="$glib_config_args gmodule"
-         ;;
-         gthread)
-             glib_config_args="$glib_config_args gthread"
-         ;;
-      esac
-  done
 
-  # Extract the first word of "glib-config", so it can be a program name with args.
-set dummy glib-config; ac_word=$2
-echo "$as_me:$LINENO: checking for $ac_word" >&5
-echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
-if test "${ac_cv_path_GLIB_CONFIG+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
+
+
+
+for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
+                  inttypes.h stdint.h unistd.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_Header=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_Header=no"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+echo "$as_me:$LINENO: checking for off_t" >&5
+echo $ECHO_N "checking for off_t... $ECHO_C" >&6
+if test "${ac_cv_type_off_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if ((off_t *) 0)
+  return 0;
+if (sizeof (off_t))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_off_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_off_t=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_off_t" >&5
+echo "${ECHO_T}$ac_cv_type_off_t" >&6
+if test $ac_cv_type_off_t = yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define off_t long
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for size_t" >&5
+echo $ECHO_N "checking for size_t... $ECHO_C" >&6
+if test "${ac_cv_type_size_t+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+int
+main ()
+{
+if ((size_t *) 0)
+  return 0;
+if (sizeof (size_t))
+  return 0;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_size_t=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_size_t=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_size_t" >&5
+echo "${ECHO_T}$ac_cv_type_size_t" >&6
+if test $ac_cv_type_size_t = yes; then
+  :
+else
+
+cat >>confdefs.h <<_ACEOF
+#define size_t unsigned
+_ACEOF
+
+fi
+
+# The Ultrix 4.2 mips builtin alloca declared by alloca.h only works
+# for constant arguments.  Useless!
+echo "$as_me:$LINENO: checking for working alloca.h" >&5
+echo $ECHO_N "checking for working alloca.h... $ECHO_C" >&6
+if test "${ac_cv_working_alloca_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <alloca.h>
+int
+main ()
+{
+char *p = (char *) alloca (2 * sizeof (int));
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_working_alloca_h=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_working_alloca_h=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_working_alloca_h" >&5
+echo "${ECHO_T}$ac_cv_working_alloca_h" >&6
+if test $ac_cv_working_alloca_h = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ALLOCA_H 1
+_ACEOF
+
+fi
+
+echo "$as_me:$LINENO: checking for alloca" >&5
+echo $ECHO_N "checking for alloca... $ECHO_C" >&6
+if test "${ac_cv_func_alloca_works+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef __GNUC__
+# define alloca __builtin_alloca
+#else
+# ifdef _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
+# else
+#  if HAVE_ALLOCA_H
+#   include <alloca.h>
+#  else
+#   ifdef _AIX
+ #pragma alloca
+#   else
+#    ifndef alloca /* predefined by HP cc +Olibcalls */
+char *alloca ();
+#    endif
+#   endif
+#  endif
+# endif
+#endif
+
+int
+main ()
+{
+char *p = (char *) alloca (1);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_alloca_works=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_func_alloca_works=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_alloca_works" >&5
+echo "${ECHO_T}$ac_cv_func_alloca_works" >&6
+
+if test $ac_cv_func_alloca_works = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ALLOCA 1
+_ACEOF
+
+else
+  # The SVR3 libPW and SVR4 libucb both contain incompatible functions
+# that cause trouble.  Some versions do not even contain alloca or
+# contain a buggy version.  If you still want to use their alloca,
+# use ar to extract alloca.o from them instead of compiling alloca.c.
+
+ALLOCA=alloca.$ac_objext
+
+cat >>confdefs.h <<\_ACEOF
+#define C_ALLOCA 1
+_ACEOF
+
+
+echo "$as_me:$LINENO: checking whether \`alloca.c' needs Cray hooks" >&5
+echo $ECHO_N "checking whether \`alloca.c' needs Cray hooks... $ECHO_C" >&6
+if test "${ac_cv_os_cray+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#if defined(CRAY) && ! defined(CRAY2)
+webecray
+#else
+wenotbecray
+#endif
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "webecray" >/dev/null 2>&1; then
+  ac_cv_os_cray=yes
+else
+  ac_cv_os_cray=no
+fi
+rm -f conftest*
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_os_cray" >&5
+echo "${ECHO_T}$ac_cv_os_cray" >&6
+if test $ac_cv_os_cray = yes; then
+  for ac_func in _getb67 GETB67 getb67; do
+    as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+
+cat >>confdefs.h <<_ACEOF
+#define CRAY_STACKSEG_END $ac_func
+_ACEOF
+
+    break
+fi
+
+  done
+fi
+
+echo "$as_me:$LINENO: checking stack direction for C alloca" >&5
+echo $ECHO_N "checking stack direction for C alloca... $ECHO_C" >&6
+if test "${ac_cv_c_stack_direction+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_c_stack_direction=0
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+int
+find_stack_direction ()
+{
+  static char *addr = 0;
+  auto char dummy;
+  if (addr == 0)
+    {
+      addr = &dummy;
+      return find_stack_direction ();
+    }
+  else
+    return (&dummy > addr) ? 1 : -1;
+}
+
+int
+main ()
+{
+  exit (find_stack_direction () < 0);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_c_stack_direction=1
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_c_stack_direction=-1
+fi
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_c_stack_direction" >&5
+echo "${ECHO_T}$ac_cv_c_stack_direction" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define STACK_DIRECTION $ac_cv_c_stack_direction
+_ACEOF
+
+
+fi
+
+
+
+for ac_header in stdlib.h unistd.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+for ac_func in getpagesize
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+echo "$as_me:$LINENO: checking for working mmap" >&5
+echo $ECHO_N "checking for working mmap... $ECHO_C" >&6
+if test "${ac_cv_func_mmap_fixed_mapped+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test "$cross_compiling" = yes; then
+  ac_cv_func_mmap_fixed_mapped=no
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+/* malloc might have been renamed as rpl_malloc. */
+#undef malloc
+
+/* Thanks to Mike Haertel and Jim Avera for this test.
+   Here is a matrix of mmap possibilities:
+	mmap private not fixed
+	mmap private fixed at somewhere currently unmapped
+	mmap private fixed at somewhere already mapped
+	mmap shared not fixed
+	mmap shared fixed at somewhere currently unmapped
+	mmap shared fixed at somewhere already mapped
+   For private mappings, we should verify that changes cannot be read()
+   back from the file, nor mmap's back from the file at a different
+   address.  (There have been systems where private was not correctly
+   implemented like the infamous i386 svr4.0, and systems where the
+   VM page cache was not coherent with the file system buffer cache
+   like early versions of FreeBSD and possibly contemporary NetBSD.)
+   For shared mappings, we should conversely verify that changes get
+   propagated back to all the places they're supposed to be.
+
+   Grep wants private fixed already mapped.
+   The main things grep needs to know about mmap are:
+   * does it exist and is it safe to write into the mmap'd area
+   * how to use it (BSD variants)  */
+
+#include <fcntl.h>
+#include <sys/mman.h>
+
+#if !STDC_HEADERS && !HAVE_STDLIB_H
+char *malloc ();
+#endif
+
+/* This mess was copied from the GNU getpagesize.h.  */
+#if !HAVE_GETPAGESIZE
+/* Assume that all systems that can run configure have sys/param.h.  */
+# if !HAVE_SYS_PARAM_H
+#  define HAVE_SYS_PARAM_H 1
+# endif
+
+# ifdef _SC_PAGESIZE
+#  define getpagesize() sysconf(_SC_PAGESIZE)
+# else /* no _SC_PAGESIZE */
+#  if HAVE_SYS_PARAM_H
+#   include <sys/param.h>
+#   ifdef EXEC_PAGESIZE
+#    define getpagesize() EXEC_PAGESIZE
+#   else /* no EXEC_PAGESIZE */
+#    ifdef NBPG
+#     define getpagesize() NBPG * CLSIZE
+#     ifndef CLSIZE
+#      define CLSIZE 1
+#     endif /* no CLSIZE */
+#    else /* no NBPG */
+#     ifdef NBPC
+#      define getpagesize() NBPC
+#     else /* no NBPC */
+#      ifdef PAGESIZE
+#       define getpagesize() PAGESIZE
+#      endif /* PAGESIZE */
+#     endif /* no NBPC */
+#    endif /* no NBPG */
+#   endif /* no EXEC_PAGESIZE */
+#  else /* no HAVE_SYS_PARAM_H */
+#   define getpagesize() 8192	/* punt totally */
+#  endif /* no HAVE_SYS_PARAM_H */
+# endif /* no _SC_PAGESIZE */
+
+#endif /* no HAVE_GETPAGESIZE */
+
+int
+main ()
+{
+  char *data, *data2, *data3;
+  int i, pagesize;
+  int fd;
+
+  pagesize = getpagesize ();
+
+  /* First, make a file with some known garbage in it. */
+  data = (char *) malloc (pagesize);
+  if (!data)
+    exit (1);
+  for (i = 0; i < pagesize; ++i)
+    *(data + i) = rand ();
+  umask (0);
+  fd = creat ("conftest.mmap", 0600);
+  if (fd < 0)
+    exit (1);
+  if (write (fd, data, pagesize) != pagesize)
+    exit (1);
+  close (fd);
+
+  /* Next, try to mmap the file at a fixed address which already has
+     something else allocated at it.  If we can, also make sure that
+     we see the same garbage.  */
+  fd = open ("conftest.mmap", O_RDWR);
+  if (fd < 0)
+    exit (1);
+  data2 = (char *) malloc (2 * pagesize);
+  if (!data2)
+    exit (1);
+  data2 += (pagesize - ((int) data2 & (pagesize - 1))) & (pagesize - 1);
+  if (data2 != mmap (data2, pagesize, PROT_READ | PROT_WRITE,
+                     MAP_PRIVATE | MAP_FIXED, fd, 0L))
+    exit (1);
+  for (i = 0; i < pagesize; ++i)
+    if (*(data + i) != *(data2 + i))
+      exit (1);
+
+  /* Finally, make sure that changes to the mapped area do not
+     percolate back to the file as seen by read().  (This is a bug on
+     some variants of i386 svr4.0.)  */
+  for (i = 0; i < pagesize; ++i)
+    *(data2 + i) = *(data2 + i) + 1;
+  data3 = (char *) malloc (pagesize);
+  if (!data3)
+    exit (1);
+  if (read (fd, data3, pagesize) != pagesize)
+    exit (1);
+  for (i = 0; i < pagesize; ++i)
+    if (*(data + i) != *(data3 + i))
+      exit (1);
+  close (fd);
+  exit (0);
+}
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_func_mmap_fixed_mapped=yes
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+ac_cv_func_mmap_fixed_mapped=no
+fi
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+fi
+echo "$as_me:$LINENO: result: $ac_cv_func_mmap_fixed_mapped" >&5
+echo "${ECHO_T}$ac_cv_func_mmap_fixed_mapped" >&6
+if test $ac_cv_func_mmap_fixed_mapped = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_MMAP 1
+_ACEOF
+
+fi
+rm -f conftest.mmap
+
+
+    echo "$as_me:$LINENO: checking whether we are using the GNU C Library 2.1 or newer" >&5
+echo $ECHO_N "checking whether we are using the GNU C Library 2.1 or newer... $ECHO_C" >&6
+if test "${ac_cv_gnu_library_2_1+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <features.h>
+#ifdef __GNU_LIBRARY__
+ #if (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 1) || (__GLIBC__ > 2)
+  Lucky GNU user
+ #endif
+#endif
+
+_ACEOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  $EGREP "Lucky GNU user" >/dev/null 2>&1; then
+  ac_cv_gnu_library_2_1=yes
+else
+  ac_cv_gnu_library_2_1=no
+fi
+rm -f conftest*
+
+
+
+fi
+echo "$as_me:$LINENO: result: $ac_cv_gnu_library_2_1" >&5
+echo "${ECHO_T}$ac_cv_gnu_library_2_1" >&6
+
+    GLIBC21="$ac_cv_gnu_library_2_1"
+
+
+
+
+  echo "$as_me:$LINENO: checking whether integer division by zero raises SIGFPE" >&5
+echo $ECHO_N "checking whether integer division by zero raises SIGFPE... $ECHO_C" >&6
+if test "${gt_cv_int_divbyzero_sigfpe+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+      if test "$cross_compiling" = yes; then
+
+          # Guess based on the CPU.
+          case "$host_cpu" in
+            alpha* | i3456786 | m68k | s390*)
+              gt_cv_int_divbyzero_sigfpe="guessing yes";;
+            *)
+              gt_cv_int_divbyzero_sigfpe="guessing no";;
+          esac
+
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <stdlib.h>
+#include <signal.h>
+
+static void
+#ifdef __cplusplus
+sigfpe_handler (int sig)
+#else
+sigfpe_handler (sig) int sig;
+#endif
+{
+  /* Exit with code 0 if SIGFPE, with code 1 if any other signal.  */
+  exit (sig != SIGFPE);
+}
+
+int x = 1;
+int y = 0;
+int z;
+int nan;
+
+int main ()
+{
+  signal (SIGFPE, sigfpe_handler);
+/* IRIX and AIX (when "xlc -qcheck" is used) yield signal SIGTRAP.  */
+#if (defined (__sgi) || defined (_AIX)) && defined (SIGTRAP)
+  signal (SIGTRAP, sigfpe_handler);
+#endif
+/* Linux/SPARC yields signal SIGILL.  */
+#if defined (__sparc__) && defined (__linux__)
+  signal (SIGILL, sigfpe_handler);
+#endif
+
+  z = x / y;
+  nan = y / y;
+  exit (1);
+}
+
+_ACEOF
+rm -f conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  gt_cv_int_divbyzero_sigfpe=yes
+else
+  echo "$as_me: program exited with status $ac_status" >&5
+echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+( exit $ac_status )
+gt_cv_int_divbyzero_sigfpe=no
+fi
+rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
+fi
+
+fi
+echo "$as_me:$LINENO: result: $gt_cv_int_divbyzero_sigfpe" >&5
+echo "${ECHO_T}$gt_cv_int_divbyzero_sigfpe" >&6
+  case "$gt_cv_int_divbyzero_sigfpe" in
+    *yes) value=1;;
+    *) value=0;;
+  esac
+
+cat >>confdefs.h <<_ACEOF
+#define INTDIV0_RAISES_SIGFPE $value
+_ACEOF
+
+
+
+  echo "$as_me:$LINENO: checking for inttypes.h" >&5
+echo $ECHO_N "checking for inttypes.h... $ECHO_C" >&6
+if test "${jm_ac_cv_header_inttypes_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <inttypes.h>
+int
+main ()
+{
+uintmax_t i = (uintmax_t) -1;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  jm_ac_cv_header_inttypes_h=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+jm_ac_cv_header_inttypes_h=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $jm_ac_cv_header_inttypes_h" >&5
+echo "${ECHO_T}$jm_ac_cv_header_inttypes_h" >&6
+  if test $jm_ac_cv_header_inttypes_h = yes; then
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_INTTYPES_H_WITH_UINTMAX 1
+_ACEOF
+
+  fi
+
+
+  echo "$as_me:$LINENO: checking for stdint.h" >&5
+echo $ECHO_N "checking for stdint.h... $ECHO_C" >&6
+if test "${jm_ac_cv_header_stdint_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <stdint.h>
+int
+main ()
+{
+uintmax_t i = (uintmax_t) -1;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  jm_ac_cv_header_stdint_h=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+jm_ac_cv_header_stdint_h=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $jm_ac_cv_header_stdint_h" >&5
+echo "${ECHO_T}$jm_ac_cv_header_stdint_h" >&6
+  if test $jm_ac_cv_header_stdint_h = yes; then
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_STDINT_H_WITH_UINTMAX 1
+_ACEOF
+
+  fi
+
+
+  echo "$as_me:$LINENO: checking for unsigned long long" >&5
+echo $ECHO_N "checking for unsigned long long... $ECHO_C" >&6
+if test "${ac_cv_type_unsigned_long_long+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+unsigned long long ull = 1; int i = 63;
+int
+main ()
+{
+unsigned long long ullmax = (unsigned long long) -1;
+     return ull << i | ull >> i | ullmax / ull | ullmax % ull;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_type_unsigned_long_long=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_type_unsigned_long_long=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $ac_cv_type_unsigned_long_long" >&5
+echo "${ECHO_T}$ac_cv_type_unsigned_long_long" >&6
+  if test $ac_cv_type_unsigned_long_long = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_UNSIGNED_LONG_LONG 1
+_ACEOF
+
+  fi
+
+
+
+
+  if test $jm_ac_cv_header_inttypes_h = no && test $jm_ac_cv_header_stdint_h = no; then
+
+    test $ac_cv_type_unsigned_long_long = yes \
+      && ac_type='unsigned long long' \
+      || ac_type='unsigned long'
+
+cat >>confdefs.h <<_ACEOF
+#define uintmax_t $ac_type
+_ACEOF
+
+  fi
+
+
+  echo "$as_me:$LINENO: checking for inttypes.h" >&5
+echo $ECHO_N "checking for inttypes.h... $ECHO_C" >&6
+if test "${gt_cv_header_inttypes_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+    cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <sys/types.h>
+#include <inttypes.h>
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  gt_cv_header_inttypes_h=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gt_cv_header_inttypes_h=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+echo "$as_me:$LINENO: result: $gt_cv_header_inttypes_h" >&5
+echo "${ECHO_T}$gt_cv_header_inttypes_h" >&6
+  if test $gt_cv_header_inttypes_h = yes; then
+
+cat >>confdefs.h <<_ACEOF
+#define HAVE_INTTYPES_H 1
+_ACEOF
+
+  fi
+
+
+
+  if test $gt_cv_header_inttypes_h = yes; then
+    echo "$as_me:$LINENO: checking whether the inttypes.h PRIxNN macros are broken" >&5
+echo $ECHO_N "checking whether the inttypes.h PRIxNN macros are broken... $ECHO_C" >&6
+if test "${gt_cv_inttypes_pri_broken+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+        cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <inttypes.h>
+#ifdef PRId32
+char *p = PRId32;
+#endif
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  gt_cv_inttypes_pri_broken=no
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gt_cv_inttypes_pri_broken=yes
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+
+fi
+echo "$as_me:$LINENO: result: $gt_cv_inttypes_pri_broken" >&5
+echo "${ECHO_T}$gt_cv_inttypes_pri_broken" >&6
+  fi
+  if test "$gt_cv_inttypes_pri_broken" = yes; then
+
+cat >>confdefs.h <<_ACEOF
+#define PRI_MACROS_BROKEN 1
+_ACEOF
+
+  fi
+
+
+      if test "X$prefix" = "XNONE"; then
+    acl_final_prefix="$ac_default_prefix"
+  else
+    acl_final_prefix="$prefix"
+  fi
+  if test "X$exec_prefix" = "XNONE"; then
+    acl_final_exec_prefix='${prefix}'
+  else
+    acl_final_exec_prefix="$exec_prefix"
+  fi
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  eval acl_final_exec_prefix=\"$acl_final_exec_prefix\"
+  prefix="$acl_save_prefix"
+
+
+# Check whether --with-gnu-ld or --without-gnu-ld was given.
+if test "${with_gnu_ld+set}" = set; then
+  withval="$with_gnu_ld"
+  test "$withval" = no || with_gnu_ld=yes
+else
+  with_gnu_ld=no
+fi;
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  echo "$as_me:$LINENO: checking for ld used by GCC" >&5
+echo $ECHO_N "checking for ld used by GCC... $ECHO_C" >&6
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [\\/]* | [A-Za-z]:[\\/]*)
+      re_direlt='/[^/][^/]*/\.\./'
+      # Canonicalize the path of ld
+      ac_prog=`echo $ac_prog| sed 's%\\\\%/%g'`
+      while echo $ac_prog | grep "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`echo $ac_prog| sed "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  echo "$as_me:$LINENO: checking for GNU ld" >&5
+echo $ECHO_N "checking for GNU ld... $ECHO_C" >&6
+else
+  echo "$as_me:$LINENO: checking for non-GNU ld" >&5
+echo $ECHO_N "checking for non-GNU ld... $ECHO_C" >&6
+fi
+if test "${acl_cv_path_LD+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -z "$LD"; then
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}${PATH_SEPARATOR-:}"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      acl_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some GNU ld's only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      if "$acl_cv_path_LD" -v 2>&1 < /dev/null | egrep '(GNU|with BFD)' > /dev/null; then
+	test "$with_gnu_ld" != no && break
+      else
+	test "$with_gnu_ld" != yes && break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+else
+  acl_cv_path_LD="$LD" # Let the user override the test with a path.
+fi
+fi
+
+LD="$acl_cv_path_LD"
+if test -n "$LD"; then
+  echo "$as_me:$LINENO: result: $LD" >&5
+echo "${ECHO_T}$LD" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+test -z "$LD" && { { echo "$as_me:$LINENO: error: no acceptable ld found in \$PATH" >&5
+echo "$as_me: error: no acceptable ld found in \$PATH" >&2;}
+   { (exit 1); exit 1; }; }
+echo "$as_me:$LINENO: checking if the linker ($LD) is GNU ld" >&5
+echo $ECHO_N "checking if the linker ($LD) is GNU ld... $ECHO_C" >&6
+if test "${acl_cv_prog_gnu_ld+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  # I'd rather use --version here, but apparently some GNU ld's only accept -v.
+if $LD -v 2>&1 </dev/null | egrep '(GNU|with BFD)' 1>&5; then
+  acl_cv_prog_gnu_ld=yes
+else
+  acl_cv_prog_gnu_ld=no
+fi
+fi
+echo "$as_me:$LINENO: result: $acl_cv_prog_gnu_ld" >&5
+echo "${ECHO_T}$acl_cv_prog_gnu_ld" >&6
+with_gnu_ld=$acl_cv_prog_gnu_ld
+
+
+
+                                                echo "$as_me:$LINENO: checking for shared library run path origin" >&5
+echo $ECHO_N "checking for shared library run path origin... $ECHO_C" >&6
+if test "${acl_cv_rpath+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+    CC="$CC" GCC="$GCC" LDFLAGS="$LDFLAGS" LD="$LD" with_gnu_ld="$with_gnu_ld" \
+    ${CONFIG_SHELL-/bin/sh} "$ac_aux_dir/config.rpath" "$host" > conftest.sh
+    . ./conftest.sh
+    rm -f ./conftest.sh
+    acl_cv_rpath=done
+
+fi
+echo "$as_me:$LINENO: result: $acl_cv_rpath" >&5
+echo "${ECHO_T}$acl_cv_rpath" >&6
+  wl="$acl_cv_wl"
+  libext="$acl_cv_libext"
+  shlibext="$acl_cv_shlibext"
+  hardcode_libdir_flag_spec="$acl_cv_hardcode_libdir_flag_spec"
+  hardcode_libdir_separator="$acl_cv_hardcode_libdir_separator"
+  hardcode_direct="$acl_cv_hardcode_direct"
+  hardcode_minus_L="$acl_cv_hardcode_minus_L"
+  sys_lib_search_path_spec="$acl_cv_sys_lib_search_path_spec"
+  sys_lib_dlsearch_path_spec="$acl_cv_sys_lib_dlsearch_path_spec"
+    # Check whether --enable-rpath or --disable-rpath was given.
+if test "${enable_rpath+set}" = set; then
+  enableval="$enable_rpath"
+  :
+else
+  enable_rpath=yes
+fi;
+
+
+
+
+
+
+
+    use_additional=yes
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+
+    eval additional_includedir=\"$includedir\"
+    eval additional_libdir=\"$libdir\"
+
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+
+# Check whether --with-libiconv-prefix or --without-libiconv-prefix was given.
+if test "${with_libiconv_prefix+set}" = set; then
+  withval="$with_libiconv_prefix"
+
+    if test "X$withval" = "Xno"; then
+      use_additional=no
+    else
+      if test "X$withval" = "X"; then
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+
+          eval additional_includedir=\"$includedir\"
+          eval additional_libdir=\"$libdir\"
+
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+      else
+        additional_includedir="$withval/include"
+        additional_libdir="$withval/lib"
+      fi
+    fi
+
+fi;
+      LIBICONV=
+  LTLIBICONV=
+  INCICONV=
+  rpathdirs=
+  ltrpathdirs=
+  names_already_handled=
+  names_next_round='iconv '
+  while test -n "$names_next_round"; do
+    names_this_round="$names_next_round"
+    names_next_round=
+    for name in $names_this_round; do
+      already_handled=
+      for n in $names_already_handled; do
+        if test "$n" = "$name"; then
+          already_handled=yes
+          break
+        fi
+      done
+      if test -z "$already_handled"; then
+        names_already_handled="$names_already_handled $name"
+                        uppername=`echo "$name" | sed -e 'y|abcdefghijklmnopqrstuvwxyz./-|ABCDEFGHIJKLMNOPQRSTUVWXYZ___|'`
+        eval value=\"\$HAVE_LIB$uppername\"
+        if test -n "$value"; then
+          if test "$value" = yes; then
+            eval value=\"\$LIB$uppername\"
+            test -z "$value" || LIBICONV="${LIBICONV}${LIBICONV:+ }$value"
+            eval value=\"\$LTLIB$uppername\"
+            test -z "$value" || LTLIBICONV="${LTLIBICONV}${LTLIBICONV:+ }$value"
+          else
+                                    :
+          fi
+        else
+                              found_dir=
+          found_la=
+          found_so=
+          found_a=
+          if test $use_additional = yes; then
+            if test -n "$shlibext" && test -f "$additional_libdir/lib$name.$shlibext"; then
+              found_dir="$additional_libdir"
+              found_so="$additional_libdir/lib$name.$shlibext"
+              if test -f "$additional_libdir/lib$name.la"; then
+                found_la="$additional_libdir/lib$name.la"
+              fi
+            else
+              if test -f "$additional_libdir/lib$name.$libext"; then
+                found_dir="$additional_libdir"
+                found_a="$additional_libdir/lib$name.$libext"
+                if test -f "$additional_libdir/lib$name.la"; then
+                  found_la="$additional_libdir/lib$name.la"
+                fi
+              fi
+            fi
+          fi
+          if test "X$found_dir" = "X"; then
+            for x in $LDFLAGS $LTLIBICONV; do
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  eval x=\"$x\"
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+              case "$x" in
+                -L*)
+                  dir=`echo "X$x" | sed -e 's/^X-L//'`
+                  if test -n "$shlibext" && test -f "$dir/lib$name.$shlibext"; then
+                    found_dir="$dir"
+                    found_so="$dir/lib$name.$shlibext"
+                    if test -f "$dir/lib$name.la"; then
+                      found_la="$dir/lib$name.la"
+                    fi
+                  else
+                    if test -f "$dir/lib$name.$libext"; then
+                      found_dir="$dir"
+                      found_a="$dir/lib$name.$libext"
+                      if test -f "$dir/lib$name.la"; then
+                        found_la="$dir/lib$name.la"
+                      fi
+                    fi
+                  fi
+                  ;;
+              esac
+              if test "X$found_dir" != "X"; then
+                break
+              fi
+            done
+          fi
+          if test "X$found_dir" != "X"; then
+                        LTLIBICONV="${LTLIBICONV}${LTLIBICONV:+ }-L$found_dir -l$name"
+            if test "X$found_so" != "X"; then
+                                                        if test "$enable_rpath" = no || test "X$found_dir" = "X/usr/lib"; then
+                                LIBICONV="${LIBICONV}${LIBICONV:+ }$found_so"
+              else
+                                                                                haveit=
+                for x in $ltrpathdirs; do
+                  if test "X$x" = "X$found_dir"; then
+                    haveit=yes
+                    break
+                  fi
+                done
+                if test -z "$haveit"; then
+                  ltrpathdirs="$ltrpathdirs $found_dir"
+                fi
+                                if test "$hardcode_direct" = yes; then
+                                                      LIBICONV="${LIBICONV}${LIBICONV:+ }$found_so"
+                else
+                  if test -n "$hardcode_libdir_flag_spec" && test "$hardcode_minus_L" = no; then
+                                                            LIBICONV="${LIBICONV}${LIBICONV:+ }$found_so"
+                                                            haveit=
+                    for x in $rpathdirs; do
+                      if test "X$x" = "X$found_dir"; then
+                        haveit=yes
+                        break
+                      fi
+                    done
+                    if test -z "$haveit"; then
+                      rpathdirs="$rpathdirs $found_dir"
+                    fi
+                  else
+                                                                                haveit=
+                    for x in $LDFLAGS $LIBICONV; do
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  eval x=\"$x\"
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+                      if test "X$x" = "X-L$found_dir"; then
+                        haveit=yes
+                        break
+                      fi
+                    done
+                    if test -z "$haveit"; then
+                      LIBICONV="${LIBICONV}${LIBICONV:+ }-L$found_dir"
+                    fi
+                    if test "$hardcode_minus_L" != no; then
+                                                                                        LIBICONV="${LIBICONV}${LIBICONV:+ }$found_so"
+                    else
+                                                                                                                                                                                LIBICONV="${LIBICONV}${LIBICONV:+ }-l$name"
+                    fi
+                  fi
+                fi
+              fi
+            else
+              if test "X$found_a" != "X"; then
+                                LIBICONV="${LIBICONV}${LIBICONV:+ }$found_a"
+              else
+                                                LIBICONV="${LIBICONV}${LIBICONV:+ }-L$found_dir -l$name"
+              fi
+            fi
+                        additional_includedir=
+            case "$found_dir" in
+              */lib | */lib/)
+                basedir=`echo "X$found_dir" | sed -e 's,^X,,' -e 's,/lib/*$,,'`
+                additional_includedir="$basedir/include"
+                ;;
+            esac
+            if test "X$additional_includedir" != "X"; then
+                                                                                                                if test "X$additional_includedir" != "X/usr/include"; then
+                haveit=
+                if test "X$additional_includedir" = "X/usr/local/include"; then
+                  if test -n "$GCC"; then
+                    case $host_os in
+                      linux*) haveit=yes;;
+                    esac
+                  fi
+                fi
+                if test -z "$haveit"; then
+                  for x in $CPPFLAGS $INCICONV; do
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  eval x=\"$x\"
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+                    if test "X$x" = "X-I$additional_includedir"; then
+                      haveit=yes
+                      break
+                    fi
+                  done
+                  if test -z "$haveit"; then
+                    if test -d "$additional_includedir"; then
+                                            INCICONV="${INCICONV}${INCICONV:+ }-I$additional_includedir"
+                    fi
+                  fi
+                fi
+              fi
+            fi
+                        if test -n "$found_la"; then
+                                                        save_libdir="$libdir"
+              case "$found_la" in
+                */* | *\\*) . "$found_la" ;;
+                *) . "./$found_la" ;;
+              esac
+              libdir="$save_libdir"
+                            for dep in $dependency_libs; do
+                case "$dep" in
+                  -L*)
+                    additional_libdir=`echo "X$dep" | sed -e 's/^X-L//'`
+                                                                                                                                                                if test "X$additional_libdir" != "X/usr/lib"; then
+                      haveit=
+                      if test "X$additional_libdir" = "X/usr/local/lib"; then
+                        if test -n "$GCC"; then
+                          case $host_os in
+                            linux*) haveit=yes;;
+                          esac
+                        fi
+                      fi
+                      if test -z "$haveit"; then
+                        haveit=
+                        for x in $LDFLAGS $LIBICONV; do
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  eval x=\"$x\"
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+                          if test "X$x" = "X-L$additional_libdir"; then
+                            haveit=yes
+                            break
+                          fi
+                        done
+                        if test -z "$haveit"; then
+                          if test -d "$additional_libdir"; then
+                                                        LIBICONV="${LIBICONV}${LIBICONV:+ }-L$additional_libdir"
+                          fi
+                        fi
+                        haveit=
+                        for x in $LDFLAGS $LTLIBICONV; do
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  eval x=\"$x\"
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+                          if test "X$x" = "X-L$additional_libdir"; then
+                            haveit=yes
+                            break
+                          fi
+                        done
+                        if test -z "$haveit"; then
+                          if test -d "$additional_libdir"; then
+                                                        LTLIBICONV="${LTLIBICONV}${LTLIBICONV:+ }-L$additional_libdir"
+                          fi
+                        fi
+                      fi
+                    fi
+                    ;;
+                  -R*)
+                    dir=`echo "X$dep" | sed -e 's/^X-R//'`
+                    if test "$enable_rpath" != no; then
+                                                                  haveit=
+                      for x in $rpathdirs; do
+                        if test "X$x" = "X$dir"; then
+                          haveit=yes
+                          break
+                        fi
+                      done
+                      if test -z "$haveit"; then
+                        rpathdirs="$rpathdirs $dir"
+                      fi
+                                                                  haveit=
+                      for x in $ltrpathdirs; do
+                        if test "X$x" = "X$dir"; then
+                          haveit=yes
+                          break
+                        fi
+                      done
+                      if test -z "$haveit"; then
+                        ltrpathdirs="$ltrpathdirs $dir"
+                      fi
+                    fi
+                    ;;
+                  -l*)
+                                        names_next_round="$names_next_round "`echo "X$dep" | sed -e 's/^X-l//'`
+                    ;;
+                  *.la)
+                                                                                names_next_round="$names_next_round "`echo "X$dep" | sed -e 's,^X.*/,,' -e 's,^lib,,' -e 's,\.la$,,'`
+                    ;;
+                  *)
+                                        LIBICONV="${LIBICONV}${LIBICONV:+ }$dep"
+                    LTLIBICONV="${LTLIBICONV}${LTLIBICONV:+ }$dep"
+                    ;;
+                esac
+              done
+            fi
+          else
+                                                            LIBICONV="${LIBICONV}${LIBICONV:+ }-l$name"
+            LTLIBICONV="${LTLIBICONV}${LTLIBICONV:+ }-l$name"
+          fi
+        fi
+      fi
+    done
+  done
+  if test "X$rpathdirs" != "X"; then
+    if test -n "$hardcode_libdir_separator"; then
+                        alldirs=
+      for found_dir in $rpathdirs; do
+        alldirs="${alldirs}${alldirs:+$hardcode_libdir_separator}$found_dir"
+      done
+            acl_save_libdir="$libdir"
+      libdir="$alldirs"
+      eval flag=\"$hardcode_libdir_flag_spec\"
+      libdir="$acl_save_libdir"
+      LIBICONV="${LIBICONV}${LIBICONV:+ }$flag"
+    else
+            for found_dir in $rpathdirs; do
+        acl_save_libdir="$libdir"
+        libdir="$found_dir"
+        eval flag=\"$hardcode_libdir_flag_spec\"
+        libdir="$acl_save_libdir"
+        LIBICONV="${LIBICONV}${LIBICONV:+ }$flag"
+      done
+    fi
+  fi
+  if test "X$ltrpathdirs" != "X"; then
+            for found_dir in $ltrpathdirs; do
+      LTLIBICONV="${LTLIBICONV}${LTLIBICONV:+ }-R$found_dir"
+    done
+  fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+for ac_header in argz.h limits.h locale.h nl_types.h malloc.h stddef.h \
+stdlib.h string.h unistd.h sys/param.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+else
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+$ac_includes_default
+#include <$ac_header>
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_header_compiler=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_header_compiler=no
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
+
+# Is the header present?
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <$ac_header>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
+fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
+
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  eval "$as_ac_Header=$ac_header_preproc"
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
+
+fi
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+
+done
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+for ac_func in feof_unlocked fgets_unlocked getc_unlocked getcwd getegid \
+geteuid getgid getuid mempcpy munmap putenv setenv setlocale stpcpy \
+strcasecmp strdup strtoul tsearch __argz_count __argz_stringify __argz_next
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+fi
+done
+
+
+
+
+
+
+
+          am_save_CPPFLAGS="$CPPFLAGS"
+
+  for element in $INCICONV; do
+    haveit=
+    for x in $CPPFLAGS; do
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  eval x=\"$x\"
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+      if test "X$x" = "X$element"; then
+        haveit=yes
+        break
+      fi
+    done
+    if test -z "$haveit"; then
+      CPPFLAGS="${CPPFLAGS}${CPPFLAGS:+ }$element"
+    fi
+  done
+
+
+  echo "$as_me:$LINENO: checking for iconv" >&5
+echo $ECHO_N "checking for iconv... $ECHO_C" >&6
+if test "${am_cv_func_iconv+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+    am_cv_func_iconv="no, consider installing GNU libiconv"
+    am_cv_lib_iconv=no
+    cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <iconv.h>
+int
+main ()
+{
+iconv_t cd = iconv_open("","");
+       iconv(cd,NULL,NULL,NULL,NULL);
+       iconv_close(cd);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  am_cv_func_iconv=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+    if test "$am_cv_func_iconv" != yes; then
+      am_save_LIBS="$LIBS"
+      LIBS="$LIBS $LIBICONV"
+      cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <stdlib.h>
+#include <iconv.h>
+int
+main ()
+{
+iconv_t cd = iconv_open("","");
+         iconv(cd,NULL,NULL,NULL,NULL);
+         iconv_close(cd);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  am_cv_lib_iconv=yes
+        am_cv_func_iconv=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+      LIBS="$am_save_LIBS"
+    fi
+
+fi
+echo "$as_me:$LINENO: result: $am_cv_func_iconv" >&5
+echo "${ECHO_T}$am_cv_func_iconv" >&6
+  if test "$am_cv_func_iconv" = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_ICONV 1
+_ACEOF
+
+  fi
+  if test "$am_cv_lib_iconv" = yes; then
+    echo "$as_me:$LINENO: checking how to link with libiconv" >&5
+echo $ECHO_N "checking how to link with libiconv... $ECHO_C" >&6
+    echo "$as_me:$LINENO: result: $LIBICONV" >&5
+echo "${ECHO_T}$LIBICONV" >&6
+  else
+            CPPFLAGS="$am_save_CPPFLAGS"
+    LIBICONV=
+    LTLIBICONV=
+  fi
+
+
+
+  if test "$am_cv_func_iconv" = yes; then
+    echo "$as_me:$LINENO: checking for iconv declaration" >&5
+echo $ECHO_N "checking for iconv declaration... $ECHO_C" >&6
+    if test "${am_cv_proto_iconv+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+
+      cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+#include <stdlib.h>
+#include <iconv.h>
+extern
+#ifdef __cplusplus
+"C"
+#endif
+#if defined(__STDC__) || defined(__cplusplus)
+size_t iconv (iconv_t cd, char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);
+#else
+size_t iconv();
+#endif
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  am_cv_proto_iconv_arg1=""
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+am_cv_proto_iconv_arg1="const"
+fi
+rm -f conftest.$ac_objext conftest.$ac_ext
+      am_cv_proto_iconv="extern size_t iconv (iconv_t cd, $am_cv_proto_iconv_arg1 char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);"
+fi
+
+    am_cv_proto_iconv=`echo "$am_cv_proto_iconv" | tr -s ' ' | sed -e 's/( /(/'`
+    echo "$as_me:$LINENO: result: ${ac_t:-
+         }$am_cv_proto_iconv" >&5
+echo "${ECHO_T}${ac_t:-
+         }$am_cv_proto_iconv" >&6
+
+cat >>confdefs.h <<_ACEOF
+#define ICONV_CONST $am_cv_proto_iconv_arg1
+_ACEOF
+
+  fi
+
+
+  echo "$as_me:$LINENO: checking for nl_langinfo and CODESET" >&5
+echo $ECHO_N "checking for nl_langinfo and CODESET... $ECHO_C" >&6
+if test "${am_cv_langinfo_codeset+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <langinfo.h>
+int
+main ()
+{
+char* cs = nl_langinfo(CODESET);
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  am_cv_langinfo_codeset=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+am_cv_langinfo_codeset=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+
+fi
+echo "$as_me:$LINENO: result: $am_cv_langinfo_codeset" >&5
+echo "${ECHO_T}$am_cv_langinfo_codeset" >&6
+  if test $am_cv_langinfo_codeset = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_LANGINFO_CODESET 1
+_ACEOF
+
+  fi
+
+  if test $ac_cv_header_locale_h = yes; then
+
+  echo "$as_me:$LINENO: checking for LC_MESSAGES" >&5
+echo $ECHO_N "checking for LC_MESSAGES... $ECHO_C" >&6
+if test "${am_cv_val_LC_MESSAGES+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <locale.h>
+int
+main ()
+{
+return LC_MESSAGES
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  am_cv_val_LC_MESSAGES=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+am_cv_val_LC_MESSAGES=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $am_cv_val_LC_MESSAGES" >&5
+echo "${ECHO_T}$am_cv_val_LC_MESSAGES" >&6
+  if test $am_cv_val_LC_MESSAGES = yes; then
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_LC_MESSAGES 1
+_ACEOF
+
+  fi
+
+  fi
+
+                      for ac_prog in bison
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_prog_INTLBISON+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  if test -n "$INTLBISON"; then
+  ac_cv_prog_INTLBISON="$INTLBISON" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_prog_INTLBISON="$ac_prog"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+fi
+fi
+INTLBISON=$ac_cv_prog_INTLBISON
+if test -n "$INTLBISON"; then
+  echo "$as_me:$LINENO: result: $INTLBISON" >&5
+echo "${ECHO_T}$INTLBISON" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  test -n "$INTLBISON" && break
+done
+
+  if test -z "$INTLBISON"; then
+    ac_verc_fail=yes
+  else
+        echo "$as_me:$LINENO: checking version of bison" >&5
+echo $ECHO_N "checking version of bison... $ECHO_C" >&6
+    ac_prog_version=`$INTLBISON --version 2>&1 | sed -n 's/^.*GNU Bison.* \([0-9]*\.[0-9.]*\).*$/\1/p'`
+    case $ac_prog_version in
+      '') ac_prog_version="v. ?.??, bad"; ac_verc_fail=yes;;
+      1.2[6-9]* | 1.[3-9][0-9]* | [2-9].*)
+         ac_prog_version="$ac_prog_version, ok"; ac_verc_fail=no;;
+      *) ac_prog_version="$ac_prog_version, bad"; ac_verc_fail=yes;;
+    esac
+    echo "$as_me:$LINENO: result: $ac_prog_version" >&5
+echo "${ECHO_T}$ac_prog_version" >&6
+  fi
+  if test $ac_verc_fail = yes; then
+    INTLBISON=:
+  fi
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+  echo "$as_me:$LINENO: checking whether NLS is requested" >&5
+echo $ECHO_N "checking whether NLS is requested... $ECHO_C" >&6
+    # Check whether --enable-nls or --disable-nls was given.
+if test "${enable_nls+set}" = set; then
+  enableval="$enable_nls"
+  USE_NLS=$enableval
+else
+  USE_NLS=yes
+fi;
+  echo "$as_me:$LINENO: result: $USE_NLS" >&5
+echo "${ECHO_T}$USE_NLS" >&6
+
+
+
+    BUILD_INCLUDED_LIBINTL=no
+    USE_INCLUDED_LIBINTL=no
+
+  LIBINTL=
+  LTLIBINTL=
+  POSUB=
+
+    if test "$USE_NLS" = "yes"; then
+    gt_use_preinstalled_gnugettext=no
+
+      echo "$as_me:$LINENO: checking whether included gettext is requested" >&5
+echo $ECHO_N "checking whether included gettext is requested... $ECHO_C" >&6
+
+# Check whether --with-included-gettext or --without-included-gettext was given.
+if test "${with_included_gettext+set}" = set; then
+  withval="$with_included_gettext"
+  nls_cv_force_use_gnu_gettext=$withval
+else
+  nls_cv_force_use_gnu_gettext=no
+fi;
+      echo "$as_me:$LINENO: result: $nls_cv_force_use_gnu_gettext" >&5
+echo "${ECHO_T}$nls_cv_force_use_gnu_gettext" >&6
+
+      nls_cv_use_gnu_gettext="$nls_cv_force_use_gnu_gettext"
+      if test "$nls_cv_force_use_gnu_gettext" != "yes"; then
+
+
+
+
+
+
+        echo "$as_me:$LINENO: checking for GNU gettext in libc" >&5
+echo $ECHO_N "checking for GNU gettext in libc... $ECHO_C" >&6
+if test "${gt_cv_func_gnugettext1_libc+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <libintl.h>
+extern int _nl_msg_cat_cntr;
+extern int *_nl_domain_bindings;
+int
+main ()
+{
+bindtextdomain ("", "");
+return (int) gettext ("") + _nl_msg_cat_cntr + *_nl_domain_bindings
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  gt_cv_func_gnugettext1_libc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gt_cv_func_gnugettext1_libc=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: $gt_cv_func_gnugettext1_libc" >&5
+echo "${ECHO_T}$gt_cv_func_gnugettext1_libc" >&6
+
+        if test "$gt_cv_func_gnugettext1_libc" != "yes"; then
+
+
+
+    use_additional=yes
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+
+    eval additional_includedir=\"$includedir\"
+    eval additional_libdir=\"$libdir\"
+
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+
+# Check whether --with-libintl-prefix or --without-libintl-prefix was given.
+if test "${with_libintl_prefix+set}" = set; then
+  withval="$with_libintl_prefix"
+
+    if test "X$withval" = "Xno"; then
+      use_additional=no
+    else
+      if test "X$withval" = "X"; then
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+
+          eval additional_includedir=\"$includedir\"
+          eval additional_libdir=\"$libdir\"
+
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+      else
+        additional_includedir="$withval/include"
+        additional_libdir="$withval/lib"
+      fi
+    fi
+
+fi;
+      LIBINTL=
+  LTLIBINTL=
+  INCINTL=
+  rpathdirs=
+  ltrpathdirs=
+  names_already_handled=
+  names_next_round='intl '
+  while test -n "$names_next_round"; do
+    names_this_round="$names_next_round"
+    names_next_round=
+    for name in $names_this_round; do
+      already_handled=
+      for n in $names_already_handled; do
+        if test "$n" = "$name"; then
+          already_handled=yes
+          break
+        fi
+      done
+      if test -z "$already_handled"; then
+        names_already_handled="$names_already_handled $name"
+                        uppername=`echo "$name" | sed -e 'y|abcdefghijklmnopqrstuvwxyz./-|ABCDEFGHIJKLMNOPQRSTUVWXYZ___|'`
+        eval value=\"\$HAVE_LIB$uppername\"
+        if test -n "$value"; then
+          if test "$value" = yes; then
+            eval value=\"\$LIB$uppername\"
+            test -z "$value" || LIBINTL="${LIBINTL}${LIBINTL:+ }$value"
+            eval value=\"\$LTLIB$uppername\"
+            test -z "$value" || LTLIBINTL="${LTLIBINTL}${LTLIBINTL:+ }$value"
+          else
+                                    :
+          fi
+        else
+                              found_dir=
+          found_la=
+          found_so=
+          found_a=
+          if test $use_additional = yes; then
+            if test -n "$shlibext" && test -f "$additional_libdir/lib$name.$shlibext"; then
+              found_dir="$additional_libdir"
+              found_so="$additional_libdir/lib$name.$shlibext"
+              if test -f "$additional_libdir/lib$name.la"; then
+                found_la="$additional_libdir/lib$name.la"
+              fi
+            else
+              if test -f "$additional_libdir/lib$name.$libext"; then
+                found_dir="$additional_libdir"
+                found_a="$additional_libdir/lib$name.$libext"
+                if test -f "$additional_libdir/lib$name.la"; then
+                  found_la="$additional_libdir/lib$name.la"
+                fi
+              fi
+            fi
+          fi
+          if test "X$found_dir" = "X"; then
+            for x in $LDFLAGS $LTLIBINTL; do
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  eval x=\"$x\"
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+              case "$x" in
+                -L*)
+                  dir=`echo "X$x" | sed -e 's/^X-L//'`
+                  if test -n "$shlibext" && test -f "$dir/lib$name.$shlibext"; then
+                    found_dir="$dir"
+                    found_so="$dir/lib$name.$shlibext"
+                    if test -f "$dir/lib$name.la"; then
+                      found_la="$dir/lib$name.la"
+                    fi
+                  else
+                    if test -f "$dir/lib$name.$libext"; then
+                      found_dir="$dir"
+                      found_a="$dir/lib$name.$libext"
+                      if test -f "$dir/lib$name.la"; then
+                        found_la="$dir/lib$name.la"
+                      fi
+                    fi
+                  fi
+                  ;;
+              esac
+              if test "X$found_dir" != "X"; then
+                break
+              fi
+            done
+          fi
+          if test "X$found_dir" != "X"; then
+                        LTLIBINTL="${LTLIBINTL}${LTLIBINTL:+ }-L$found_dir -l$name"
+            if test "X$found_so" != "X"; then
+                                                        if test "$enable_rpath" = no || test "X$found_dir" = "X/usr/lib"; then
+                                LIBINTL="${LIBINTL}${LIBINTL:+ }$found_so"
+              else
+                                                                                haveit=
+                for x in $ltrpathdirs; do
+                  if test "X$x" = "X$found_dir"; then
+                    haveit=yes
+                    break
+                  fi
+                done
+                if test -z "$haveit"; then
+                  ltrpathdirs="$ltrpathdirs $found_dir"
+                fi
+                                if test "$hardcode_direct" = yes; then
+                                                      LIBINTL="${LIBINTL}${LIBINTL:+ }$found_so"
+                else
+                  if test -n "$hardcode_libdir_flag_spec" && test "$hardcode_minus_L" = no; then
+                                                            LIBINTL="${LIBINTL}${LIBINTL:+ }$found_so"
+                                                            haveit=
+                    for x in $rpathdirs; do
+                      if test "X$x" = "X$found_dir"; then
+                        haveit=yes
+                        break
+                      fi
+                    done
+                    if test -z "$haveit"; then
+                      rpathdirs="$rpathdirs $found_dir"
+                    fi
+                  else
+                                                                                haveit=
+                    for x in $LDFLAGS $LIBINTL; do
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  eval x=\"$x\"
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+                      if test "X$x" = "X-L$found_dir"; then
+                        haveit=yes
+                        break
+                      fi
+                    done
+                    if test -z "$haveit"; then
+                      LIBINTL="${LIBINTL}${LIBINTL:+ }-L$found_dir"
+                    fi
+                    if test "$hardcode_minus_L" != no; then
+                                                                                        LIBINTL="${LIBINTL}${LIBINTL:+ }$found_so"
+                    else
+                                                                                                                                                                                LIBINTL="${LIBINTL}${LIBINTL:+ }-l$name"
+                    fi
+                  fi
+                fi
+              fi
+            else
+              if test "X$found_a" != "X"; then
+                                LIBINTL="${LIBINTL}${LIBINTL:+ }$found_a"
+              else
+                                                LIBINTL="${LIBINTL}${LIBINTL:+ }-L$found_dir -l$name"
+              fi
+            fi
+                        additional_includedir=
+            case "$found_dir" in
+              */lib | */lib/)
+                basedir=`echo "X$found_dir" | sed -e 's,^X,,' -e 's,/lib/*$,,'`
+                additional_includedir="$basedir/include"
+                ;;
+            esac
+            if test "X$additional_includedir" != "X"; then
+                                                                                                                if test "X$additional_includedir" != "X/usr/include"; then
+                haveit=
+                if test "X$additional_includedir" = "X/usr/local/include"; then
+                  if test -n "$GCC"; then
+                    case $host_os in
+                      linux*) haveit=yes;;
+                    esac
+                  fi
+                fi
+                if test -z "$haveit"; then
+                  for x in $CPPFLAGS $INCINTL; do
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  eval x=\"$x\"
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+                    if test "X$x" = "X-I$additional_includedir"; then
+                      haveit=yes
+                      break
+                    fi
+                  done
+                  if test -z "$haveit"; then
+                    if test -d "$additional_includedir"; then
+                                            INCINTL="${INCINTL}${INCINTL:+ }-I$additional_includedir"
+                    fi
+                  fi
+                fi
+              fi
+            fi
+                        if test -n "$found_la"; then
+                                                        save_libdir="$libdir"
+              case "$found_la" in
+                */* | *\\*) . "$found_la" ;;
+                *) . "./$found_la" ;;
+              esac
+              libdir="$save_libdir"
+                            for dep in $dependency_libs; do
+                case "$dep" in
+                  -L*)
+                    additional_libdir=`echo "X$dep" | sed -e 's/^X-L//'`
+                                                                                                                                                                if test "X$additional_libdir" != "X/usr/lib"; then
+                      haveit=
+                      if test "X$additional_libdir" = "X/usr/local/lib"; then
+                        if test -n "$GCC"; then
+                          case $host_os in
+                            linux*) haveit=yes;;
+                          esac
+                        fi
+                      fi
+                      if test -z "$haveit"; then
+                        haveit=
+                        for x in $LDFLAGS $LIBINTL; do
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  eval x=\"$x\"
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+                          if test "X$x" = "X-L$additional_libdir"; then
+                            haveit=yes
+                            break
+                          fi
+                        done
+                        if test -z "$haveit"; then
+                          if test -d "$additional_libdir"; then
+                                                        LIBINTL="${LIBINTL}${LIBINTL:+ }-L$additional_libdir"
+                          fi
+                        fi
+                        haveit=
+                        for x in $LDFLAGS $LTLIBINTL; do
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  eval x=\"$x\"
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+                          if test "X$x" = "X-L$additional_libdir"; then
+                            haveit=yes
+                            break
+                          fi
+                        done
+                        if test -z "$haveit"; then
+                          if test -d "$additional_libdir"; then
+                                                        LTLIBINTL="${LTLIBINTL}${LTLIBINTL:+ }-L$additional_libdir"
+                          fi
+                        fi
+                      fi
+                    fi
+                    ;;
+                  -R*)
+                    dir=`echo "X$dep" | sed -e 's/^X-R//'`
+                    if test "$enable_rpath" != no; then
+                                                                  haveit=
+                      for x in $rpathdirs; do
+                        if test "X$x" = "X$dir"; then
+                          haveit=yes
+                          break
+                        fi
+                      done
+                      if test -z "$haveit"; then
+                        rpathdirs="$rpathdirs $dir"
+                      fi
+                                                                  haveit=
+                      for x in $ltrpathdirs; do
+                        if test "X$x" = "X$dir"; then
+                          haveit=yes
+                          break
+                        fi
+                      done
+                      if test -z "$haveit"; then
+                        ltrpathdirs="$ltrpathdirs $dir"
+                      fi
+                    fi
+                    ;;
+                  -l*)
+                                        names_next_round="$names_next_round "`echo "X$dep" | sed -e 's/^X-l//'`
+                    ;;
+                  *.la)
+                                                                                names_next_round="$names_next_round "`echo "X$dep" | sed -e 's,^X.*/,,' -e 's,^lib,,' -e 's,\.la$,,'`
+                    ;;
+                  *)
+                                        LIBINTL="${LIBINTL}${LIBINTL:+ }$dep"
+                    LTLIBINTL="${LTLIBINTL}${LTLIBINTL:+ }$dep"
+                    ;;
+                esac
+              done
+            fi
+          else
+                                                            LIBINTL="${LIBINTL}${LIBINTL:+ }-l$name"
+            LTLIBINTL="${LTLIBINTL}${LTLIBINTL:+ }-l$name"
+          fi
+        fi
+      fi
+    done
+  done
+  if test "X$rpathdirs" != "X"; then
+    if test -n "$hardcode_libdir_separator"; then
+                        alldirs=
+      for found_dir in $rpathdirs; do
+        alldirs="${alldirs}${alldirs:+$hardcode_libdir_separator}$found_dir"
+      done
+            acl_save_libdir="$libdir"
+      libdir="$alldirs"
+      eval flag=\"$hardcode_libdir_flag_spec\"
+      libdir="$acl_save_libdir"
+      LIBINTL="${LIBINTL}${LIBINTL:+ }$flag"
+    else
+            for found_dir in $rpathdirs; do
+        acl_save_libdir="$libdir"
+        libdir="$found_dir"
+        eval flag=\"$hardcode_libdir_flag_spec\"
+        libdir="$acl_save_libdir"
+        LIBINTL="${LIBINTL}${LIBINTL:+ }$flag"
+      done
+    fi
+  fi
+  if test "X$ltrpathdirs" != "X"; then
+            for found_dir in $ltrpathdirs; do
+      LTLIBINTL="${LTLIBINTL}${LTLIBINTL:+ }-R$found_dir"
+    done
+  fi
+
+          echo "$as_me:$LINENO: checking for GNU gettext in libintl" >&5
+echo $ECHO_N "checking for GNU gettext in libintl... $ECHO_C" >&6
+if test "${gt_cv_func_gnugettext1_libintl+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  gt_save_CPPFLAGS="$CPPFLAGS"
+            CPPFLAGS="$CPPFLAGS $INCINTL"
+            gt_save_LIBS="$LIBS"
+            LIBS="$LIBS $LIBINTL"
+                        cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <libintl.h>
+extern int _nl_msg_cat_cntr;
+extern
+#ifdef __cplusplus
+"C"
+#endif
+const char *_nl_expand_alias ();
+int
+main ()
+{
+bindtextdomain ("", "");
+return (int) gettext ("") + _nl_msg_cat_cntr + *_nl_expand_alias (0)
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  gt_cv_func_gnugettext1_libintl=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+gt_cv_func_gnugettext1_libintl=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+                        if test "$gt_cv_func_gnugettext1_libintl" != yes && test -n "$LIBICONV"; then
+              LIBS="$LIBS $LIBICONV"
+              cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <libintl.h>
+extern int _nl_msg_cat_cntr;
+extern
+#ifdef __cplusplus
+"C"
+#endif
+const char *_nl_expand_alias ();
+int
+main ()
+{
+bindtextdomain ("", "");
+return (int) gettext ("") + _nl_msg_cat_cntr + *_nl_expand_alias (0)
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  LIBINTL="$LIBINTL $LIBICONV"
+                LTLIBINTL="$LTLIBINTL $LTLIBICONV"
+                gt_cv_func_gnugettext1_libintl=yes
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+            fi
+            CPPFLAGS="$gt_save_CPPFLAGS"
+            LIBS="$gt_save_LIBS"
+fi
+echo "$as_me:$LINENO: result: $gt_cv_func_gnugettext1_libintl" >&5
+echo "${ECHO_T}$gt_cv_func_gnugettext1_libintl" >&6
+        fi
+
+                                        if test "$gt_cv_func_gnugettext1_libc" = "yes" \
+           || { test "$gt_cv_func_gnugettext1_libintl" = "yes" \
+                && test "$PACKAGE" != gettext; }; then
+          gt_use_preinstalled_gnugettext=yes
+        else
+                    LIBINTL=
+          LTLIBINTL=
+          INCINTL=
+        fi
+
+
+        if test "$gt_use_preinstalled_gnugettext" != "yes"; then
+                              nls_cv_use_gnu_gettext=yes
+        fi
+      fi
+
+      if test "$nls_cv_use_gnu_gettext" = "yes"; then
+                INTLOBJS="\$(GETTOBJS)"
+        BUILD_INCLUDED_LIBINTL=yes
+        USE_INCLUDED_LIBINTL=yes
+        LIBINTL="\${top_builddir}/intl/libintl.a $LIBICONV"
+        LTLIBINTL="\${top_builddir}/intl/libintl.a $LTLIBICONV"
+        LIBS=`echo " $LIBS " | sed -e 's/ -lintl / /' -e 's/^ //' -e 's/ $//'`
+      fi
+
+      if test "$gt_use_preinstalled_gnugettext" = "yes" \
+         || test "$nls_cv_use_gnu_gettext" = "yes"; then
+                CATOBJEXT=.gmo
+      fi
+
+
+    if test "$gt_use_preinstalled_gnugettext" = "yes" \
+       || test "$nls_cv_use_gnu_gettext" = "yes"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define ENABLE_NLS 1
+_ACEOF
+
+    else
+      USE_NLS=no
+    fi
+  fi
+
+  if test "$USE_NLS" = "yes"; then
+
+    if test "$gt_use_preinstalled_gnugettext" = "yes"; then
+      if test "$gt_cv_func_gnugettext1_libintl" = "yes"; then
+        echo "$as_me:$LINENO: checking how to link with libintl" >&5
+echo $ECHO_N "checking how to link with libintl... $ECHO_C" >&6
+        echo "$as_me:$LINENO: result: $LIBINTL" >&5
+echo "${ECHO_T}$LIBINTL" >&6
+
+  for element in $INCINTL; do
+    haveit=
+    for x in $CPPFLAGS; do
+
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  eval x=\"$x\"
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+
+      if test "X$x" = "X$element"; then
+        haveit=yes
+        break
+      fi
+    done
+    if test -z "$haveit"; then
+      CPPFLAGS="${CPPFLAGS}${CPPFLAGS:+ }$element"
+    fi
+  done
+
+      fi
+
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETTEXT 1
+_ACEOF
+
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_DCGETTEXT 1
+_ACEOF
+
+    fi
+
+        POSUB=po
+  fi
+
+
+            if test "$PACKAGE" = gettext; then
+      BUILD_INCLUDED_LIBINTL=yes
+    fi
+
+
+
+
+
+
+        nls_cv_header_intl=
+    nls_cv_header_libgt=
+
+        DATADIRNAME=share
+
+
+        INSTOBJEXT=.mo
+
+
+        GENCAT=gencat
+
+
+        INTL_LIBTOOL_SUFFIX_PREFIX=
+
+
+
+    INTLLIBS="$LIBINTL"
+
+
+
+
+
+
+localedir='${prefix}/share/locale'
+
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_CATGETS 1
+_ACEOF
+
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_GETTEXT 1
+_ACEOF
+
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_LC_MESSAGES 1
+_ACEOF
+
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_STPCPY 1
+_ACEOF
+
+
+cat >>confdefs.h <<\_ACEOF
+#define ENABLE_NLS 1
+_ACEOF
+
+
+#dnl --------------------------------------
+#dnl Check whether to add /usr/local or not
+#dnl (this is somewhat a religious problem)
+#dnl --------------------------------------
+#dnl
+#if test "`$CPP -v < /dev/null 2>&1 | grep '/usr/local/include' 2>&1`" = ""; then
+#  CPPFLAGS="$CPPFLAGS -I/usr/local/include"
+#  LDFLAGS="$LDFLAGS -L/usr/local/lib"
+#fi
+
+
+for ac_func in gethostbyname
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+else
+
+echo "$as_me:$LINENO: checking for gethostbyname in -lnsl" >&5
+echo $ECHO_N "checking for gethostbyname in -lnsl... $ECHO_C" >&6
+if test "${ac_cv_lib_nsl_gethostbyname+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lnsl  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gethostbyname ();
+int
+main ()
+{
+gethostbyname ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_nsl_gethostbyname=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_nsl_gethostbyname=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_nsl_gethostbyname" >&5
+echo "${ECHO_T}$ac_cv_lib_nsl_gethostbyname" >&6
+if test $ac_cv_lib_nsl_gethostbyname = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBNSL 1
+_ACEOF
+
+  LIBS="-lnsl $LIBS"
+
+else
+
+echo "$as_me:$LINENO: checking for gethostbyname in -lsocket" >&5
+echo $ECHO_N "checking for gethostbyname in -lsocket... $ECHO_C" >&6
+if test "${ac_cv_lib_socket_gethostbyname+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsocket  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char gethostbyname ();
+int
+main ()
+{
+gethostbyname ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_socket_gethostbyname=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_socket_gethostbyname=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_socket_gethostbyname" >&5
+echo "${ECHO_T}$ac_cv_lib_socket_gethostbyname" >&6
+if test $ac_cv_lib_socket_gethostbyname = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBSOCKET 1
+_ACEOF
+
+  LIBS="-lsocket $LIBS"
+
+fi
+
+fi
+
+fi
+done
+
+
+for ac_func in setsockopt
+do
+as_ac_var=`echo "ac_cv_func_$ac_func" | $as_tr_sh`
+echo "$as_me:$LINENO: checking for $ac_func" >&5
+echo $ECHO_N "checking for $ac_func... $ECHO_C" >&6
+if eval "test \"\${$as_ac_var+set}\" = set"; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+/* System header to define __stub macros and hopefully few prototypes,
+    which can conflict with char $ac_func (); below.
+    Prefer <limits.h> to <assert.h> if __STDC__ is defined, since
+    <limits.h> exists even on freestanding compilers.  */
+#ifdef __STDC__
+# include <limits.h>
+#else
+# include <assert.h>
+#endif
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char $ac_func ();
+/* The GNU C library defines this for functions which it implements
+    to always fail with ENOSYS.  Some functions are actually named
+    something starting with __ and the normal name is an alias.  */
+#if defined (__stub_$ac_func) || defined (__stub___$ac_func)
+choke me
+#else
+char (*f) () = $ac_func;
+#endif
+#ifdef __cplusplus
+}
+#endif
+
+int
+main ()
+{
+return f != $ac_func;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  eval "$as_ac_var=yes"
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+eval "$as_ac_var=no"
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+fi
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_var'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_var'}'`" >&6
+if test `eval echo '${'$as_ac_var'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_func" | $as_tr_cpp` 1
+_ACEOF
+
+else
+
+echo "$as_me:$LINENO: checking for setsockopt in -lsocket" >&5
+echo $ECHO_N "checking for setsockopt in -lsocket... $ECHO_C" >&6
+if test "${ac_cv_lib_socket_setsockopt+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lsocket  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char setsockopt ();
+int
+main ()
+{
+setsockopt ();
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_socket_setsockopt=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_socket_setsockopt=no
+fi
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_socket_setsockopt" >&5
+echo "${ECHO_T}$ac_cv_lib_socket_setsockopt" >&6
+if test $ac_cv_lib_socket_setsockopt = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBSOCKET 1
+_ACEOF
+
+  LIBS="-lsocket $LIBS"
+
+fi
+
+fi
+done
+
+
+
+# Check whether --with-glib-prefix or --without-glib-prefix was given.
+if test "${with_glib_prefix+set}" = set; then
+  withval="$with_glib_prefix"
+  glib_config_prefix="$withval"
+else
+  glib_config_prefix=""
+fi;
+
+# Check whether --with-glib-exec-prefix or --without-glib-exec-prefix was given.
+if test "${with_glib_exec_prefix+set}" = set; then
+  withval="$with_glib_exec_prefix"
+  glib_config_exec_prefix="$withval"
+else
+  glib_config_exec_prefix=""
+fi;
+# Check whether --enable-glibtest or --disable-glibtest was given.
+if test "${enable_glibtest+set}" = set; then
+  enableval="$enable_glibtest"
+
+else
+  enable_glibtest=yes
+fi;
+
+  if test x$glib_config_exec_prefix != x ; then
+     glib_config_args="$glib_config_args --exec-prefix=$glib_config_exec_prefix"
+     if test x${GLIB_CONFIG+set} != xset ; then
+        GLIB_CONFIG=$glib_config_exec_prefix/bin/glib-config
+     fi
+  fi
+  if test x$glib_config_prefix != x ; then
+     glib_config_args="$glib_config_args --prefix=$glib_config_prefix"
+     if test x${GLIB_CONFIG+set} != xset ; then
+        GLIB_CONFIG=$glib_config_prefix/bin/glib-config
+     fi
+  fi
+
+  for module in .
+  do
+      case "$module" in
+         gmodule)
+             glib_config_args="$glib_config_args gmodule"
+         ;;
+         gthread)
+             glib_config_args="$glib_config_args gthread"
+         ;;
+      esac
+  done
+
+  # Extract the first word of "glib-config", so it can be a program name with args.
+set dummy glib-config; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_GLIB_CONFIG+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
   case $GLIB_CONFIG in
   [\\/]* | ?:[\\/]*)
   ac_cv_path_GLIB_CONFIG="$GLIB_CONFIG" # Let the user override the test with a path.
@@ -4290,53 +8181,34 @@
      { { echo "$as_me:$LINENO: error: Unable to find Gtk+ with a version >= 1.2.0. Dillo NEEDS Gtk+" >&5
 echo "$as_me: error: Unable to find Gtk+ with a version >= 1.2.0. Dillo NEEDS Gtk+" >&2;}
    { (exit 1); exit 1; }; }
-  fi
-
-
-  rm -f conf.gtktest
-
-
-if test "x$enable_jpeg" = "xyes"; then
-
-echo "$as_me:$LINENO: checking for egrep" >&5
-echo $ECHO_N "checking for egrep... $ECHO_C" >&6
-if test "${ac_cv_prog_egrep+set}" = set; then
-  echo $ECHO_N "(cached) $ECHO_C" >&6
-else
-  if echo a | (grep -E '(a|b)') >/dev/null 2>&1
-    then ac_cv_prog_egrep='grep -E'
-    else ac_cv_prog_egrep='egrep'
-    fi
-fi
-echo "$as_me:$LINENO: result: $ac_cv_prog_egrep" >&5
-echo "${ECHO_T}$ac_cv_prog_egrep" >&6
- EGREP=$ac_cv_prog_egrep
+  fi
 
 
-echo "$as_me:$LINENO: checking for ANSI C header files" >&5
-echo $ECHO_N "checking for ANSI C header files... $ECHO_C" >&6
-if test "${ac_cv_header_stdc+set}" = set; then
+  rm -f conf.gtktest
+
+
+if test "x$enable_jpeg" = "xyes"; then
+  if test "${ac_cv_header_jpeglib_h+set}" = set; then
+  echo "$as_me:$LINENO: checking for jpeglib.h" >&5
+echo $ECHO_N "checking for jpeglib.h... $ECHO_C" >&6
+if test "${ac_cv_header_jpeglib_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_jpeglib_h" >&5
+echo "${ECHO_T}$ac_cv_header_jpeglib_h" >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking jpeglib.h usability" >&5
+echo $ECHO_N "checking jpeglib.h usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#include <stdlib.h>
-#include <stdarg.h>
-#include <string.h>
-#include <float.h>
-
-int
-main ()
-{
-
-  ;
-  return 0;
-}
+$ac_includes_default
+#include <jpeglib.h>
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
@@ -4350,204 +8222,428 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_header_stdc=yes
+  ac_header_compiler=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-ac_cv_header_stdc=no
+ac_header_compiler=no
 fi
 rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
 
-if test $ac_cv_header_stdc = yes; then
-  # SunOS 4.x string.h does not declare mem*, contrary to ANSI.
-  cat >conftest.$ac_ext <<_ACEOF
+# Is the header present?
+echo "$as_me:$LINENO: checking jpeglib.h presence" >&5
+echo $ECHO_N "checking jpeglib.h presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#include <string.h>
-
+#include <jpeglib.h>
 _ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "memchr" >/dev/null 2>&1; then
-  :
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
 else
-  ac_cv_header_stdc=no
+  ac_cpp_err=yes
 fi
-rm -f conftest*
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
+  ac_header_preproc=no
 fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
 
-if test $ac_cv_header_stdc = yes; then
-  # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.
-  cat >conftest.$ac_ext <<_ACEOF
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: jpeglib.h: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: jpeglib.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: jpeglib.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: jpeglib.h: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: jpeglib.h: present but cannot be compiled" >&5
+echo "$as_me: WARNING: jpeglib.h: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: jpeglib.h: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: jpeglib.h: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: jpeglib.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: jpeglib.h: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for jpeglib.h" >&5
+echo $ECHO_N "checking for jpeglib.h... $ECHO_C" >&6
+if test "${ac_cv_header_jpeglib_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_header_jpeglib_h=$ac_header_preproc
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_jpeglib_h" >&5
+echo "${ECHO_T}$ac_cv_header_jpeglib_h" >&6
+
+fi
+if test $ac_cv_header_jpeglib_h = yes; then
+  jpeg_ok=yes
+else
+  jpeg_ok=no
+fi
+
+
+
+  if test -e /usr/include/jpeglib.h || test -e /usr/local/include/jpeglib.h
+  then
+    jpeg_ok=yes
+  fi
+
+  if test "x$jpeg_ok" = "xyes"; then
+    old_libs="$LIBS"
+    echo "$as_me:$LINENO: checking for jpeg_destroy_decompress in -ljpeg" >&5
+echo $ECHO_N "checking for jpeg_destroy_decompress in -ljpeg... $ECHO_C" >&6
+if test "${ac_cv_lib_jpeg_jpeg_destroy_decompress+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-ljpeg  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#include <stdlib.h>
 
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char jpeg_destroy_decompress ();
+int
+main ()
+{
+jpeg_destroy_decompress ();
+  ;
+  return 0;
+}
 _ACEOF
-if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
-  $EGREP "free" >/dev/null 2>&1; then
-  :
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest$ac_exeext'
+  { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); }; }; then
+  ac_cv_lib_jpeg_jpeg_destroy_decompress=yes
 else
-  ac_cv_header_stdc=no
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+ac_cv_lib_jpeg_jpeg_destroy_decompress=no
 fi
-rm -f conftest*
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+echo "$as_me:$LINENO: result: $ac_cv_lib_jpeg_jpeg_destroy_decompress" >&5
+echo "${ECHO_T}$ac_cv_lib_jpeg_jpeg_destroy_decompress" >&6
+if test $ac_cv_lib_jpeg_jpeg_destroy_decompress = yes; then
+  jpeg_ok=yes
+else
+  jpeg_ok=no
+fi
+
+    LIBS="$old_libs"
+  fi
 
+  if test "x$jpeg_ok" = "xyes"; then
+    LIBJPEG_LIBS="-ljpeg"
+    if test -n "$LIBJPEG_LIBDIR"; then
+      LIBJPEG_LDFLAGS="-L$LIBJPEG_LIBDIR"
+    fi
+    if test -n "$LIBJPEG_INCDIR"; then
+      LIBJPEG_CPPFLAGS="-I$LIBJPEG_INCDIR"
+    fi
+  else
+    { echo "$as_me:$LINENO: WARNING: *** No libjpeg found. Disabling jpeg images.***" >&5
+echo "$as_me: WARNING: *** No libjpeg found. Disabling jpeg images.***" >&2;}
+  fi
 fi
 
-if test $ac_cv_header_stdc = yes; then
-  # /bin/cc in Irix-4.0.5 gets non-ANSI ctype macros unless using -ansi.
-  if test "$cross_compiling" = yes; then
-  :
+if test "x$jpeg_ok" = "xyes"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define ENABLE_JPEG
+_ACEOF
+
+fi
+
+  if test "${ac_cv_header_zlib_h+set}" = set; then
+  echo "$as_me:$LINENO: checking for zlib.h" >&5
+echo $ECHO_N "checking for zlib.h... $ECHO_C" >&6
+if test "${ac_cv_header_zlib_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_zlib_h" >&5
+echo "${ECHO_T}$ac_cv_header_zlib_h" >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
+  # Is the header compilable?
+echo "$as_me:$LINENO: checking zlib.h usability" >&5
+echo $ECHO_N "checking zlib.h usability... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#include <ctype.h>
-#if ((' ' & 0x0FF) == 0x020)
-# define ISLOWER(c) ('a' <= (c) && (c) <= 'z')
-# define TOUPPER(c) (ISLOWER(c) ? 'A' + ((c) - 'a') : (c))
-#else
-# define ISLOWER(c) \
-                   (('a' <= (c) && (c) <= 'i') \
-                     || ('j' <= (c) && (c) <= 'r') \
-                     || ('s' <= (c) && (c) <= 'z'))
-# define TOUPPER(c) (ISLOWER(c) ? ((c) | 0x40) : (c))
-#endif
-
-#define XOR(e, f) (((e) && !(f)) || (!(e) && (f)))
-int
-main ()
-{
-  int i;
-  for (i = 0; i < 256; i++)
-    if (XOR (islower (i), ISLOWER (i))
-        || toupper (i) != TOUPPER (i))
-      exit(2);
-  exit (0);
-}
+$ac_includes_default
+#include <zlib.h>
 _ACEOF
-rm -f conftest$ac_exeext
-if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
-  (eval $ac_link) 2>&5
+rm -f conftest.$ac_objext
+if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
+  (eval $ac_compile) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
-  (exit $ac_status); } && { ac_try='./conftest$ac_exeext'
+  (exit $ac_status); } &&
+         { ac_try='test -s conftest.$ac_objext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  :
+  ac_header_compiler=yes
 else
-  echo "$as_me: program exited with status $ac_status" >&5
-echo "$as_me: failed program was:" >&5
+  echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-( exit $ac_status )
-ac_cv_header_stdc=no
-fi
-rm -f core core.* *.core gmon.out bb.out conftest$ac_exeext conftest.$ac_objext conftest.$ac_ext
-fi
-fi
+ac_header_compiler=no
 fi
-echo "$as_me:$LINENO: result: $ac_cv_header_stdc" >&5
-echo "${ECHO_T}$ac_cv_header_stdc" >&6
-if test $ac_cv_header_stdc = yes; then
+rm -f conftest.$ac_objext conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_compiler" >&5
+echo "${ECHO_T}$ac_header_compiler" >&6
 
-cat >>confdefs.h <<\_ACEOF
-#define STDC_HEADERS 1
+# Is the header present?
+echo "$as_me:$LINENO: checking zlib.h presence" >&5
+echo $ECHO_N "checking zlib.h presence... $ECHO_C" >&6
+cat >conftest.$ac_ext <<_ACEOF
+#line $LINENO "configure"
+/* confdefs.h.  */
 _ACEOF
-
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#include <zlib.h>
+_ACEOF
+if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
+  (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } >/dev/null; then
+  if test -s conftest.err; then
+    ac_cpp_err=$ac_c_preproc_warn_flag
+  else
+    ac_cpp_err=
+  fi
+else
+  ac_cpp_err=yes
 fi
+if test -z "$ac_cpp_err"; then
+  ac_header_preproc=yes
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
 
-# On IRIX 5.3, sys/types and inttypes.h are conflicting.
-
-
-
-
+  ac_header_preproc=no
+fi
+rm -f conftest.err conftest.$ac_ext
+echo "$as_me:$LINENO: result: $ac_header_preproc" >&5
+echo "${ECHO_T}$ac_header_preproc" >&6
 
+# So?  What about this header?
+case $ac_header_compiler:$ac_header_preproc in
+  yes:no )
+    { echo "$as_me:$LINENO: WARNING: zlib.h: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: zlib.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: zlib.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: zlib.h: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+  no:yes )
+    { echo "$as_me:$LINENO: WARNING: zlib.h: present but cannot be compiled" >&5
+echo "$as_me: WARNING: zlib.h: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: zlib.h: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: zlib.h: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: zlib.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: zlib.h: proceeding with the preprocessor's result" >&2;}
+    (
+      cat <<\_ASBOX
+## ------------------------------------ ##
+## Report this to bug-autoconf@gnu.org. ##
+## ------------------------------------ ##
+_ASBOX
+    ) |
+      sed "s/^/$as_me: WARNING:     /" >&2
+    ;;
+esac
+echo "$as_me:$LINENO: checking for zlib.h" >&5
+echo $ECHO_N "checking for zlib.h... $ECHO_C" >&6
+if test "${ac_cv_header_zlib_h+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  ac_cv_header_zlib_h=$ac_header_preproc
+fi
+echo "$as_me:$LINENO: result: $ac_cv_header_zlib_h" >&5
+echo "${ECHO_T}$ac_cv_header_zlib_h" >&6
 
+fi
+if test $ac_cv_header_zlib_h = yes; then
+  libz_ok=yes
+else
+  libz_ok=no
+fi
 
 
 
-for ac_header in sys/types.h sys/stat.h stdlib.h string.h memory.h strings.h \
-                  inttypes.h stdint.h unistd.h
-do
-as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
-echo "$as_me:$LINENO: checking for $ac_header" >&5
-echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
-if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  if test "x$libz_ok" = "xyes"; then
+    old_libs="$LIBS"
+    echo "$as_me:$LINENO: checking for zlibVersion in -lz" >&5
+echo $ECHO_N "checking for zlibVersion in -lz... $ECHO_C" >&6
+if test "${ac_cv_lib_z_zlibVersion+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  cat >conftest.$ac_ext <<_ACEOF
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lz  $LIBS"
+cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
 /* confdefs.h.  */
 _ACEOF
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-$ac_includes_default
 
-#include <$ac_header>
+/* Override any gcc2 internal prototype to avoid an error.  */
+#ifdef __cplusplus
+extern "C"
+#endif
+/* We use char because int might match the return type of a gcc2
+   builtin and then its argument prototype would still apply.  */
+char zlibVersion ();
+int
+main ()
+{
+zlibVersion ();
+  ;
+  return 0;
+}
 _ACEOF
-rm -f conftest.$ac_objext
-if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
-  (eval $ac_compile) 2>&5
+rm -f conftest.$ac_objext conftest$ac_exeext
+if { (eval echo "$as_me:$LINENO: \"$ac_link\"") >&5
+  (eval $ac_link) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); } &&
-         { ac_try='test -s conftest.$ac_objext'
+         { ac_try='test -s conftest$ac_exeext'
   { (eval echo "$as_me:$LINENO: \"$ac_try\"") >&5
   (eval $ac_try) 2>&5
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  eval "$as_ac_Header=yes"
+  ac_cv_lib_z_zlibVersion=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-eval "$as_ac_Header=no"
+ac_cv_lib_z_zlibVersion=no
 fi
-rm -f conftest.$ac_objext conftest.$ac_ext
+rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
-echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
-if test `eval echo '${'$as_ac_Header'}'` = yes; then
-  cat >>confdefs.h <<_ACEOF
-#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
-_ACEOF
-
+echo "$as_me:$LINENO: result: $ac_cv_lib_z_zlibVersion" >&5
+echo "${ECHO_T}$ac_cv_lib_z_zlibVersion" >&6
+if test $ac_cv_lib_z_zlibVersion = yes; then
+  libz_ok=yes
+else
+  libz_ok=no
 fi
 
-done
+    LIBS="$old_libs"
+  fi
 
+  if test "x$libz_ok" = xyes; then
+    LIBZ_LIBS="-lz"
+  else
+    { echo "$as_me:$LINENO: WARNING: *** No libz found. Disabling PNG images ***" >&5
+echo "$as_me: WARNING: *** No libz found. Disabling PNG images ***" >&2;}
+  fi
 
-if test "${ac_cv_header_jpeglib_h+set}" = set; then
-  echo "$as_me:$LINENO: checking for jpeglib.h" >&5
-echo $ECHO_N "checking for jpeglib.h... $ECHO_C" >&6
-if test "${ac_cv_header_jpeglib_h+set}" = set; then
+if test "x$enable_png" = "xyes" && test "x$libz_ok" = "xyes"; then
+
+
+for ac_header in png.h libpng/png.h
+do
+as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
+  echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 fi
-echo "$as_me:$LINENO: result: $ac_cv_header_jpeglib_h" >&5
-echo "${ECHO_T}$ac_cv_header_jpeglib_h" >&6
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
 else
   # Is the header compilable?
-echo "$as_me:$LINENO: checking jpeglib.h usability" >&5
-echo $ECHO_N "checking jpeglib.h usability... $ECHO_C" >&6
+echo "$as_me:$LINENO: checking $ac_header usability" >&5
+echo $ECHO_N "checking $ac_header usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
 /* confdefs.h.  */
@@ -4556,7 +8652,7 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-#include <jpeglib.h>
+#include <$ac_header>
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
@@ -4582,8 +8678,8 @@
 echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
-echo "$as_me:$LINENO: checking jpeglib.h presence" >&5
-echo $ECHO_N "checking jpeglib.h presence... $ECHO_C" >&6
+echo "$as_me:$LINENO: checking $ac_header presence" >&5
+echo $ECHO_N "checking $ac_header presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
 /* confdefs.h.  */
@@ -4591,7 +8687,7 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#include <jpeglib.h>
+#include <$ac_header>
 _ACEOF
 if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
@@ -4624,10 +8720,10 @@
 # So?  What about this header?
 case $ac_header_compiler:$ac_header_preproc in
   yes:no )
-    { echo "$as_me:$LINENO: WARNING: jpeglib.h: accepted by the compiler, rejected by the preprocessor!" >&5
-echo "$as_me: WARNING: jpeglib.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: jpeglib.h: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: jpeglib.h: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: $ac_header: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
     (
       cat <<\_ASBOX
 ## ------------------------------------ ##
@@ -4638,12 +8734,12 @@
       sed "s/^/$as_me: WARNING:     /" >&2
     ;;
   no:yes )
-    { echo "$as_me:$LINENO: WARNING: jpeglib.h: present but cannot be compiled" >&5
-echo "$as_me: WARNING: jpeglib.h: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: jpeglib.h: check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: jpeglib.h: check for missing prerequisite headers?" >&2;}
-    { echo "$as_me:$LINENO: WARNING: jpeglib.h: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: jpeglib.h: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: present but cannot be compiled" >&5
+echo "$as_me: WARNING: $ac_header: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: $ac_header: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: $ac_header: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: $ac_header: proceeding with the preprocessor's result" >&2;}
     (
       cat <<\_ASBOX
 ## ------------------------------------ ##
@@ -4654,34 +8750,38 @@
       sed "s/^/$as_me: WARNING:     /" >&2
     ;;
 esac
-echo "$as_me:$LINENO: checking for jpeglib.h" >&5
-echo $ECHO_N "checking for jpeglib.h... $ECHO_C" >&6
-if test "${ac_cv_header_jpeglib_h+set}" = set; then
+echo "$as_me:$LINENO: checking for $ac_header" >&5
+echo $ECHO_N "checking for $ac_header... $ECHO_C" >&6
+if eval "test \"\${$as_ac_Header+set}\" = set"; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  ac_cv_header_jpeglib_h=$ac_header_preproc
+  eval "$as_ac_Header=$ac_header_preproc"
 fi
-echo "$as_me:$LINENO: result: $ac_cv_header_jpeglib_h" >&5
-echo "${ECHO_T}$ac_cv_header_jpeglib_h" >&6
+echo "$as_me:$LINENO: result: `eval echo '${'$as_ac_Header'}'`" >&5
+echo "${ECHO_T}`eval echo '${'$as_ac_Header'}'`" >&6
 
 fi
-if test $ac_cv_header_jpeglib_h = yes; then
-  jpeg_ok=yes
+if test `eval echo '${'$as_ac_Header'}'` = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
+_ACEOF
+ png_ok=yes && break
 else
-  jpeg_ok=no
+  png_ok=no
 fi
 
+done
 
 
-  if test "x$jpeg_ok" = "xyes"; then
-    old_libs="$LIBS"
-    echo "$as_me:$LINENO: checking for jpeg_destroy_decompress in -ljpeg" >&5
-echo $ECHO_N "checking for jpeg_destroy_decompress in -ljpeg... $ECHO_C" >&6
-if test "${ac_cv_lib_jpeg_jpeg_destroy_decompress+set}" = set; then
+    if test "x$png_ok" = "xyes"; then
+      old_libs="$LIBS"
+      echo "$as_me:$LINENO: checking for png_check_sig in -lpng" >&5
+echo $ECHO_N "checking for png_check_sig in -lpng... $ECHO_C" >&6
+if test "${ac_cv_lib_png_png_check_sig+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-ljpeg  $LIBS"
+LIBS="-lpng $LIBZ_LIBS -lm $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
 /* confdefs.h.  */
@@ -4696,11 +8796,11 @@
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
-char jpeg_destroy_decompress ();
+char png_check_sig ();
 int
 main ()
 {
-jpeg_destroy_decompress ();
+png_check_sig ();
   ;
   return 0;
 }
@@ -4717,62 +8817,65 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_jpeg_jpeg_destroy_decompress=yes
+  ac_cv_lib_png_png_check_sig=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-ac_cv_lib_jpeg_jpeg_destroy_decompress=no
+ac_cv_lib_png_png_check_sig=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:$LINENO: result: $ac_cv_lib_jpeg_jpeg_destroy_decompress" >&5
-echo "${ECHO_T}$ac_cv_lib_jpeg_jpeg_destroy_decompress" >&6
-if test $ac_cv_lib_jpeg_jpeg_destroy_decompress = yes; then
-  jpeg_ok=yes
+echo "$as_me:$LINENO: result: $ac_cv_lib_png_png_check_sig" >&5
+echo "${ECHO_T}$ac_cv_lib_png_png_check_sig" >&6
+if test $ac_cv_lib_png_png_check_sig = yes; then
+  png_ok=yes
 else
-  jpeg_ok=no
+  png_ok=no
 fi
 
-    LIBS="$old_libs"
-  fi
+      LIBS="$old_libs"
 
-  if test "x$jpeg_ok" = "xyes"; then
-    LIBJPEG_LIBS="-ljpeg"
-    if test -n "$LIBJPEG_LIBDIR"; then
-      LIBJPEG_LDFLAGS="-L$LIBJPEG_LIBDIR"
+      if test "x$png_ok" = "xyes"; then
+        LIBPNG_LIBS="-lpng -lm"
+      fi
     fi
-    if test -n "$LIBJPEG_INCDIR"; then
-      LIBJPEG_CPPFLAGS="-I$LIBJPEG_INCDIR"
+
+    if test "x$png_ok" = "xno"; then
+      { echo "$as_me:$LINENO: WARNING: *** No libpng found. Disabling PNG images ***" >&5
+echo "$as_me: WARNING: *** No libpng found. Disabling PNG images ***" >&2;}
     fi
-  else
-    { echo "$as_me:$LINENO: WARNING: *** No libjpeg found. Disabling jpeg images.***" >&5
-echo "$as_me: WARNING: *** No libjpeg found. Disabling jpeg images.***" >&2;}
-  fi
 fi
 
-if test "x$jpeg_ok" = "xyes"; then
+if test "x$png_ok" = "xyes"; then
 
 cat >>confdefs.h <<\_ACEOF
-#define ENABLE_JPEG
+#define ENABLE_PNG
 _ACEOF
 
 fi
 
-if test "x$enable_png" = "xyes"; then
-  if test "${ac_cv_header_zlib_h+set}" = set; then
-  echo "$as_me:$LINENO: checking for zlib.h" >&5
-echo $ECHO_N "checking for zlib.h... $ECHO_C" >&6
-if test "${ac_cv_header_zlib_h+set}" = set; then
+if test "x$enable_gif" = "xyes"; then
+
+cat >>confdefs.h <<\_ACEOF
+#define ENABLE_GIF
+_ACEOF
+
+fi
+
+  if test "${ac_cv_header_iconv_h+set}" = set; then
+  echo "$as_me:$LINENO: checking for iconv.h" >&5
+echo $ECHO_N "checking for iconv.h... $ECHO_C" >&6
+if test "${ac_cv_header_iconv_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 fi
-echo "$as_me:$LINENO: result: $ac_cv_header_zlib_h" >&5
-echo "${ECHO_T}$ac_cv_header_zlib_h" >&6
+echo "$as_me:$LINENO: result: $ac_cv_header_iconv_h" >&5
+echo "${ECHO_T}$ac_cv_header_iconv_h" >&6
 else
   # Is the header compilable?
-echo "$as_me:$LINENO: checking zlib.h usability" >&5
-echo $ECHO_N "checking zlib.h usability... $ECHO_C" >&6
+echo "$as_me:$LINENO: checking iconv.h usability" >&5
+echo $ECHO_N "checking iconv.h usability... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
 /* confdefs.h.  */
@@ -4781,7 +8884,7 @@
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
 $ac_includes_default
-#include <zlib.h>
+#include <iconv.h>
 _ACEOF
 rm -f conftest.$ac_objext
 if { (eval echo "$as_me:$LINENO: \"$ac_compile\"") >&5
@@ -4807,8 +8910,8 @@
 echo "${ECHO_T}$ac_header_compiler" >&6
 
 # Is the header present?
-echo "$as_me:$LINENO: checking zlib.h presence" >&5
-echo $ECHO_N "checking zlib.h presence... $ECHO_C" >&6
+echo "$as_me:$LINENO: checking iconv.h presence" >&5
+echo $ECHO_N "checking iconv.h presence... $ECHO_C" >&6
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
 /* confdefs.h.  */
@@ -4816,7 +8919,7 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-#include <zlib.h>
+#include <iconv.h>
 _ACEOF
 if { (eval echo "$as_me:$LINENO: \"$ac_cpp conftest.$ac_ext\"") >&5
   (eval $ac_cpp conftest.$ac_ext) 2>conftest.er1
@@ -4849,10 +8952,10 @@
 # So?  What about this header?
 case $ac_header_compiler:$ac_header_preproc in
   yes:no )
-    { echo "$as_me:$LINENO: WARNING: zlib.h: accepted by the compiler, rejected by the preprocessor!" >&5
-echo "$as_me: WARNING: zlib.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
-    { echo "$as_me:$LINENO: WARNING: zlib.h: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: zlib.h: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: iconv.h: accepted by the compiler, rejected by the preprocessor!" >&5
+echo "$as_me: WARNING: iconv.h: accepted by the compiler, rejected by the preprocessor!" >&2;}
+    { echo "$as_me:$LINENO: WARNING: iconv.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: iconv.h: proceeding with the preprocessor's result" >&2;}
     (
       cat <<\_ASBOX
 ## ------------------------------------ ##
@@ -4863,12 +8966,12 @@
       sed "s/^/$as_me: WARNING:     /" >&2
     ;;
   no:yes )
-    { echo "$as_me:$LINENO: WARNING: zlib.h: present but cannot be compiled" >&5
-echo "$as_me: WARNING: zlib.h: present but cannot be compiled" >&2;}
-    { echo "$as_me:$LINENO: WARNING: zlib.h: check for missing prerequisite headers?" >&5
-echo "$as_me: WARNING: zlib.h: check for missing prerequisite headers?" >&2;}
-    { echo "$as_me:$LINENO: WARNING: zlib.h: proceeding with the preprocessor's result" >&5
-echo "$as_me: WARNING: zlib.h: proceeding with the preprocessor's result" >&2;}
+    { echo "$as_me:$LINENO: WARNING: iconv.h: present but cannot be compiled" >&5
+echo "$as_me: WARNING: iconv.h: present but cannot be compiled" >&2;}
+    { echo "$as_me:$LINENO: WARNING: iconv.h: check for missing prerequisite headers?" >&5
+echo "$as_me: WARNING: iconv.h: check for missing prerequisite headers?" >&2;}
+    { echo "$as_me:$LINENO: WARNING: iconv.h: proceeding with the preprocessor's result" >&5
+echo "$as_me: WARNING: iconv.h: proceeding with the preprocessor's result" >&2;}
     (
       cat <<\_ASBOX
 ## ------------------------------------ ##
@@ -4879,34 +8982,34 @@
       sed "s/^/$as_me: WARNING:     /" >&2
     ;;
 esac
-echo "$as_me:$LINENO: checking for zlib.h" >&5
-echo $ECHO_N "checking for zlib.h... $ECHO_C" >&6
-if test "${ac_cv_header_zlib_h+set}" = set; then
+echo "$as_me:$LINENO: checking for iconv.h" >&5
+echo $ECHO_N "checking for iconv.h... $ECHO_C" >&6
+if test "${ac_cv_header_iconv_h+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
-  ac_cv_header_zlib_h=$ac_header_preproc
+  ac_cv_header_iconv_h=$ac_header_preproc
 fi
-echo "$as_me:$LINENO: result: $ac_cv_header_zlib_h" >&5
-echo "${ECHO_T}$ac_cv_header_zlib_h" >&6
+echo "$as_me:$LINENO: result: $ac_cv_header_iconv_h" >&5
+echo "${ECHO_T}$ac_cv_header_iconv_h" >&6
 
 fi
-if test $ac_cv_header_zlib_h = yes; then
-  libz_ok=yes
+if test $ac_cv_header_iconv_h = yes; then
+  libiconv_ok=yes
 else
-  libz_ok=no
+  libiconv_ok=no
 fi
 
 
 
-  if test "x$libz_ok" = "xyes"; then
+  if test "x$libiconv_ok" = "xyes"; then
     old_libs="$LIBS"
-    echo "$as_me:$LINENO: checking for zlibVersion in -lz" >&5
-echo $ECHO_N "checking for zlibVersion in -lz... $ECHO_C" >&6
-if test "${ac_cv_lib_z_zlibVersion+set}" = set; then
+    echo "$as_me:$LINENO: checking for iconv_open in -liconv" >&5
+echo $ECHO_N "checking for iconv_open in -liconv... $ECHO_C" >&6
+if test "${ac_cv_lib_iconv_iconv_open+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lz  $LIBS"
+LIBS="-liconv  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
 /* confdefs.h.  */
@@ -4921,11 +9024,11 @@
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
-char zlibVersion ();
+char iconv_open ();
 int
 main ()
 {
-zlibVersion ();
+iconv_open ();
   ;
   return 0;
 }
@@ -4942,72 +9045,38 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_z_zlibVersion=yes
+  ac_cv_lib_iconv_iconv_open=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-ac_cv_lib_z_zlibVersion=no
+ac_cv_lib_iconv_iconv_open=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:$LINENO: result: $ac_cv_lib_z_zlibVersion" >&5
-echo "${ECHO_T}$ac_cv_lib_z_zlibVersion" >&6
-if test $ac_cv_lib_z_zlibVersion = yes; then
-  libz_ok=yes
+echo "$as_me:$LINENO: result: $ac_cv_lib_iconv_iconv_open" >&5
+echo "${ECHO_T}$ac_cv_lib_iconv_iconv_open" >&6
+if test $ac_cv_lib_iconv_iconv_open = yes; then
+  libiconv_ok=yes
 else
-  libz_ok=no
+  libiconv_ok=no
 fi
 
     LIBS="$old_libs"
   fi
 
-  if test "x$libz_ok" = xyes; then
-    LIBZ_LIBS="-lz"
+  if test "x$libiconv_ok" = xyes; then
+    LIBICONV_LIBS="-liconv"
   else
-    { echo "$as_me:$LINENO: WARNING: *** No libz found. Disabling PNG images ***" >&5
-echo "$as_me: WARNING: *** No libz found. Disabling PNG images ***" >&2;}
-  fi
-fi
-
-if test "x$enable_png" = "xyes" && test "x$libz_ok" = "xyes"; then
-  echo "$as_me:$LINENO: checking for libpng-config" >&5
-echo $ECHO_N "checking for libpng-config... $ECHO_C" >&6
-
-  if test -z "$PNG_CONFIG"; then
-    PNG_CONFIG=`which libpng12-config || which libpng-config || which libpng10-config`
+    { echo "$as_me:$LINENO: WARNING: *** No libiconv found. ***" >&5
+echo "$as_me: WARNING: *** No libiconv found. ***" >&2;}
   fi
 
-  if test -n "$PNG_CONFIG" && test -x "$PNG_CONFIG"; then
-    echo "$as_me:$LINENO: result: $PNG_CONFIG" >&5
-echo "${ECHO_T}$PNG_CONFIG" >&6
-    png_ok="yes"
-  else
-    echo "$as_me:$LINENO: result: missing" >&5
-echo "${ECHO_T}missing" >&6
-    png_ok="no"
-  fi
-
-  if test "x$png_ok" = "xyes"; then
-    echo "$as_me:$LINENO: checking for libpng version" >&5
-echo $ECHO_N "checking for libpng version... $ECHO_C" >&6
-    png_version=`$PNG_CONFIG --version`
-    case $png_version in
-      1.2.*) echo "$as_me:$LINENO: result: $png_version (newer version)" >&5
-echo "${ECHO_T}$png_version (newer version)" >&6 ;;
-      1.0.*) echo "$as_me:$LINENO: result: $png_version (older version)" >&5
-echo "${ECHO_T}$png_version (older version)" >&6 ;;
-          *) echo "$as_me:$LINENO: result: ERROR" >&5
-echo "${ECHO_T}ERROR" >&6 ;;
-    esac
-
-    LIBPNG_CFLAGS=`$PNG_CONFIG --cflags`
-    LIBPNG_LIBS=`$PNG_CONFIG --ldflags`
-  else
+if test "x$enable_ssl" = "xyes" ; then
 
 
-for ac_header in png.h libpng/png.h
+for ac_header in openssl/ssl.h openssl/err.h
 do
 as_ac_Header=`echo "ac_cv_header_$ac_header" | $as_tr_sh`
 if eval "test \"\${$as_ac_Header+set}\" = set"; then
@@ -5143,23 +9212,73 @@
   cat >>confdefs.h <<_ACEOF
 #define `echo "HAVE_$ac_header" | $as_tr_cpp` 1
 _ACEOF
- png_ok=yes && break
-else
-  png_ok=no
+
 fi
 
 done
 
+  # Extract the first word of "krb5-config", so it can be a program name with args.
+set dummy krb5-config; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_KRB5_CONFIG+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $KRB5_CONFIG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_KRB5_CONFIG="$KRB5_CONFIG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_dummy="$PATH:/usr/local/bin:/usr/kerberos/bin"
+for as_dir in $as_dummy
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_KRB5_CONFIG="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
 
-    if test "x$png_ok" = "xyes"; then
-      old_libs="$LIBS"
-      echo "$as_me:$LINENO: checking for png_check_sig in -lpng" >&5
-echo $ECHO_N "checking for png_check_sig in -lpng... $ECHO_C" >&6
-if test "${ac_cv_lib_png_png_check_sig+set}" = set; then
+  test -z "$ac_cv_path_KRB5_CONFIG" && ac_cv_path_KRB5_CONFIG="no"
+  ;;
+esac
+fi
+KRB5_CONFIG=$ac_cv_path_KRB5_CONFIG
+
+if test -n "$KRB5_CONFIG"; then
+  echo "$as_me:$LINENO: result: $KRB5_CONFIG" >&5
+echo "${ECHO_T}$KRB5_CONFIG" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  if test "$KRB5_CONFIG" = "no" ; then
+	if test -d "$KRB5_INCDIR"; then
+	  CPPFLAGS="$CPPFLAGS -I$KRB5_INCDIR"
+	elif test -d "/usr/kerberos/include"; then
+	  CPPFLAGS="$CPPFLAGS -I/usr/kerberos/include"
+	else
+	  { echo "$as_me:$LINENO: WARNING: *** No kerberos5 found. ***" >&5
+echo "$as_me: WARNING: *** No kerberos5 found. ***" >&2;}
+	fi
+  else
+    CFLAGS="$CFLAGS `$KRB5_CONFIG --cflags`"
+    LDFLAGS="$LDFLAGS `$KRB5_CONFIG --libs`"
+  fi
+
+echo "$as_me:$LINENO: checking for SSL_connect in -lssl" >&5
+echo $ECHO_N "checking for SSL_connect in -lssl... $ECHO_C" >&6
+if test "${ac_cv_lib_ssl_SSL_connect+set}" = set; then
   echo $ECHO_N "(cached) $ECHO_C" >&6
 else
   ac_check_lib_save_LIBS=$LIBS
-LIBS="-lpng $LIBZ_LIBS -lm $LIBS"
+LIBS="-lssl  $LIBS"
 cat >conftest.$ac_ext <<_ACEOF
 #line $LINENO "configure"
 /* confdefs.h.  */
@@ -5174,11 +9293,11 @@
 #endif
 /* We use char because int might match the return type of a gcc2
    builtin and then its argument prototype would still apply.  */
-char png_check_sig ();
+char SSL_connect ();
 int
 main ()
 {
-png_check_sig ();
+SSL_connect ();
   ;
   return 0;
 }
@@ -5195,52 +9314,39 @@
   ac_status=$?
   echo "$as_me:$LINENO: \$? = $ac_status" >&5
   (exit $ac_status); }; }; then
-  ac_cv_lib_png_png_check_sig=yes
+  ac_cv_lib_ssl_SSL_connect=yes
 else
   echo "$as_me: failed program was:" >&5
 sed 's/^/| /' conftest.$ac_ext >&5
 
-ac_cv_lib_png_png_check_sig=no
+ac_cv_lib_ssl_SSL_connect=no
 fi
 rm -f conftest.$ac_objext conftest$ac_exeext conftest.$ac_ext
 LIBS=$ac_check_lib_save_LIBS
 fi
-echo "$as_me:$LINENO: result: $ac_cv_lib_png_png_check_sig" >&5
-echo "${ECHO_T}$ac_cv_lib_png_png_check_sig" >&6
-if test $ac_cv_lib_png_png_check_sig = yes; then
-  png_ok=yes
-else
-  png_ok=no
-fi
-
-      LIBS="$old_libs"
-
-      if test "x$png_ok" = "xyes"; then
-        LIBPNG_LIBS="-lpng -lm"
-      fi
-    fi
-
-    if test "x$png_ok" = "xno"; then
-      { echo "$as_me:$LINENO: WARNING: *** No libpng found. Disabling PNG images ***" >&5
-echo "$as_me: WARNING: *** No libpng found. Disabling PNG images ***" >&2;}
-    fi
-  fi
-fi
-
-if test "x$png_ok" = "xyes"; then
-
-cat >>confdefs.h <<\_ACEOF
-#define ENABLE_PNG
+echo "$as_me:$LINENO: result: $ac_cv_lib_ssl_SSL_connect" >&5
+echo "${ECHO_T}$ac_cv_lib_ssl_SSL_connect" >&6
+if test $ac_cv_lib_ssl_SSL_connect = yes; then
+  cat >>confdefs.h <<_ACEOF
+#define HAVE_LIBSSL 1
 _ACEOF
 
+  LIBS="-lssl $LIBS"
+
+else
+  enable_ssl="no"
 fi
 
-if test "x$enable_gif" = "xyes"; then
+  if test "x$enable_ssl" = "xno" ; then
+    { echo "$as_me:$LINENO: WARNING: *** No libssl found. Disabling ssl. ***" >&5
+echo "$as_me: WARNING: *** No libssl found. Disabling ssl. ***" >&2;}
+  else
 
 cat >>confdefs.h <<\_ACEOF
-#define ENABLE_GIF
+#define DILLO_SSL 1
 _ACEOF
 
+  fi
 fi
 
 case $target in
@@ -5613,6 +9719,86 @@
   ;;
 esac
 
+if test "x$enable_tabs" = "xno" ; then
+  CFLAGS="$CFLAGS -DDISABLE_TABS"
+fi
+if test "x$enable_anti_alias" = "xno" ; then
+  CFLAGS="$CFLAGS -DDISABLE_ANTI_ALIAS"
+else
+  # Extract the first word of "xft-config", so it can be a program name with args.
+set dummy xft-config; ac_word=$2
+echo "$as_me:$LINENO: checking for $ac_word" >&5
+echo $ECHO_N "checking for $ac_word... $ECHO_C" >&6
+if test "${ac_cv_path_XFT_CONFIG+set}" = set; then
+  echo $ECHO_N "(cached) $ECHO_C" >&6
+else
+  case $XFT_CONFIG in
+  [\\/]* | ?:[\\/]*)
+  ac_cv_path_XFT_CONFIG="$XFT_CONFIG" # Let the user override the test with a path.
+  ;;
+  *)
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_dummy="$PATH:/usr/local/bin"
+for as_dir in $as_dummy
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  for ac_exec_ext in '' $ac_executable_extensions; do
+  if $as_executable_p "$as_dir/$ac_word$ac_exec_ext"; then
+    ac_cv_path_XFT_CONFIG="$as_dir/$ac_word$ac_exec_ext"
+    echo "$as_me:$LINENO: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+done
+
+  test -z "$ac_cv_path_XFT_CONFIG" && ac_cv_path_XFT_CONFIG="no"
+  ;;
+esac
+fi
+XFT_CONFIG=$ac_cv_path_XFT_CONFIG
+
+if test -n "$XFT_CONFIG"; then
+  echo "$as_me:$LINENO: result: $XFT_CONFIG" >&5
+echo "${ECHO_T}$XFT_CONFIG" >&6
+else
+  echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6
+fi
+
+  if test "$XFT_CONFIG" = "no" ; then
+    if test -d "/usr/include/freetype2" ; then
+        CPPFLAGS="$CPPFLAGS -I/usr/include/freetype2"
+	elif test -d "/usr/include/freetype1" ; then
+		CPPFLAGS="$CPPFLAGS -I/usr/include/freetype1"
+	fi
+	if test -e "/usr/X11R6/include/X11/Xft/Xft.h" ; then
+        echo "$as_me:$LINENO: checking checking for Xft" >&5
+echo $ECHO_N "checking checking for Xft... $ECHO_C" >&6
+        if test -e "/usr/X11R6/lib/libXft.so.2" ; then
+            echo "$as_me:$LINENO: result: Xft2" >&5
+echo "${ECHO_T}Xft2" >&6
+            LIBS="/usr/X11R6/lib/libXft.so.2 $LIBS"
+        elif test -e "/usr/lib/libXft.so.2" ; then
+            echo "$as_me:$LINENO: result: Xft2" >&5
+echo "${ECHO_T}Xft2" >&6
+            LIBS="/usr/lib/libXft.so.2 $LIBS"
+        else
+            echo "$as_me:$LINENO: result: Xft" >&5
+echo "${ECHO_T}Xft" >&6
+            LIBS="-lXft $LIBS"
+        fi
+    else
+        { echo "$as_me:$LINENO: WARNING: *** Xft not found. Disabling anti-alias.***" >&5
+echo "$as_me: WARNING: *** Xft not found. Disabling anti-alias.***" >&2;}
+        enable_anti_alias="no"
+		CFLAGS="$CFLAGS -DDISABLE_ANTI_ALIAS"
+    fi
+  else
+    CFLAGS="$CFLAGS `$XFT_CONFIG --cflags`"
+    LDFLAGS="$LDFLAGS `$XFT_CONFIG --libs`"
+  fi
+fi
 if test "x$enable_cookies" = "xno" ; then
   CFLAGS="$CFLAGS -DDISABLE_COOKIES"
 fi
@@ -5629,8 +9815,11 @@
   CC="insure -Zoi \"compiler $CC\""
   LIBS="$LIBS -lstdc++-2-libc6.1-1-2.9.0"
 fi
-if test "x$enable_rtfl" = "xyes" ; then
-  CFLAGS="$CFLAGS -DDBG_RTFL"
+if test "x$enable_meta_refresh" = "xyes" ; then
+  CFLAGS="$CFLAGS -DENABLE_META_REFRESH"
+fi
+if test "x$use_useragent" = "yes" ; then
+  CFLAGS="$CFLAGS -DENABLE_USER_AGENT"
 fi
 
 echo "$as_me:$LINENO: checking for ANSI C header files" >&5
@@ -5967,6 +10156,10 @@
     fi
   fi
 fi
+if test "x$enable_rtfl" = "xyes" ; then
+  CFLAGS="$CFLAGS -DDBG_RTFL"
+fi
+
 
 
 
@@ -5977,7 +10170,8 @@
 
 
 
-                                                            ac_config_files="$ac_config_files Makefile dpid/Makefile dpi/Makefile doc/Makefile src/Makefile src/IO/Makefile"
+
+                                                                                                    ac_config_files="$ac_config_files Makefile dpid/Makefile dpi/Makefile doc/Makefile config/Makefile src/Makefile src/IO/Makefile po/Makefile.in m4/Makefile intl/Makefile"
 cat >confcache <<\_ACEOF
 # This file is a shell script that caches the results of configure
 # tests run on this system so they can be shared between configure
@@ -6516,6 +10710,13 @@
 #
 
 AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
+# Capture the value of obsolete ALL_LINGUAS because we need it to compute
+    # POFILES, GMOFILES, UPDATEPOFILES, DUMMYPOFILES, CATALOGS. But hide it
+    # from automake.
+    eval 'ALL_LINGUAS''="$ALL_LINGUAS"'
+    # Capture the value of LINGUAS because we need it to compute CATALOGS.
+    LINGUAS="${LINGUAS-%UNSET%}"
+
 
 _ACEOF
 
@@ -6530,9 +10731,14 @@
   "dpid/Makefile" ) CONFIG_FILES="$CONFIG_FILES dpid/Makefile" ;;
   "dpi/Makefile" ) CONFIG_FILES="$CONFIG_FILES dpi/Makefile" ;;
   "doc/Makefile" ) CONFIG_FILES="$CONFIG_FILES doc/Makefile" ;;
+  "config/Makefile" ) CONFIG_FILES="$CONFIG_FILES config/Makefile" ;;
   "src/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/Makefile" ;;
   "src/IO/Makefile" ) CONFIG_FILES="$CONFIG_FILES src/IO/Makefile" ;;
+  "po/Makefile.in" ) CONFIG_FILES="$CONFIG_FILES po/Makefile.in" ;;
+  "m4/Makefile" ) CONFIG_FILES="$CONFIG_FILES m4/Makefile" ;;
+  "intl/Makefile" ) CONFIG_FILES="$CONFIG_FILES intl/Makefile" ;;
   "depfiles" ) CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
+  "default-1" ) CONFIG_COMMANDS="$CONFIG_COMMANDS default-1" ;;
   "config.h" ) CONFIG_HEADERS="$CONFIG_HEADERS config.h" ;;
   *) { { echo "$as_me:$LINENO: error: invalid argument: $ac_config_target" >&5
 echo "$as_me: error: invalid argument: $ac_config_target" >&2;}
@@ -6669,19 +10875,47 @@
 s,@RANLIB@,$RANLIB,;t t
 s,@ac_ct_RANLIB@,$ac_ct_RANLIB,;t t
 s,@CPP@,$CPP,;t t
+s,@MKINSTALLDIRS@,$MKINSTALLDIRS,;t t
+s,@MSGFMT@,$MSGFMT,;t t
+s,@GMSGFMT@,$GMSGFMT,;t t
+s,@XGETTEXT@,$XGETTEXT,;t t
+s,@MSGMERGE@,$MSGMERGE,;t t
+s,@EGREP@,$EGREP,;t t
+s,@ALLOCA@,$ALLOCA,;t t
+s,@GLIBC21@,$GLIBC21,;t t
+s,@LIBICONV@,$LIBICONV,;t t
+s,@LTLIBICONV@,$LTLIBICONV,;t t
+s,@INTLBISON@,$INTLBISON,;t t
+s,@USE_NLS@,$USE_NLS,;t t
+s,@BUILD_INCLUDED_LIBINTL@,$BUILD_INCLUDED_LIBINTL,;t t
+s,@USE_INCLUDED_LIBINTL@,$USE_INCLUDED_LIBINTL,;t t
+s,@CATOBJEXT@,$CATOBJEXT,;t t
+s,@INTLOBJS@,$INTLOBJS,;t t
+s,@DATADIRNAME@,$DATADIRNAME,;t t
+s,@INSTOBJEXT@,$INSTOBJEXT,;t t
+s,@GENCAT@,$GENCAT,;t t
+s,@INTL_LIBTOOL_SUFFIX_PREFIX@,$INTL_LIBTOOL_SUFFIX_PREFIX,;t t
+s,@INTLLIBS@,$INTLLIBS,;t t
+s,@LIBINTL@,$LIBINTL,;t t
+s,@LTLIBINTL@,$LTLIBINTL,;t t
+s,@POSUB@,$POSUB,;t t
+s,@localedir@,$localedir,;t t
 s,@GLIB_CONFIG@,$GLIB_CONFIG,;t t
 s,@GLIB_CFLAGS@,$GLIB_CFLAGS,;t t
 s,@GLIB_LIBS@,$GLIB_LIBS,;t t
 s,@GTK_CONFIG@,$GTK_CONFIG,;t t
 s,@GTK_CFLAGS@,$GTK_CFLAGS,;t t
 s,@GTK_LIBS@,$GTK_LIBS,;t t
-s,@EGREP@,$EGREP,;t t
+s,@KRB5_CONFIG@,$KRB5_CONFIG,;t t
+s,@XFT_CONFIG@,$XFT_CONFIG,;t t
 s,@LIBJPEG_LIBS@,$LIBJPEG_LIBS,;t t
 s,@LIBJPEG_LDFLAGS@,$LIBJPEG_LDFLAGS,;t t
 s,@LIBJPEG_CPPFLAGS@,$LIBJPEG_CPPFLAGS,;t t
 s,@LIBPNG_LIBS@,$LIBPNG_LIBS,;t t
 s,@LIBPNG_CFLAGS@,$LIBPNG_CFLAGS,;t t
 s,@LIBZ_LIBS@,$LIBZ_LIBS,;t t
+s,@LIBICONV_CFLAGS@,$LIBICONV_CFLAGS,;t t
+s,@LIBICONV_LIBS@,$LIBICONV_LIBS,;t t
 s,@src@,$src,;t t
 s,@doc@,$doc,;t t
 s,@bin@,$bin,;t t
@@ -7285,6 +11519,102 @@
   done
 done
  ;;
+    default-1 )
+    for ac_file in $CONFIG_FILES; do
+      # Support "outfile[:infile[:infile...]]"
+      case "$ac_file" in
+        *:*) ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+      esac
+      # PO directories have a Makefile.in generated from Makefile.in.in.
+      case "$ac_file" in */Makefile.in)
+        # Adjust a relative srcdir.
+        ac_dir=`echo "$ac_file"|sed 's%/[^/][^/]*$%%'`
+        ac_dir_suffix="/`echo "$ac_dir"|sed 's%^\./%%'`"
+        ac_dots=`echo "$ac_dir_suffix"|sed 's%/[^/]*%../%g'`
+        # In autoconf-2.13 it is called $ac_given_srcdir.
+        # In autoconf-2.50 it is called $srcdir.
+        test -n "$ac_given_srcdir" || ac_given_srcdir="$srcdir"
+        case "$ac_given_srcdir" in
+          .)  top_srcdir=`echo $ac_dots|sed 's%/$%%'` ;;
+          /*) top_srcdir="$ac_given_srcdir" ;;
+          *)  top_srcdir="$ac_dots$ac_given_srcdir" ;;
+        esac
+        if test -f "$ac_given_srcdir/$ac_dir/POTFILES.in"; then
+          rm -f "$ac_dir/POTFILES"
+          test -n "$as_me" && echo "$as_me: creating $ac_dir/POTFILES" || echo "creating $ac_dir/POTFILES"
+          cat "$ac_given_srcdir/$ac_dir/POTFILES.in" | sed -e "/^#/d" -e "/^[ 	]*\$/d" -e "s,.*,     $top_srcdir/& \\\\," | sed -e "\$s/\(.*\) \\\\/\1/" > "$ac_dir/POTFILES"
+          # ALL_LINGUAS, POFILES, GMOFILES, UPDATEPOFILES, DUMMYPOFILES depend
+          # on $ac_dir but don't depend on user-specified configuration
+          # parameters.
+          if test -f "$ac_given_srcdir/$ac_dir/LINGUAS"; then
+            # The LINGUAS file contains the set of available languages.
+            if test -n "$ALL_LINGUAS"; then
+              test -n "$as_me" && echo "$as_me: setting ALL_LINGUAS in configure.in is obsolete" || echo "setting ALL_LINGUAS in configure.in is obsolete"
+            fi
+            ALL_LINGUAS_=`sed -e "/^#/d" "$ac_given_srcdir/$ac_dir/LINGUAS"`
+            # Hide the ALL_LINGUAS assigment from automake.
+            eval 'ALL_LINGUAS''=$ALL_LINGUAS_'
+          fi
+          case "$ac_given_srcdir" in
+            .) srcdirpre= ;;
+            *) srcdirpre='$(srcdir)/' ;;
+          esac
+          POFILES=
+          GMOFILES=
+          UPDATEPOFILES=
+          DUMMYPOFILES=
+          for lang in $ALL_LINGUAS; do
+            POFILES="$POFILES $srcdirpre$lang.po"
+            GMOFILES="$GMOFILES $srcdirpre$lang.gmo"
+            UPDATEPOFILES="$UPDATEPOFILES $lang.po-update"
+            DUMMYPOFILES="$DUMMYPOFILES $lang.nop"
+          done
+          # CATALOGS depends on both $ac_dir and the user's LINGUAS
+          # environment variable.
+          INST_LINGUAS=
+          if test -n "$ALL_LINGUAS"; then
+            for presentlang in $ALL_LINGUAS; do
+              useit=no
+              if test "%UNSET%" != "$LINGUAS"; then
+                desiredlanguages="$LINGUAS"
+              else
+                desiredlanguages="$ALL_LINGUAS"
+              fi
+              for desiredlang in $desiredlanguages; do
+                # Use the presentlang catalog if desiredlang is
+                #   a. equal to presentlang, or
+                #   b. a variant of presentlang (because in this case,
+                #      presentlang can be used as a fallback for messages
+                #      which are not translated in the desiredlang catalog).
+                case "$desiredlang" in
+                  "$presentlang"*) useit=yes;;
+                esac
+              done
+              if test $useit = yes; then
+                INST_LINGUAS="$INST_LINGUAS $presentlang"
+              fi
+            done
+          fi
+          CATALOGS=
+          if test -n "$INST_LINGUAS"; then
+            for lang in $INST_LINGUAS; do
+              CATALOGS="$CATALOGS $lang.gmo"
+            done
+          fi
+          test -n "$as_me" && echo "$as_me: creating $ac_dir/Makefile" || echo "creating $ac_dir/Makefile"
+          sed -e "/^POTFILES =/r $ac_dir/POTFILES" -e "/^# Makevars/r $ac_given_srcdir/$ac_dir/Makevars" -e "s|@POFILES@|$POFILES|g" -e "s|@GMOFILES@|$GMOFILES|g" -e "s|@UPDATEPOFILES@|$UPDATEPOFILES|g" -e "s|@DUMMYPOFILES@|$DUMMYPOFILES|g" -e "s|@CATALOGS@|$CATALOGS|g" "$ac_dir/Makefile.in" > "$ac_dir/Makefile"
+          for f in "$ac_given_srcdir/$ac_dir"/Rules-*; do
+            if test -f "$f"; then
+              case "$f" in
+                *.orig | *.bak | *~) ;;
+                *) cat "$f" >> "$ac_dir/Makefile" ;;
+              esac
+            fi
+          done
+        fi
+        ;;
+      esac
+    done ;;
   esac
 done
 _ACEOF
@@ -7319,3 +11649,19 @@
 fi
 
 
+echo ""
+echo "Finished configure:"
+echo "           tabs: $enable_tabs";
+echo "        cookies: $enable_cookies";
+echo "     anti-alias: $enable_anti_alias";
+echo "            ssl: $enable_ssl";
+echo "   meta refresh: $enable_meta_refresh";
+echo "     user agent: $use_useragent";
+echo "         efence: $enable_efence";
+echo "          gprof: $enable_gprof";
+echo "         insure: $enable_insure";
+echo "         prefix: $prefix";
+
+echo ""
+echo "Run configure --help for explanation of these options,"
+echo "otherwise type 'make' to build Dillo."
diff -Nur dillo-0.8.0/configure.in dillo-0.8.0.new/configure.in
--- dillo-0.8.0/configure.in	2004-02-08 12:55:12.000000000 +0000
+++ dillo-0.8.0.new/configure.in	2004-10-13 01:13:30.000000000 +0000
@@ -5,22 +5,27 @@
 dnl Detect the canonical host and target build environment
 AC_CANONICAL_SYSTEM
 
-AM_INIT_AUTOMAKE(dillo, 0.8.0)
+AM_INIT_AUTOMAKE(dillo, 0.8.0-i18n-misc-20040613)
 AM_CONFIG_HEADER(config.h)
 
 dnl Options
 
 AC_ARG_WITH(jpeg-lib, [  --with-jpeg-lib=DIR     Specify where to find libjpeg], LIBJPEG_LIBDIR=$withval)
 AC_ARG_WITH(jpeg-inc, [  --with-jpeg-inc=DIR     Specify where to find libjpeg's headers], LIBJPEG_INCDIR=$withval)
+AC_ARG_WITH(krb5-inc, [  --with-krb5-inc=DIR     Specify where to find Kerberos V's headers], KRB5_INCDIR=$withval)
 
 AC_ARG_ENABLE(efence, [  --enable-efence         Try to compile and run with Electric Fence],
-                    , enable_fence=no)
+                    , enable_efence=no)
 AC_ARG_ENABLE(gprof,  [  --enable-gprof          Try to compile and run with profiling enabled],
                     , enable_gprof=no)
 AC_ARG_ENABLE(insure, [  --enable-insure         Try to compile and run with Insure++],
                     , enable_insure=no)
 AC_ARG_ENABLE(ansi,   [  --enable-ansi           Try to compile and run with ANSI flags],
                     , enable_ansi=no)
+AC_ARG_ENABLE(tabs,   [  --disable-tabs          Don't compile support for tabs],
+                    , enable_tabs=yes)
+AC_ARG_ENABLE(anti_alias,[  --disable-anti-alias    Don't compile support for anti-alias],
+                    , enable_anti_alias=yes)
 AC_ARG_ENABLE(ipv6,   [  --enable-ipv6           Build with support for IPv6], , )
 AC_ARG_ENABLE(rtfl,   [  --enable-rtfl           Build with rtfl messages], enable_rtfl=yes)
 AC_ARG_ENABLE(cookies,[  --disable-cookies       Don't compile support for cookies],
@@ -31,6 +36,12 @@
               enable_jpeg=$enableval, enable_jpeg=yes)
 AC_ARG_ENABLE(gif,    [  --disable-gif           Disable support for GIF images],
               enable_gif=$enableval, enable_gif=yes)
+AC_ARG_ENABLE(ssl,    [  --disable-ssl           Don't compile support for SSL],
+                    , enable_ssl=yes)
+AC_ARG_ENABLE(meta_refresh, [  --enable-meta-refresh   Allow meta refresh],
+                    , enable_meta_refresh=no)
+AC_ARG_ENABLE(user_agent,[  --enable-user-agent           Build with UserAgentBox.],
+                    , use_useragent=no)
 
 AC_PROG_CC
 AM_PROG_CC_STDC
@@ -38,14 +49,33 @@
 AC_PROG_CPP
 
 dnl --------------------------------------
-dnl Check whether to add /usr/local or not
-dnl (this is somewhat a religious problem)
+dnl Check for Gettext
 dnl --------------------------------------
 dnl
-if test "`$CPP -v < /dev/null 2>&1 | grep '/usr/local/include' 2>&1`" = ""; then
-  CPPFLAGS="$CPPFLAGS -I/usr/local/include"
-  LDFLAGS="$LDFLAGS -L/usr/local/lib"
-fi
+ALL_LINGUAS="ja"
+AM_GNU_GETTEXT
+localedir='${prefix}/share/locale'
+AC_SUBST(localedir)
+AC_DEFINE(HAVE_CATGETS, 1,
+          Define as 1 if you have catgets and don't want to use GNU gettext.)
+AC_DEFINE(HAVE_GETTEXT, 1,
+          Define as 1 if you have GNU gettext.)
+AC_DEFINE(HAVE_LC_MESSAGES, 1,
+          Define as 1 if you have LC_MESSAGES.)
+AC_DEFINE(HAVE_STPCPY, 1,
+          Define as 1 if you have stpcpy() function.)
+AC_DEFINE(ENABLE_NLS, 1,
+          Define as 1 if you want to use NLS.)
+
+#dnl --------------------------------------
+#dnl Check whether to add /usr/local or not
+#dnl (this is somewhat a religious problem)
+#dnl --------------------------------------
+#dnl
+#if test "`$CPP -v < /dev/null 2>&1 | grep '/usr/local/include' 2>&1`" = ""; then
+#  CPPFLAGS="$CPPFLAGS -I/usr/local/include"
+#  LDFLAGS="$LDFLAGS -L/usr/local/lib"
+#fi
 
 dnl ------------------------------------
 dnl Check for socket libs (AIX, Solaris)
@@ -77,6 +107,11 @@
 if test "x$enable_jpeg" = "xyes"; then
   AC_CHECK_HEADER(jpeglib.h, jpeg_ok=yes, jpeg_ok=no)
 
+  if test -e /usr/include/jpeglib.h || test -e /usr/local/include/jpeglib.h
+  then
+    jpeg_ok=yes
+  fi
+
   if test "x$jpeg_ok" = "xyes"; then
     old_libs="$LIBS"
     AC_CHECK_LIB(jpeg, jpeg_destroy_decompress, jpeg_ok=yes, jpeg_ok=no)
@@ -104,7 +139,7 @@
 dnl Test for zlib (libpng uses it)
 dnl ------------------------------
 dnl
-if test "x$enable_png" = "xyes"; then
+dnl if test "x$enable_png" = "xyes"; then
   AC_CHECK_HEADER(zlib.h, libz_ok=yes, libz_ok=no)
 
   if test "x$libz_ok" = "xyes"; then
@@ -118,43 +153,13 @@
   else
     AC_MSG_WARN([*** No libz found. Disabling PNG images ***])
   fi
-fi
+dnl fi
 
 dnl ---------------
 dnl Test for libpng
 dnl ---------------
 dnl
 if test "x$enable_png" = "xyes" && test "x$libz_ok" = "xyes"; then
-  AC_MSG_CHECKING([for libpng-config])
-
-dnl Check if the user hasn't set the variable $PNG_CONFIG
-  if test -z "$PNG_CONFIG"; then
-    PNG_CONFIG=`which libpng12-config || which libpng-config || which libpng10-config`
-  fi
-
-dnl Check if the libpng-config script was found and is executable
-  if test -n "$PNG_CONFIG" && test -x "$PNG_CONFIG"; then
-    AC_MSG_RESULT([$PNG_CONFIG])
-    png_ok="yes"
-  else
-    AC_MSG_RESULT([missing])
-    png_ok="no"
-  fi
-
-  if test "x$png_ok" = "xyes"; then
-dnl For debugging and to be user friendly
-    AC_MSG_CHECKING([for libpng version])
-    png_version=`$PNG_CONFIG --version`
-    case $png_version in
-      1.2.*) AC_MSG_RESULT([$png_version (newer version)]) ;;
-      1.0.*) AC_MSG_RESULT([$png_version (older version)]) ;;
-          *) AC_MSG_RESULT([ERROR]) ;;
-    esac
-
-dnl Tries to use options that are supported by all libpng-config versions...
-    LIBPNG_CFLAGS=`$PNG_CONFIG --cflags`
-    LIBPNG_LIBS=`$PNG_CONFIG --ldflags`
-  else
 dnl Try to find libpng even though libpng-config wasn't found
     AC_CHECK_HEADERS(png.h libpng/png.h, png_ok=yes && break, png_ok=no)
 
@@ -171,7 +176,6 @@
     if test "x$png_ok" = "xno"; then
       AC_MSG_WARN([*** No libpng found. Disabling PNG images ***])
     fi
-  fi
 fi
 
 if test "x$png_ok" = "xyes"; then
@@ -183,6 +187,54 @@
   AC_DEFINE([ENABLE_GIF], [], [Enable GIF images])
 fi
 
+dnl ------------------------------
+dnl Test for libiconv
+dnl ------------------------------
+dnl
+dnl if test "x$enable_png" = "xyes"; then
+  AC_CHECK_HEADER(iconv.h, libiconv_ok=yes, libiconv_ok=no)
+
+  if test "x$libiconv_ok" = "xyes"; then
+    old_libs="$LIBS"
+    AC_CHECK_LIB(iconv, iconv_open, libiconv_ok=yes, libiconv_ok=no)
+    LIBS="$old_libs"
+  fi
+
+  if test "x$libiconv_ok" = xyes; then
+    LIBICONV_LIBS="-liconv"
+  else
+    AC_MSG_WARN([*** No libiconv found. ***])
+  fi
+dnl fi
+
+dnl ----------------------
+dnl Test for libssl
+dnl ----------------------
+dnl
+if test "x$enable_ssl" = "xyes" ; then
+  AC_CHECK_HEADERS(openssl/ssl.h openssl/err.h)
+  AC_PATH_PROG(KRB5_CONFIG, krb5-config, no,
+			   $PATH:/usr/local/bin:/usr/kerberos/bin)
+  if test "$KRB5_CONFIG" = "no" ; then
+	if test -d "$KRB5_INCDIR"; then
+	  CPPFLAGS="$CPPFLAGS -I$KRB5_INCDIR"
+	elif test -d "/usr/kerberos/include"; then
+	  CPPFLAGS="$CPPFLAGS -I/usr/kerberos/include"
+	else
+	  AC_MSG_WARN(*** No kerberos5 found. ***)
+	fi
+  else
+    CFLAGS="$CFLAGS `$KRB5_CONFIG --cflags`"
+    LDFLAGS="$LDFLAGS `$KRB5_CONFIG --libs`"
+  fi
+  AC_CHECK_LIB(ssl, SSL_connect, , enable_ssl="no")
+  if test "x$enable_ssl" = "xno" ; then
+    AC_MSG_WARN(*** No libssl found. Disabling ssl. ***)
+  else
+    AC_DEFINE(DILLO_SSL, 1, [Enable SSL Processing])
+  fi
+fi
+
 dnl ----------------------
 dnl Test for POSIX threads
 dnl ----------------------
@@ -253,6 +305,41 @@
 dnl Command line options
 dnl --------------------
 dnl
+if test "x$enable_tabs" = "xno" ; then
+  CFLAGS="$CFLAGS -DDISABLE_TABS"
+fi
+if test "x$enable_anti_alias" = "xno" ; then
+  CFLAGS="$CFLAGS -DDISABLE_ANTI_ALIAS"
+else
+  AC_PATH_PROG(XFT_CONFIG, xft-config, no, $PATH:/usr/local/bin)
+  if test "$XFT_CONFIG" = "no" ; then
+    if test -d "/usr/include/freetype2" ; then
+        CPPFLAGS="$CPPFLAGS -I/usr/include/freetype2"
+	elif test -d "/usr/include/freetype1" ; then
+		CPPFLAGS="$CPPFLAGS -I/usr/include/freetype1"
+	fi
+	if test -e "/usr/X11R6/include/X11/Xft/Xft.h" ; then
+        AC_MSG_CHECKING(checking for Xft)
+        if test -e "/usr/X11R6/lib/libXft.so.2" ; then
+            AC_MSG_RESULT(Xft2)
+            LIBS="/usr/X11R6/lib/libXft.so.2 $LIBS"
+        elif test -e "/usr/lib/libXft.so.2" ; then
+            AC_MSG_RESULT(Xft2)
+            LIBS="/usr/lib/libXft.so.2 $LIBS"
+        else
+            AC_MSG_RESULT(Xft)
+            LIBS="-lXft $LIBS"
+        fi
+    else
+        AC_MSG_WARN(*** Xft not found. Disabling anti-alias.***)
+        enable_anti_alias="no"
+		CFLAGS="$CFLAGS -DDISABLE_ANTI_ALIAS"
+    fi
+  else
+    CFLAGS="$CFLAGS `$XFT_CONFIG --cflags`"
+    LDFLAGS="$LDFLAGS `$XFT_CONFIG --libs`"
+  fi
+fi
 if test "x$enable_cookies" = "xno" ; then
   CFLAGS="$CFLAGS -DDISABLE_COOKIES"
 fi
@@ -269,10 +356,13 @@
   CC="insure -Zoi \"compiler $CC\""
   LIBS="$LIBS -lstdc++-2-libc6.1-1-2.9.0"
 fi
-if test "x$enable_rtfl" = "xyes" ; then
-  CFLAGS="$CFLAGS -DDBG_RTFL"
+if test "x$enable_meta_refresh" = "xyes" ; then
+  CFLAGS="$CFLAGS -DENABLE_META_REFRESH"
 fi
-
+if test "x$use_useragent" = "yes" ; then
+  CFLAGS="$CFLAGS -DENABLE_USER_AGENT"
+fi
+   
 dnl -----------------------
 dnl Checks for header files
 dnl -----------------------
@@ -313,6 +403,9 @@
     fi
   fi
 fi
+if test "x$enable_rtfl" = "xyes" ; then
+  CFLAGS="$CFLAGS -DDBG_RTFL"
+fi
 
 AC_SUBST(LIBJPEG_LIBS)
 AC_SUBST(LIBJPEG_LDFLAGS)
@@ -320,8 +413,30 @@
 AC_SUBST(LIBPNG_LIBS)
 AC_SUBST(LIBPNG_CFLAGS)
 AC_SUBST(LIBZ_LIBS)
+AC_SUBST(LIBICONV_CFLAGS)
+AC_SUBST(LIBICONV_LIBS)
 AC_SUBST(datadir)
 AC_SUBST(src doc bin util lib)
 
-AC_OUTPUT(Makefile dpid/Makefile dpi/Makefile doc/Makefile src/Makefile src/IO/Makefile)
+AC_OUTPUT(Makefile dpid/Makefile dpi/Makefile doc/Makefile config/Makefile src/Makefile src/IO/Makefile po/Makefile.in m4/Makefile  intl/Makefile )
 
+dnl ----------------------
+dnl Show configure summary
+dnl ----------------------
+echo ""
+echo "Finished configure:"
+echo "           tabs: $enable_tabs";
+echo "        cookies: $enable_cookies";
+echo "     anti-alias: $enable_anti_alias";
+echo "            ssl: $enable_ssl";
+echo "   meta refresh: $enable_meta_refresh";
+echo "     user agent: $use_useragent";
+dnl echo "           ipv6: $enable_ipv6";
+echo "         efence: $enable_efence";
+echo "          gprof: $enable_gprof";
+echo "         insure: $enable_insure";
+echo "         prefix: $prefix";
+                                                                                
+echo ""
+echo "Run configure --help for explanation of these options,"
+echo "otherwise type 'make' to build Dillo."
diff -Nur dillo-0.8.0/depcomp dillo-0.8.0.new/depcomp
--- dillo-0.8.0/depcomp	2003-09-21 23:02:39.000000000 +0000
+++ dillo-0.8.0.new/depcomp	2004-10-13 01:13:29.000000000 +0000
@@ -1,7 +1,7 @@
 #! /bin/sh
 
 # depcomp - compile a program generating dependencies as side-effects
-# Copyright 1999, 2000, 2003 Free Software Foundation, Inc.
+# Copyright 1999, 2000 Free Software Foundation, Inc.
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -172,25 +172,19 @@
 
 aix)
   # The C for AIX Compiler uses -M and outputs the dependencies
-  # in a .u file.  In older versions, this file always lives in the
-  # current directory.  Also, the AIX compiler puts `$object:' at the
-  # start of each line; $object doesn't have directory information.
-  # Version 6 uses the directory in both cases.
-  stripped=`echo "$object" | sed 's/\(.*\)\..*$/\1/'`
+  # in a .u file.  This file always lives in the current directory.
+  # Also, the AIX compiler puts `$object:' at the start of each line;
+  # $object doesn't have directory information.
+  stripped=`echo "$object" | sed -e 's,^.*/,,' -e 's/\(.*\)\..*$/\1/'`
   tmpdepfile="$stripped.u"
+  outname="$stripped.o"
   if test "$libtool" = yes; then
     "$@" -Wc,-M
   else
     "$@" -M
   fi
-  stat=$?
-
-  if test -f "$tmpdepfile"; then :
-  else
-    stripped=`echo "$stripped" | sed 's,^.*/,,'`
-    tmpdepfile="$stripped.u"
-  fi
 
+  stat=$?
   if test $stat -eq 0; then :
   else
     rm -f "$tmpdepfile"
@@ -198,7 +192,6 @@
   fi
 
   if test -f "$tmpdepfile"; then
-    outname="$stripped.o"
     # Each line is of the form `foo.o: dependent.h'.
     # Do two passes, one to just change these to
     # `$object: dependent.h' and one to simply `dependent.h:'.
@@ -214,9 +207,11 @@
   ;;
 
 icc)
-  # Intel's C compiler understands `-MD -MF file'.  However on
+  # Must come before tru64.
+
+  # Intel's C compiler understands `-MD -MF file'.  However
   #    icc -MD -MF foo.d -c -o sub/foo.o sub/foo.c
-  # ICC 7.0 will fill foo.d with something like
+  # will fill foo.d with something like
   #    foo.o: sub/foo.c
   #    foo.o: sub/foo.h
   # which is wrong.  We want:
@@ -224,12 +219,6 @@
   #    sub/foo.o: sub/foo.h
   #    sub/foo.c:
   #    sub/foo.h:
-  # ICC 7.1 will output
-  #    foo.o: sub/foo.c sub/foo.h
-  # and will wrap long lines using \ :
-  #    foo.o: sub/foo.c ... \
-  #     sub/foo.h ... \
-  #     ...
 
   "$@" -MD -MF "$tmpdepfile"
   stat=$?
@@ -239,15 +228,11 @@
     exit $stat
   fi
   rm -f "$depfile"
-  # Each line is of the form `foo.o: dependent.h',
-  # or `foo.o: dep1.h dep2.h \', or ` dep3.h dep4.h \'.
+  # Each line is of the form `foo.o: dependent.h'.
   # Do two passes, one to just change these to
   # `$object: dependent.h' and one to simply `dependent.h:'.
-  sed "s,^[^:]*:,$object :," < "$tmpdepfile" > "$depfile"
-  # Some versions of the HPUX 10.20 sed can't process this invocation
-  # correctly.  Breaking it into two sed invocations is a workaround.
-  sed 's,^[^:]*: \(.*\)$,\1,;s/^\\$//;/^$/d;/:$/d' < "$tmpdepfile" |
-    sed -e 's/$/ :/' >> "$depfile"
+  sed -e "s,^[^:]*:,$object :," < "$tmpdepfile" > "$depfile"
+  sed -e "s,^[^:]*: \(.*\)$,\1:," < "$tmpdepfile" >> "$depfile"
   rm -f "$tmpdepfile"
   ;;
 
@@ -285,8 +270,8 @@
    fi
    if test -f "$tmpdepfile"; then
       sed -e "s,^.*\.[a-z]*:,$object:," < "$tmpdepfile" > "$depfile"
-      # That's a tab and a space in the [].
-      sed -e 's,^.*\.[a-z]*:[	 ]*,,' -e 's,$,:,' < "$tmpdepfile" >> "$depfile"
+      # That's a space and a tab in the [].
+      sed -e 's,^.*\.[a-z]*:[ 	]*,,' -e 's,$,:,' < "$tmpdepfile" >> "$depfile"
    else
       echo "#dummy" > "$depfile"
    fi
@@ -299,7 +284,7 @@
 
 dashmstdout)
   # Important note: in order to support this mode, a compiler *must*
-  # always write the preprocessed file to stdout, regardless of -o.
+  # always write the proprocessed file to stdout, regardless of -o.
   "$@" || exit $?
 
   # Remove the call to Libtool.
@@ -395,7 +380,7 @@
 
 cpp)
   # Important note: in order to support this mode, a compiler *must*
-  # always write the preprocessed file to stdout.
+  # always write the proprocessed file to stdout.
   "$@" || exit $?
 
   # Remove the call to Libtool.
@@ -437,7 +422,7 @@
 
 msvisualcpp)
   # Important note: in order to support this mode, a compiler *must*
-  # always write the preprocessed file to stdout, regardless of -o,
+  # always write the proprocessed file to stdout, regardless of -o,
   # because we must use -o when running libtool.
   "$@" || exit $?
   IFS=" "
diff -Nur dillo-0.8.0/dillorc dillo-0.8.0.new/dillorc
--- dillo-0.8.0/dillorc	2004-01-25 15:18:12.000000000 +0000
+++ dillo-0.8.0.new/dillorc	2004-10-13 01:13:29.000000000 +0000
@@ -3,7 +3,6 @@
 # Copy this file to ~/.dillo/dillorc and edit to your taste.
 # Lines that start with a '#' are comments.
 
-
 #-------------------------------------------------------------------------
 #                             FIRST SECTION                             :)
 #-------------------------------------------------------------------------
@@ -22,18 +21,29 @@
 
 # Fontname for variable width rendering (most of the text).
 #   - some fonts may slow down rendering, some others not!
-#   - try to tune a fontname/font_factor combination.
-# Ex. {helvetica, lucida, times, "new century schoolbook", utopia, ...}
-vw_fontname=helvetica
+#   - try to tune a fontname/font_sizes combination.
+# format is "fndry-fmly" (fndry and fmly is XLFD's item.)
+# Ex. {"*-*", "*-gothic", "misc-fixed" ...}
+vw_fontname="*-*"
 
 # Fontname for fixed width rendering (mainly <pre> quoted text)
-fw_fontname=courier
+fw_fontname="*-*"
+
+# If Anti-Alias is enable, These options will be applied.
+# format is the same as family of Xft.
+# Ex. {"sans-serif", "monospace" ...}
+vw_aafontname="*"
+fw_aafontname="*"
+
+# Fontsizes
+# The 3rd value is used for plain text
+# font_sizes="10 12 14 16 18 20"
 
 # All fontsizes are scaled by this value (default is 1.0)
 #font_factor=1.2
 
 # If you prefer oblique over italic fonts, uncoment next line
-#use_oblique=YES
+use_oblique=NO
 
 # Show tooltip popup for images?
 # Note: We use the "title" attribute and not "alt".
@@ -50,13 +60,21 @@
 #-------------------------------------------------------------------------
 
 # Set the home location
-home="http://www.dillo.org/"
+#home="http://www.dillo.org/"
+home="http://www.google.com/"
 
-# Set search url to use with "s <keywords>".
-# %s is replaced with keywords separated by '+'.
-search_url="http://www.google.com/search?q=%s"
-#search_url="http://search.lycos.com/default.asp?query=%s"
-#search_url="http://www.alltheweb.com/search?cat=web&query=%s"
+# Set the startup URL
+#startup=http://www.google.com/
+
+# Search engine's URL
+# (%s = keywords)
+#search_url="http://www.google.com/search?ie=UTF-8&oe=UTF-8&q=%s"
+#search_url="http://www.google.co.jp/search?ie=UTF-8&oe=UTF-8&q=%s"
+#search_url="http://www.excite.co.jp/dictionary/english_japanese/?match=beginswith&dictionary=NEW_EJJE&search=%s"
+
+# Search engine's charset
+#search_charset=EUC-JP
+search_charset=UTF-8
 
 # Set the proxy information for http
 #http_proxy=http://localhost:8080/
@@ -66,6 +84,9 @@
 #no_proxy = ".mynet.com"
 #no_proxy = ".mynet.com .other.net .foo.bar.org"
 
+# Set the User-Agent
+# (%v = Version)
+#user_agent = "Dillo/%v"
 
 #-------------------------------------------------------------------------
 #                            COLORS SECTION
@@ -76,7 +97,8 @@
 # Set the background color
 # bg_color=gray
 # bg_color=0xd6d6c0
-bg_color=0xdcd1ba
+#bg_color=0xdcd1ba
+bg_color=white
 
 # Set the text color
 text_color=black
@@ -104,8 +126,8 @@
 # tiny   :  recommended for iPAQ (with small_icons)
 # medium :  nice!
 # large  :  Traditional
-panel_size=medium
-small_icons=NO
+panel_size=tiny
+small_icons=YES
 
 # Here you can choose to hide some widgets of the dillo panel...
 #show_back=NO
@@ -118,9 +140,16 @@
 #show_menubar=NO
 #show_clear_url=NO
 #show_url=NO
-#show_search=NO
+#show_search=YES
 #show_progress_box=NO
 
+# Enabling User Agent box.
+# It needs to compile with --enable-user-agent option
+#show_user_agent=NO
+
+# Show or hide navigation controls (back, forward, etc) in popup menu...
+#show_popup_navigation=NO
+
 # Start dillo windows with a hidden panel?
 fullwindow_start=NO
 
@@ -128,6 +157,52 @@
 # for the ION window manager.
 transient_dialogs=NO
 
+# Forcus location bar on new window.
+# focus_location_on_new=YES
+
+# Enabling this will make 'load link in new tab' be executed in the
+# background, leaving the focus on the current tab
+tab_load_in_background=YES
+
+# Enabling this will open a new tab (instead of a new window)
+# on link-middle-click (button 2) and for the "_blank" url target
+tab_instead_of_window=YES
+
+# Show the tab bar (sometimes called the 'gutter') even when there is
+# only a single tab (document) loaded in the browser window?
+# tab_bar_show_single_tab=NO
+
+# Show the tab bar even in full screen mode?
+# tab_bar_show_fullscreen=NO
+
+# Make all tabs the same width?
+# tab_bar_homogeneous=YES
+
+# When there are more tabs than fit on the tab bar, add scrolling arrows
+# to the tab bar.
+# tab_bar_scroller=NO
+
+# Enabling this will close a tab by middle click
+# tab_close_middle_click=YES
+
+# Compress titles in tabs by removing vowels? If this is set to NO,
+# tabs will be shortened instead. This is what it looks like:
+#
+# Normal                Compressed               Shortened
+# The Quick Brown Fox   Th Qck Brwn Fx           The Q...Fox
+# tab_title_compress=YES
+
+# This defines which vowels are considered 'expendable' by the tab
+# title compression algorithm. The tab title will be shortened by
+# removing characters matching this pattern, starting from the end
+# of the tab title. Adjust this to taste or language if needed.
+# compress_vowels="aeiouyAEIOUY"
+
+# A semicolon-separated string of common prefixes. The compression
+# algorithm begins by trying to discard anything from the title
+# which matches this pattern.
+# compress_common_prefixes="index of ;re: ;fwd: ;www.;welcome to ;the "
+
 # When filling forms, our default behaviour is to submit on enterpress,
 # but only when there's a single text entry (to avoid incomplete submits).
 # OTOH, if you have to fill the same form lots of times, you may find
@@ -137,7 +212,7 @@
 # Some forms lack a submit button, and dillo can generate a custom one
 # internally. Unfortunately there's no guarantee for it to work. :(
 # (my experience is that forms that lack a submit rely on Javascript)
-generate_submit=NO
+generate_submit=YES
 
 #-------------------------------------------------------------------------
 #                        DEBUG MESSAGES SECTION
diff -Nur dillo-0.8.0/doc/Makefile.in dillo-0.8.0.new/doc/Makefile.in
--- dillo-0.8.0/doc/Makefile.in	2004-02-08 12:57:12.000000000 +0000
+++ dillo-0.8.0.new/doc/Makefile.in	2004-10-13 01:20:01.000000000 +0000
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.7 from Makefile.am.
+# Makefile.in generated by automake 1.7.3 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -39,6 +39,7 @@
 host_triplet = @host@
 target_triplet = @target@
 ACLOCAL = @ACLOCAL@
+ALLOCA = @ALLOCA@
 AMDEP_FALSE = @AMDEP_FALSE@
 AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
@@ -46,12 +47,15 @@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
+BUILD_INCLUDED_LIBINTL = @BUILD_INCLUDED_LIBINTL@
+CATOBJEXT = @CATOBJEXT@
 CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CYGPATH_W = @CYGPATH_W@
+DATADIRNAME = @DATADIRNAME@
 DEFS = @DEFS@
 DEPDIR = @DEPDIR@
 ECHO_C = @ECHO_C@
@@ -59,9 +63,12 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+GENCAT = @GENCAT@
+GLIBC21 = @GLIBC21@
 GLIB_CFLAGS = @GLIB_CFLAGS@
 GLIB_CONFIG = @GLIB_CONFIG@
 GLIB_LIBS = @GLIB_LIBS@
+GMSGFMT = @GMSGFMT@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_CONFIG = @GTK_CONFIG@
 GTK_LIBS = @GTK_LIBS@
@@ -69,7 +76,17 @@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+INSTOBJEXT = @INSTOBJEXT@
+INTLBISON = @INTLBISON@
+INTLLIBS = @INTLLIBS@
+INTLOBJS = @INTLOBJS@
+INTL_LIBTOOL_SUFFIX_PREFIX = @INTL_LIBTOOL_SUFFIX_PREFIX@
+KRB5_CONFIG = @KRB5_CONFIG@
 LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBICONV_CFLAGS = @LIBICONV_CFLAGS@
+LIBICONV_LIBS = @LIBICONV_LIBS@
+LIBINTL = @LIBINTL@
 LIBJPEG_CPPFLAGS = @LIBJPEG_CPPFLAGS@
 LIBJPEG_LDFLAGS = @LIBJPEG_LDFLAGS@
 LIBJPEG_LIBS = @LIBJPEG_LIBS@
@@ -78,8 +95,13 @@
 LIBPNG_LIBS = @LIBPNG_LIBS@
 LIBS = @LIBS@
 LIBZ_LIBS = @LIBZ_LIBS@
+LTLIBICONV = @LTLIBICONV@
+LTLIBINTL = @LTLIBINTL@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
+MKINSTALLDIRS = @MKINSTALLDIRS@
+MSGFMT = @MSGFMT@
+MSGMERGE = @MSGMERGE@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -88,11 +110,16 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+POSUB = @POSUB@
 RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
+USE_INCLUDED_LIBINTL = @USE_INCLUDED_LIBINTL@
+USE_NLS = @USE_NLS@
 VERSION = @VERSION@
+XFT_CONFIG = @XFT_CONFIG@
+XGETTEXT = @XGETTEXT@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
@@ -119,6 +146,7 @@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 oldincludedir = @oldincludedir@
@@ -151,12 +179,11 @@
 	README
 
 subdir = doc
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
 DIST_SOURCES =
-DIST_COMMON = README $(srcdir)/Makefile.in Makefile.am
+DIST_COMMON = README Makefile.am Makefile.in
 all: all-am
 
 .SUFFIXES:
@@ -209,6 +236,7 @@
 all-am: Makefile
 
 installdirs:
+
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -228,7 +256,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f $(CONFIG_CLEAN_FILES)
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -238,7 +266,6 @@
 clean-am: clean-generic mostlyclean-am
 
 distclean: distclean-am
-	-rm -f Makefile
 
 distclean-am: clean-am distclean-generic
 
@@ -261,7 +288,6 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-	-rm -f Makefile
 
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
diff -Nur dillo-0.8.0/doc/README dillo-0.8.0.new/doc/README
--- dillo-0.8.0/doc/README	2003-08-08 19:25:19.000000000 +0000
+++ dillo-0.8.0.new/doc/README	2004-10-13 01:13:29.000000000 +0000
@@ -18,8 +18,6 @@
    DwPage.txt          Dillo Widget page (shortly)          Incomplete
    DwStyle.txt         Styles of Dillo Widgets              Pending
    DwTable.txt         Tables in dillo                      Current
-   Selection.txt       Selections, and link activation      Current (?)
-   Cookies.txt         Explains how to enable cookies       Current
    Dpid.txt            Dillo plugin daemon                  Current
  --------------------------------------------------------------------------
  [This documents cover dillo's internal working. They're NOT a user manual]
diff -Nur dillo-0.8.0/dpi/bookmarks.c dillo-0.8.0.new/dpi/bookmarks.c
--- dillo-0.8.0/dpi/bookmarks.c	2004-01-29 20:32:01.000000000 +0000
+++ dillo-0.8.0.new/dpi/bookmarks.c	2004-10-13 01:13:29.000000000 +0000
@@ -19,6 +19,7 @@
  * final '>' of a tag.
  */
 
+#include <config.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <stddef.h>
@@ -36,6 +37,7 @@
 #include <signal.h>
 
 #include <glib.h>
+#include "src/intl.h"
 
 /* This one os tricky, some sources state it should include the byte
  * for the terminating NULL, and others say it shouldn't. */
@@ -81,7 +83,7 @@
 /* -- HTML templates ------------------------------------------------------- */
 
 char *mainpage_header =
-"<html>\n"
+N_("<html>\n"
 "<head>\n"
 "<title>Bookmarks</title>\n"
 "</head>\n"
@@ -96,10 +98,10 @@
 "    </td></tr>\n"
 "  </table></td></tr>\n"
 "</table>\n"
-"<br>\n";
+"<br>\n");
 
 char *modifypage_header =
-"<html>\n"
+N_("<html>\n"
 "<head>\n"
 "<title>Bookmarks</title>\n"
 "</head>\n"
@@ -131,36 +133,36 @@
 "    <td width='100%'></td>\n"
 "    </b></tr>\n"
 "  </table></td></tr>\n"
-"</table>\n";
+"</table>\n");
 
 char *mainpage_sections_header =
-"<table border='1' cellpadding='0' cellspacing='20' width='100%'>\n"
+N_("<table border='1' cellpadding='0' cellspacing='20' width='100%'>\n"
 " <tr valign='top'>\n"
 "  <td>\n"
 "   <table bgcolor='#b4b4b4' border='1' cellpadding='4' cellspacing='1'>\n"
 "    <tr><td>\n"
 "     <table width='100%' bgcolor='#b4b4b4'>\n"
-"      <tr><td><small>Sections:</small></td></tr></table></td></tr>\n";
+"      <tr><td><small>Sections:</small></td></tr></table></td></tr>\n");
 
 char *modifypage_sections_header =
-"<table border='1' cellpadding='0' cellspacing='20' width='100%'>\n"
+N_("<table border='1' cellpadding='0' cellspacing='20' width='100%'>\n"
 " <tr valign='top'>\n"
 "  <td>\n"
 "   <table bgcolor='#b4b4b4' border='1'>\n"
 "    <tr><td>\n"                                           
 "     <table width='100%' bgcolor='#b4b4b4'>\n"
-"      <tr><td><small>Sections:</small></td></tr></table></td></tr>\n";
+"      <tr><td><small>Sections:</small></td></tr></table></td></tr>\n");
 
 char *mainpage_sections_item =
-"    <tr><td>\n"
+N_("    <tr><td>\n"
 "     <table width='100%%' bgcolor='#b4b4b4'>\n"
-"      <tr><td><b><a href='#s%d'>%s</a></b></td></tr></table></td></tr>\n";
+"      <tr><td><b><a href='#s%d'>%s</a></b></td></tr></table></td></tr>\n");
 
 char *modifypage_sections_item =
-"    <tr><td>\n"
+N_("    <tr><td>\n"
 "     <table width='100%%' bgcolor='#b4b4b4'>\n"
 "      <tr><td width='1%%'><input type='checkbox' name='s%d'></td>\n"
-"       <td><b><a href='#s%d'>%s</a></b></td></tr></table></td></tr>\n";
+"       <td><b><a href='#s%d'>%s</a></b></td></tr></table></td></tr>\n");
 
 char *mainpage_sections_footer =
 "   </table>\n";
@@ -177,20 +179,20 @@
 "  <td width='100%'>\n";
 
 char *mainpage_section_card_header =
-"   <a name='s%d'></a>\n"
+N_("   <a name='s%d'></a>\n"
 "   <table bgcolor='#bfbfbf' width='100%%' cellspacing='2'>\n"
 "    <tr>\n"
 "     <td bgcolor='#bf0c0c'><font color='white'><b>\n"
 "      &nbsp;&nbsp;&nbsp;%s&nbsp;&nbsp;&nbsp;</b></font></td>\n"
-"     <td bgcolor='white' width='100%%'>&nbsp;</td></tr>\n";
+"     <td bgcolor='white' width='100%%'>&nbsp;</td></tr>\n");
 
 char *modifypage_section_card_header =
-"   <a name='s%d'></a>\n"
+N_("   <a name='s%d'></a>\n"
 "   <table bgcolor='#bfbfbf' width='100%%' cellspacing='2'>\n"
 "    <tr>\n"
 "     <td bgcolor='#bf0c0c'><font color='white'><b>\n"
 "      &nbsp;&nbsp;&nbsp;%s&nbsp;&nbsp;&nbsp;</b></font></td>\n"
-"     <td bgcolor='white' width='100%%'>&nbsp;</td></tr>\n";
+"     <td bgcolor='white' width='100%%'>&nbsp;</td></tr>\n");
 
 char *mainpage_section_card_item =
 "    <tr><td colspan='2'>\n"
@@ -226,7 +228,7 @@
 
 /* ------------------------------------------------------------------------- */
 char *modifypage_add_section_page =
-"<html>\n"
+N_("<html>\n"
 "<head>\n"
 "<title>Bookmarks</title>\n"
 "</head>\n"
@@ -261,11 +263,11 @@
 "</form>\n"
 "</body>\n"
 "</html>\n"
-"\n";
+"\n");
 
 /* ------------------------------------------------------------------------- */
 char *modifypage_update_header = 
-"<html>\n"
+N_("<html>\n"
 "<head>\n"
 "<title>Bookmarks</title>\n"
 "</head>\n"
@@ -278,7 +280,7 @@
 "</table>\n"
 "<br>\n"
 "<form>\n"
-"<input type='hidden' name='operation' value='modify2'>\n";
+"<input type='hidden' name='operation' value='modify2'>\n");
 
 char *modifypage_update_title =
 "<table border='1' width='100%%'>\n"
@@ -291,7 +293,7 @@
 "<table width='100%' cellpadding='10'>\n";
 
 char *modifypage_update_item =
-"<tr><td>\n"
+N_("<tr><td>\n"
 " <table width='100%%' bgcolor='teal'>\n"
 "  <tr>\n"
 "   <td>Title:</td>\n"
@@ -301,33 +303,33 @@
 "   <td>URL:</td>\n"
 "   <td>%s</td></tr>\n"
 " </table>\n"
-" </td></tr>\n";
+" </td></tr>\n");
 
 char *modifypage_update_item2 =
-"<tr><td>\n"
+N_("<tr><td>\n"
 " <table width='100%%' bgcolor='teal'>\n"
 "  <tr>\n"
 "   <td>Title:</td>\n"
 "   <td><input type='text' name='s%d' size='64'\n"
 "        value='%s'></td></tr>\n"
 " </table>\n"
-" </td></tr>\n";
+" </td></tr>\n");
 
 char *modifypage_update_item_footer =
 "</table>\n";
 
 char *modifypage_update_footer =
-"<table width='100%' cellpadding='4' border='0'>\n"
+N_("<table width='100%' cellpadding='4' border='0'>\n"
 "<tr><td bgcolor='#a0a0a0'>\n"
 " <input type='submit' name='submit' value='submit.'></td></tr>\n"
 "</table>\n"
 "</form>\n"
 "</body>\n"
-"</html>\n";
+"</html>\n");
 
 /* ------------------------------------------------------------------------- */
 char *modifypage_add_url =
-"<html>\n"
+N_("<html>\n"
 "<head>\n"
 "<title>Bookmarks</title>\n"
 "</head>\n"
@@ -364,7 +366,7 @@
 "</table>\n"
 "</form>\n"
 "</body>\n"
-"</html>\n";
+"</html>\n");
 
 
 /* ------------------------------------------------------------------------- */
@@ -752,7 +754,7 @@
 
    /* we need at least one section */
    if (!B_secs)
-      Bms_sec_add("Unclassified");
+      Bms_sec_add(_("Unclassified"));
 
    /* make correlative section numbers */
    n = 0;
@@ -785,7 +787,7 @@
 {
    gchar *OldBmFile;
    char *cmd1 = 
-      "echo \":s0: Unclassified\" > %s";
+      _("echo \":s0: Unclassified\" > %s");
    char *cmd2 =
       "grep -i \"href\" %s | "
       "sed -e 's/<li><A HREF=\"/s0 /' -e 's/\">/ /' -e 's/<.*$//' >> %s";
@@ -846,7 +848,7 @@
          Bms_sec_add(title);
 
       } else {
-         g_print("Syntax error in bookmarks file:\n %s", buf);
+         g_print(_("Syntax error in bookmarks file:\n %s"), buf);
       }
       g_free(buf);
    }
@@ -953,10 +955,10 @@
  */
 int Bmsrv_add_bm(int SockFD, char *url, char *title)
 {
-   char *msg="Added bookmark!";
+   char *msg=_("Added bookmark!");
    int section = 0;
 
-   //g_print("Adding:\n  %s\n  %s\n", title, url);
+   //g_print(_("Adding:\n  %s\n  %s\n"), title, url);
 
    /* Add in memory */
    Bms_add(section, url, title);
@@ -1022,22 +1024,22 @@
    BmSec *sec_node;
    BmRec *bm_node;
 
-   //g_print("  sending page body...\n");
+   //g_print(_("  sending page body...\n"));
 
    if (!gstr)
       gstr = g_string_new("");
 
    /* send modify page header */
-   if (send_data_string(OutFD, modifypage_header))
+   if (send_data_string(OutFD, _(modifypage_header)))
       return 1;
 
    /* write sections header */
-   if (send_data_string(OutFD, modifypage_sections_header))
+   if (send_data_string(OutFD, _(modifypage_sections_header)))
       return 1;
    /* write sections */
    for (list1 = B_secs; list1; list1 = list1->next) {
       sec_node = list1->data;
-      g_string_sprintf(gstr, modifypage_sections_item,
+      g_string_sprintf(gstr, _(modifypage_sections_item),
                        sec_node->section, sec_node->section, sec_node->title);
       if (send_data_string(OutFD, gstr->str))
          return 1;
@@ -1056,7 +1058,7 @@
 
       /* send card header */
       l_title = make_one_line_str(sec_node->title);
-      g_string_sprintf(gstr, modifypage_section_card_header,
+      g_string_sprintf(gstr, _(modifypage_section_card_header),
                        sec_node->section, l_title);
       g_free(l_title);
       if (send_data_string(OutFD, gstr->str))
@@ -1082,7 +1084,7 @@
    if (send_data_string(OutFD, modifypage_footer))
       return 1;
 
-   //g_print("  page body sent.\n");
+   //g_print(_("  page body sent.\n"));
    return 2;
 }
 
@@ -1092,13 +1094,13 @@
  */
 static int Bmsrv_send_modify_page_add_section(int OutFD)
 {
-   //g_print("  sending page body...\n");
+   //g_print(_("  sending page body...\n"));
 
    /* send modify page2 */
-   if (send_data_string(OutFD, modifypage_add_section_page))
+   if (send_data_string(OutFD, _(modifypage_add_section_page)))
       return 1;
 
-   //g_print("  page body sent.\n");
+   //g_print(_("  page body sent.\n"));
    return 2;
 }
 
@@ -1108,7 +1110,7 @@
  */
 static int Bmsrv_send_modify_page_add_url(int OutFD)
 {
-   if (send_data_string(OutFD, modifypage_add_url))
+   if (send_data_string(OutFD, _(modifypage_add_url)))
       return 1;
    return 2;
 }
@@ -1142,14 +1144,14 @@
    }
 
    /* send HTML here */
-   if (send_data_string(OutFD, modifypage_update_header))
+   if (send_data_string(OutFD, _(modifypage_update_header)))
       return 1;
 
    /* Count number of marked urls and sections */
    Bmsrv_count_urls_and_sections(url1, &n_sec, &n_url);
 
    if (n_sec) {
-      g_string_sprintf(gstr, modifypage_update_title, "Update&nbsp;sections:");
+      g_string_sprintf(gstr, modifypage_update_title, _("Update&nbsp;sections:"));
       send_data_chunk(OutFD, gstr->str, gstr->len);
       send_data_string(OutFD, modifypage_update_item_header);
       /* send items here */
@@ -1159,7 +1161,7 @@
          if (q[2+i] == '=') {
             key = strtol(q + 2, NULL, 10);
             if ((sec_node = Bms_get_sec(key))) {
-               g_string_sprintf(gstr, modifypage_update_item2,
+               g_string_sprintf(gstr, _(modifypage_update_item2),
                                 sec_node->section, sec_node->title);
                send_data_chunk(OutFD, gstr->str, gstr->len);
             }
@@ -1169,7 +1171,7 @@
    }
 
    if (n_url) {
-      g_string_sprintf(gstr, modifypage_update_title, "Update&nbsp;titles:");
+      g_string_sprintf(gstr, modifypage_update_title, _("Update&nbsp;titles:"));
       send_data_chunk(OutFD, gstr->str, gstr->len);
       send_data_string(OutFD, modifypage_update_item_header);
       /* send items here */
@@ -1179,7 +1181,7 @@
          if (q[4+i] == '=') {
             key = strtol(q + 4, NULL, 10);
             bm_node = Bms_get(key);
-            g_string_sprintf(gstr, modifypage_update_item,
+            g_string_sprintf(gstr, _(modifypage_update_item),
                              bm_node->key, bm_node->title, bm_node->url);
             send_data_chunk(OutFD, gstr->str, gstr->len);
          }
@@ -1187,7 +1189,7 @@
       send_data_string(OutFD, modifypage_update_item_footer);
    }
 
-   send_data_string(OutFD, modifypage_update_footer);
+   send_data_string(OutFD, _(modifypage_update_footer));
 
    return 2;
 }
@@ -1211,7 +1213,7 @@
    g_string_free(gstr, TRUE);
 
    /* Send HTTP header */
-   //g_print("  sending Header...\n");
+   //g_print(_("  sending Header...\n"));
    if (send(SockFD, Header, strlen(Header), 0) == -1) {
       perror("[send]");
       return 1;
@@ -1268,7 +1270,7 @@
 /* -- This doesn't work because dillo erases the message upon the
  *    receipt of the first data stream.
  *
-   sprintf(msg, "Deleted %d bookmark%s!>", n, (n > 1) ? "s" : "");
+   sprintf(msg, _("Deleted %d bookmark%s!>"), n, (n > 1) ? "s" : "");
    if (Bmsrv_dpi_send_status_msg(OutFD, msg))
       return 1;
 */
@@ -1469,22 +1471,22 @@
    if (strstr(p, "operation=delete&")) {
       if (n_url || n_sec)
          return 0;
-      msg = "Delete: you must mark what to delete!";
+      msg = _("Delete: you must mark what to delete!");
 
    } else if (strstr(url, "operation=move&")) {
       if (n_url && n_sec)
          return 0;
       else if (n_url)
-         msg = "Move: you must mark a target section!";
+         msg = _("Move: you must mark a target section!");
       else if (n_sec)
-         msg = "Move: can not move a section (yet).";
+         msg = _("Move: can not move a section (yet).");
       else
-         msg = "Move: you must mark some urls, and a target section!";
+         msg = _("Move: you must mark some urls, and a target section!");
 
    } else if (strstr(url, "operation=modify&")) {
       if (n_url || n_sec)
          return 0;
-      msg = "Modify: you must mark what to update!";
+      msg = _("Modify: you must mark what to update!");
 
    } else if (strstr(url, "operation=modify2&")) {
       /* nothing to check here */
@@ -1501,17 +1503,17 @@
    } else if (strstr(url, "operation=add_url&")) {
       if (n_sec <= 1)
          return 0;
-      msg = "Add url: only one target section is allowed!";
+      msg = _("Add url: only one target section is allowed!");
 
    } else if (strstr(url, "operation=add_url2&")) {
       /* nothing to check here */
       return 0;
 
    } else if (strstr(url, "operation=none&")) {
-      msg = "No operation, just do nothing!";
+      msg = _("No operation, just do nothing!");
 
    } else {
-      msg = "Sorry, not implemented yet.";
+      msg = _("Sorry, not implemented yet.");
    }
 
    Bmsrv_dpi_send_status_msg(OutFD, msg);
@@ -1599,22 +1601,22 @@
    if (!gstr)
       gstr = g_string_new("");
 
-   if (send_data_string(OutFD, mainpage_header))
+   if (send_data_string(OutFD, _(mainpage_header)))
       return 1;
 
    /* write sections header */
-   if (send_data_string(OutFD, mainpage_sections_header))
+   if (send_data_string(OutFD, _(mainpage_sections_header)))
       return 1;
    /* write sections */
    for (list1 = B_secs; list1; list1 = list1->next) {
       sec_node = list1->data;
-      g_string_sprintf(gstr, mainpage_sections_item,
+      g_string_sprintf(gstr, _(mainpage_sections_item),
                        sec_node->section, sec_node->title);
       if (send_data_string(OutFD, gstr->str))
          return 1;
    }
    /* write sections footer */
-   if (send_data_string(OutFD, mainpage_sections_footer))
+   if (send_data_string(OutFD, _(mainpage_sections_footer)))
       return 1;
 
    /* send page middle */
@@ -1627,7 +1629,7 @@
 
       /* send card header */
       l_title = make_one_line_str(sec_node->title);
-      g_string_sprintf(gstr, mainpage_section_card_header,
+      g_string_sprintf(gstr, _(mainpage_section_card_header),
                        sec_node->section, l_title);
       g_free(l_title);
       if (send_data_string(OutFD, gstr->str))
@@ -1645,7 +1647,7 @@
       }
 
       /* send card footer */
-      if (send_data_string(OutFD, mainpage_section_card_footer))
+      if (send_data_string(OutFD, _(mainpage_section_card_footer)))
          return 1;
    }
 
@@ -1675,7 +1677,7 @@
 
    if (!(p = strchr(Buf, '>'))) {
       /* Haven't got a full tag */
-      g_print("Haven't got a full tag!\n");
+      g_print(_("Haven't got a full tag!\n"));
       return 1;
    }
 
@@ -1715,7 +1717,7 @@
       title = Get_attr_value(Buf, BufSize, "title");
       if (strlen(title) == 0) {
          g_free(title);
-         title = g_strdup("(Untitled)");
+         title = g_strdup(_("(Untitled)"));
       }
       if (url && title)
          Bmsrv_add_bm(SockFD, url, title);
@@ -1746,23 +1748,23 @@
       }
 
       /* Send HTTP header */
-      //g_print("  sending HTTP header...\n");
+      //g_print(_("  sending HTTP header...\n"));
       if (send(SockFD, Header, strlen(Header), 0) == -1) {
          perror("[send]");
          return 1;
       }
 
-      //g_print("  sending page body...\n");
+      //g_print(_("  sending page body...\n"));
       st = send_bm_page(SockFD);
       if (st != 0) {
          char *err = 
-            "<HTML><body> Error on the bookmarks server...</body></html>";
+            _("<HTML><body> Error on the bookmarks server...</body></html>");
          if (send(SockFD, err, strlen(err), 0) == -1) {
             perror("[send]");
             return 1;
          }
       }
-      //g_print("  page body sent.\n");
+      //g_print(_("  page body sent.\n"));
       return 2;
    }
 
@@ -1798,6 +1800,11 @@
    char buf[16384];
    int st, code;
 
+   /* Initialize Gettext */
+   setlocale(LC_ALL, "");
+   bindtextdomain (PACKAGE, LOCALEDIR);
+   textdomain (PACKAGE);
+   
    /* Arrange the cleanup function for terminations via exit() */
    atexit(cleanup);
 
@@ -1814,7 +1821,7 @@
 
    BmFile = g_strconcat(g_get_home_dir(), "/", ".dillo/bm.txt", NULL);
 
-   g_print("bookmarks.dpi (v.13): accepting connections...\n");
+   //g_print(_("bookmarks.dpi (v.13): accepting connections...\n"));
 
    /* some OSes may need this... */
    address_size = sizeof(struct sockaddr_un);
@@ -1837,7 +1844,7 @@
             exit(1);
          }
          buf[st] = 0;
-         //g_print("Received from client: %s\n", buf);
+         //g_print(_("Received from client: %s\n"), buf);
    
          /* Let's see what we fished... */
          code = Bmsrv_parse_buf(temp_sock_descriptor, buf, st);
@@ -1847,7 +1854,7 @@
             break;
       }
 
-      //g_print("Closing temp_sock_descriptor\n");
+      //g_print(_("Closing temp_sock_descriptor\n"));
       close(temp_sock_descriptor);
 
    }/*while*/
diff -Nur dillo-0.8.0/dpi/Makefile.am dillo-0.8.0.new/dpi/Makefile.am
--- dillo-0.8.0/dpi/Makefile.am	2004-01-29 20:34:05.000000000 +0000
+++ dillo-0.8.0.new/dpi/Makefile.am	2004-10-13 01:13:29.000000000 +0000
@@ -1,3 +1,4 @@
+AM_CPPFLAGS=-DLOCALEDIR='"$(localedir)"'
 AM_CFLAGS = @GLIB_CFLAGS@
 
 bookmarksdir = $(libdir)/dillo/dpi/bookmarks
diff -Nur dillo-0.8.0/dpi/Makefile.in dillo-0.8.0.new/dpi/Makefile.in
--- dillo-0.8.0/dpi/Makefile.in	2004-02-08 12:57:57.000000000 +0000
+++ dillo-0.8.0.new/dpi/Makefile.in	2004-10-13 01:20:01.000000000 +0000
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.7 from Makefile.am.
+# Makefile.in generated by automake 1.7.3 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -39,6 +39,7 @@
 host_triplet = @host@
 target_triplet = @target@
 ACLOCAL = @ACLOCAL@
+ALLOCA = @ALLOCA@
 AMDEP_FALSE = @AMDEP_FALSE@
 AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
@@ -46,12 +47,15 @@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
+BUILD_INCLUDED_LIBINTL = @BUILD_INCLUDED_LIBINTL@
+CATOBJEXT = @CATOBJEXT@
 CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CYGPATH_W = @CYGPATH_W@
+DATADIRNAME = @DATADIRNAME@
 DEFS = @DEFS@
 DEPDIR = @DEPDIR@
 ECHO_C = @ECHO_C@
@@ -59,9 +63,12 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+GENCAT = @GENCAT@
+GLIBC21 = @GLIBC21@
 GLIB_CFLAGS = @GLIB_CFLAGS@
 GLIB_CONFIG = @GLIB_CONFIG@
 GLIB_LIBS = @GLIB_LIBS@
+GMSGFMT = @GMSGFMT@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_CONFIG = @GTK_CONFIG@
 GTK_LIBS = @GTK_LIBS@
@@ -69,7 +76,17 @@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+INSTOBJEXT = @INSTOBJEXT@
+INTLBISON = @INTLBISON@
+INTLLIBS = @INTLLIBS@
+INTLOBJS = @INTLOBJS@
+INTL_LIBTOOL_SUFFIX_PREFIX = @INTL_LIBTOOL_SUFFIX_PREFIX@
+KRB5_CONFIG = @KRB5_CONFIG@
 LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBICONV_CFLAGS = @LIBICONV_CFLAGS@
+LIBICONV_LIBS = @LIBICONV_LIBS@
+LIBINTL = @LIBINTL@
 LIBJPEG_CPPFLAGS = @LIBJPEG_CPPFLAGS@
 LIBJPEG_LDFLAGS = @LIBJPEG_LDFLAGS@
 LIBJPEG_LIBS = @LIBJPEG_LIBS@
@@ -78,8 +95,13 @@
 LIBPNG_LIBS = @LIBPNG_LIBS@
 LIBS = @LIBS@
 LIBZ_LIBS = @LIBZ_LIBS@
+LTLIBICONV = @LTLIBICONV@
+LTLIBINTL = @LTLIBINTL@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
+MKINSTALLDIRS = @MKINSTALLDIRS@
+MSGFMT = @MSGFMT@
+MSGMERGE = @MSGMERGE@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -88,11 +110,16 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+POSUB = @POSUB@
 RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
+USE_INCLUDED_LIBINTL = @USE_INCLUDED_LIBINTL@
+USE_NLS = @USE_NLS@
 VERSION = @VERSION@
+XFT_CONFIG = @XFT_CONFIG@
+XGETTEXT = @XGETTEXT@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
@@ -119,6 +146,7 @@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 oldincludedir = @oldincludedir@
@@ -132,6 +160,7 @@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
+AM_CPPFLAGS = -DLOCALEDIR='"$(localedir)"'
 AM_CFLAGS = @GLIB_CFLAGS@
 
 bookmarksdir = $(libdir)/dillo/dpi/bookmarks
@@ -157,7 +186,6 @@
 https_filter_dpi_SOURCES = https.c
 hello_filter_dpi_SOURCES = hello.c
 subdir = dpi
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
@@ -203,7 +231,7 @@
 DIST_SOURCES = $(bookmarks_dpi_SOURCES) $(downloads_dpi_SOURCES) \
 	$(ftp_filter_dpi_SOURCES) $(hello_filter_dpi_SOURCES) \
 	$(https_filter_dpi_SOURCES)
-DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
+DIST_COMMON = Makefile.am Makefile.in
 SOURCES = $(bookmarks_dpi_SOURCES) $(downloads_dpi_SOURCES) $(ftp_filter_dpi_SOURCES) $(hello_filter_dpi_SOURCES) $(https_filter_dpi_SOURCES)
 
 all: all-am
@@ -363,10 +391,13 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/hello.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/https.Po@am__quote@
 
+distclean-depend:
+	-rm -rf ./$(DEPDIR)
+
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
+@am__fastdepCC_TRUE@	then mv "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
 @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; \
 @am__fastdepCC_TRUE@	fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
@@ -377,7 +408,7 @@
 .c.obj:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `if test -f '$<'; then $(CYGPATH_W) '$<'; else $(CYGPATH_W) '$(srcdir)/$<'; fi`; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
+@am__fastdepCC_TRUE@	then mv "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
 @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; \
 @am__fastdepCC_TRUE@	fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
@@ -477,6 +508,7 @@
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(bookmarksdir) $(DESTDIR)$(downloadsdir) $(DESTDIR)$(ftpdir) $(DESTDIR)$(hellodir) $(DESTDIR)$(httpsdir)
+
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -496,7 +528,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f $(CONFIG_CLEAN_FILES)
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -508,11 +540,9 @@
 	clean-httpsPROGRAMS mostlyclean-am
 
 distclean: distclean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
 
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-tags
+distclean-am: clean-am distclean-compile distclean-depend \
+	distclean-generic distclean-tags
 
 dvi: dvi-am
 
@@ -534,8 +564,6 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
 
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
@@ -559,13 +587,13 @@
 	clean-bookmarksPROGRAMS clean-downloadsPROGRAMS \
 	clean-ftpPROGRAMS clean-generic clean-helloPROGRAMS \
 	clean-httpsPROGRAMS ctags distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am info \
-	info-am install install-am install-bookmarksPROGRAMS \
-	install-data install-data-am install-downloadsPROGRAMS \
-	install-exec install-exec-am install-ftpPROGRAMS \
-	install-helloPROGRAMS install-httpsPROGRAMS install-info \
-	install-info-am install-man install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
+	distclean-depend distclean-generic distclean-tags distdir dvi \
+	dvi-am info info-am install install-am \
+	install-bookmarksPROGRAMS install-data install-data-am \
+	install-downloadsPROGRAMS install-exec install-exec-am \
+	install-ftpPROGRAMS install-helloPROGRAMS install-httpsPROGRAMS \
+	install-info install-info-am install-man install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
 	maintainer-clean-generic mostlyclean mostlyclean-compile \
 	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
 	uninstall-am uninstall-bookmarksPROGRAMS \
diff -Nur dillo-0.8.0/dpid/dpi_socket_dir.c dillo-0.8.0.new/dpid/dpi_socket_dir.c
--- dillo-0.8.0/dpid/dpi_socket_dir.c	2003-11-11 23:31:16.000000000 +0000
+++ dillo-0.8.0.new/dpid/dpi_socket_dir.c	2004-10-13 01:13:29.000000000 +0000
@@ -23,6 +23,7 @@
 #include <errno.h>
 #include "dpid_common.h"
 #include "dpi.h"
+#include "../src/intl.h"
 #include "misc_new.h"
 
 /*! Save socket directory name in ~/.dillo/dpi_socket_dir
@@ -101,16 +102,16 @@
 
    if ((sockdir = a_Dpi_rd_dpi_socket_dir(dpi_socket_dir)) == NULL) {
       fprintf(stderr, "debug_msg - init_sockdir: ");
-      fprintf(stderr, "The dpi_socket_dir file does not exist\n");
+      fprintf(stderr, _("The dpi_socket_dir file does not exist\n"));
    } else {
       if ((dir_ok = tst_dir(sockdir)) == 1) {
          fprintf(stderr,
-                 "debug_msg - init_sockdir: The socket directory ");
-         fprintf(stderr, "%s exists and is OK\n", sockdir);
+                 _("debug_msg - init_sockdir: The socket directory "));
+         fprintf(stderr, _("%s exists and is OK\n"), sockdir);
       } else {
          fprintf(stderr,
-                 "debug_msg - init_sockdir: The socket directory ");
-         fprintf(stderr, "%s does not exist or is not a directory\n",
+                 _("debug_msg - init_sockdir: The socket directory "));
+         fprintf(stderr, _("%s does not exist or is not a directory\n"),
                  sockdir);
          g_free(sockdir);
       }
@@ -119,10 +120,10 @@
       sockdir = mk_sockdir();
       if (sockdir == NULL) {
          ERRMSG("init_sockdir", "mk_sockdir", 0);
-         fprintf(stderr, " - Failed to create dpi socket directory\n");
+         fprintf(stderr, _(" - Failed to create dpi socket directory\n"));
       } else if ((w_dpi_socket_dir(dpi_socket_dir, sockdir)) == -1) {
          ERRMSG("init_sockdir", "w_dpi_socket_dir", 0);
-         fprintf(stderr, " - failed to save %s\n", sockdir);
+         fprintf(stderr, _(" - failed to save %s\n"), sockdir);
          g_free(sockdir);
          sockdir = NULL;
       }
diff -Nur dillo-0.8.0/dpid/main.c dillo-0.8.0.new/dpid/main.c
--- dillo-0.8.0/dpid/main.c	2004-02-06 15:54:26.000000000 +0000
+++ dillo-0.8.0.new/dpid/main.c	2004-10-13 01:13:29.000000000 +0000
@@ -22,6 +22,9 @@
 #include <sys/stat.h>
 #include <sys/time.h>
 #include <glib.h>
+#include <locale.h>
+#include "config.h"
+#include "../src/intl.h"
 #include "dpid_common.h"
 #include "dpid.h"
 #include "dpi.h"
@@ -51,14 +54,14 @@
    dup2(STDIN_FILENO, old_stdin);
    if (dup2(newsock, STDIN_FILENO) == -1) {
       ERRMSG("start_plugin", "dup2", errno);
-      fprintf(stderr, "ERROR in child proc for %s\n", dpi_attr.path);
+      fprintf(stderr, _("ERROR in child proc for %s\n"), dpi_attr.path);
       exit(1);
    }
 
    dup2(STDOUT_FILENO, old_stdout);
    if (dup2(newsock, STDOUT_FILENO) == -1) {
       ERRMSG("start_plugin", "dup2", errno);
-      fprintf(stderr, "ERROR in child proc for %s\n", dpi_attr.path);
+      fprintf(stderr, _("ERROR in child proc for %s\n"), dpi_attr.path);
       exit(1);
    }
    if ((pid = fork()) == -1) {
@@ -69,7 +72,7 @@
       /* Child, start plugin */
       if (execl(dpi_attr.path, dpi_attr.path, NULL) == -1) {
          ERRMSG("start_plugin", "execl", errno);
-         fprintf(stderr, "ERROR in child proc for %s\n", dpi_attr.path);
+         fprintf(stderr, _("ERROR in child proc for %s\n"), dpi_attr.path);
          exit(1);
       }
    }
@@ -77,7 +80,7 @@
    /* Parent, Close sockets fix stdio and return pid */
    if (a_Misc_close_fd(newsock) == -1) {
       ERRMSG("start_plugin", "close", errno);
-      fprintf(stderr, "ERROR in child proc for %s\n", dpi_attr.path);
+      fprintf(stderr, _("ERROR in child proc for %s\n"), dpi_attr.path);
       exit(1);
    }
    a_Misc_close_fd(STDIN_FILENO);
@@ -91,17 +94,17 @@
 {
    if (dup2(dpi_attr.socket, STDIN_FILENO) == -1) {
       ERRMSG("start_plugin", "dup2", errno);
-      fprintf(stderr, "ERROR in child proc for %s\n", dpi_attr.path);
+      fprintf(stderr, _("ERROR in child proc for %s\n"), dpi_attr.path);
       exit(1);
    }
    if (a_Misc_close_fd(dpi_attr.socket) == -1) {
       ERRMSG("start_plugin", "close", errno);
-      fprintf(stderr, "ERROR in child proc for %s\n", dpi_attr.path);
+      fprintf(stderr, _("ERROR in child proc for %s\n"), dpi_attr.path);
       exit(1);
    }
    if (execl(dpi_attr.path, dpi_attr.path, NULL) == -1) {
       ERRMSG("start_plugin", "execl", errno);
-      fprintf(stderr, "ERROR in child proc for %s\n", dpi_attr.path);
+      fprintf(stderr, _("ERROR in child proc for %s\n"), dpi_attr.path);
       exit(1);
    }
 }
@@ -150,7 +153,7 @@
    int COMMAND;
 
    if (dpi_tag == NULL) {
-      ERRMSG("get_command", "dpid tag is NULL\n", 0);
+      //ERRMSG("get_command", _("dpid tag is NULL\n"), 0);
       return (-1);
    }
 
@@ -158,7 +161,7 @@
 
    if (cmd == NULL) {
       ERRMSG("get_command", "a_Misc_get_attr_value", 0);
-      fprintf(stderr, ": dpid failed to parse cmd in %s\n", dpi_tag);
+      fprintf(stderr, _(": dpid failed to parse cmd in %s\n"), dpi_tag);
       (void) CKD_WRITE(sock, tag_prserr);
       COMMAND = -1;
    } else if (strcmp("DpiBye", cmd) == 0) {
@@ -205,6 +208,11 @@
    sigset_t mask_none;
    fd_set selected_set;
 
+   /* Initialize Gettext */
+   setlocale(LC_ALL, "");
+   bindtextdomain (PACKAGE, LOCALEDIR);
+   textdomain (PACKAGE);
+
    dpi_attr_list = NULL;
    //daemon(0,0); /* Use 0,1 for feedback */
    /* todo: call setsid() ?? */
@@ -231,7 +239,7 @@
    dirname = a_Dpi_sockdir_file();
    if ((sockdir = init_sockdir(dirname)) == NULL) {
       ERRMSG("main", "init_sockdir", 0);
-      fprintf(stderr, "Failed to create socket directory\n");
+      fprintf(stderr, _("Failed to create socket directory\n"));
       exit(1);
    }
 
@@ -241,12 +249,12 @@
    if ((numsocks = init_srs_socket(sockdir)) == -1) {
       switch (dpi_errno) {
       case dpid_srs_addrinuse:
-         fprintf(stderr, "dpid refuses to start, possibly because:\n");
-         fprintf(stderr, "\t1) An instance of dpid is already running.\n");
-         fprintf(stderr, "\t2) A previous dpid didn't clean up on exit.\n");
+         fprintf(stderr, _("dpid refuses to start, possibly because:\n"));
+         fprintf(stderr, _("\t1) An instance of dpid is already running.\n"));
+         fprintf(stderr, _("\t2) A previous dpid didn't clean up on exit.\n"));
          exit(1);
       default:
-         ERRMSG("main", "init_srs_sockets failed\n", 0);
+         ERRMSG("main", _("init_srs_sockets failed\n"), 0);
          exit(1);
       }
    }
@@ -259,7 +267,7 @@
    (void) sigemptyset(&mask_none);
    (void) sigprocmask(SIG_SETMASK, &mask_none, NULL);
 
-   printf("dpid started\n");
+   printf(_("dpid started\n"));
 /* Start main loop */
    while (1) {
       do {
@@ -298,8 +306,8 @@
          sock = accept(srs, (struct sockaddr *) &clnt_addr, &csz);
          if (sock == -1) {
             ERRMSG("main", "accept", errno);
-            fprintf(stderr, "accept on srs socket failed\n");
-            fprintf(stderr, "service pending connections, and continue\n");
+            fprintf(stderr, _("accept on srs socket failed\n"));
+            fprintf(stderr, _("service pending connections, and continue\n"));
          } else {
             int command;
 
@@ -323,7 +331,7 @@
                fprintf(stderr, " for request: %s\n", req);
                break;
             case -1:
-               ERRMSG("main", "get_command failed\n", 0);
+               ERRMSG("main", _("get_command failed\n"), 0);
                break;
             }
             if (req)
diff -Nur dillo-0.8.0/dpid/Makefile.am dillo-0.8.0.new/dpid/Makefile.am
--- dillo-0.8.0/dpid/Makefile.am	2004-01-30 15:32:12.000000000 +0000
+++ dillo-0.8.0.new/dpid/Makefile.am	2004-10-13 01:13:29.000000000 +0000
@@ -1,4 +1,4 @@
-AM_CPPFLAGS=-DDPIDRC_SYS='"$(sysconfdir)/dpidrc"'
+AM_CPPFLAGS=-DDPIDRC_SYS='"$(sysconfdir)/dpidrc"' -DLOCALEDIR='"$(localedir)"'
 AM_CFLAGS = @GLIB_CFLAGS@
 
 bin_PROGRAMS = dpid
diff -Nur dillo-0.8.0/dpid/Makefile.in dillo-0.8.0.new/dpid/Makefile.in
--- dillo-0.8.0/dpid/Makefile.in	2004-02-08 12:57:47.000000000 +0000
+++ dillo-0.8.0.new/dpid/Makefile.in	2004-10-13 01:20:01.000000000 +0000
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.7 from Makefile.am.
+# Makefile.in generated by automake 1.7.3 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -39,6 +39,7 @@
 host_triplet = @host@
 target_triplet = @target@
 ACLOCAL = @ACLOCAL@
+ALLOCA = @ALLOCA@
 AMDEP_FALSE = @AMDEP_FALSE@
 AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
@@ -46,12 +47,15 @@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
+BUILD_INCLUDED_LIBINTL = @BUILD_INCLUDED_LIBINTL@
+CATOBJEXT = @CATOBJEXT@
 CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CYGPATH_W = @CYGPATH_W@
+DATADIRNAME = @DATADIRNAME@
 DEFS = @DEFS@
 DEPDIR = @DEPDIR@
 ECHO_C = @ECHO_C@
@@ -59,9 +63,12 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+GENCAT = @GENCAT@
+GLIBC21 = @GLIBC21@
 GLIB_CFLAGS = @GLIB_CFLAGS@
 GLIB_CONFIG = @GLIB_CONFIG@
 GLIB_LIBS = @GLIB_LIBS@
+GMSGFMT = @GMSGFMT@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_CONFIG = @GTK_CONFIG@
 GTK_LIBS = @GTK_LIBS@
@@ -69,7 +76,17 @@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+INSTOBJEXT = @INSTOBJEXT@
+INTLBISON = @INTLBISON@
+INTLLIBS = @INTLLIBS@
+INTLOBJS = @INTLOBJS@
+INTL_LIBTOOL_SUFFIX_PREFIX = @INTL_LIBTOOL_SUFFIX_PREFIX@
+KRB5_CONFIG = @KRB5_CONFIG@
 LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBICONV_CFLAGS = @LIBICONV_CFLAGS@
+LIBICONV_LIBS = @LIBICONV_LIBS@
+LIBINTL = @LIBINTL@
 LIBJPEG_CPPFLAGS = @LIBJPEG_CPPFLAGS@
 LIBJPEG_LDFLAGS = @LIBJPEG_LDFLAGS@
 LIBJPEG_LIBS = @LIBJPEG_LIBS@
@@ -78,8 +95,13 @@
 LIBPNG_LIBS = @LIBPNG_LIBS@
 LIBS = @LIBS@
 LIBZ_LIBS = @LIBZ_LIBS@
+LTLIBICONV = @LTLIBICONV@
+LTLIBINTL = @LTLIBINTL@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
+MKINSTALLDIRS = @MKINSTALLDIRS@
+MSGFMT = @MSGFMT@
+MSGMERGE = @MSGMERGE@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -88,11 +110,16 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+POSUB = @POSUB@
 RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
+USE_INCLUDED_LIBINTL = @USE_INCLUDED_LIBINTL@
+USE_NLS = @USE_NLS@
 VERSION = @VERSION@
+XFT_CONFIG = @XFT_CONFIG@
+XGETTEXT = @XGETTEXT@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
@@ -119,6 +146,7 @@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 oldincludedir = @oldincludedir@
@@ -132,7 +160,7 @@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-AM_CPPFLAGS = -DDPIDRC_SYS='"$(sysconfdir)/dpidrc"'
+AM_CPPFLAGS = -DDPIDRC_SYS='"$(sysconfdir)/dpidrc"' -DLOCALEDIR='"$(localedir)"'
 AM_CFLAGS = @GLIB_CFLAGS@
 
 bin_PROGRAMS = dpid
@@ -157,7 +185,6 @@
 	     misc_new.c
 
 subdir = dpid
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
@@ -185,7 +212,7 @@
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 DIST_SOURCES = $(dpid_SOURCES)
-DIST_COMMON = $(srcdir)/Makefile.in Makefile.am TODO
+DIST_COMMON = Makefile.am Makefile.in TODO
 SOURCES = $(dpid_SOURCES)
 
 all: all-am
@@ -259,10 +286,13 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/main.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/misc_new.Po@am__quote@
 
+distclean-depend:
+	-rm -rf ./$(DEPDIR)
+
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
+@am__fastdepCC_TRUE@	then mv "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
 @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; \
 @am__fastdepCC_TRUE@	fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
@@ -273,7 +303,7 @@
 .c.obj:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `if test -f '$<'; then $(CYGPATH_W) '$<'; else $(CYGPATH_W) '$(srcdir)/$<'; fi`; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
+@am__fastdepCC_TRUE@	then mv "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
 @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; \
 @am__fastdepCC_TRUE@	fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
@@ -373,6 +403,7 @@
 
 installdirs:
 	$(mkinstalldirs) $(DESTDIR)$(bindir) $(DESTDIR)$(bindir)
+
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -392,7 +423,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f $(CONFIG_CLEAN_FILES)
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -402,11 +433,9 @@
 clean-am: clean-binPROGRAMS clean-generic mostlyclean-am
 
 distclean: distclean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
 
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-tags
+distclean-am: clean-am distclean-compile distclean-depend \
+	distclean-generic distclean-tags
 
 dvi: dvi-am
 
@@ -427,8 +456,6 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
 
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
@@ -449,8 +476,8 @@
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-binPROGRAMS \
 	clean-generic ctags distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am info \
-	info-am install install-am install-binPROGRAMS \
+	distclean-depend distclean-generic distclean-tags distdir dvi \
+	dvi-am info info-am install install-am install-binPROGRAMS \
 	install-binSCRIPTS install-data install-data-am \
 	install-data-local install-exec install-exec-am install-info \
 	install-info-am install-man install-strip installcheck \
diff -Nur dillo-0.8.0/install-sh dillo-0.8.0.new/install-sh
--- dillo-0.8.0/install-sh	2003-09-21 23:02:39.000000000 +0000
+++ dillo-0.8.0.new/install-sh	2004-10-13 01:13:29.000000000 +0000
@@ -1,37 +1,19 @@
 #!/bin/sh
 #
 # install - install a program, script, or datafile
+# This comes from X11R5 (mit/util/scripts/install.sh).
 #
-# This originates from X11R5 (mit/util/scripts/install.sh), which was
-# later released in X11R6 (xc/config/util/install.sh) with the
-# following copyright and license.
+# Copyright 1991 by the Massachusetts Institute of Technology
 #
-# Copyright (C) 1994 X Consortium
-#
-# Permission is hereby granted, free of charge, to any person obtaining a copy
-# of this software and associated documentation files (the "Software"), to
-# deal in the Software without restriction, including without limitation the
-# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
-# sell copies of the Software, and to permit persons to whom the Software is
-# furnished to do so, subject to the following conditions:
-#
-# The above copyright notice and this permission notice shall be included in
-# all copies or substantial portions of the Software.
-#
-# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
-# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
-# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
-# X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN
-# AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNEC-
-# TION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-#
-# Except as contained in this notice, the name of the X Consortium shall not
-# be used in advertising or otherwise to promote the sale, use or other deal-
-# ings in this Software without prior written authorization from the X Consor-
-# tium.
-#
-#
-# FSF changes to this file are in the public domain.
+# Permission to use, copy, modify, distribute, and sell this software and its
+# documentation for any purpose is hereby granted without fee, provided that
+# the above copyright notice appear in all copies and that both that
+# copyright notice and this permission notice appear in supporting
+# documentation, and that the name of M.I.T. not be used in advertising or
+# publicity pertaining to distribution of the software without specific,
+# written prior permission.  M.I.T. makes no representations about the
+# suitability of this software for any purpose.  It is provided "as is"
+# without express or implied warranty.
 #
 # Calling this script install-sh is preferred over install.sh, to prevent
 # `make' implicit rules from creating a file called install from it
@@ -239,8 +221,8 @@
 
 # Make a couple of temp file names in the proper directory.
 
-	dsttmp=$dstdir/_inst.$$_
-	rmtmp=$dstdir/_rm.$$_
+	dsttmp=$dstdir/#inst.$$#
+	rmtmp=$dstdir/#rm.$$#
 
 # Trap to clean up temp files at exit.
 
diff -Nur dillo-0.8.0/intl/bindtextdom.c dillo-0.8.0.new/intl/bindtextdom.c
--- dillo-0.8.0/intl/bindtextdom.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/bindtextdom.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,369 @@
+/* Implementation of the bindtextdomain(3) function
+   Copyright (C) 1995-1998, 2000, 2001, 2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+#include "gettextP.h"
+
+#ifdef _LIBC
+/* We have to handle multi-threaded applications.  */
+# include <bits/libc-lock.h>
+#else
+/* Provide dummy implementation if this is outside glibc.  */
+# define __libc_rwlock_define(CLASS, NAME)
+# define __libc_rwlock_wrlock(NAME)
+# define __libc_rwlock_unlock(NAME)
+#endif
+
+/* The internal variables in the standalone libintl.a must have different
+   names than the internal variables in GNU libc, otherwise programs
+   using libintl.a cannot be linked statically.  */
+#if !defined _LIBC
+# define _nl_default_dirname libintl_nl_default_dirname
+# define _nl_domain_bindings libintl_nl_domain_bindings
+#endif
+
+/* Some compilers, like SunOS4 cc, don't have offsetof in <stddef.h>.  */
+#ifndef offsetof
+# define offsetof(type,ident) ((size_t)&(((type*)0)->ident))
+#endif
+
+/* @@ end of prolog @@ */
+
+/* Contains the default location of the message catalogs.  */
+extern const char _nl_default_dirname[];
+
+/* List with bindings of specific domains.  */
+extern struct binding *_nl_domain_bindings;
+
+/* Lock variable to protect the global data in the gettext implementation.  */
+__libc_rwlock_define (extern, _nl_state_lock attribute_hidden)
+
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define BINDTEXTDOMAIN __bindtextdomain
+# define BIND_TEXTDOMAIN_CODESET __bind_textdomain_codeset
+# ifndef strdup
+#  define strdup(str) __strdup (str)
+# endif
+#else
+# define BINDTEXTDOMAIN libintl_bindtextdomain
+# define BIND_TEXTDOMAIN_CODESET libintl_bind_textdomain_codeset
+#endif
+
+/* Prototypes for local functions.  */
+static void set_binding_values PARAMS ((const char *domainname,
+					const char **dirnamep,
+					const char **codesetp));
+
+/* Specifies the directory name *DIRNAMEP and the output codeset *CODESETP
+   to be used for the DOMAINNAME message catalog.
+   If *DIRNAMEP or *CODESETP is NULL, the corresponding attribute is not
+   modified, only the current value is returned.
+   If DIRNAMEP or CODESETP is NULL, the corresponding attribute is neither
+   modified nor returned.  */
+static void
+set_binding_values (domainname, dirnamep, codesetp)
+     const char *domainname;
+     const char **dirnamep;
+     const char **codesetp;
+{
+  struct binding *binding;
+  int modified;
+
+  /* Some sanity checks.  */
+  if (domainname == NULL || domainname[0] == '\0')
+    {
+      if (dirnamep)
+	*dirnamep = NULL;
+      if (codesetp)
+	*codesetp = NULL;
+      return;
+    }
+
+  __libc_rwlock_wrlock (_nl_state_lock);
+
+  modified = 0;
+
+  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)
+    {
+      int compare = strcmp (domainname, binding->domainname);
+      if (compare == 0)
+	/* We found it!  */
+	break;
+      if (compare < 0)
+	{
+	  /* It is not in the list.  */
+	  binding = NULL;
+	  break;
+	}
+    }
+
+  if (binding != NULL)
+    {
+      if (dirnamep)
+	{
+	  const char *dirname = *dirnamep;
+
+	  if (dirname == NULL)
+	    /* The current binding has be to returned.  */
+	    *dirnamep = binding->dirname;
+	  else
+	    {
+	      /* The domain is already bound.  If the new value and the old
+		 one are equal we simply do nothing.  Otherwise replace the
+		 old binding.  */
+	      char *result = binding->dirname;
+	      if (strcmp (dirname, result) != 0)
+		{
+		  if (strcmp (dirname, _nl_default_dirname) == 0)
+		    result = (char *) _nl_default_dirname;
+		  else
+		    {
+#if defined _LIBC || defined HAVE_STRDUP
+		      result = strdup (dirname);
+#else
+		      size_t len = strlen (dirname) + 1;
+		      result = (char *) malloc (len);
+		      if (__builtin_expect (result != NULL, 1))
+			memcpy (result, dirname, len);
+#endif
+		    }
+
+		  if (__builtin_expect (result != NULL, 1))
+		    {
+		      if (binding->dirname != _nl_default_dirname)
+			free (binding->dirname);
+
+		      binding->dirname = result;
+		      modified = 1;
+		    }
+		}
+	      *dirnamep = result;
+	    }
+	}
+
+      if (codesetp)
+	{
+	  const char *codeset = *codesetp;
+
+	  if (codeset == NULL)
+	    /* The current binding has be to returned.  */
+	    *codesetp = binding->codeset;
+	  else
+	    {
+	      /* The domain is already bound.  If the new value and the old
+		 one are equal we simply do nothing.  Otherwise replace the
+		 old binding.  */
+	      char *result = binding->codeset;
+	      if (result == NULL || strcmp (codeset, result) != 0)
+		{
+#if defined _LIBC || defined HAVE_STRDUP
+		  result = strdup (codeset);
+#else
+		  size_t len = strlen (codeset) + 1;
+		  result = (char *) malloc (len);
+		  if (__builtin_expect (result != NULL, 1))
+		    memcpy (result, codeset, len);
+#endif
+
+		  if (__builtin_expect (result != NULL, 1))
+		    {
+		      if (binding->codeset != NULL)
+			free (binding->codeset);
+
+		      binding->codeset = result;
+		      binding->codeset_cntr++;
+		      modified = 1;
+		    }
+		}
+	      *codesetp = result;
+	    }
+	}
+    }
+  else if ((dirnamep == NULL || *dirnamep == NULL)
+	   && (codesetp == NULL || *codesetp == NULL))
+    {
+      /* Simply return the default values.  */
+      if (dirnamep)
+	*dirnamep = _nl_default_dirname;
+      if (codesetp)
+	*codesetp = NULL;
+    }
+  else
+    {
+      /* We have to create a new binding.  */
+      size_t len = strlen (domainname) + 1;
+      struct binding *new_binding =
+	(struct binding *) malloc (offsetof (struct binding, domainname) + len);
+
+      if (__builtin_expect (new_binding == NULL, 0))
+	goto failed;
+
+      memcpy (new_binding->domainname, domainname, len);
+
+      if (dirnamep)
+	{
+	  const char *dirname = *dirnamep;
+
+	  if (dirname == NULL)
+	    /* The default value.  */
+	    dirname = _nl_default_dirname;
+	  else
+	    {
+	      if (strcmp (dirname, _nl_default_dirname) == 0)
+		dirname = _nl_default_dirname;
+	      else
+		{
+		  char *result;
+#if defined _LIBC || defined HAVE_STRDUP
+		  result = strdup (dirname);
+		  if (__builtin_expect (result == NULL, 0))
+		    goto failed_dirname;
+#else
+		  size_t len = strlen (dirname) + 1;
+		  result = (char *) malloc (len);
+		  if (__builtin_expect (result == NULL, 0))
+		    goto failed_dirname;
+		  memcpy (result, dirname, len);
+#endif
+		  dirname = result;
+		}
+	    }
+	  *dirnamep = dirname;
+	  new_binding->dirname = (char *) dirname;
+	}
+      else
+	/* The default value.  */
+	new_binding->dirname = (char *) _nl_default_dirname;
+
+      new_binding->codeset_cntr = 0;
+
+      if (codesetp)
+	{
+	  const char *codeset = *codesetp;
+
+	  if (codeset != NULL)
+	    {
+	      char *result;
+
+#if defined _LIBC || defined HAVE_STRDUP
+	      result = strdup (codeset);
+	      if (__builtin_expect (result == NULL, 0))
+		goto failed_codeset;
+#else
+	      size_t len = strlen (codeset) + 1;
+	      result = (char *) malloc (len);
+	      if (__builtin_expect (result == NULL, 0))
+		goto failed_codeset;
+	      memcpy (result, codeset, len);
+#endif
+	      codeset = result;
+	      new_binding->codeset_cntr++;
+	    }
+	  *codesetp = codeset;
+	  new_binding->codeset = (char *) codeset;
+	}
+      else
+	new_binding->codeset = NULL;
+
+      /* Now enqueue it.  */
+      if (_nl_domain_bindings == NULL
+	  || strcmp (domainname, _nl_domain_bindings->domainname) < 0)
+	{
+	  new_binding->next = _nl_domain_bindings;
+	  _nl_domain_bindings = new_binding;
+	}
+      else
+	{
+	  binding = _nl_domain_bindings;
+	  while (binding->next != NULL
+		 && strcmp (domainname, binding->next->domainname) > 0)
+	    binding = binding->next;
+
+	  new_binding->next = binding->next;
+	  binding->next = new_binding;
+	}
+
+      modified = 1;
+
+      /* Here we deal with memory allocation failures.  */
+      if (0)
+	{
+	failed_codeset:
+	  if (new_binding->dirname != _nl_default_dirname)
+	    free (new_binding->dirname);
+	failed_dirname:
+	  free (new_binding);
+	failed:
+	  if (dirnamep)
+	    *dirnamep = NULL;
+	  if (codesetp)
+	    *codesetp = NULL;
+	}
+    }
+
+  /* If we modified any binding, we flush the caches.  */
+  if (modified)
+    ++_nl_msg_cat_cntr;
+
+  __libc_rwlock_unlock (_nl_state_lock);
+}
+
+/* Specify that the DOMAINNAME message catalog will be found
+   in DIRNAME rather than in the system locale data base.  */
+char *
+BINDTEXTDOMAIN (domainname, dirname)
+     const char *domainname;
+     const char *dirname;
+{
+  set_binding_values (domainname, &dirname, NULL);
+  return (char *) dirname;
+}
+
+/* Specify the character encoding in which the messages from the
+   DOMAINNAME message catalog will be returned.  */
+char *
+BIND_TEXTDOMAIN_CODESET (domainname, codeset)
+     const char *domainname;
+     const char *codeset;
+{
+  set_binding_values (domainname, NULL, &codeset);
+  return (char *) codeset;
+}
+
+#ifdef _LIBC
+/* Aliases for function names in GNU C Library.  */
+weak_alias (__bindtextdomain, bindtextdomain);
+weak_alias (__bind_textdomain_codeset, bind_textdomain_codeset);
+#endif
diff -Nur dillo-0.8.0/intl/ChangeLog dillo-0.8.0.new/intl/ChangeLog
--- dillo-0.8.0/intl/ChangeLog	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/ChangeLog	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,4 @@
+2002-07-25  GNU  <bug-gnu-gettext@gnu.org>
+
+	* Version 0.11.4 released.
+
diff -Nur dillo-0.8.0/intl/config.charset dillo-0.8.0.new/intl/config.charset
--- dillo-0.8.0/intl/config.charset	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/config.charset	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,466 @@
+#! /bin/sh
+# Output a system dependent table of character encoding aliases.
+#
+#   Copyright (C) 2000-2002 Free Software Foundation, Inc.
+#
+#   This program is free software; you can redistribute it and/or modify it
+#   under the terms of the GNU Library General Public License as published
+#   by the Free Software Foundation; either version 2, or (at your option)
+#   any later version.
+#
+#   This program is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Library General Public License for more details.
+#
+#   You should have received a copy of the GNU Library General Public
+#   License along with this program; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+#   USA.
+#
+# The table consists of lines of the form
+#    ALIAS  CANONICAL
+#
+# ALIAS is the (system dependent) result of "nl_langinfo (CODESET)".
+# ALIAS is compared in a case sensitive way.
+#
+# CANONICAL is the GNU canonical name for this character encoding.
+# It must be an encoding supported by libiconv. Support by GNU libc is
+# also desirable. CANONICAL is case insensitive. Usually an upper case
+# MIME charset name is preferred.
+# The current list of GNU canonical charset names is as follows.
+#
+#       name                         used by which systems         a MIME name?
+#   ASCII, ANSI_X3.4-1968     glibc solaris freebsd
+#   ISO-8859-1                glibc aix hpux irix osf solaris freebsd   yes
+#   ISO-8859-2                glibc aix hpux irix osf solaris freebsd   yes
+#   ISO-8859-3                glibc solaris                             yes
+#   ISO-8859-4                osf solaris freebsd                       yes
+#   ISO-8859-5                glibc aix hpux irix osf solaris freebsd   yes
+#   ISO-8859-6                glibc aix hpux solaris                    yes
+#   ISO-8859-7                glibc aix hpux irix osf solaris           yes
+#   ISO-8859-8                glibc aix hpux osf solaris                yes
+#   ISO-8859-9                glibc aix hpux irix osf solaris           yes
+#   ISO-8859-13               glibc
+#   ISO-8859-14               glibc
+#   ISO-8859-15               glibc aix osf solaris freebsd
+#   KOI8-R                    glibc solaris freebsd                     yes
+#   KOI8-U                    glibc freebsd                             yes
+#   KOI8-T                    glibc
+#   CP437                     dos
+#   CP775                     dos
+#   CP850                     aix osf dos
+#   CP852                     dos
+#   CP855                     dos
+#   CP856                     aix
+#   CP857                     dos
+#   CP861                     dos
+#   CP862                     dos
+#   CP864                     dos
+#   CP865                     dos
+#   CP866                     freebsd dos
+#   CP869                     dos
+#   CP874                     woe32 dos
+#   CP922                     aix
+#   CP932                     aix woe32 dos
+#   CP943                     aix
+#   CP949                     osf woe32 dos
+#   CP950                     woe32 dos
+#   CP1046                    aix
+#   CP1124                    aix
+#   CP1125                    dos
+#   CP1129                    aix
+#   CP1250                    woe32
+#   CP1251                    glibc woe32
+#   CP1252                    aix woe32
+#   CP1253                    woe32
+#   CP1254                    woe32
+#   CP1255                    glibc woe32
+#   CP1256                    woe32
+#   CP1257                    woe32
+#   GB2312                    glibc aix hpux irix solaris freebsd       yes
+#   EUC-JP                    glibc aix hpux irix osf solaris freebsd   yes
+#   EUC-KR                    glibc aix hpux irix osf solaris freebsd   yes
+#   EUC-TW                    glibc aix hpux irix osf solaris
+#   BIG5                      glibc aix hpux osf solaris freebsd        yes
+#   BIG5-HKSCS                glibc solaris
+#   GBK                       glibc aix osf solaris woe32 dos
+#   GB18030                   glibc solaris
+#   SHIFT_JIS                 hpux osf solaris freebsd                  yes
+#   JOHAB                     glibc solaris woe32
+#   TIS-620                   glibc aix hpux osf solaris
+#   VISCII                    glibc                                     yes
+#   TCVN5712-1                glibc
+#   GEORGIAN-PS               glibc
+#   HP-ROMAN8                 hpux
+#   HP-ARABIC8                hpux
+#   HP-GREEK8                 hpux
+#   HP-HEBREW8                hpux
+#   HP-TURKISH8               hpux
+#   HP-KANA8                  hpux
+#   DEC-KANJI                 osf
+#   DEC-HANYU                 osf
+#   UTF-8                     glibc aix hpux osf solaris                yes
+#
+# Note: Names which are not marked as being a MIME name should not be used in
+# Internet protocols for information interchange (mail, news, etc.).
+#
+# Note: ASCII and ANSI_X3.4-1968 are synonymous canonical names. Applications
+# must understand both names and treat them as equivalent.
+#
+# The first argument passed to this file is the canonical host specification,
+#    CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or
+#    CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+
+host="$1"
+os=`echo "$host" | sed -e 's/^[^-]*-[^-]*-\(.*\)$/\1/'`
+echo "# This file contains a table of character encoding aliases,"
+echo "# suitable for operating system '${os}'."
+echo "# It was automatically generated from config.charset."
+# List of references, updated during installation:
+echo "# Packages using this file: "
+case "$os" in
+    linux* | *-gnu*)
+	# With glibc-2.1 or newer, we don't need any canonicalization,
+	# because glibc has iconv and both glibc and libiconv support all
+	# GNU canonical names directly. Therefore, the Makefile does not
+	# need to install the alias file at all.
+	# The following applies only to glibc-2.0.x and older libcs.
+	echo "ISO_646.IRV:1983 ASCII"
+	;;
+    aix*)
+	echo "ISO8859-1 ISO-8859-1"
+	echo "ISO8859-2 ISO-8859-2"
+	echo "ISO8859-5 ISO-8859-5"
+	echo "ISO8859-6 ISO-8859-6"
+	echo "ISO8859-7 ISO-8859-7"
+	echo "ISO8859-8 ISO-8859-8"
+	echo "ISO8859-9 ISO-8859-9"
+	echo "ISO8859-15 ISO-8859-15"
+	echo "IBM-850 CP850"
+	echo "IBM-856 CP856"
+	echo "IBM-921 ISO-8859-13"
+	echo "IBM-922 CP922"
+	echo "IBM-932 CP932"
+	echo "IBM-943 CP943"
+	echo "IBM-1046 CP1046"
+	echo "IBM-1124 CP1124"
+	echo "IBM-1129 CP1129"
+	echo "IBM-1252 CP1252"
+	echo "IBM-eucCN GB2312"
+	echo "IBM-eucJP EUC-JP"
+	echo "IBM-eucKR EUC-KR"
+	echo "IBM-eucTW EUC-TW"
+	echo "big5 BIG5"
+	echo "GBK GBK"
+	echo "TIS-620 TIS-620"
+	echo "UTF-8 UTF-8"
+	;;
+    hpux*)
+	echo "iso88591 ISO-8859-1"
+	echo "iso88592 ISO-8859-2"
+	echo "iso88595 ISO-8859-5"
+	echo "iso88596 ISO-8859-6"
+	echo "iso88597 ISO-8859-7"
+	echo "iso88598 ISO-8859-8"
+	echo "iso88599 ISO-8859-9"
+	echo "iso885915 ISO-8859-15"
+	echo "roman8 HP-ROMAN8"
+	echo "arabic8 HP-ARABIC8"
+	echo "greek8 HP-GREEK8"
+	echo "hebrew8 HP-HEBREW8"
+	echo "turkish8 HP-TURKISH8"
+	echo "kana8 HP-KANA8"
+	echo "tis620 TIS-620"
+	echo "big5 BIG5"
+	echo "eucJP EUC-JP"
+	echo "eucKR EUC-KR"
+	echo "eucTW EUC-TW"
+	echo "hp15CN GB2312"
+	#echo "ccdc ?" # what is this?
+	echo "SJIS SHIFT_JIS"
+	echo "utf8 UTF-8"
+	;;
+    irix*)
+	echo "ISO8859-1 ISO-8859-1"
+	echo "ISO8859-2 ISO-8859-2"
+	echo "ISO8859-5 ISO-8859-5"
+	echo "ISO8859-7 ISO-8859-7"
+	echo "ISO8859-9 ISO-8859-9"
+	echo "eucCN GB2312"
+	echo "eucJP EUC-JP"
+	echo "eucKR EUC-KR"
+	echo "eucTW EUC-TW"
+	;;
+    osf*)
+	echo "ISO8859-1 ISO-8859-1"
+	echo "ISO8859-2 ISO-8859-2"
+	echo "ISO8859-4 ISO-8859-4"
+	echo "ISO8859-5 ISO-8859-5"
+	echo "ISO8859-7 ISO-8859-7"
+	echo "ISO8859-8 ISO-8859-8"
+	echo "ISO8859-9 ISO-8859-9"
+	echo "ISO8859-15 ISO-8859-15"
+	echo "cp850 CP850"
+	echo "big5 BIG5"
+	echo "dechanyu DEC-HANYU"
+	echo "dechanzi GB2312"
+	echo "deckanji DEC-KANJI"
+	echo "deckorean EUC-KR"
+	echo "eucJP EUC-JP"
+	echo "eucKR EUC-KR"
+	echo "eucTW EUC-TW"
+	echo "GBK GBK"
+	echo "KSC5601 CP949"
+	echo "sdeckanji EUC-JP"
+	echo "SJIS SHIFT_JIS"
+	echo "TACTIS TIS-620"
+	echo "UTF-8 UTF-8"
+	;;
+    solaris*)
+	echo "646 ASCII"
+	echo "ISO8859-1 ISO-8859-1"
+	echo "ISO8859-2 ISO-8859-2"
+	echo "ISO8859-3 ISO-8859-3"
+	echo "ISO8859-4 ISO-8859-4"
+	echo "ISO8859-5 ISO-8859-5"
+	echo "ISO8859-6 ISO-8859-6"
+	echo "ISO8859-7 ISO-8859-7"
+	echo "ISO8859-8 ISO-8859-8"
+	echo "ISO8859-9 ISO-8859-9"
+	echo "ISO8859-15 ISO-8859-15"
+	echo "koi8-r KOI8-R"
+	echo "BIG5 BIG5"
+	echo "Big5-HKSCS BIG5-HKSCS"
+	echo "gb2312 GB2312"
+	echo "GBK GBK"
+	echo "GB18030 GB18030"
+	echo "cns11643 EUC-TW"
+	echo "5601 EUC-KR"
+	echo "ko_KR.johap92 JOHAB"
+	echo "eucJP EUC-JP"
+	echo "PCK SHIFT_JIS"
+	echo "TIS620.2533 TIS-620"
+	#echo "sun_eu_greek ?" # what is this?
+	echo "UTF-8 UTF-8"
+	;;
+    freebsd* | os2*)
+	# FreeBSD 4.2 doesn't have nl_langinfo(CODESET); therefore
+	# localcharset.c falls back to using the full locale name
+	# from the environment variables.
+	# Likewise for OS/2. OS/2 has XFree86 just like FreeBSD. Just
+	# reuse FreeBSD's locale data for OS/2.
+	echo "C ASCII"
+	echo "US-ASCII ASCII"
+	for l in la_LN lt_LN; do
+	  echo "$l.ASCII ASCII"
+	done
+	for l in da_DK de_AT de_CH de_DE en_AU en_CA en_GB en_US es_ES \
+	         fi_FI fr_BE fr_CA fr_CH fr_FR is_IS it_CH it_IT la_LN \
+	         lt_LN nl_BE nl_NL no_NO pt_PT sv_SE; do
+	  echo "$l.ISO_8859-1 ISO-8859-1"
+	  echo "$l.DIS_8859-15 ISO-8859-15"
+	done
+	for l in cs_CZ hr_HR hu_HU la_LN lt_LN pl_PL sl_SI; do
+	  echo "$l.ISO_8859-2 ISO-8859-2"
+	done
+	for l in la_LN lt_LT; do
+	  echo "$l.ISO_8859-4 ISO-8859-4"
+	done
+	for l in ru_RU ru_SU; do
+	  echo "$l.KOI8-R KOI8-R"
+	  echo "$l.ISO_8859-5 ISO-8859-5"
+	  echo "$l.CP866 CP866"
+	done
+	echo "uk_UA.KOI8-U KOI8-U"
+	echo "zh_TW.BIG5 BIG5"
+	echo "zh_TW.Big5 BIG5"
+	echo "zh_CN.EUC GB2312"
+	echo "ja_JP.EUC EUC-JP"
+	echo "ja_JP.SJIS SHIFT_JIS"
+	echo "ja_JP.Shift_JIS SHIFT_JIS"
+	echo "ko_KR.EUC EUC-KR"
+	;;
+    netbsd*)
+	echo "646 ASCII"
+	echo "ISO8859-1 ISO-8859-1"
+	echo "ISO8859-2 ISO-8859-2"
+	echo "ISO8859-4 ISO-8859-4"
+	echo "ISO8859-5 ISO-8859-5"
+	echo "ISO8859-15 ISO-8859-15"
+	echo "eucCN GB2312"
+	echo "eucJP EUC-JP"
+	echo "eucKR EUC-KR"
+	echo "eucTW EUC-TW"
+	echo "BIG5 BIG5"
+	echo "SJIS SHIFT_JIS"
+	;;
+    beos*)
+	# BeOS has a single locale, and it has UTF-8 encoding.
+	echo "* UTF-8"
+	;;
+    msdosdjgpp*)
+	# DJGPP 2.03 doesn't have nl_langinfo(CODESET); therefore
+	# localcharset.c falls back to using the full locale name
+	# from the environment variables.
+	echo "#"
+	echo "# The encodings given here may not all be correct."
+	echo "# If you find that the encoding given for your language and"
+	echo "# country is not the one your DOS machine actually uses, just"
+	echo "# correct it in this file, and send a mail to"
+	echo "# Juan Manuel Guerrero <st001906@hrz1.hrz.tu-darmstadt.de>"
+	echo "# and Bruno Haible <bruno@clisp.org>."
+	echo "#"
+	echo "C ASCII"
+	# ISO-8859-1 languages
+	echo "ca CP850"
+	echo "ca_ES CP850"
+	echo "da CP865"    # not CP850 ??
+	echo "da_DK CP865" # not CP850 ??
+	echo "de CP850"
+	echo "de_AT CP850"
+	echo "de_CH CP850"
+	echo "de_DE CP850"
+	echo "en CP850"
+	echo "en_AU CP850" # not CP437 ??
+	echo "en_CA CP850"
+	echo "en_GB CP850"
+	echo "en_NZ CP437"
+	echo "en_US CP437"
+	echo "en_ZA CP850" # not CP437 ??
+	echo "es CP850"
+	echo "es_AR CP850"
+	echo "es_BO CP850"
+	echo "es_CL CP850"
+	echo "es_CO CP850"
+	echo "es_CR CP850"
+	echo "es_CU CP850"
+	echo "es_DO CP850"
+	echo "es_EC CP850"
+	echo "es_ES CP850"
+	echo "es_GT CP850"
+	echo "es_HN CP850"
+	echo "es_MX CP850"
+	echo "es_NI CP850"
+	echo "es_PA CP850"
+	echo "es_PY CP850"
+	echo "es_PE CP850"
+	echo "es_SV CP850"
+	echo "es_UY CP850"
+	echo "es_VE CP850"
+	echo "et CP850"
+	echo "et_EE CP850"
+	echo "eu CP850"
+	echo "eu_ES CP850"
+	echo "fi CP850"
+	echo "fi_FI CP850"
+	echo "fr CP850"
+	echo "fr_BE CP850"
+	echo "fr_CA CP850"
+	echo "fr_CH CP850"
+	echo "fr_FR CP850"
+	echo "ga CP850"
+	echo "ga_IE CP850"
+	echo "gd CP850"
+	echo "gd_GB CP850"
+	echo "gl CP850"
+	echo "gl_ES CP850"
+	echo "id CP850"    # not CP437 ??
+	echo "id_ID CP850" # not CP437 ??
+	echo "is CP861"    # not CP850 ??
+	echo "is_IS CP861" # not CP850 ??
+	echo "it CP850"
+	echo "it_CH CP850"
+	echo "it_IT CP850"
+	echo "lt CP775"
+	echo "lt_LT CP775"
+	echo "lv CP775"
+	echo "lv_LV CP775"
+	echo "nb CP865"    # not CP850 ??
+	echo "nb_NO CP865" # not CP850 ??
+	echo "nl CP850"
+	echo "nl_BE CP850"
+	echo "nl_NL CP850"
+	echo "nn CP865"    # not CP850 ??
+	echo "nn_NO CP865" # not CP850 ??
+	echo "no CP865"    # not CP850 ??
+	echo "no_NO CP865" # not CP850 ??
+	echo "pt CP850"
+	echo "pt_BR CP850"
+	echo "pt_PT CP850"
+	echo "sv CP850"
+	echo "sv_SE CP850"
+	# ISO-8859-2 languages
+	echo "cs CP852"
+	echo "cs_CZ CP852"
+	echo "hr CP852"
+	echo "hr_HR CP852"
+	echo "hu CP852"
+	echo "hu_HU CP852"
+	echo "pl CP852"
+	echo "pl_PL CP852"
+	echo "ro CP852"
+	echo "ro_RO CP852"
+	echo "sk CP852"
+	echo "sk_SK CP852"
+	echo "sl CP852"
+	echo "sl_SI CP852"
+	echo "sq CP852"
+	echo "sq_AL CP852"
+	echo "sr CP852"    # CP852 or CP866 or CP855 ??
+	echo "sr_YU CP852" # CP852 or CP866 or CP855 ??
+	# ISO-8859-3 languages
+	echo "mt CP850"
+	echo "mt_MT CP850"
+	# ISO-8859-5 languages
+	echo "be CP866"
+	echo "be_BE CP866"
+	echo "bg CP866"    # not CP855 ??
+	echo "bg_BG CP866" # not CP855 ??
+	echo "mk CP866"    # not CP855 ??
+	echo "mk_MK CP866" # not CP855 ??
+	echo "ru CP866"
+	echo "ru_RU CP866"
+	echo "uk CP1125"
+	echo "uk_UA CP1125"
+	# ISO-8859-6 languages
+	echo "ar CP864"
+	echo "ar_AE CP864"
+	echo "ar_DZ CP864"
+	echo "ar_EG CP864"
+	echo "ar_IQ CP864"
+	echo "ar_IR CP864"
+	echo "ar_JO CP864"
+	echo "ar_KW CP864"
+	echo "ar_MA CP864"
+	echo "ar_OM CP864"
+	echo "ar_QA CP864"
+	echo "ar_SA CP864"
+	echo "ar_SY CP864"
+	# ISO-8859-7 languages
+	echo "el CP869"
+	echo "el_GR CP869"
+	# ISO-8859-8 languages
+	echo "he CP862"
+	echo "he_IL CP862"
+	# ISO-8859-9 languages
+	echo "tr CP857"
+	echo "tr_TR CP857"
+	# Japanese
+	echo "ja CP932"
+	echo "ja_JP CP932"
+	# Chinese
+	echo "zh_CN GBK"
+	echo "zh_TW CP950" # not CP938 ??
+	# Korean
+	echo "kr CP949"    # not CP934 ??
+	echo "kr_KR CP949" # not CP934 ??
+	# Thai
+	echo "th CP874"
+	echo "th_TH CP874"
+	# Other
+	echo "eo CP850"
+	echo "eo_EO CP850"
+	;;
+esac
diff -Nur dillo-0.8.0/intl/dcgettext.c dillo-0.8.0.new/intl/dcgettext.c
--- dillo-0.8.0/intl/dcgettext.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/dcgettext.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,59 @@
+/* Implementation of the dcgettext(3) function.
+   Copyright (C) 1995-1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include "gettextP.h"
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+
+/* @@ end of prolog @@ */
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define DCGETTEXT __dcgettext
+# define DCIGETTEXT __dcigettext
+#else
+# define DCGETTEXT libintl_dcgettext
+# define DCIGETTEXT libintl_dcigettext
+#endif
+
+/* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY
+   locale.  */
+char *
+DCGETTEXT (domainname, msgid, category)
+     const char *domainname;
+     const char *msgid;
+     int category;
+{
+  return DCIGETTEXT (domainname, msgid, NULL, 0, 0, category);
+}
+
+#ifdef _LIBC
+/* Alias for function name in GNU C Library.  */
+INTDEF(__dcgettext)
+weak_alias (__dcgettext, dcgettext);
+#endif
diff -Nur dillo-0.8.0/intl/dcigettext.c dillo-0.8.0.new/intl/dcigettext.c
--- dillo-0.8.0/intl/dcigettext.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/dcigettext.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,1206 @@
+/* Implementation of the internal dcigettext function.
+   Copyright (C) 1995-1999, 2000-2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+/* Tell glibc's <string.h> to provide a prototype for mempcpy().
+   This must come before <config.h> because <config.h> may include
+   <features.h>, and once <features.h> has been included, it's too late.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE	1
+#endif
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <sys/types.h>
+
+#ifdef __GNUC__
+# define alloca __builtin_alloca
+# define HAVE_ALLOCA 1
+#else
+# if defined HAVE_ALLOCA_H || defined _LIBC
+#  include <alloca.h>
+# else
+#  ifdef _AIX
+ #pragma alloca
+#  else
+#   ifndef alloca
+char *alloca ();
+#   endif
+#  endif
+# endif
+#endif
+
+#include <errno.h>
+#ifndef errno
+extern int errno;
+#endif
+#ifndef __set_errno
+# define __set_errno(val) errno = (val)
+#endif
+
+#include <stddef.h>
+#include <stdlib.h>
+#include <string.h>
+
+#if defined HAVE_UNISTD_H || defined _LIBC
+# include <unistd.h>
+#endif
+
+#include <locale.h>
+
+#ifdef _LIBC
+  /* Guess whether integer division by zero raises signal SIGFPE.
+     Set to 1 only if you know for sure.  In case of doubt, set to 0.  */
+# if defined __alpha__ || defined __arm__ || defined __i386__ \
+     || defined __m68k__ || defined __s390__
+#  define INTDIV0_RAISES_SIGFPE 1
+# else
+#  define INTDIV0_RAISES_SIGFPE 0
+# endif
+#endif
+#if !INTDIV0_RAISES_SIGFPE
+# include <signal.h>
+#endif
+
+#if defined HAVE_SYS_PARAM_H || defined _LIBC
+# include <sys/param.h>
+#endif
+
+#include "gettextP.h"
+#include "plural-exp.h"
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+#include "hash-string.h"
+
+/* Thread safetyness.  */
+#ifdef _LIBC
+# include <bits/libc-lock.h>
+#else
+/* Provide dummy implementation if this is outside glibc.  */
+# define __libc_lock_define_initialized(CLASS, NAME)
+# define __libc_lock_lock(NAME)
+# define __libc_lock_unlock(NAME)
+# define __libc_rwlock_define_initialized(CLASS, NAME)
+# define __libc_rwlock_rdlock(NAME)
+# define __libc_rwlock_unlock(NAME)
+#endif
+
+/* Alignment of types.  */
+#if defined __GNUC__ && __GNUC__ >= 2
+# define alignof(TYPE) __alignof__ (TYPE)
+#else
+# define alignof(TYPE) \
+    ((int) &((struct { char dummy1; TYPE dummy2; } *) 0)->dummy2)
+#endif
+
+/* The internal variables in the standalone libintl.a must have different
+   names than the internal variables in GNU libc, otherwise programs
+   using libintl.a cannot be linked statically.  */
+#if !defined _LIBC
+# define _nl_default_default_domain libintl_nl_default_default_domain
+# define _nl_current_default_domain libintl_nl_current_default_domain
+# define _nl_default_dirname libintl_nl_default_dirname
+# define _nl_domain_bindings libintl_nl_domain_bindings
+#endif
+
+/* Some compilers, like SunOS4 cc, don't have offsetof in <stddef.h>.  */
+#ifndef offsetof
+# define offsetof(type,ident) ((size_t)&(((type*)0)->ident))
+#endif
+
+/* @@ end of prolog @@ */
+
+#ifdef _LIBC
+/* Rename the non ANSI C functions.  This is required by the standard
+   because some ANSI C functions will require linking with this object
+   file and the name space must not be polluted.  */
+# define getcwd __getcwd
+# ifndef stpcpy
+#  define stpcpy __stpcpy
+# endif
+# define tfind __tfind
+#else
+# if !defined HAVE_GETCWD
+char *getwd ();
+#  define getcwd(buf, max) getwd (buf)
+# else
+char *getcwd ();
+# endif
+# ifndef HAVE_STPCPY
+static char *stpcpy PARAMS ((char *dest, const char *src));
+# endif
+# ifndef HAVE_MEMPCPY
+static void *mempcpy PARAMS ((void *dest, const void *src, size_t n));
+# endif
+#endif
+
+/* Amount to increase buffer size by in each try.  */
+#define PATH_INCR 32
+
+/* The following is from pathmax.h.  */
+/* Non-POSIX BSD systems might have gcc's limits.h, which doesn't define
+   PATH_MAX but might cause redefinition warnings when sys/param.h is
+   later included (as on MORE/BSD 4.3).  */
+#if defined _POSIX_VERSION || (defined HAVE_LIMITS_H && !defined __GNUC__)
+# include <limits.h>
+#endif
+
+#ifndef _POSIX_PATH_MAX
+# define _POSIX_PATH_MAX 255
+#endif
+
+#if !defined PATH_MAX && defined _PC_PATH_MAX
+# define PATH_MAX (pathconf ("/", _PC_PATH_MAX) < 1 ? 1024 : pathconf ("/", _PC_PATH_MAX))
+#endif
+
+/* Don't include sys/param.h if it already has been.  */
+#if defined HAVE_SYS_PARAM_H && !defined PATH_MAX && !defined MAXPATHLEN
+# include <sys/param.h>
+#endif
+
+#if !defined PATH_MAX && defined MAXPATHLEN
+# define PATH_MAX MAXPATHLEN
+#endif
+
+#ifndef PATH_MAX
+# define PATH_MAX _POSIX_PATH_MAX
+#endif
+
+/* Pathname support.
+   ISSLASH(C)           tests whether C is a directory separator character.
+   IS_ABSOLUTE_PATH(P)  tests whether P is an absolute path.  If it is not,
+                        it may be concatenated to a directory pathname.
+   IS_PATH_WITH_DIR(P)  tests whether P contains a directory specification.
+ */
+#if defined _WIN32 || defined __WIN32__ || defined __EMX__ || defined __DJGPP__
+  /* Win32, OS/2, DOS */
+# define ISSLASH(C) ((C) == '/' || (C) == '\\')
+# define HAS_DEVICE(P) \
+    ((((P)[0] >= 'A' && (P)[0] <= 'Z') || ((P)[0] >= 'a' && (P)[0] <= 'z')) \
+     && (P)[1] == ':')
+# define IS_ABSOLUTE_PATH(P) (ISSLASH ((P)[0]) || HAS_DEVICE (P))
+# define IS_PATH_WITH_DIR(P) \
+    (strchr (P, '/') != NULL || strchr (P, '\\') != NULL || HAS_DEVICE (P))
+#else
+  /* Unix */
+# define ISSLASH(C) ((C) == '/')
+# define IS_ABSOLUTE_PATH(P) ISSLASH ((P)[0])
+# define IS_PATH_WITH_DIR(P) (strchr (P, '/') != NULL)
+#endif
+
+/* This is the type used for the search tree where known translations
+   are stored.  */
+struct known_translation_t
+{
+  /* Domain in which to search.  */
+  char *domainname;
+
+  /* The category.  */
+  int category;
+
+  /* State of the catalog counter at the point the string was found.  */
+  int counter;
+
+  /* Catalog where the string was found.  */
+  struct loaded_l10nfile *domain;
+
+  /* And finally the translation.  */
+  const char *translation;
+  size_t translation_length;
+
+  /* Pointer to the string in question.  */
+  char msgid[ZERO];
+};
+
+/* Root of the search tree with known translations.  We can use this
+   only if the system provides the `tsearch' function family.  */
+#if defined HAVE_TSEARCH || defined _LIBC
+# include <search.h>
+
+static void *root;
+
+# ifdef _LIBC
+#  define tsearch __tsearch
+# endif
+
+/* Function to compare two entries in the table of known translations.  */
+static int transcmp PARAMS ((const void *p1, const void *p2));
+static int
+transcmp (p1, p2)
+     const void *p1;
+     const void *p2;
+{
+  const struct known_translation_t *s1;
+  const struct known_translation_t *s2;
+  int result;
+
+  s1 = (const struct known_translation_t *) p1;
+  s2 = (const struct known_translation_t *) p2;
+
+  result = strcmp (s1->msgid, s2->msgid);
+  if (result == 0)
+    {
+      result = strcmp (s1->domainname, s2->domainname);
+      if (result == 0)
+	/* We compare the category last (though this is the cheapest
+	   operation) since it is hopefully always the same (namely
+	   LC_MESSAGES).  */
+	result = s1->category - s2->category;
+    }
+
+  return result;
+}
+#endif
+
+/* Name of the default domain used for gettext(3) prior any call to
+   textdomain(3).  The default value for this is "messages".  */
+const char _nl_default_default_domain[] attribute_hidden = "messages";
+
+/* Value used as the default domain for gettext(3).  */
+const char *_nl_current_default_domain attribute_hidden
+     = _nl_default_default_domain;
+
+/* Contains the default location of the message catalogs.  */
+#if defined __EMX__
+extern const char _nl_default_dirname[];
+#else
+const char _nl_default_dirname[] = LOCALEDIR;
+#endif
+
+/* List with bindings of specific domains created by bindtextdomain()
+   calls.  */
+struct binding *_nl_domain_bindings;
+
+/* Prototypes for local functions.  */
+static char *plural_lookup PARAMS ((struct loaded_l10nfile *domain,
+				    unsigned long int n,
+				    const char *translation,
+				    size_t translation_len))
+     internal_function;
+static const char *category_to_name PARAMS ((int category)) internal_function;
+static const char *guess_category_value PARAMS ((int category,
+						 const char *categoryname))
+     internal_function;
+
+
+/* For those loosing systems which don't have `alloca' we have to add
+   some additional code emulating it.  */
+#ifdef HAVE_ALLOCA
+/* Nothing has to be done.  */
+# define freea(p) /* nothing */
+# define ADD_BLOCK(list, address) /* nothing */
+# define FREE_BLOCKS(list) /* nothing */
+#else
+struct block_list
+{
+  void *address;
+  struct block_list *next;
+};
+# define ADD_BLOCK(list, addr)						      \
+  do {									      \
+    struct block_list *newp = (struct block_list *) malloc (sizeof (*newp));  \
+    /* If we cannot get a free block we cannot add the new element to	      \
+       the list.  */							      \
+    if (newp != NULL) {							      \
+      newp->address = (addr);						      \
+      newp->next = (list);						      \
+      (list) = newp;							      \
+    }									      \
+  } while (0)
+# define FREE_BLOCKS(list)						      \
+  do {									      \
+    while (list != NULL) {						      \
+      struct block_list *old = list;					      \
+      list = list->next;						      \
+      free (old->address);						      \
+      free (old);							      \
+    }									      \
+  } while (0)
+# undef alloca
+# define alloca(size) (malloc (size))
+# define freea(p) free (p)
+#endif	/* have alloca */
+
+
+#ifdef _LIBC
+/* List of blocks allocated for translations.  */
+typedef struct transmem_list
+{
+  struct transmem_list *next;
+  char data[ZERO];
+} transmem_block_t;
+static struct transmem_list *transmem_list;
+#else
+typedef unsigned char transmem_block_t;
+#endif
+
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define DCIGETTEXT __dcigettext
+#else
+# define DCIGETTEXT libintl_dcigettext
+#endif
+
+/* Lock variable to protect the global data in the gettext implementation.  */
+#ifdef _LIBC
+__libc_rwlock_define_initialized (, _nl_state_lock attribute_hidden)
+#endif
+
+/* Checking whether the binaries runs SUID must be done and glibc provides
+   easier methods therefore we make a difference here.  */
+#ifdef _LIBC
+# define ENABLE_SECURE __libc_enable_secure
+# define DETERMINE_SECURE
+#else
+# ifndef HAVE_GETUID
+#  define getuid() 0
+# endif
+# ifndef HAVE_GETGID
+#  define getgid() 0
+# endif
+# ifndef HAVE_GETEUID
+#  define geteuid() getuid()
+# endif
+# ifndef HAVE_GETEGID
+#  define getegid() getgid()
+# endif
+static int enable_secure;
+# define ENABLE_SECURE (enable_secure == 1)
+# define DETERMINE_SECURE \
+  if (enable_secure == 0)						      \
+    {									      \
+      if (getuid () != geteuid () || getgid () != getegid ())		      \
+	enable_secure = 1;						      \
+      else								      \
+	enable_secure = -1;						      \
+    }
+#endif
+
+/* Get the function to evaluate the plural expression.  */
+#include "eval-plural.h"
+
+/* Look up MSGID in the DOMAINNAME message catalog for the current
+   CATEGORY locale and, if PLURAL is nonzero, search over string
+   depending on the plural form determined by N.  */
+char *
+DCIGETTEXT (domainname, msgid1, msgid2, plural, n, category)
+     const char *domainname;
+     const char *msgid1;
+     const char *msgid2;
+     int plural;
+     unsigned long int n;
+     int category;
+{
+#ifndef HAVE_ALLOCA
+  struct block_list *block_list = NULL;
+#endif
+  struct loaded_l10nfile *domain;
+  struct binding *binding;
+  const char *categoryname;
+  const char *categoryvalue;
+  char *dirname, *xdomainname;
+  char *single_locale;
+  char *retval;
+  size_t retlen;
+  int saved_errno;
+#if defined HAVE_TSEARCH || defined _LIBC
+  struct known_translation_t *search;
+  struct known_translation_t **foundp = NULL;
+  size_t msgid_len;
+#endif
+  size_t domainname_len;
+
+  /* If no real MSGID is given return NULL.  */
+  if (msgid1 == NULL)
+    return NULL;
+
+  __libc_rwlock_rdlock (_nl_state_lock);
+
+  /* If DOMAINNAME is NULL, we are interested in the default domain.  If
+     CATEGORY is not LC_MESSAGES this might not make much sense but the
+     definition left this undefined.  */
+  if (domainname == NULL)
+    domainname = _nl_current_default_domain;
+
+  /* OS/2 specific: backward compatibility with older libintl versions  */
+#ifdef LC_MESSAGES_COMPAT
+  if (category == LC_MESSAGES_COMPAT)
+    category = LC_MESSAGES;
+#endif
+
+#if defined HAVE_TSEARCH || defined _LIBC
+  msgid_len = strlen (msgid1) + 1;
+
+  /* Try to find the translation among those which we found at
+     some time.  */
+  search = (struct known_translation_t *)
+	   alloca (offsetof (struct known_translation_t, msgid) + msgid_len);
+  memcpy (search->msgid, msgid1, msgid_len);
+  search->domainname = (char *) domainname;
+  search->category = category;
+
+  foundp = (struct known_translation_t **) tfind (search, &root, transcmp);
+  freea (search);
+  if (foundp != NULL && (*foundp)->counter == _nl_msg_cat_cntr)
+    {
+      /* Now deal with plural.  */
+      if (plural)
+	retval = plural_lookup ((*foundp)->domain, n, (*foundp)->translation,
+				(*foundp)->translation_length);
+      else
+	retval = (char *) (*foundp)->translation;
+
+      __libc_rwlock_unlock (_nl_state_lock);
+      return retval;
+    }
+#endif
+
+  /* Preserve the `errno' value.  */
+  saved_errno = errno;
+
+  /* See whether this is a SUID binary or not.  */
+  DETERMINE_SECURE;
+
+  /* First find matching binding.  */
+  for (binding = _nl_domain_bindings; binding != NULL; binding = binding->next)
+    {
+      int compare = strcmp (domainname, binding->domainname);
+      if (compare == 0)
+	/* We found it!  */
+	break;
+      if (compare < 0)
+	{
+	  /* It is not in the list.  */
+	  binding = NULL;
+	  break;
+	}
+    }
+
+  if (binding == NULL)
+    dirname = (char *) _nl_default_dirname;
+  else if (IS_ABSOLUTE_PATH (binding->dirname))
+    dirname = binding->dirname;
+  else
+    {
+      /* We have a relative path.  Make it absolute now.  */
+      size_t dirname_len = strlen (binding->dirname) + 1;
+      size_t path_max;
+      char *ret;
+
+      path_max = (unsigned int) PATH_MAX;
+      path_max += 2;		/* The getcwd docs say to do this.  */
+
+      for (;;)
+	{
+	  dirname = (char *) alloca (path_max + dirname_len);
+	  ADD_BLOCK (block_list, dirname);
+
+	  __set_errno (0);
+	  ret = getcwd (dirname, path_max);
+	  if (ret != NULL || errno != ERANGE)
+	    break;
+
+	  path_max += path_max / 2;
+	  path_max += PATH_INCR;
+	}
+
+      if (ret == NULL)
+	{
+	  /* We cannot get the current working directory.  Don't signal an
+	     error but simply return the default string.  */
+	  FREE_BLOCKS (block_list);
+	  __libc_rwlock_unlock (_nl_state_lock);
+	  __set_errno (saved_errno);
+	  return (plural == 0
+		  ? (char *) msgid1
+		  /* Use the Germanic plural rule.  */
+		  : n == 1 ? (char *) msgid1 : (char *) msgid2);
+	}
+
+      stpcpy (stpcpy (strchr (dirname, '\0'), "/"), binding->dirname);
+    }
+
+  /* Now determine the symbolic name of CATEGORY and its value.  */
+  categoryname = category_to_name (category);
+  categoryvalue = guess_category_value (category, categoryname);
+
+  domainname_len = strlen (domainname);
+  xdomainname = (char *) alloca (strlen (categoryname)
+				 + domainname_len + 5);
+  ADD_BLOCK (block_list, xdomainname);
+
+  stpcpy (mempcpy (stpcpy (stpcpy (xdomainname, categoryname), "/"),
+		  domainname, domainname_len),
+	  ".mo");
+
+  /* Creating working area.  */
+  single_locale = (char *) alloca (strlen (categoryvalue) + 1);
+  ADD_BLOCK (block_list, single_locale);
+
+
+  /* Search for the given string.  This is a loop because we perhaps
+     got an ordered list of languages to consider for the translation.  */
+  while (1)
+    {
+      /* Make CATEGORYVALUE point to the next element of the list.  */
+      while (categoryvalue[0] != '\0' && categoryvalue[0] == ':')
+	++categoryvalue;
+      if (categoryvalue[0] == '\0')
+	{
+	  /* The whole contents of CATEGORYVALUE has been searched but
+	     no valid entry has been found.  We solve this situation
+	     by implicitly appending a "C" entry, i.e. no translation
+	     will take place.  */
+	  single_locale[0] = 'C';
+	  single_locale[1] = '\0';
+	}
+      else
+	{
+	  char *cp = single_locale;
+	  while (categoryvalue[0] != '\0' && categoryvalue[0] != ':')
+	    *cp++ = *categoryvalue++;
+	  *cp = '\0';
+
+	  /* When this is a SUID binary we must not allow accessing files
+	     outside the dedicated directories.  */
+	  if (ENABLE_SECURE && IS_PATH_WITH_DIR (single_locale))
+	    /* Ingore this entry.  */
+	    continue;
+	}
+
+      /* If the current locale value is C (or POSIX) we don't load a
+	 domain.  Return the MSGID.  */
+      if (strcmp (single_locale, "C") == 0
+	  || strcmp (single_locale, "POSIX") == 0)
+	{
+	  FREE_BLOCKS (block_list);
+	  __libc_rwlock_unlock (_nl_state_lock);
+	  __set_errno (saved_errno);
+	  return (plural == 0
+		  ? (char *) msgid1
+		  /* Use the Germanic plural rule.  */
+		  : n == 1 ? (char *) msgid1 : (char *) msgid2);
+	}
+
+
+      /* Find structure describing the message catalog matching the
+	 DOMAINNAME and CATEGORY.  */
+      domain = _nl_find_domain (dirname, single_locale, xdomainname, binding);
+
+      if (domain != NULL)
+	{
+	  retval = _nl_find_msg (domain, binding, msgid1, &retlen);
+
+	  if (retval == NULL)
+	    {
+	      int cnt;
+
+	      for (cnt = 0; domain->successor[cnt] != NULL; ++cnt)
+		{
+		  retval = _nl_find_msg (domain->successor[cnt], binding,
+					 msgid1, &retlen);
+
+		  if (retval != NULL)
+		    {
+		      domain = domain->successor[cnt];
+		      break;
+		    }
+		}
+	    }
+
+	  if (retval != NULL)
+	    {
+	      /* Found the translation of MSGID1 in domain DOMAIN:
+		 starting at RETVAL, RETLEN bytes.  */
+	      FREE_BLOCKS (block_list);
+	      __set_errno (saved_errno);
+#if defined HAVE_TSEARCH || defined _LIBC
+	      if (foundp == NULL)
+		{
+		  /* Create a new entry and add it to the search tree.  */
+		  struct known_translation_t *newp;
+
+		  newp = (struct known_translation_t *)
+		    malloc (offsetof (struct known_translation_t, msgid)
+			    + msgid_len + domainname_len + 1);
+		  if (newp != NULL)
+		    {
+		      newp->domainname =
+			mempcpy (newp->msgid, msgid1, msgid_len);
+		      memcpy (newp->domainname, domainname, domainname_len + 1);
+		      newp->category = category;
+		      newp->counter = _nl_msg_cat_cntr;
+		      newp->domain = domain;
+		      newp->translation = retval;
+		      newp->translation_length = retlen;
+
+		      /* Insert the entry in the search tree.  */
+		      foundp = (struct known_translation_t **)
+			tsearch (newp, &root, transcmp);
+		      if (foundp == NULL
+			  || __builtin_expect (*foundp != newp, 0))
+			/* The insert failed.  */
+			free (newp);
+		    }
+		}
+	      else
+		{
+		  /* We can update the existing entry.  */
+		  (*foundp)->counter = _nl_msg_cat_cntr;
+		  (*foundp)->domain = domain;
+		  (*foundp)->translation = retval;
+		  (*foundp)->translation_length = retlen;
+		}
+#endif
+	      /* Now deal with plural.  */
+	      if (plural)
+		retval = plural_lookup (domain, n, retval, retlen);
+
+	      __libc_rwlock_unlock (_nl_state_lock);
+	      return retval;
+	    }
+	}
+    }
+  /* NOTREACHED */
+}
+
+
+char *
+internal_function
+_nl_find_msg (domain_file, domainbinding, msgid, lengthp)
+     struct loaded_l10nfile *domain_file;
+     struct binding *domainbinding;
+     const char *msgid;
+     size_t *lengthp;
+{
+  struct loaded_domain *domain;
+  nls_uint32 nstrings;
+  size_t act;
+  char *result;
+  size_t resultlen;
+
+  if (domain_file->decided == 0)
+    _nl_load_domain (domain_file, domainbinding);
+
+  if (domain_file->data == NULL)
+    return NULL;
+
+  domain = (struct loaded_domain *) domain_file->data;
+
+  nstrings = domain->nstrings;
+
+  /* Locate the MSGID and its translation.  */
+  if (domain->hash_tab != NULL)
+    {
+      /* Use the hashing table.  */
+      nls_uint32 len = strlen (msgid);
+      nls_uint32 hash_val = hash_string (msgid);
+      nls_uint32 idx = hash_val % domain->hash_size;
+      nls_uint32 incr = 1 + (hash_val % (domain->hash_size - 2));
+
+      while (1)
+	{
+	  nls_uint32 nstr =
+	    W (domain->must_swap_hash_tab, domain->hash_tab[idx]);
+
+	  if (nstr == 0)
+	    /* Hash table entry is empty.  */
+	    return NULL;
+
+	  nstr--;
+
+	  /* Compare msgid with the original string at index nstr.
+	     We compare the lengths with >=, not ==, because plural entries
+	     are represented by strings with an embedded NUL.  */
+	  if (nstr < nstrings
+	      ? W (domain->must_swap, domain->orig_tab[nstr].length) >= len
+		&& (strcmp (msgid,
+			    domain->data + W (domain->must_swap,
+					      domain->orig_tab[nstr].offset))
+		    == 0)
+	      : domain->orig_sysdep_tab[nstr - nstrings].length > len
+		&& (strcmp (msgid,
+			    domain->orig_sysdep_tab[nstr - nstrings].pointer)
+		    == 0))
+	    {
+	      act = nstr;
+	      goto found;
+	    }
+
+	  if (idx >= domain->hash_size - incr)
+	    idx -= domain->hash_size - incr;
+	  else
+	    idx += incr;
+	}
+      /* NOTREACHED */
+    }
+  else
+    {
+      /* Try the default method:  binary search in the sorted array of
+	 messages.  */
+      size_t top, bottom;
+
+      bottom = 0;
+      top = nstrings;
+      while (bottom < top)
+	{
+	  int cmp_val;
+
+	  act = (bottom + top) / 2;
+	  cmp_val = strcmp (msgid, (domain->data
+				    + W (domain->must_swap,
+					 domain->orig_tab[act].offset)));
+	  if (cmp_val < 0)
+	    top = act;
+	  else if (cmp_val > 0)
+	    bottom = act + 1;
+	  else
+	    goto found;
+	}
+      /* No translation was found.  */
+      return NULL;
+    }
+
+ found:
+  /* The translation was found at index ACT.  If we have to convert the
+     string to use a different character set, this is the time.  */
+  if (act < nstrings)
+    {
+      result = (char *)
+	(domain->data + W (domain->must_swap, domain->trans_tab[act].offset));
+      resultlen = W (domain->must_swap, domain->trans_tab[act].length) + 1;
+    }
+  else
+    {
+      result = (char *) domain->trans_sysdep_tab[act - nstrings].pointer;
+      resultlen = domain->trans_sysdep_tab[act - nstrings].length;
+    }
+
+#if defined _LIBC || HAVE_ICONV
+  if (domain->codeset_cntr
+      != (domainbinding != NULL ? domainbinding->codeset_cntr : 0))
+    {
+      /* The domain's codeset has changed through bind_textdomain_codeset()
+	 since the message catalog was initialized or last accessed.  We
+	 have to reinitialize the converter.  */
+      _nl_free_domain_conv (domain);
+      _nl_init_domain_conv (domain_file, domain, domainbinding);
+    }
+
+  if (
+# ifdef _LIBC
+      domain->conv != (__gconv_t) -1
+# else
+#  if HAVE_ICONV
+      domain->conv != (iconv_t) -1
+#  endif
+# endif
+      )
+    {
+      /* We are supposed to do a conversion.  First allocate an
+	 appropriate table with the same structure as the table
+	 of translations in the file, where we can put the pointers
+	 to the converted strings in.
+	 There is a slight complication with plural entries.  They
+	 are represented by consecutive NUL terminated strings.  We
+	 handle this case by converting RESULTLEN bytes, including
+	 NULs.  */
+
+      if (domain->conv_tab == NULL
+	  && ((domain->conv_tab =
+		 (char **) calloc (nstrings + domain->n_sysdep_strings,
+				   sizeof (char *)))
+	      == NULL))
+	/* Mark that we didn't succeed allocating a table.  */
+	domain->conv_tab = (char **) -1;
+
+      if (__builtin_expect (domain->conv_tab == (char **) -1, 0))
+	/* Nothing we can do, no more memory.  */
+	goto converted;
+
+      if (domain->conv_tab[act] == NULL)
+	{
+	  /* We haven't used this string so far, so it is not
+	     translated yet.  Do this now.  */
+	  /* We use a bit more efficient memory handling.
+	     We allocate always larger blocks which get used over
+	     time.  This is faster than many small allocations.   */
+	  __libc_lock_define_initialized (static, lock)
+# define INITIAL_BLOCK_SIZE	4080
+	  static unsigned char *freemem;
+	  static size_t freemem_size;
+
+	  const unsigned char *inbuf;
+	  unsigned char *outbuf;
+	  int malloc_count;
+# ifndef _LIBC
+	  transmem_block_t *transmem_list = NULL;
+# endif
+
+	  __libc_lock_lock (lock);
+
+	  inbuf = (const unsigned char *) result;
+	  outbuf = freemem + sizeof (size_t);
+
+	  malloc_count = 0;
+	  while (1)
+	    {
+	      transmem_block_t *newmem;
+# ifdef _LIBC
+	      size_t non_reversible;
+	      int res;
+
+	      if (freemem_size < sizeof (size_t))
+		goto resize_freemem;
+
+	      res = __gconv (domain->conv,
+			     &inbuf, inbuf + resultlen,
+			     &outbuf,
+			     outbuf + freemem_size - sizeof (size_t),
+			     &non_reversible);
+
+	      if (res == __GCONV_OK || res == __GCONV_EMPTY_INPUT)
+		break;
+
+	      if (res != __GCONV_FULL_OUTPUT)
+		{
+		  __libc_lock_unlock (lock);
+		  goto converted;
+		}
+
+	      inbuf = result;
+# else
+#  if HAVE_ICONV
+	      const char *inptr = (const char *) inbuf;
+	      size_t inleft = resultlen;
+	      char *outptr = (char *) outbuf;
+	      size_t outleft;
+
+	      if (freemem_size < sizeof (size_t))
+		goto resize_freemem;
+
+	      outleft = freemem_size - sizeof (size_t);
+	      if (iconv (domain->conv,
+			 (ICONV_CONST char **) &inptr, &inleft,
+			 &outptr, &outleft)
+		  != (size_t) (-1))
+		{
+		  outbuf = (unsigned char *) outptr;
+		  break;
+		}
+	      if (errno != E2BIG)
+		{
+		  __libc_lock_unlock (lock);
+		  goto converted;
+		}
+#  endif
+# endif
+
+	    resize_freemem:
+	      /* We must allocate a new buffer or resize the old one.  */
+	      if (malloc_count > 0)
+		{
+		  ++malloc_count;
+		  freemem_size = malloc_count * INITIAL_BLOCK_SIZE;
+		  newmem = (transmem_block_t *) realloc (transmem_list,
+							 freemem_size);
+# ifdef _LIBC
+		  if (newmem != NULL)
+		    transmem_list = transmem_list->next;
+		  else
+		    {
+		      struct transmem_list *old = transmem_list;
+
+		      transmem_list = transmem_list->next;
+		      free (old);
+		    }
+# endif
+		}
+	      else
+		{
+		  malloc_count = 1;
+		  freemem_size = INITIAL_BLOCK_SIZE;
+		  newmem = (transmem_block_t *) malloc (freemem_size);
+		}
+	      if (__builtin_expect (newmem == NULL, 0))
+		{
+		  freemem = NULL;
+		  freemem_size = 0;
+		  __libc_lock_unlock (lock);
+		  goto converted;
+		}
+
+# ifdef _LIBC
+	      /* Add the block to the list of blocks we have to free
+                 at some point.  */
+	      newmem->next = transmem_list;
+	      transmem_list = newmem;
+
+	      freemem = newmem->data;
+	      freemem_size -= offsetof (struct transmem_list, data);
+# else
+	      transmem_list = newmem;
+	      freemem = newmem;
+# endif
+
+	      outbuf = freemem + sizeof (size_t);
+	    }
+
+	  /* We have now in our buffer a converted string.  Put this
+	     into the table of conversions.  */
+	  *(size_t *) freemem = outbuf - freemem - sizeof (size_t);
+	  domain->conv_tab[act] = (char *) freemem;
+	  /* Shrink freemem, but keep it aligned.  */
+	  freemem_size -= outbuf - freemem;
+	  freemem = outbuf;
+	  freemem += freemem_size & (alignof (size_t) - 1);
+	  freemem_size = freemem_size & ~ (alignof (size_t) - 1);
+
+	  __libc_lock_unlock (lock);
+	}
+
+      /* Now domain->conv_tab[act] contains the translation of all
+	 the plural variants.  */
+      result = domain->conv_tab[act] + sizeof (size_t);
+      resultlen = *(size_t *) domain->conv_tab[act];
+    }
+
+ converted:
+  /* The result string is converted.  */
+
+#endif /* _LIBC || HAVE_ICONV */
+
+  *lengthp = resultlen;
+  return result;
+}
+
+
+/* Look up a plural variant.  */
+static char *
+internal_function
+plural_lookup (domain, n, translation, translation_len)
+     struct loaded_l10nfile *domain;
+     unsigned long int n;
+     const char *translation;
+     size_t translation_len;
+{
+  struct loaded_domain *domaindata = (struct loaded_domain *) domain->data;
+  unsigned long int index;
+  const char *p;
+
+  index = plural_eval (domaindata->plural, n);
+  if (index >= domaindata->nplurals)
+    /* This should never happen.  It means the plural expression and the
+       given maximum value do not match.  */
+    index = 0;
+
+  /* Skip INDEX strings at TRANSLATION.  */
+  p = translation;
+  while (index-- > 0)
+    {
+#ifdef _LIBC
+      p = __rawmemchr (p, '\0');
+#else
+      p = strchr (p, '\0');
+#endif
+      /* And skip over the NUL byte.  */
+      p++;
+
+      if (p >= translation + translation_len)
+	/* This should never happen.  It means the plural expression
+	   evaluated to a value larger than the number of variants
+	   available for MSGID1.  */
+	return (char *) translation;
+    }
+  return (char *) p;
+}
+
+
+/* Return string representation of locale CATEGORY.  */
+static const char *
+internal_function
+category_to_name (category)
+     int category;
+{
+  const char *retval;
+
+  switch (category)
+  {
+#ifdef LC_COLLATE
+  case LC_COLLATE:
+    retval = "LC_COLLATE";
+    break;
+#endif
+#ifdef LC_CTYPE
+  case LC_CTYPE:
+    retval = "LC_CTYPE";
+    break;
+#endif
+#ifdef LC_MONETARY
+  case LC_MONETARY:
+    retval = "LC_MONETARY";
+    break;
+#endif
+#ifdef LC_NUMERIC
+  case LC_NUMERIC:
+    retval = "LC_NUMERIC";
+    break;
+#endif
+#ifdef LC_TIME
+  case LC_TIME:
+    retval = "LC_TIME";
+    break;
+#endif
+#ifdef LC_MESSAGES
+  case LC_MESSAGES:
+    retval = "LC_MESSAGES";
+    break;
+#endif
+#ifdef LC_RESPONSE
+  case LC_RESPONSE:
+    retval = "LC_RESPONSE";
+    break;
+#endif
+#ifdef LC_ALL
+  case LC_ALL:
+    /* This might not make sense but is perhaps better than any other
+       value.  */
+    retval = "LC_ALL";
+    break;
+#endif
+  default:
+    /* If you have a better idea for a default value let me know.  */
+    retval = "LC_XXX";
+  }
+
+  return retval;
+}
+
+/* Guess value of current locale from value of the environment variables.  */
+static const char *
+internal_function
+guess_category_value (category, categoryname)
+     int category;
+     const char *categoryname;
+{
+  const char *language;
+  const char *retval;
+
+  /* The highest priority value is the `LANGUAGE' environment
+     variable.  But we don't use the value if the currently selected
+     locale is the C locale.  This is a GNU extension.  */
+  language = getenv ("LANGUAGE");
+  if (language != NULL && language[0] == '\0')
+    language = NULL;
+
+  /* We have to proceed with the POSIX methods of looking to `LC_ALL',
+     `LC_xxx', and `LANG'.  On some systems this can be done by the
+     `setlocale' function itself.  */
+#ifdef _LIBC
+  retval = setlocale (category, NULL);
+#else
+  retval = _nl_locale_name (category, categoryname);
+#endif
+
+  /* Ignore LANGUAGE if the locale is set to "C" because
+     1. "C" locale usually uses the ASCII encoding, and most international
+	messages use non-ASCII characters. These characters get displayed
+	as question marks (if using glibc's iconv()) or as invalid 8-bit
+	characters (because other iconv()s refuse to convert most non-ASCII
+	characters to ASCII). In any case, the output is ugly.
+     2. The precise output of some programs in the "C" locale is specified
+	by POSIX and should not depend on environment variables like
+	"LANGUAGE".  We allow such programs to use gettext().  */
+  return language != NULL && strcmp (retval, "C") != 0 ? language : retval;
+}
+
+/* @@ begin of epilog @@ */
+
+/* We don't want libintl.a to depend on any other library.  So we
+   avoid the non-standard function stpcpy.  In GNU C Library this
+   function is available, though.  Also allow the symbol HAVE_STPCPY
+   to be defined.  */
+#if !_LIBC && !HAVE_STPCPY
+static char *
+stpcpy (dest, src)
+     char *dest;
+     const char *src;
+{
+  while ((*dest++ = *src++) != '\0')
+    /* Do nothing. */ ;
+  return dest - 1;
+}
+#endif
+
+#if !_LIBC && !HAVE_MEMPCPY
+static void *
+mempcpy (dest, src, n)
+     void *dest;
+     const void *src;
+     size_t n;
+{
+  return (void *) ((char *) memcpy (dest, src, n) + n);
+}
+#endif
+
+
+#ifdef _LIBC
+/* If we want to free all resources we have to do some work at
+   program's end.  */
+static void __attribute__ ((unused))
+free_mem (void)
+{
+  void *old;
+
+  while (_nl_domain_bindings != NULL)
+    {
+      struct binding *oldp = _nl_domain_bindings;
+      _nl_domain_bindings = _nl_domain_bindings->next;
+      if (oldp->dirname != _nl_default_dirname)
+	/* Yes, this is a pointer comparison.  */
+	free (oldp->dirname);
+      free (oldp->codeset);
+      free (oldp);
+    }
+
+  if (_nl_current_default_domain != _nl_default_default_domain)
+    /* Yes, again a pointer comparison.  */
+    free ((char *) _nl_current_default_domain);
+
+  /* Remove the search tree with the known translations.  */
+  __tdestroy (root, free);
+  root = NULL;
+
+  while (transmem_list != NULL)
+    {
+      old = transmem_list;
+      transmem_list = transmem_list->next;
+      free (old);
+    }
+}
+
+text_set_element (__libc_subfreeres, free_mem);
+#endif
diff -Nur dillo-0.8.0/intl/dcngettext.c dillo-0.8.0.new/intl/dcngettext.c
--- dillo-0.8.0/intl/dcngettext.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/dcngettext.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,61 @@
+/* Implementation of the dcngettext(3) function.
+   Copyright (C) 1995-1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include "gettextP.h"
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+
+/* @@ end of prolog @@ */
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define DCNGETTEXT __dcngettext
+# define DCIGETTEXT __dcigettext
+#else
+# define DCNGETTEXT libintl_dcngettext
+# define DCIGETTEXT libintl_dcigettext
+#endif
+
+/* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY
+   locale.  */
+char *
+DCNGETTEXT (domainname, msgid1, msgid2, n, category)
+     const char *domainname;
+     const char *msgid1;
+     const char *msgid2;
+     unsigned long int n;
+     int category;
+{
+  return DCIGETTEXT (domainname, msgid1, msgid2, 1, n, category);
+}
+
+#ifdef _LIBC
+/* Alias for function name in GNU C Library.  */
+INTDEF(__dcngettext)
+weak_alias (__dcngettext, dcngettext);
+#endif
diff -Nur dillo-0.8.0/intl/dgettext.c dillo-0.8.0.new/intl/dgettext.c
--- dillo-0.8.0/intl/dgettext.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/dgettext.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,59 @@
+/* Implementation of the dgettext(3) function.
+   Copyright (C) 1995-1997, 2000, 2001, 2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <locale.h>
+
+#include "gettextP.h"
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+
+/* @@ end of prolog @@ */
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define DGETTEXT __dgettext
+# define DCGETTEXT INTUSE(__dcgettext)
+#else
+# define DGETTEXT libintl_dgettext
+# define DCGETTEXT libintl_dcgettext
+#endif
+
+/* Look up MSGID in the DOMAINNAME message catalog of the current
+   LC_MESSAGES locale.  */
+char *
+DGETTEXT (domainname, msgid)
+     const char *domainname;
+     const char *msgid;
+{
+  return DCGETTEXT (domainname, msgid, LC_MESSAGES);
+}
+
+#ifdef _LIBC
+/* Alias for function name in GNU C Library.  */
+weak_alias (__dgettext, dgettext);
+#endif
diff -Nur dillo-0.8.0/intl/dngettext.c dillo-0.8.0.new/intl/dngettext.c
--- dillo-0.8.0/intl/dngettext.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/dngettext.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,61 @@
+/* Implementation of the dngettext(3) function.
+   Copyright (C) 1995-1997, 2000, 2001, 2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <locale.h>
+
+#include "gettextP.h"
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+
+/* @@ end of prolog @@ */
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define DNGETTEXT __dngettext
+# define DCNGETTEXT INTUSE(__dcngettext)
+#else
+# define DNGETTEXT libintl_dngettext
+# define DCNGETTEXT libintl_dcngettext
+#endif
+
+/* Look up MSGID in the DOMAINNAME message catalog of the current
+   LC_MESSAGES locale and skip message according to the plural form.  */
+char *
+DNGETTEXT (domainname, msgid1, msgid2, n)
+     const char *domainname;
+     const char *msgid1;
+     const char *msgid2;
+     unsigned long int n;
+{
+  return DCNGETTEXT (domainname, msgid1, msgid2, n, LC_MESSAGES);
+}
+
+#ifdef _LIBC
+/* Alias for function name in GNU C Library.  */
+weak_alias (__dngettext, dngettext);
+#endif
diff -Nur dillo-0.8.0/intl/eval-plural.h dillo-0.8.0.new/intl/eval-plural.h
--- dillo-0.8.0/intl/eval-plural.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/eval-plural.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,114 @@
+/* Plural expression evaluation.
+   Copyright (C) 2000-2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifndef STATIC
+#define STATIC static
+#endif
+
+/* Evaluate the plural expression and return an index value.  */
+STATIC unsigned long int plural_eval PARAMS ((struct expression *pexp,
+					      unsigned long int n))
+     internal_function;
+
+STATIC
+unsigned long int
+internal_function
+plural_eval (pexp, n)
+     struct expression *pexp;
+     unsigned long int n;
+{
+  switch (pexp->nargs)
+    {
+    case 0:
+      switch (pexp->operation)
+	{
+	case var:
+	  return n;
+	case num:
+	  return pexp->val.num;
+	default:
+	  break;
+	}
+      /* NOTREACHED */
+      break;
+    case 1:
+      {
+	/* pexp->operation must be lnot.  */
+	unsigned long int arg = plural_eval (pexp->val.args[0], n);
+	return ! arg;
+      }
+    case 2:
+      {
+	unsigned long int leftarg = plural_eval (pexp->val.args[0], n);
+	if (pexp->operation == lor)
+	  return leftarg || plural_eval (pexp->val.args[1], n);
+	else if (pexp->operation == land)
+	  return leftarg && plural_eval (pexp->val.args[1], n);
+	else
+	  {
+	    unsigned long int rightarg = plural_eval (pexp->val.args[1], n);
+
+	    switch (pexp->operation)
+	      {
+	      case mult:
+		return leftarg * rightarg;
+	      case divide:
+#if !INTDIV0_RAISES_SIGFPE
+		if (rightarg == 0)
+		  raise (SIGFPE);
+#endif
+		return leftarg / rightarg;
+	      case module:
+#if !INTDIV0_RAISES_SIGFPE
+		if (rightarg == 0)
+		  raise (SIGFPE);
+#endif
+		return leftarg % rightarg;
+	      case plus:
+		return leftarg + rightarg;
+	      case minus:
+		return leftarg - rightarg;
+	      case less_than:
+		return leftarg < rightarg;
+	      case greater_than:
+		return leftarg > rightarg;
+	      case less_or_equal:
+		return leftarg <= rightarg;
+	      case greater_or_equal:
+		return leftarg >= rightarg;
+	      case equal:
+		return leftarg == rightarg;
+	      case not_equal:
+		return leftarg != rightarg;
+	      default:
+		break;
+	      }
+	  }
+	/* NOTREACHED */
+	break;
+      }
+    case 3:
+      {
+	/* pexp->operation must be qmop.  */
+	unsigned long int boolarg = plural_eval (pexp->val.args[0], n);
+	return plural_eval (pexp->val.args[boolarg ? 1 : 2], n);
+      }
+    }
+  /* NOTREACHED */
+  return 0;
+}
diff -Nur dillo-0.8.0/intl/explodename.c dillo-0.8.0.new/intl/explodename.c
--- dillo-0.8.0/intl/explodename.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/explodename.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,192 @@
+/* Copyright (C) 1995-1998, 2000, 2001 Free Software Foundation, Inc.
+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+
+#include "loadinfo.h"
+
+/* On some strange systems still no definition of NULL is found.  Sigh!  */
+#ifndef NULL
+# if defined __STDC__ && __STDC__
+#  define NULL ((void *) 0)
+# else
+#  define NULL 0
+# endif
+#endif
+
+/* @@ end of prolog @@ */
+
+char *
+_nl_find_language (name)
+     const char *name;
+{
+  while (name[0] != '\0' && name[0] != '_' && name[0] != '@'
+	 && name[0] != '+' && name[0] != ',')
+    ++name;
+
+  return (char *) name;
+}
+
+
+int
+_nl_explode_name (name, language, modifier, territory, codeset,
+		  normalized_codeset, special, sponsor, revision)
+     char *name;
+     const char **language;
+     const char **modifier;
+     const char **territory;
+     const char **codeset;
+     const char **normalized_codeset;
+     const char **special;
+     const char **sponsor;
+     const char **revision;
+{
+  enum { undecided, xpg, cen } syntax;
+  char *cp;
+  int mask;
+
+  *modifier = NULL;
+  *territory = NULL;
+  *codeset = NULL;
+  *normalized_codeset = NULL;
+  *special = NULL;
+  *sponsor = NULL;
+  *revision = NULL;
+
+  /* Now we determine the single parts of the locale name.  First
+     look for the language.  Termination symbols are `_' and `@' if
+     we use XPG4 style, and `_', `+', and `,' if we use CEN syntax.  */
+  mask = 0;
+  syntax = undecided;
+  *language = cp = name;
+  cp = _nl_find_language (*language);
+
+  if (*language == cp)
+    /* This does not make sense: language has to be specified.  Use
+       this entry as it is without exploding.  Perhaps it is an alias.  */
+    cp = strchr (*language, '\0');
+  else if (cp[0] == '_')
+    {
+      /* Next is the territory.  */
+      cp[0] = '\0';
+      *territory = ++cp;
+
+      while (cp[0] != '\0' && cp[0] != '.' && cp[0] != '@'
+	     && cp[0] != '+' && cp[0] != ',' && cp[0] != '_')
+	++cp;
+
+      mask |= TERRITORY;
+
+      if (cp[0] == '.')
+	{
+	  /* Next is the codeset.  */
+	  syntax = xpg;
+	  cp[0] = '\0';
+	  *codeset = ++cp;
+
+	  while (cp[0] != '\0' && cp[0] != '@')
+	    ++cp;
+
+	  mask |= XPG_CODESET;
+
+	  if (*codeset != cp && (*codeset)[0] != '\0')
+	    {
+	      *normalized_codeset = _nl_normalize_codeset (*codeset,
+							   cp - *codeset);
+	      if (strcmp (*codeset, *normalized_codeset) == 0)
+		free ((char *) *normalized_codeset);
+	      else
+		mask |= XPG_NORM_CODESET;
+	    }
+	}
+    }
+
+  if (cp[0] == '@' || (syntax != xpg && cp[0] == '+'))
+    {
+      /* Next is the modifier.  */
+      syntax = cp[0] == '@' ? xpg : cen;
+      cp[0] = '\0';
+      *modifier = ++cp;
+
+      while (syntax == cen && cp[0] != '\0' && cp[0] != '+'
+	     && cp[0] != ',' && cp[0] != '_')
+	++cp;
+
+      mask |= XPG_MODIFIER | CEN_AUDIENCE;
+    }
+
+  if (syntax != xpg && (cp[0] == '+' || cp[0] == ',' || cp[0] == '_'))
+    {
+      syntax = cen;
+
+      if (cp[0] == '+')
+	{
+ 	  /* Next is special application (CEN syntax).  */
+	  cp[0] = '\0';
+	  *special = ++cp;
+
+	  while (cp[0] != '\0' && cp[0] != ',' && cp[0] != '_')
+	    ++cp;
+
+	  mask |= CEN_SPECIAL;
+	}
+
+      if (cp[0] == ',')
+	{
+ 	  /* Next is sponsor (CEN syntax).  */
+	  cp[0] = '\0';
+	  *sponsor = ++cp;
+
+	  while (cp[0] != '\0' && cp[0] != '_')
+	    ++cp;
+
+	  mask |= CEN_SPONSOR;
+	}
+
+      if (cp[0] == '_')
+	{
+ 	  /* Next is revision (CEN syntax).  */
+	  cp[0] = '\0';
+	  *revision = ++cp;
+
+	  mask |= CEN_REVISION;
+	}
+    }
+
+  /* For CEN syntax values it might be important to have the
+     separator character in the file name, not for XPG syntax.  */
+  if (syntax == xpg)
+    {
+      if (*territory != NULL && (*territory)[0] == '\0')
+	mask &= ~TERRITORY;
+
+      if (*codeset != NULL && (*codeset)[0] == '\0')
+	mask &= ~XPG_CODESET;
+
+      if (*modifier != NULL && (*modifier)[0] == '\0')
+	mask &= ~XPG_MODIFIER;
+    }
+
+  return mask;
+}
diff -Nur dillo-0.8.0/intl/finddomain.c dillo-0.8.0.new/intl/finddomain.c
--- dillo-0.8.0/intl/finddomain.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/finddomain.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,198 @@
+/* Handle list of needed message catalogs
+   Copyright (C) 1995-1999, 2000, 2001 Free Software Foundation, Inc.
+   Written by Ulrich Drepper <drepper@gnu.org>, 1995.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <stdio.h>
+#include <sys/types.h>
+#include <stdlib.h>
+#include <string.h>
+
+#if defined HAVE_UNISTD_H || defined _LIBC
+# include <unistd.h>
+#endif
+
+#include "gettextP.h"
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+
+/* @@ end of prolog @@ */
+/* List of already loaded domains.  */
+static struct loaded_l10nfile *_nl_loaded_domains;
+
+
+/* Return a data structure describing the message catalog described by
+   the DOMAINNAME and CATEGORY parameters with respect to the currently
+   established bindings.  */
+struct loaded_l10nfile *
+internal_function
+_nl_find_domain (dirname, locale, domainname, domainbinding)
+     const char *dirname;
+     char *locale;
+     const char *domainname;
+     struct binding *domainbinding;
+{
+  struct loaded_l10nfile *retval;
+  const char *language;
+  const char *modifier;
+  const char *territory;
+  const char *codeset;
+  const char *normalized_codeset;
+  const char *special;
+  const char *sponsor;
+  const char *revision;
+  const char *alias_value;
+  int mask;
+
+  /* LOCALE can consist of up to four recognized parts for the XPG syntax:
+
+		language[_territory[.codeset]][@modifier]
+
+     and six parts for the CEN syntax:
+
+	language[_territory][+audience][+special][,[sponsor][_revision]]
+
+     Beside the first part all of them are allowed to be missing.  If
+     the full specified locale is not found, the less specific one are
+     looked for.  The various parts will be stripped off according to
+     the following order:
+		(1) revision
+		(2) sponsor
+		(3) special
+		(4) codeset
+		(5) normalized codeset
+		(6) territory
+		(7) audience/modifier
+   */
+
+  /* If we have already tested for this locale entry there has to
+     be one data set in the list of loaded domains.  */
+  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,
+			       strlen (dirname) + 1, 0, locale, NULL, NULL,
+			       NULL, NULL, NULL, NULL, NULL, domainname, 0);
+  if (retval != NULL)
+    {
+      /* We know something about this locale.  */
+      int cnt;
+
+      if (retval->decided == 0)
+	_nl_load_domain (retval, domainbinding);
+
+      if (retval->data != NULL)
+	return retval;
+
+      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)
+	{
+	  if (retval->successor[cnt]->decided == 0)
+	    _nl_load_domain (retval->successor[cnt], domainbinding);
+
+	  if (retval->successor[cnt]->data != NULL)
+	    break;
+	}
+      return cnt >= 0 ? retval : NULL;
+      /* NOTREACHED */
+    }
+
+  /* See whether the locale value is an alias.  If yes its value
+     *overwrites* the alias name.  No test for the original value is
+     done.  */
+  alias_value = _nl_expand_alias (locale);
+  if (alias_value != NULL)
+    {
+#if defined _LIBC || defined HAVE_STRDUP
+      locale = strdup (alias_value);
+      if (locale == NULL)
+	return NULL;
+#else
+      size_t len = strlen (alias_value) + 1;
+      locale = (char *) malloc (len);
+      if (locale == NULL)
+	return NULL;
+
+      memcpy (locale, alias_value, len);
+#endif
+    }
+
+  /* Now we determine the single parts of the locale name.  First
+     look for the language.  Termination symbols are `_' and `@' if
+     we use XPG4 style, and `_', `+', and `,' if we use CEN syntax.  */
+  mask = _nl_explode_name (locale, &language, &modifier, &territory,
+			   &codeset, &normalized_codeset, &special,
+			   &sponsor, &revision);
+
+  /* Create all possible locale entries which might be interested in
+     generalization.  */
+  retval = _nl_make_l10nflist (&_nl_loaded_domains, dirname,
+			       strlen (dirname) + 1, mask, language, territory,
+			       codeset, normalized_codeset, modifier, special,
+			       sponsor, revision, domainname, 1);
+  if (retval == NULL)
+    /* This means we are out of core.  */
+    return NULL;
+
+  if (retval->decided == 0)
+    _nl_load_domain (retval, domainbinding);
+  if (retval->data == NULL)
+    {
+      int cnt;
+      for (cnt = 0; retval->successor[cnt] != NULL; ++cnt)
+	{
+	  if (retval->successor[cnt]->decided == 0)
+	    _nl_load_domain (retval->successor[cnt], domainbinding);
+	  if (retval->successor[cnt]->data != NULL)
+	    break;
+	}
+    }
+
+  /* The room for an alias was dynamically allocated.  Free it now.  */
+  if (alias_value != NULL)
+    free (locale);
+
+  /* The space for normalized_codeset is dynamically allocated.  Free it.  */
+  if (mask & XPG_NORM_CODESET)
+    free ((void *) normalized_codeset);
+
+  return retval;
+}
+
+
+#ifdef _LIBC
+static void __attribute__ ((unused))
+free_mem (void)
+{
+  struct loaded_l10nfile *runp = _nl_loaded_domains;
+
+  while (runp != NULL)
+    {
+      struct loaded_l10nfile *here = runp;
+      if (runp->data != NULL)
+	_nl_unload_domain ((struct loaded_domain *) runp->data);
+      runp = runp->next;
+      free ((char *) here->filename);
+      free (here);
+    }
+}
+
+text_set_element (__libc_subfreeres, free_mem);
+#endif
diff -Nur dillo-0.8.0/intl/gettext.c dillo-0.8.0.new/intl/gettext.c
--- dillo-0.8.0/intl/gettext.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/gettext.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,64 @@
+/* Implementation of gettext(3) function.
+   Copyright (C) 1995, 1997, 2000, 2001, 2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#ifdef _LIBC
+# define __need_NULL
+# include <stddef.h>
+#else
+# include <stdlib.h>		/* Just for NULL.  */
+#endif
+
+#include "gettextP.h"
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+
+/* @@ end of prolog @@ */
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define GETTEXT __gettext
+# define DCGETTEXT INTUSE(__dcgettext)
+#else
+# define GETTEXT libintl_gettext
+# define DCGETTEXT libintl_dcgettext
+#endif
+
+/* Look up MSGID in the current default message catalog for the current
+   LC_MESSAGES locale.  If not found, returns MSGID itself (the default
+   text).  */
+char *
+GETTEXT (msgid)
+     const char *msgid;
+{
+  return DCGETTEXT (NULL, msgid, LC_MESSAGES);
+}
+
+#ifdef _LIBC
+/* Alias for function name in GNU C Library.  */
+weak_alias (__gettext, gettext);
+#endif
diff -Nur dillo-0.8.0/intl/gettextP.h dillo-0.8.0.new/intl/gettextP.h
--- dillo-0.8.0/intl/gettextP.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/gettextP.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,242 @@
+/* Header describing internals of libintl library.
+   Copyright (C) 1995-1999, 2000-2002 Free Software Foundation, Inc.
+   Written by Ulrich Drepper <drepper@cygnus.com>, 1995.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifndef _GETTEXTP_H
+#define _GETTEXTP_H
+
+#include <stddef.h>		/* Get size_t.  */
+
+#ifdef _LIBC
+# include "../iconv/gconv_int.h"
+#else
+# if HAVE_ICONV
+#  include <iconv.h>
+# endif
+#endif
+
+#include "loadinfo.h"
+
+#include "gmo.h"		/* Get nls_uint32.  */
+
+/* @@ end of prolog @@ */
+
+#ifndef PARAMS
+# if __STDC__ || defined __GNUC__ || defined __SUNPRO_C || defined __cplusplus || __PROTOTYPES
+#  define PARAMS(args) args
+# else
+#  define PARAMS(args) ()
+# endif
+#endif
+
+#ifndef internal_function
+# define internal_function
+#endif
+
+#ifndef attribute_hidden
+# define attribute_hidden
+#endif
+
+/* Tell the compiler when a conditional or integer expression is
+   almost always true or almost always false.  */
+#ifndef HAVE_BUILTIN_EXPECT
+# define __builtin_expect(expr, val) (expr)
+#endif
+
+#ifndef W
+# define W(flag, data) ((flag) ? SWAP (data) : (data))
+#endif
+
+
+#ifdef _LIBC
+# include <byteswap.h>
+# define SWAP(i) bswap_32 (i)
+#else
+static inline nls_uint32
+SWAP (i)
+     nls_uint32 i;
+{
+  return (i << 24) | ((i & 0xff00) << 8) | ((i >> 8) & 0xff00) | (i >> 24);
+}
+#endif
+
+
+/* In-memory representation of system dependent string.  */
+struct sysdep_string_desc
+{
+  /* Length of addressed string, including the trailing NUL.  */
+  size_t length;
+  /* Pointer to addressed string.  */
+  const char *pointer;
+};
+
+/* The representation of an opened message catalog.  */
+struct loaded_domain
+{
+  /* Pointer to memory containing the .mo file.  */
+  const char *data;
+  /* 1 if the memory is mmap()ed, 0 if the memory is malloc()ed.  */
+  int use_mmap;
+  /* Size of mmap()ed memory.  */
+  size_t mmap_size;
+  /* 1 if the .mo file uses a different endianness than this machine.  */
+  int must_swap;
+  /* Pointer to additional malloc()ed memory.  */
+  void *malloced;
+
+  /* Number of static strings pairs.  */
+  nls_uint32 nstrings;
+  /* Pointer to descriptors of original strings in the file.  */
+  const struct string_desc *orig_tab;
+  /* Pointer to descriptors of translated strings in the file.  */
+  const struct string_desc *trans_tab;
+
+  /* Number of system dependent strings pairs.  */
+  nls_uint32 n_sysdep_strings;
+  /* Pointer to descriptors of original sysdep strings.  */
+  const struct sysdep_string_desc *orig_sysdep_tab;
+  /* Pointer to descriptors of translated sysdep strings.  */
+  const struct sysdep_string_desc *trans_sysdep_tab;
+
+  /* Size of hash table.  */
+  nls_uint32 hash_size;
+  /* Pointer to hash table.  */
+  const nls_uint32 *hash_tab;
+  /* 1 if the hash table uses a different endianness than this machine.  */
+  int must_swap_hash_tab;
+
+  int codeset_cntr;
+#ifdef _LIBC
+  __gconv_t conv;
+#else
+# if HAVE_ICONV
+  iconv_t conv;
+# endif
+#endif
+  char **conv_tab;
+
+  struct expression *plural;
+  unsigned long int nplurals;
+};
+
+/* We want to allocate a string at the end of the struct.  But ISO C
+   doesn't allow zero sized arrays.  */
+#ifdef __GNUC__
+# define ZERO 0
+#else
+# define ZERO 1
+#endif
+
+/* A set of settings bound to a message domain.  Used to store settings
+   from bindtextdomain() and bind_textdomain_codeset().  */
+struct binding
+{
+  struct binding *next;
+  char *dirname;
+  int codeset_cntr;	/* Incremented each time codeset changes.  */
+  char *codeset;
+  char domainname[ZERO];
+};
+
+/* A counter which is incremented each time some previous translations
+   become invalid.
+   This variable is part of the external ABI of the GNU libintl.  */
+extern int _nl_msg_cat_cntr;
+
+#ifndef _LIBC
+const char *_nl_locale_name PARAMS ((int category, const char *categoryname));
+#endif
+
+struct loaded_l10nfile *_nl_find_domain PARAMS ((const char *__dirname,
+						 char *__locale,
+						 const char *__domainname,
+					      struct binding *__domainbinding))
+     internal_function;
+void _nl_load_domain PARAMS ((struct loaded_l10nfile *__domain,
+			      struct binding *__domainbinding))
+     internal_function;
+void _nl_unload_domain PARAMS ((struct loaded_domain *__domain))
+     internal_function;
+const char *_nl_init_domain_conv PARAMS ((struct loaded_l10nfile *__domain_file,
+					  struct loaded_domain *__domain,
+					  struct binding *__domainbinding))
+     internal_function;
+void _nl_free_domain_conv PARAMS ((struct loaded_domain *__domain))
+     internal_function;
+
+char *_nl_find_msg PARAMS ((struct loaded_l10nfile *domain_file,
+			    struct binding *domainbinding,
+			    const char *msgid, size_t *lengthp))
+     internal_function;
+
+#ifdef _LIBC
+extern char *__gettext PARAMS ((const char *__msgid));
+extern char *__dgettext PARAMS ((const char *__domainname,
+				 const char *__msgid));
+extern char *__dcgettext PARAMS ((const char *__domainname,
+				  const char *__msgid, int __category));
+extern char *__ngettext PARAMS ((const char *__msgid1, const char *__msgid2,
+				 unsigned long int __n));
+extern char *__dngettext PARAMS ((const char *__domainname,
+				  const char *__msgid1, const char *__msgid2,
+				  unsigned long int n));
+extern char *__dcngettext PARAMS ((const char *__domainname,
+				   const char *__msgid1, const char *__msgid2,
+				   unsigned long int __n, int __category));
+extern char *__dcigettext PARAMS ((const char *__domainname,
+				   const char *__msgid1, const char *__msgid2,
+				   int __plural, unsigned long int __n,
+				   int __category));
+extern char *__textdomain PARAMS ((const char *__domainname));
+extern char *__bindtextdomain PARAMS ((const char *__domainname,
+				       const char *__dirname));
+extern char *__bind_textdomain_codeset PARAMS ((const char *__domainname,
+						const char *__codeset));
+#else
+extern char *libintl_gettext PARAMS ((const char *__msgid));
+extern char *libintl_dgettext PARAMS ((const char *__domainname,
+				       const char *__msgid));
+extern char *libintl_dcgettext PARAMS ((const char *__domainname,
+					const char *__msgid, int __category));
+extern char *libintl_ngettext PARAMS ((const char *__msgid1,
+				       const char *__msgid2,
+				       unsigned long int __n));
+extern char *libintl_dngettext PARAMS ((const char *__domainname,
+					const char *__msgid1,
+					const char *__msgid2,
+					unsigned long int __n));
+extern char *libintl_dcngettext PARAMS ((const char *__domainname,
+					 const char *__msgid1,
+					 const char *__msgid2,
+					 unsigned long int __n,
+					 int __category));
+extern char *libintl_dcigettext PARAMS ((const char *__domainname,
+					 const char *__msgid1,
+					 const char *__msgid2,
+					 int __plural, unsigned long int __n,
+					 int __category));
+extern char *libintl_textdomain PARAMS ((const char *__domainname));
+extern char *libintl_bindtextdomain PARAMS ((const char *__domainname,
+					     const char *__dirname));
+extern char *libintl_bind_textdomain_codeset PARAMS ((const char *__domainname,
+						      const char *__codeset));
+#endif
+
+/* @@ begin of epilog @@ */
+
+#endif /* gettextP.h  */
diff -Nur dillo-0.8.0/intl/gmo.h dillo-0.8.0.new/intl/gmo.h
--- dillo-0.8.0/intl/gmo.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/gmo.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,148 @@
+/* Description of GNU message catalog format: general file layout.
+   Copyright (C) 1995, 1997, 2000-2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifndef _GETTEXT_H
+#define _GETTEXT_H 1
+
+#include <limits.h>
+
+/* @@ end of prolog @@ */
+
+/* The magic number of the GNU message catalog format.  */
+#define _MAGIC 0x950412de
+#define _MAGIC_SWAPPED 0xde120495
+
+/* Revision number of the currently used .mo (binary) file format.  */
+#define MO_REVISION_NUMBER 0
+
+/* The following contortions are an attempt to use the C preprocessor
+   to determine an unsigned integral type that is 32 bits wide.  An
+   alternative approach is to use autoconf's AC_CHECK_SIZEOF macro, but
+   as of version autoconf-2.13, the AC_CHECK_SIZEOF macro doesn't work
+   when cross-compiling.  */
+
+#if __STDC__
+# define UINT_MAX_32_BITS 4294967295U
+#else
+# define UINT_MAX_32_BITS 0xFFFFFFFF
+#endif
+
+/* If UINT_MAX isn't defined, assume it's a 32-bit type.
+   This should be valid for all systems GNU cares about because
+   that doesn't include 16-bit systems, and only modern systems
+   (that certainly have <limits.h>) have 64+-bit integral types.  */
+
+#ifndef UINT_MAX
+# define UINT_MAX UINT_MAX_32_BITS
+#endif
+
+#if UINT_MAX == UINT_MAX_32_BITS
+typedef unsigned nls_uint32;
+#else
+# if USHRT_MAX == UINT_MAX_32_BITS
+typedef unsigned short nls_uint32;
+# else
+#  if ULONG_MAX == UINT_MAX_32_BITS
+typedef unsigned long nls_uint32;
+#  else
+  /* The following line is intended to throw an error.  Using #error is
+     not portable enough.  */
+  "Cannot determine unsigned 32-bit data type."
+#  endif
+# endif
+#endif
+
+
+/* Header for binary .mo file format.  */
+struct mo_file_header
+{
+  /* The magic number.  */
+  nls_uint32 magic;
+  /* The revision number of the file format.  */
+  nls_uint32 revision;
+
+  /* The following are only used in .mo files with major revision 0.  */
+
+  /* The number of strings pairs.  */
+  nls_uint32 nstrings;
+  /* Offset of table with start offsets of original strings.  */
+  nls_uint32 orig_tab_offset;
+  /* Offset of table with start offsets of translated strings.  */
+  nls_uint32 trans_tab_offset;
+  /* Size of hash table.  */
+  nls_uint32 hash_tab_size;
+  /* Offset of first hash table entry.  */
+  nls_uint32 hash_tab_offset;
+
+  /* The following are only used in .mo files with minor revision >= 1.  */
+
+  /* The number of system dependent segments.  */
+  nls_uint32 n_sysdep_segments;
+  /* Offset of table describing system dependent segments.  */
+  nls_uint32 sysdep_segments_offset;
+  /* The number of system dependent strings pairs.  */
+  nls_uint32 n_sysdep_strings;
+  /* Offset of table with start offsets of original sysdep strings.  */
+  nls_uint32 orig_sysdep_tab_offset;
+  /* Offset of table with start offsets of translated sysdep strings.  */
+  nls_uint32 trans_sysdep_tab_offset;
+};
+
+/* Descriptor for static string contained in the binary .mo file.  */
+struct string_desc
+{
+  /* Length of addressed string, not including the trailing NUL.  */
+  nls_uint32 length;
+  /* Offset of string in file.  */
+  nls_uint32 offset;
+};
+
+/* The following are only used in .mo files with minor revision >= 1.  */
+
+/* Descriptor for system dependent string segment.  */
+struct sysdep_segment
+{
+  /* Length of addressed string, including the trailing NUL.  */
+  nls_uint32 length;
+  /* Offset of string in file.  */
+  nls_uint32 offset;
+};
+
+/* Descriptor for system dependent string.  */
+struct sysdep_string
+{
+  /* Offset of static string segments in file.  */
+  nls_uint32 offset;
+  /* Alternating sequence of static and system dependent segments.
+     The last segment is a static segment, including the trailing NUL.  */
+  struct segment_pair
+  {
+    /* Size of static segment.  */
+    nls_uint32 segsize;
+    /* Reference to system dependent string segment, or ~0 at the end.  */
+    nls_uint32 sysdepref;
+  } segments[1];
+};
+
+/* Marker for the end of the segments[] array.  This has the value 0xFFFFFFFF,
+   regardless whether 'int' is 16 bit, 32 bit, or 64 bit.  */
+#define SEGMENTS_END ((nls_uint32) ~0)
+
+/* @@ begin of epilog @@ */
+
+#endif	/* gettext.h  */
diff -Nur dillo-0.8.0/intl/hash-string.h dillo-0.8.0.new/intl/hash-string.h
--- dillo-0.8.0/intl/hash-string.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/hash-string.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,59 @@
+/* Description of GNU message catalog format: string hashing function.
+   Copyright (C) 1995, 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+/* @@ end of prolog @@ */
+
+#ifndef PARAMS
+# if __STDC__ || defined __GNUC__ || defined __SUNPRO_C || defined __cplusplus || __PROTOTYPES
+#  define PARAMS(Args) Args
+# else
+#  define PARAMS(Args) ()
+# endif
+#endif
+
+/* We assume to have `unsigned long int' value with at least 32 bits.  */
+#define HASHWORDBITS 32
+
+
+/* Defines the so called `hashpjw' function by P.J. Weinberger
+   [see Aho/Sethi/Ullman, COMPILERS: Principles, Techniques and Tools,
+   1986, 1987 Bell Telephone Laboratories, Inc.]  */
+static unsigned long int hash_string PARAMS ((const char *__str_param));
+
+static inline unsigned long int
+hash_string (str_param)
+     const char *str_param;
+{
+  unsigned long int hval, g;
+  const char *str = str_param;
+
+  /* Compute the hash value for the given string.  */
+  hval = 0;
+  while (*str != '\0')
+    {
+      hval <<= 4;
+      hval += (unsigned long int) *str++;
+      g = hval & ((unsigned long int) 0xf << (HASHWORDBITS - 4));
+      if (g != 0)
+	{
+	  hval ^= g >> (HASHWORDBITS - 8);
+	  hval ^= g;
+	}
+    }
+  return hval;
+}
diff -Nur dillo-0.8.0/intl/intl-compat.c dillo-0.8.0.new/intl/intl-compat.c
--- dillo-0.8.0/intl/intl-compat.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/intl-compat.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,131 @@
+/* intl-compat.c - Stub functions to call gettext functions from GNU gettext
+   Library.
+   Copyright (C) 1995, 2000-2002 Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#define _INTL_REDIRECT_MACROS
+#include "libgnuintl.h"
+#include "gettextP.h"
+
+/* @@ end of prolog @@ */
+
+/* This file redirects the gettext functions (without prefix) to those
+   defined in the included GNU libintl library (with "libintl_" prefix).
+   It is compiled into libintl in order to make the AM_GNU_GETTEXT test
+   of gettext <= 0.11.2 work with the libintl library >= 0.11.3 which
+   has the redirections primarily in the <libintl.h> include file.  */
+
+
+#undef gettext
+#undef dgettext
+#undef dcgettext
+#undef ngettext
+#undef dngettext
+#undef dcngettext
+#undef textdomain
+#undef bindtextdomain
+#undef bind_textdomain_codeset
+
+
+char *
+gettext (msgid)
+     const char *msgid;
+{
+  return libintl_gettext (msgid);
+}
+
+
+char *
+dgettext (domainname, msgid)
+     const char *domainname;
+     const char *msgid;
+{
+  return libintl_dgettext (domainname, msgid);
+}
+
+
+char *
+dcgettext (domainname, msgid, category)
+     const char *domainname;
+     const char *msgid;
+     int category;
+{
+  return libintl_dcgettext (domainname, msgid, category);
+}
+
+
+char *
+ngettext (msgid1, msgid2, n)
+     const char *msgid1;
+     const char *msgid2;
+     unsigned long int n;
+{
+  return libintl_ngettext (msgid1, msgid2, n);
+}
+
+
+char *
+dngettext (domainname, msgid1, msgid2, n)
+     const char *domainname;
+     const char *msgid1;
+     const char *msgid2;
+     unsigned long int n;
+{
+  return libintl_dngettext (domainname, msgid1, msgid2, n);
+}
+
+
+char *
+dcngettext (domainname, msgid1, msgid2, n, category)
+     const char *domainname;
+     const char *msgid1;
+     const char *msgid2;
+     unsigned long int n;
+     int category;
+{
+  return libintl_dcngettext (domainname, msgid1, msgid2, n, category);
+}
+
+
+char *
+textdomain (domainname)
+     const char *domainname;
+{
+  return libintl_textdomain (domainname);
+}
+
+
+char *
+bindtextdomain (domainname, dirname)
+     const char *domainname;
+     const char *dirname;
+{
+  return libintl_bindtextdomain (domainname, dirname);
+}
+
+
+char *
+bind_textdomain_codeset (domainname, codeset)
+     const char *domainname;
+     const char *codeset;
+{
+  return libintl_bind_textdomain_codeset (domainname, codeset);
+}
diff -Nur dillo-0.8.0/intl/l10nflist.c dillo-0.8.0.new/intl/l10nflist.c
--- dillo-0.8.0/intl/l10nflist.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/l10nflist.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,453 @@
+/* Copyright (C) 1995-1999, 2000, 2001, 2002 Free Software Foundation, Inc.
+   Contributed by Ulrich Drepper <drepper@gnu.ai.mit.edu>, 1995.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+/* Tell glibc's <string.h> to provide a prototype for stpcpy().
+   This must come before <config.h> because <config.h> may include
+   <features.h>, and once <features.h> has been included, it's too late.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE	1
+#endif
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <string.h>
+
+#if defined _LIBC || defined HAVE_ARGZ_H
+# include <argz.h>
+#endif
+#include <ctype.h>
+#include <sys/types.h>
+#include <stdlib.h>
+
+#include "loadinfo.h"
+
+/* On some strange systems still no definition of NULL is found.  Sigh!  */
+#ifndef NULL
+# if defined __STDC__ && __STDC__
+#  define NULL ((void *) 0)
+# else
+#  define NULL 0
+# endif
+#endif
+
+/* @@ end of prolog @@ */
+
+#ifdef _LIBC
+/* Rename the non ANSI C functions.  This is required by the standard
+   because some ANSI C functions will require linking with this object
+   file and the name space must not be polluted.  */
+# ifndef stpcpy
+#  define stpcpy(dest, src) __stpcpy(dest, src)
+# endif
+#else
+# ifndef HAVE_STPCPY
+static char *stpcpy PARAMS ((char *dest, const char *src));
+# endif
+#endif
+
+/* Pathname support.
+   ISSLASH(C)           tests whether C is a directory separator character.
+   IS_ABSOLUTE_PATH(P)  tests whether P is an absolute path.  If it is not,
+                        it may be concatenated to a directory pathname.
+ */
+#if defined _WIN32 || defined __WIN32__ || defined __EMX__ || defined __DJGPP__
+  /* Win32, OS/2, DOS */
+# define ISSLASH(C) ((C) == '/' || (C) == '\\')
+# define HAS_DEVICE(P) \
+    ((((P)[0] >= 'A' && (P)[0] <= 'Z') || ((P)[0] >= 'a' && (P)[0] <= 'z')) \
+     && (P)[1] == ':')
+# define IS_ABSOLUTE_PATH(P) (ISSLASH ((P)[0]) || HAS_DEVICE (P))
+#else
+  /* Unix */
+# define ISSLASH(C) ((C) == '/')
+# define IS_ABSOLUTE_PATH(P) ISSLASH ((P)[0])
+#endif
+
+/* Define function which are usually not available.  */
+
+#if !defined _LIBC && !defined HAVE___ARGZ_COUNT
+/* Returns the number of strings in ARGZ.  */
+static size_t argz_count__ PARAMS ((const char *argz, size_t len));
+
+static size_t
+argz_count__ (argz, len)
+     const char *argz;
+     size_t len;
+{
+  size_t count = 0;
+  while (len > 0)
+    {
+      size_t part_len = strlen (argz);
+      argz += part_len + 1;
+      len -= part_len + 1;
+      count++;
+    }
+  return count;
+}
+# undef __argz_count
+# define __argz_count(argz, len) argz_count__ (argz, len)
+#else
+# ifdef _LIBC
+#  define __argz_count(argz, len) INTUSE(__argz_count) (argz, len)
+# endif
+#endif	/* !_LIBC && !HAVE___ARGZ_COUNT */
+
+#if !defined _LIBC && !defined HAVE___ARGZ_STRINGIFY
+/* Make '\0' separated arg vector ARGZ printable by converting all the '\0's
+   except the last into the character SEP.  */
+static void argz_stringify__ PARAMS ((char *argz, size_t len, int sep));
+
+static void
+argz_stringify__ (argz, len, sep)
+     char *argz;
+     size_t len;
+     int sep;
+{
+  while (len > 0)
+    {
+      size_t part_len = strlen (argz);
+      argz += part_len;
+      len -= part_len + 1;
+      if (len > 0)
+	*argz++ = sep;
+    }
+}
+# undef __argz_stringify
+# define __argz_stringify(argz, len, sep) argz_stringify__ (argz, len, sep)
+#else
+# ifdef _LIBC
+#  define __argz_stringify(argz, len, sep) \
+  INTUSE(__argz_stringify) (argz, len, sep)
+# endif
+#endif	/* !_LIBC && !HAVE___ARGZ_STRINGIFY */
+
+#if !defined _LIBC && !defined HAVE___ARGZ_NEXT
+static char *argz_next__ PARAMS ((char *argz, size_t argz_len,
+				  const char *entry));
+
+static char *
+argz_next__ (argz, argz_len, entry)
+     char *argz;
+     size_t argz_len;
+     const char *entry;
+{
+  if (entry)
+    {
+      if (entry < argz + argz_len)
+        entry = strchr (entry, '\0') + 1;
+
+      return entry >= argz + argz_len ? NULL : (char *) entry;
+    }
+  else
+    if (argz_len > 0)
+      return argz;
+    else
+      return 0;
+}
+# undef __argz_next
+# define __argz_next(argz, len, entry) argz_next__ (argz, len, entry)
+#endif	/* !_LIBC && !HAVE___ARGZ_NEXT */
+
+
+/* Return number of bits set in X.  */
+static int pop PARAMS ((int x));
+
+static inline int
+pop (x)
+     int x;
+{
+  /* We assume that no more than 16 bits are used.  */
+  x = ((x & ~0x5555) >> 1) + (x & 0x5555);
+  x = ((x & ~0x3333) >> 2) + (x & 0x3333);
+  x = ((x >> 4) + x) & 0x0f0f;
+  x = ((x >> 8) + x) & 0xff;
+
+  return x;
+}
+
+
+struct loaded_l10nfile *
+_nl_make_l10nflist (l10nfile_list, dirlist, dirlist_len, mask, language,
+		    territory, codeset, normalized_codeset, modifier, special,
+		    sponsor, revision, filename, do_allocate)
+     struct loaded_l10nfile **l10nfile_list;
+     const char *dirlist;
+     size_t dirlist_len;
+     int mask;
+     const char *language;
+     const char *territory;
+     const char *codeset;
+     const char *normalized_codeset;
+     const char *modifier;
+     const char *special;
+     const char *sponsor;
+     const char *revision;
+     const char *filename;
+     int do_allocate;
+{
+  char *abs_filename;
+  struct loaded_l10nfile **lastp;
+  struct loaded_l10nfile *retval;
+  char *cp;
+  size_t dirlist_count;
+  size_t entries;
+  int cnt;
+
+  /* If LANGUAGE contains an absolute directory specification, we ignore
+     DIRLIST.  */
+  if (IS_ABSOLUTE_PATH (language))
+    dirlist_len = 0;
+
+  /* Allocate room for the full file name.  */
+  abs_filename = (char *) malloc (dirlist_len
+				  + strlen (language)
+				  + ((mask & TERRITORY) != 0
+				     ? strlen (territory) + 1 : 0)
+				  + ((mask & XPG_CODESET) != 0
+				     ? strlen (codeset) + 1 : 0)
+				  + ((mask & XPG_NORM_CODESET) != 0
+				     ? strlen (normalized_codeset) + 1 : 0)
+				  + (((mask & XPG_MODIFIER) != 0
+				      || (mask & CEN_AUDIENCE) != 0)
+				     ? strlen (modifier) + 1 : 0)
+				  + ((mask & CEN_SPECIAL) != 0
+				     ? strlen (special) + 1 : 0)
+				  + (((mask & CEN_SPONSOR) != 0
+				      || (mask & CEN_REVISION) != 0)
+				     ? (1 + ((mask & CEN_SPONSOR) != 0
+					     ? strlen (sponsor) : 0)
+					+ ((mask & CEN_REVISION) != 0
+					   ? strlen (revision) + 1 : 0)) : 0)
+				  + 1 + strlen (filename) + 1);
+
+  if (abs_filename == NULL)
+    return NULL;
+
+  /* Construct file name.  */
+  cp = abs_filename;
+  if (dirlist_len > 0)
+    {
+      memcpy (cp, dirlist, dirlist_len);
+      __argz_stringify (cp, dirlist_len, PATH_SEPARATOR);
+      cp += dirlist_len;
+      cp[-1] = '/';
+    }
+
+  cp = stpcpy (cp, language);
+
+  if ((mask & TERRITORY) != 0)
+    {
+      *cp++ = '_';
+      cp = stpcpy (cp, territory);
+    }
+  if ((mask & XPG_CODESET) != 0)
+    {
+      *cp++ = '.';
+      cp = stpcpy (cp, codeset);
+    }
+  if ((mask & XPG_NORM_CODESET) != 0)
+    {
+      *cp++ = '.';
+      cp = stpcpy (cp, normalized_codeset);
+    }
+  if ((mask & (XPG_MODIFIER | CEN_AUDIENCE)) != 0)
+    {
+      /* This component can be part of both syntaces but has different
+	 leading characters.  For CEN we use `+', else `@'.  */
+      *cp++ = (mask & CEN_AUDIENCE) != 0 ? '+' : '@';
+      cp = stpcpy (cp, modifier);
+    }
+  if ((mask & CEN_SPECIAL) != 0)
+    {
+      *cp++ = '+';
+      cp = stpcpy (cp, special);
+    }
+  if ((mask & (CEN_SPONSOR | CEN_REVISION)) != 0)
+    {
+      *cp++ = ',';
+      if ((mask & CEN_SPONSOR) != 0)
+	cp = stpcpy (cp, sponsor);
+      if ((mask & CEN_REVISION) != 0)
+	{
+	  *cp++ = '_';
+	  cp = stpcpy (cp, revision);
+	}
+    }
+
+  *cp++ = '/';
+  stpcpy (cp, filename);
+
+  /* Look in list of already loaded domains whether it is already
+     available.  */
+  lastp = l10nfile_list;
+  for (retval = *l10nfile_list; retval != NULL; retval = retval->next)
+    if (retval->filename != NULL)
+      {
+	int compare = strcmp (retval->filename, abs_filename);
+	if (compare == 0)
+	  /* We found it!  */
+	  break;
+	if (compare < 0)
+	  {
+	    /* It's not in the list.  */
+	    retval = NULL;
+	    break;
+	  }
+
+	lastp = &retval->next;
+      }
+
+  if (retval != NULL || do_allocate == 0)
+    {
+      free (abs_filename);
+      return retval;
+    }
+
+  dirlist_count = (dirlist_len > 0 ? __argz_count (dirlist, dirlist_len) : 1);
+
+  /* Allocate a new loaded_l10nfile.  */
+  retval =
+    (struct loaded_l10nfile *)
+    malloc (sizeof (*retval)
+	    + (((dirlist_count << pop (mask)) + (dirlist_count > 1 ? 1 : 0))
+	       * sizeof (struct loaded_l10nfile *)));
+  if (retval == NULL)
+    return NULL;
+
+  retval->filename = abs_filename;
+
+  /* We set retval->data to NULL here; it is filled in later.
+     Setting retval->decided to 1 here means that retval does not
+     correspond to a real file (dirlist_count > 1) or is not worth
+     looking up (if an unnormalized codeset was specified).  */
+  retval->decided = (dirlist_count > 1
+		     || ((mask & XPG_CODESET) != 0
+			 && (mask & XPG_NORM_CODESET) != 0));
+  retval->data = NULL;
+
+  retval->next = *lastp;
+  *lastp = retval;
+
+  entries = 0;
+  /* Recurse to fill the inheritance list of RETVAL.
+     If the DIRLIST is a real list (i.e. DIRLIST_COUNT > 1), the RETVAL
+     entry does not correspond to a real file; retval->filename contains
+     colons.  In this case we loop across all elements of DIRLIST and
+     across all bit patterns dominated by MASK.
+     If the DIRLIST is a single directory or entirely redundant (i.e.
+     DIRLIST_COUNT == 1), we loop across all bit patterns dominated by
+     MASK, excluding MASK itself.
+     In either case, we loop down from MASK to 0.  This has the effect
+     that the extra bits in the locale name are dropped in this order:
+     first the modifier, then the territory, then the codeset, then the
+     normalized_codeset.  */
+  for (cnt = dirlist_count > 1 ? mask : mask - 1; cnt >= 0; --cnt)
+    if ((cnt & ~mask) == 0
+	&& ((cnt & CEN_SPECIFIC) == 0 || (cnt & XPG_SPECIFIC) == 0)
+	&& ((cnt & XPG_CODESET) == 0 || (cnt & XPG_NORM_CODESET) == 0))
+      {
+	if (dirlist_count > 1)
+	  {
+	    /* Iterate over all elements of the DIRLIST.  */
+	    char *dir = NULL;
+
+	    while ((dir = __argz_next ((char *) dirlist, dirlist_len, dir))
+		   != NULL)
+	      retval->successor[entries++]
+		= _nl_make_l10nflist (l10nfile_list, dir, strlen (dir) + 1,
+				      cnt, language, territory, codeset,
+				      normalized_codeset, modifier, special,
+				      sponsor, revision, filename, 1);
+	  }
+	else
+	  retval->successor[entries++]
+	    = _nl_make_l10nflist (l10nfile_list, dirlist, dirlist_len,
+				  cnt, language, territory, codeset,
+				  normalized_codeset, modifier, special,
+				  sponsor, revision, filename, 1);
+      }
+  retval->successor[entries] = NULL;
+
+  return retval;
+}
+
+/* Normalize codeset name.  There is no standard for the codeset
+   names.  Normalization allows the user to use any of the common
+   names.  The return value is dynamically allocated and has to be
+   freed by the caller.  */
+const char *
+_nl_normalize_codeset (codeset, name_len)
+     const char *codeset;
+     size_t name_len;
+{
+  int len = 0;
+  int only_digit = 1;
+  char *retval;
+  char *wp;
+  size_t cnt;
+
+  for (cnt = 0; cnt < name_len; ++cnt)
+    if (isalnum ((unsigned char) codeset[cnt]))
+      {
+	++len;
+
+	if (isalpha ((unsigned char) codeset[cnt]))
+	  only_digit = 0;
+      }
+
+  retval = (char *) malloc ((only_digit ? 3 : 0) + len + 1);
+
+  if (retval != NULL)
+    {
+      if (only_digit)
+	wp = stpcpy (retval, "iso");
+      else
+	wp = retval;
+
+      for (cnt = 0; cnt < name_len; ++cnt)
+	if (isalpha ((unsigned char) codeset[cnt]))
+	  *wp++ = tolower ((unsigned char) codeset[cnt]);
+	else if (isdigit ((unsigned char) codeset[cnt]))
+	  *wp++ = codeset[cnt];
+
+      *wp = '\0';
+    }
+
+  return (const char *) retval;
+}
+
+
+/* @@ begin of epilog @@ */
+
+/* We don't want libintl.a to depend on any other library.  So we
+   avoid the non-standard function stpcpy.  In GNU C Library this
+   function is available, though.  Also allow the symbol HAVE_STPCPY
+   to be defined.  */
+#if !_LIBC && !HAVE_STPCPY
+static char *
+stpcpy (dest, src)
+     char *dest;
+     const char *src;
+{
+  while ((*dest++ = *src++) != '\0')
+    /* Do nothing. */ ;
+  return dest - 1;
+}
+#endif
diff -Nur dillo-0.8.0/intl/libgnuintl.h dillo-0.8.0.new/intl/libgnuintl.h
--- dillo-0.8.0/intl/libgnuintl.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/libgnuintl.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,296 @@
+/* Message catalogs for internationalization.
+   Copyright (C) 1995-1997, 2000-2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifndef _LIBINTL_H
+#define _LIBINTL_H	1
+
+#include <locale.h>
+
+/* The LC_MESSAGES locale category is the category used by the functions
+   gettext() and dgettext().  It is specified in POSIX, but not in ANSI C.
+   On systems that don't define it, use an arbitrary value instead.
+   On Solaris, <locale.h> defines __LOCALE_H (or _LOCALE_H in Solaris 2.5)
+   then includes <libintl.h> (i.e. this file!) and then only defines
+   LC_MESSAGES.  To avoid a redefinition warning, don't define LC_MESSAGES
+   in this case.  */
+#if !defined LC_MESSAGES && !(defined __LOCALE_H || (defined _LOCALE_H && defined __sun))
+# define LC_MESSAGES 1729
+#endif
+
+/* We define an additional symbol to signal that we use the GNU
+   implementation of gettext.  */
+#define __USE_GNU_GETTEXT 1
+
+/* Provide information about the supported file formats.  Returns the
+   maximum minor revision number supported for a given major revision.  */
+#define __GNU_GETTEXT_SUPPORTED_REVISION(major) \
+  ((major) == 0 ? 1 : -1)
+
+/* Resolve a platform specific conflict on DJGPP.  GNU gettext takes
+   precedence over _conio_gettext.  */
+#ifdef __DJGPP__
+# undef gettext
+#endif
+
+/* Use _INTL_PARAMS, not PARAMS, in order to avoid clashes with identifiers
+   used by programs.  Similarly, test __PROTOTYPES, not PROTOTYPES.  */
+#ifndef _INTL_PARAMS
+# if __STDC__ || defined __GNUC__ || defined __SUNPRO_C || defined __cplusplus || __PROTOTYPES
+#  define _INTL_PARAMS(args) args
+# else
+#  define _INTL_PARAMS(args) ()
+# endif
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* We redirect the functions to those prefixed with "libintl_".  This is
+   necessary, because some systems define gettext/textdomain/... in the C
+   library (namely, Solaris 2.4 and newer, and GNU libc 2.0 and newer).
+   If we used the unprefixed names, there would be cases where the
+   definition in the C library would override the one in the libintl.so
+   shared library.  Recall that on ELF systems, the symbols are looked
+   up in the following order:
+     1. in the executable,
+     2. in the shared libraries specified on the link command line, in order,
+     3. in the dependencies of the shared libraries specified on the link
+        command line,
+     4. in the dlopen()ed shared libraries, in the order in which they were
+        dlopen()ed.
+   The definition in the C library would override the one in libintl.so if
+   either
+     * -lc is given on the link command line and -lintl isn't, or
+     * -lc is given on the link command line before -lintl, or
+     * libintl.so is a dependency of a dlopen()ed shared library but not
+       linked to the executable at link time.
+   Since Solaris gettext() behaves differently than GNU gettext(), this
+   would be unacceptable.
+
+   The redirection happens by default through macros in C, so that &gettext
+   is independent of the compilation unit, but through inline functions in
+   C++, in order not to interfere with the name mangling of class fields or
+   class methods called 'gettext'.  */
+
+/* The user can define _INTL_REDIRECT_INLINE or _INTL_REDIRECT_MACROS.
+   If he doesn't, we choose the method.  A third possible method is
+   _INTL_REDIRECT_ASM, supported only by GCC.  */
+#if !(defined _INTL_REDIRECT_INLINE || defined _INTL_REDIRECT_MACROS)
+# if __GNUC__ >= 2 && (defined __STDC__ || defined __cplusplus)
+#  define _INTL_REDIRECT_ASM
+# else
+#  ifdef __cplusplus
+#   define _INTL_REDIRECT_INLINE
+#  else
+#   define _INTL_REDIRECT_MACROS
+#  endif
+# endif
+#endif
+/* Auxiliary macros.  */
+#ifdef _INTL_REDIRECT_ASM
+# define _INTL_ASM(cname) __asm__ (_INTL_ASMNAME (__USER_LABEL_PREFIX__, #cname))
+# define _INTL_ASMNAME(prefix,cnamestring) _INTL_STRINGIFY (prefix) cnamestring
+# define _INTL_STRINGIFY(prefix) #prefix
+#else
+# define _INTL_ASM(cname)
+#endif
+
+/* Look up MSGID in the current default message catalog for the current
+   LC_MESSAGES locale.  If not found, returns MSGID itself (the default
+   text).  */
+#ifdef _INTL_REDIRECT_INLINE
+extern char *libintl_gettext (const char *__msgid);
+static inline char *gettext (const char *__msgid)
+{
+  return libintl_gettext (__msgid);
+}
+#else
+#ifdef _INTL_REDIRECT_MACROS
+# define gettext libintl_gettext
+#endif
+extern char *gettext _INTL_PARAMS ((const char *__msgid))
+       _INTL_ASM (libintl_gettext);
+#endif
+
+/* Look up MSGID in the DOMAINNAME message catalog for the current
+   LC_MESSAGES locale.  */
+#ifdef _INTL_REDIRECT_INLINE
+extern char *libintl_dgettext (const char *__domainname, const char *__msgid);
+static inline char *dgettext (const char *__domainname, const char *__msgid)
+{
+  return libintl_dgettext (__domainname, __msgid);
+}
+#else
+#ifdef _INTL_REDIRECT_MACROS
+# define dgettext libintl_dgettext
+#endif
+extern char *dgettext _INTL_PARAMS ((const char *__domainname,
+				     const char *__msgid))
+       _INTL_ASM (libintl_dgettext);
+#endif
+
+/* Look up MSGID in the DOMAINNAME message catalog for the current CATEGORY
+   locale.  */
+#ifdef _INTL_REDIRECT_INLINE
+extern char *libintl_dcgettext (const char *__domainname, const char *__msgid,
+				int __category);
+static inline char *dcgettext (const char *__domainname, const char *__msgid,
+			       int __category)
+{
+  return libintl_dcgettext (__domainname, __msgid, __category);
+}
+#else
+#ifdef _INTL_REDIRECT_MACROS
+# define dcgettext libintl_dcgettext
+#endif
+extern char *dcgettext _INTL_PARAMS ((const char *__domainname,
+				      const char *__msgid,
+				      int __category))
+       _INTL_ASM (libintl_dcgettext);
+#endif
+
+
+/* Similar to `gettext' but select the plural form corresponding to the
+   number N.  */
+#ifdef _INTL_REDIRECT_INLINE
+extern char *libintl_ngettext (const char *__msgid1, const char *__msgid2,
+			       unsigned long int __n);
+static inline char *ngettext (const char *__msgid1, const char *__msgid2,
+			      unsigned long int __n)
+{
+  return libintl_ngettext (__msgid1, __msgid2, __n);
+}
+#else
+#ifdef _INTL_REDIRECT_MACROS
+# define ngettext libintl_ngettext
+#endif
+extern char *ngettext _INTL_PARAMS ((const char *__msgid1,
+				     const char *__msgid2,
+				     unsigned long int __n))
+       _INTL_ASM (libintl_ngettext);
+#endif
+
+/* Similar to `dgettext' but select the plural form corresponding to the
+   number N.  */
+#ifdef _INTL_REDIRECT_INLINE
+extern char *libintl_dngettext (const char *__domainname, const char *__msgid1,
+				const char *__msgid2, unsigned long int __n);
+static inline char *dngettext (const char *__domainname, const char *__msgid1,
+			       const char *__msgid2, unsigned long int __n)
+{
+  return libintl_dngettext (__domainname, __msgid1, __msgid2, __n);
+}
+#else
+#ifdef _INTL_REDIRECT_MACROS
+# define dngettext libintl_dngettext
+#endif
+extern char *dngettext _INTL_PARAMS ((const char *__domainname,
+				      const char *__msgid1,
+				      const char *__msgid2,
+				      unsigned long int __n))
+       _INTL_ASM (libintl_dngettext);
+#endif
+
+/* Similar to `dcgettext' but select the plural form corresponding to the
+   number N.  */
+#ifdef _INTL_REDIRECT_INLINE
+extern char *libintl_dcngettext (const char *__domainname,
+				 const char *__msgid1, const char *__msgid2,
+				 unsigned long int __n, int __category);
+static inline char *dcngettext (const char *__domainname,
+				const char *__msgid1, const char *__msgid2,
+				unsigned long int __n, int __category)
+{
+  return libintl_dcngettext (__domainname, __msgid1, __msgid2, __n, __category);
+}
+#else
+#ifdef _INTL_REDIRECT_MACROS
+# define dcngettext libintl_dcngettext
+#endif
+extern char *dcngettext _INTL_PARAMS ((const char *__domainname,
+				       const char *__msgid1,
+				       const char *__msgid2,
+				       unsigned long int __n,
+				       int __category))
+       _INTL_ASM (libintl_dcngettext);
+#endif
+
+
+/* Set the current default message catalog to DOMAINNAME.
+   If DOMAINNAME is null, return the current default.
+   If DOMAINNAME is "", reset to the default of "messages".  */
+#ifdef _INTL_REDIRECT_INLINE
+extern char *libintl_textdomain (const char *__domainname);
+static inline char *textdomain (const char *__domainname)
+{
+  return libintl_textdomain (__domainname);
+}
+#else
+#ifdef _INTL_REDIRECT_MACROS
+# define textdomain libintl_textdomain
+#endif
+extern char *textdomain _INTL_PARAMS ((const char *__domainname))
+       _INTL_ASM (libintl_textdomain);
+#endif
+
+/* Specify that the DOMAINNAME message catalog will be found
+   in DIRNAME rather than in the system locale data base.  */
+#ifdef _INTL_REDIRECT_INLINE
+extern char *libintl_bindtextdomain (const char *__domainname,
+				     const char *__dirname);
+static inline char *bindtextdomain (const char *__domainname,
+				    const char *__dirname)
+{
+  return libintl_bindtextdomain (__domainname, __dirname);
+}
+#else
+#ifdef _INTL_REDIRECT_MACROS
+# define bindtextdomain libintl_bindtextdomain
+#endif
+extern char *bindtextdomain _INTL_PARAMS ((const char *__domainname,
+					   const char *__dirname))
+       _INTL_ASM (libintl_bindtextdomain);
+#endif
+
+/* Specify the character encoding in which the messages from the
+   DOMAINNAME message catalog will be returned.  */
+#ifdef _INTL_REDIRECT_INLINE
+extern char *libintl_bind_textdomain_codeset (const char *__domainname,
+					      const char *__codeset);
+static inline char *bind_textdomain_codeset (const char *__domainname,
+					     const char *__codeset)
+{
+  return libintl_bind_textdomain_codeset (__domainname, __codeset);
+}
+#else
+#ifdef _INTL_REDIRECT_MACROS
+# define bind_textdomain_codeset libintl_bind_textdomain_codeset
+#endif
+extern char *bind_textdomain_codeset _INTL_PARAMS ((const char *__domainname,
+						    const char *__codeset))
+       _INTL_ASM (libintl_bind_textdomain_codeset);
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* libintl.h */
diff -Nur dillo-0.8.0/intl/loadinfo.h dillo-0.8.0.new/intl/loadinfo.h
--- dillo-0.8.0/intl/loadinfo.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/loadinfo.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,156 @@
+/* Copyright (C) 1996-1999, 2000-2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Ulrich Drepper <drepper@cygnus.com>, 1996.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifndef _LOADINFO_H
+#define _LOADINFO_H	1
+
+/* Declarations of locale dependent catalog lookup functions.
+   Implemented in
+
+     localealias.c    Possibly replace a locale name by another.
+     explodename.c    Split a locale name into its various fields.
+     l10nflist.c      Generate a list of filenames of possible message catalogs.
+     finddomain.c     Find and open the relevant message catalogs.
+
+   The main function _nl_find_domain() in finddomain.c is declared
+   in gettextP.h.
+ */
+
+#ifndef PARAMS
+# if __STDC__ || defined __GNUC__ || defined __SUNPRO_C || defined __cplusplus || __PROTOTYPES
+#  define PARAMS(args) args
+# else
+#  define PARAMS(args) ()
+# endif
+#endif
+
+#ifndef internal_function
+# define internal_function
+#endif
+
+/* Tell the compiler when a conditional or integer expression is
+   almost always true or almost always false.  */
+#ifndef HAVE_BUILTIN_EXPECT
+# define __builtin_expect(expr, val) (expr)
+#endif
+
+/* Separator in PATH like lists of pathnames.  */
+#if defined _WIN32 || defined __WIN32__ || defined __EMX__ || defined __DJGPP__
+  /* Win32, OS/2, DOS */
+# define PATH_SEPARATOR ';'
+#else
+  /* Unix */
+# define PATH_SEPARATOR ':'
+#endif
+
+/* Encoding of locale name parts.  */
+#define CEN_REVISION		1
+#define CEN_SPONSOR		2
+#define CEN_SPECIAL		4
+#define XPG_NORM_CODESET	8
+#define XPG_CODESET		16
+#define TERRITORY		32
+#define CEN_AUDIENCE		64
+#define XPG_MODIFIER		128
+
+#define CEN_SPECIFIC	(CEN_REVISION|CEN_SPONSOR|CEN_SPECIAL|CEN_AUDIENCE)
+#define XPG_SPECIFIC	(XPG_CODESET|XPG_NORM_CODESET|XPG_MODIFIER)
+
+
+struct loaded_l10nfile
+{
+  const char *filename;
+  int decided;
+
+  const void *data;
+
+  struct loaded_l10nfile *next;
+  struct loaded_l10nfile *successor[1];
+};
+
+
+/* Normalize codeset name.  There is no standard for the codeset
+   names.  Normalization allows the user to use any of the common
+   names.  The return value is dynamically allocated and has to be
+   freed by the caller.  */
+extern const char *_nl_normalize_codeset PARAMS ((const char *codeset,
+						  size_t name_len));
+
+/* Lookup a locale dependent file.
+   *L10NFILE_LIST denotes a pool of lookup results of locale dependent
+   files of the same kind, sorted in decreasing order of ->filename.
+   DIRLIST and DIRLIST_LEN are an argz list of directories in which to
+   look, containing at least one directory (i.e. DIRLIST_LEN > 0).
+   MASK, LANGUAGE, TERRITORY, CODESET, NORMALIZED_CODESET, MODIFIER,
+   SPECIAL, SPONSOR, REVISION are the pieces of the locale name, as
+   produced by _nl_explode_name().  FILENAME is the filename suffix.
+   The return value is the lookup result, either found in *L10NFILE_LIST,
+   or - if DO_ALLOCATE is nonzero - freshly allocated, or possibly NULL.
+   If the return value is non-NULL, it is added to *L10NFILE_LIST, and
+   its ->next field denotes the chaining inside *L10NFILE_LIST, and
+   furthermore its ->successor[] field contains a list of other lookup
+   results from which this lookup result inherits.  */
+extern struct loaded_l10nfile *
+_nl_make_l10nflist PARAMS ((struct loaded_l10nfile **l10nfile_list,
+			    const char *dirlist, size_t dirlist_len, int mask,
+			    const char *language, const char *territory,
+			    const char *codeset,
+			    const char *normalized_codeset,
+			    const char *modifier, const char *special,
+			    const char *sponsor, const char *revision,
+			    const char *filename, int do_allocate));
+
+/* Lookup the real locale name for a locale alias NAME, or NULL if
+   NAME is not a locale alias (but possibly a real locale name).
+   The return value is statically allocated and must not be freed.  */
+extern const char *_nl_expand_alias PARAMS ((const char *name));
+
+/* Split a locale name NAME into its pieces: language, modifier,
+   territory, codeset, special, sponsor, revision.
+   NAME gets destructively modified: NUL bytes are inserted here and
+   there.  *LANGUAGE gets assigned NAME.  Each of *MODIFIER, *TERRITORY,
+   *CODESET, *SPECIAL, *SPONSOR, *REVISION gets assigned either a
+   pointer into the old NAME string, or NULL.  *NORMALIZED_CODESET
+   gets assigned the expanded *CODESET, if it is different from *CODESET;
+   this one is dynamically allocated and has to be freed by the caller.
+   The return value is a bitmask, where each bit corresponds to one
+   filled-in value:
+     XPG_MODIFIER, CEN_AUDIENCE  for *MODIFIER,
+     TERRITORY                   for *TERRITORY,
+     XPG_CODESET                 for *CODESET,
+     XPG_NORM_CODESET            for *NORMALIZED_CODESET,
+     CEN_SPECIAL                 for *SPECIAL,
+     CEN_SPONSOR                 for *SPONSOR,
+     CEN_REVISION                for *REVISION.
+ */
+extern int _nl_explode_name PARAMS ((char *name, const char **language,
+				     const char **modifier,
+				     const char **territory,
+				     const char **codeset,
+				     const char **normalized_codeset,
+				     const char **special,
+				     const char **sponsor,
+				     const char **revision));
+
+/* Split a locale name NAME into a leading language part and all the
+   rest.  Return a pointer to the first character after the language,
+   i.e. to the first byte of the rest.  */
+extern char *_nl_find_language PARAMS ((const char *name));
+
+#endif	/* loadinfo.h */
diff -Nur dillo-0.8.0/intl/loadmsgcat.c dillo-0.8.0.new/intl/loadmsgcat.c
--- dillo-0.8.0/intl/loadmsgcat.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/loadmsgcat.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,1316 @@
+/* Load needed message catalogs.
+   Copyright (C) 1995-1999, 2000-2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+/* Tell glibc's <string.h> to provide a prototype for mempcpy().
+   This must come before <config.h> because <config.h> may include
+   <features.h>, and once <features.h> has been included, it's too late.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE    1
+#endif
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <ctype.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#ifdef __GNUC__
+# define alloca __builtin_alloca
+# define HAVE_ALLOCA 1
+#else
+# if defined HAVE_ALLOCA_H || defined _LIBC
+#  include <alloca.h>
+# else
+#  ifdef _AIX
+ #pragma alloca
+#  else
+#   ifndef alloca
+char *alloca ();
+#   endif
+#  endif
+# endif
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+
+#if defined HAVE_UNISTD_H || defined _LIBC
+# include <unistd.h>
+#endif
+
+#ifdef _LIBC
+# include <langinfo.h>
+# include <locale.h>
+#endif
+
+#if (defined HAVE_MMAP && defined HAVE_MUNMAP && !defined DISALLOW_MMAP) \
+    || (defined _LIBC && defined _POSIX_MAPPED_FILES)
+# include <sys/mman.h>
+# undef HAVE_MMAP
+# define HAVE_MMAP	1
+#else
+# undef HAVE_MMAP
+#endif
+
+#if defined HAVE_STDINT_H_WITH_UINTMAX || defined _LIBC
+# include <stdint.h>
+#endif
+#if defined HAVE_INTTYPES_H || defined _LIBC
+# include <inttypes.h>
+#endif
+
+#include "gmo.h"
+#include "gettextP.h"
+#include "hash-string.h"
+#include "plural-exp.h"
+
+#ifdef _LIBC
+# include "../locale/localeinfo.h"
+#endif
+
+/* Provide fallback values for macros that ought to be defined in <inttypes.h>.
+   Note that our fallback values need not be literal strings, because we don't
+   use them with preprocessor string concatenation.  */
+#if !defined PRId8 || PRI_MACROS_BROKEN
+# undef PRId8
+# define PRId8 "d"
+#endif
+#if !defined PRIi8 || PRI_MACROS_BROKEN
+# undef PRIi8
+# define PRIi8 "i"
+#endif
+#if !defined PRIo8 || PRI_MACROS_BROKEN
+# undef PRIo8
+# define PRIo8 "o"
+#endif
+#if !defined PRIu8 || PRI_MACROS_BROKEN
+# undef PRIu8
+# define PRIu8 "u"
+#endif
+#if !defined PRIx8 || PRI_MACROS_BROKEN
+# undef PRIx8
+# define PRIx8 "x"
+#endif
+#if !defined PRIX8 || PRI_MACROS_BROKEN
+# undef PRIX8
+# define PRIX8 "X"
+#endif
+#if !defined PRId16 || PRI_MACROS_BROKEN
+# undef PRId16
+# define PRId16 "d"
+#endif
+#if !defined PRIi16 || PRI_MACROS_BROKEN
+# undef PRIi16
+# define PRIi16 "i"
+#endif
+#if !defined PRIo16 || PRI_MACROS_BROKEN
+# undef PRIo16
+# define PRIo16 "o"
+#endif
+#if !defined PRIu16 || PRI_MACROS_BROKEN
+# undef PRIu16
+# define PRIu16 "u"
+#endif
+#if !defined PRIx16 || PRI_MACROS_BROKEN
+# undef PRIx16
+# define PRIx16 "x"
+#endif
+#if !defined PRIX16 || PRI_MACROS_BROKEN
+# undef PRIX16
+# define PRIX16 "X"
+#endif
+#if !defined PRId32 || PRI_MACROS_BROKEN
+# undef PRId32
+# define PRId32 "d"
+#endif
+#if !defined PRIi32 || PRI_MACROS_BROKEN
+# undef PRIi32
+# define PRIi32 "i"
+#endif
+#if !defined PRIo32 || PRI_MACROS_BROKEN
+# undef PRIo32
+# define PRIo32 "o"
+#endif
+#if !defined PRIu32 || PRI_MACROS_BROKEN
+# undef PRIu32
+# define PRIu32 "u"
+#endif
+#if !defined PRIx32 || PRI_MACROS_BROKEN
+# undef PRIx32
+# define PRIx32 "x"
+#endif
+#if !defined PRIX32 || PRI_MACROS_BROKEN
+# undef PRIX32
+# define PRIX32 "X"
+#endif
+#if !defined PRId64 || PRI_MACROS_BROKEN
+# undef PRId64
+# define PRId64 (sizeof (long) == 8 ? "ld" : "lld")
+#endif
+#if !defined PRIi64 || PRI_MACROS_BROKEN
+# undef PRIi64
+# define PRIi64 (sizeof (long) == 8 ? "li" : "lli")
+#endif
+#if !defined PRIo64 || PRI_MACROS_BROKEN
+# undef PRIo64
+# define PRIo64 (sizeof (long) == 8 ? "lo" : "llo")
+#endif
+#if !defined PRIu64 || PRI_MACROS_BROKEN
+# undef PRIu64
+# define PRIu64 (sizeof (long) == 8 ? "lu" : "llu")
+#endif
+#if !defined PRIx64 || PRI_MACROS_BROKEN
+# undef PRIx64
+# define PRIx64 (sizeof (long) == 8 ? "lx" : "llx")
+#endif
+#if !defined PRIX64 || PRI_MACROS_BROKEN
+# undef PRIX64
+# define PRIX64 (sizeof (long) == 8 ? "lX" : "llX")
+#endif
+#if !defined PRIdLEAST8 || PRI_MACROS_BROKEN
+# undef PRIdLEAST8
+# define PRIdLEAST8 "d"
+#endif
+#if !defined PRIiLEAST8 || PRI_MACROS_BROKEN
+# undef PRIiLEAST8
+# define PRIiLEAST8 "i"
+#endif
+#if !defined PRIoLEAST8 || PRI_MACROS_BROKEN
+# undef PRIoLEAST8
+# define PRIoLEAST8 "o"
+#endif
+#if !defined PRIuLEAST8 || PRI_MACROS_BROKEN
+# undef PRIuLEAST8
+# define PRIuLEAST8 "u"
+#endif
+#if !defined PRIxLEAST8 || PRI_MACROS_BROKEN
+# undef PRIxLEAST8
+# define PRIxLEAST8 "x"
+#endif
+#if !defined PRIXLEAST8 || PRI_MACROS_BROKEN
+# undef PRIXLEAST8
+# define PRIXLEAST8 "X"
+#endif
+#if !defined PRIdLEAST16 || PRI_MACROS_BROKEN
+# undef PRIdLEAST16
+# define PRIdLEAST16 "d"
+#endif
+#if !defined PRIiLEAST16 || PRI_MACROS_BROKEN
+# undef PRIiLEAST16
+# define PRIiLEAST16 "i"
+#endif
+#if !defined PRIoLEAST16 || PRI_MACROS_BROKEN
+# undef PRIoLEAST16
+# define PRIoLEAST16 "o"
+#endif
+#if !defined PRIuLEAST16 || PRI_MACROS_BROKEN
+# undef PRIuLEAST16
+# define PRIuLEAST16 "u"
+#endif
+#if !defined PRIxLEAST16 || PRI_MACROS_BROKEN
+# undef PRIxLEAST16
+# define PRIxLEAST16 "x"
+#endif
+#if !defined PRIXLEAST16 || PRI_MACROS_BROKEN
+# undef PRIXLEAST16
+# define PRIXLEAST16 "X"
+#endif
+#if !defined PRIdLEAST32 || PRI_MACROS_BROKEN
+# undef PRIdLEAST32
+# define PRIdLEAST32 "d"
+#endif
+#if !defined PRIiLEAST32 || PRI_MACROS_BROKEN
+# undef PRIiLEAST32
+# define PRIiLEAST32 "i"
+#endif
+#if !defined PRIoLEAST32 || PRI_MACROS_BROKEN
+# undef PRIoLEAST32
+# define PRIoLEAST32 "o"
+#endif
+#if !defined PRIuLEAST32 || PRI_MACROS_BROKEN
+# undef PRIuLEAST32
+# define PRIuLEAST32 "u"
+#endif
+#if !defined PRIxLEAST32 || PRI_MACROS_BROKEN
+# undef PRIxLEAST32
+# define PRIxLEAST32 "x"
+#endif
+#if !defined PRIXLEAST32 || PRI_MACROS_BROKEN
+# undef PRIXLEAST32
+# define PRIXLEAST32 "X"
+#endif
+#if !defined PRIdLEAST64 || PRI_MACROS_BROKEN
+# undef PRIdLEAST64
+# define PRIdLEAST64 PRId64
+#endif
+#if !defined PRIiLEAST64 || PRI_MACROS_BROKEN
+# undef PRIiLEAST64
+# define PRIiLEAST64 PRIi64
+#endif
+#if !defined PRIoLEAST64 || PRI_MACROS_BROKEN
+# undef PRIoLEAST64
+# define PRIoLEAST64 PRIo64
+#endif
+#if !defined PRIuLEAST64 || PRI_MACROS_BROKEN
+# undef PRIuLEAST64
+# define PRIuLEAST64 PRIu64
+#endif
+#if !defined PRIxLEAST64 || PRI_MACROS_BROKEN
+# undef PRIxLEAST64
+# define PRIxLEAST64 PRIx64
+#endif
+#if !defined PRIXLEAST64 || PRI_MACROS_BROKEN
+# undef PRIXLEAST64
+# define PRIXLEAST64 PRIX64
+#endif
+#if !defined PRIdFAST8 || PRI_MACROS_BROKEN
+# undef PRIdFAST8
+# define PRIdFAST8 "d"
+#endif
+#if !defined PRIiFAST8 || PRI_MACROS_BROKEN
+# undef PRIiFAST8
+# define PRIiFAST8 "i"
+#endif
+#if !defined PRIoFAST8 || PRI_MACROS_BROKEN
+# undef PRIoFAST8
+# define PRIoFAST8 "o"
+#endif
+#if !defined PRIuFAST8 || PRI_MACROS_BROKEN
+# undef PRIuFAST8
+# define PRIuFAST8 "u"
+#endif
+#if !defined PRIxFAST8 || PRI_MACROS_BROKEN
+# undef PRIxFAST8
+# define PRIxFAST8 "x"
+#endif
+#if !defined PRIXFAST8 || PRI_MACROS_BROKEN
+# undef PRIXFAST8
+# define PRIXFAST8 "X"
+#endif
+#if !defined PRIdFAST16 || PRI_MACROS_BROKEN
+# undef PRIdFAST16
+# define PRIdFAST16 "d"
+#endif
+#if !defined PRIiFAST16 || PRI_MACROS_BROKEN
+# undef PRIiFAST16
+# define PRIiFAST16 "i"
+#endif
+#if !defined PRIoFAST16 || PRI_MACROS_BROKEN
+# undef PRIoFAST16
+# define PRIoFAST16 "o"
+#endif
+#if !defined PRIuFAST16 || PRI_MACROS_BROKEN
+# undef PRIuFAST16
+# define PRIuFAST16 "u"
+#endif
+#if !defined PRIxFAST16 || PRI_MACROS_BROKEN
+# undef PRIxFAST16
+# define PRIxFAST16 "x"
+#endif
+#if !defined PRIXFAST16 || PRI_MACROS_BROKEN
+# undef PRIXFAST16
+# define PRIXFAST16 "X"
+#endif
+#if !defined PRIdFAST32 || PRI_MACROS_BROKEN
+# undef PRIdFAST32
+# define PRIdFAST32 "d"
+#endif
+#if !defined PRIiFAST32 || PRI_MACROS_BROKEN
+# undef PRIiFAST32
+# define PRIiFAST32 "i"
+#endif
+#if !defined PRIoFAST32 || PRI_MACROS_BROKEN
+# undef PRIoFAST32
+# define PRIoFAST32 "o"
+#endif
+#if !defined PRIuFAST32 || PRI_MACROS_BROKEN
+# undef PRIuFAST32
+# define PRIuFAST32 "u"
+#endif
+#if !defined PRIxFAST32 || PRI_MACROS_BROKEN
+# undef PRIxFAST32
+# define PRIxFAST32 "x"
+#endif
+#if !defined PRIXFAST32 || PRI_MACROS_BROKEN
+# undef PRIXFAST32
+# define PRIXFAST32 "X"
+#endif
+#if !defined PRIdFAST64 || PRI_MACROS_BROKEN
+# undef PRIdFAST64
+# define PRIdFAST64 PRId64
+#endif
+#if !defined PRIiFAST64 || PRI_MACROS_BROKEN
+# undef PRIiFAST64
+# define PRIiFAST64 PRIi64
+#endif
+#if !defined PRIoFAST64 || PRI_MACROS_BROKEN
+# undef PRIoFAST64
+# define PRIoFAST64 PRIo64
+#endif
+#if !defined PRIuFAST64 || PRI_MACROS_BROKEN
+# undef PRIuFAST64
+# define PRIuFAST64 PRIu64
+#endif
+#if !defined PRIxFAST64 || PRI_MACROS_BROKEN
+# undef PRIxFAST64
+# define PRIxFAST64 PRIx64
+#endif
+#if !defined PRIXFAST64 || PRI_MACROS_BROKEN
+# undef PRIXFAST64
+# define PRIXFAST64 PRIX64
+#endif
+#if !defined PRIdMAX || PRI_MACROS_BROKEN
+# undef PRIdMAX
+# define PRIdMAX (sizeof (uintmax_t) == sizeof (long) ? "ld" : "lld")
+#endif
+#if !defined PRIiMAX || PRI_MACROS_BROKEN
+# undef PRIiMAX
+# define PRIiMAX (sizeof (uintmax_t) == sizeof (long) ? "li" : "lli")
+#endif
+#if !defined PRIoMAX || PRI_MACROS_BROKEN
+# undef PRIoMAX
+# define PRIoMAX (sizeof (uintmax_t) == sizeof (long) ? "lo" : "llo")
+#endif
+#if !defined PRIuMAX || PRI_MACROS_BROKEN
+# undef PRIuMAX
+# define PRIuMAX (sizeof (uintmax_t) == sizeof (long) ? "lu" : "llu")
+#endif
+#if !defined PRIxMAX || PRI_MACROS_BROKEN
+# undef PRIxMAX
+# define PRIxMAX (sizeof (uintmax_t) == sizeof (long) ? "lx" : "llx")
+#endif
+#if !defined PRIXMAX || PRI_MACROS_BROKEN
+# undef PRIXMAX
+# define PRIXMAX (sizeof (uintmax_t) == sizeof (long) ? "lX" : "llX")
+#endif
+#if !defined PRIdPTR || PRI_MACROS_BROKEN
+# undef PRIdPTR
+# define PRIdPTR \
+  (sizeof (void *) == sizeof (long) ? "ld" : \
+   sizeof (void *) == sizeof (int) ? "d" : \
+   "lld")
+#endif
+#if !defined PRIiPTR || PRI_MACROS_BROKEN
+# undef PRIiPTR
+# define PRIiPTR \
+  (sizeof (void *) == sizeof (long) ? "li" : \
+   sizeof (void *) == sizeof (int) ? "i" : \
+   "lli")
+#endif
+#if !defined PRIoPTR || PRI_MACROS_BROKEN
+# undef PRIoPTR
+# define PRIoPTR \
+  (sizeof (void *) == sizeof (long) ? "lo" : \
+   sizeof (void *) == sizeof (int) ? "o" : \
+   "llo")
+#endif
+#if !defined PRIuPTR || PRI_MACROS_BROKEN
+# undef PRIuPTR
+# define PRIuPTR \
+  (sizeof (void *) == sizeof (long) ? "lu" : \
+   sizeof (void *) == sizeof (int) ? "u" : \
+   "llu")
+#endif
+#if !defined PRIxPTR || PRI_MACROS_BROKEN
+# undef PRIxPTR
+# define PRIxPTR \
+  (sizeof (void *) == sizeof (long) ? "lx" : \
+   sizeof (void *) == sizeof (int) ? "x" : \
+   "llx")
+#endif
+#if !defined PRIXPTR || PRI_MACROS_BROKEN
+# undef PRIXPTR
+# define PRIXPTR \
+  (sizeof (void *) == sizeof (long) ? "lX" : \
+   sizeof (void *) == sizeof (int) ? "X" : \
+   "llX")
+#endif
+
+/* @@ end of prolog @@ */
+
+#ifdef _LIBC
+/* Rename the non ISO C functions.  This is required by the standard
+   because some ISO C functions will require linking with this object
+   file and the name space must not be polluted.  */
+# define open   __open
+# define close  __close
+# define read   __read
+# define mmap   __mmap
+# define munmap __munmap
+#endif
+
+/* For those losing systems which don't have `alloca' we have to add
+   some additional code emulating it.  */
+#ifdef HAVE_ALLOCA
+# define freea(p) /* nothing */
+#else
+# define alloca(n) malloc (n)
+# define freea(p) free (p)
+#endif
+
+/* For systems that distinguish between text and binary I/O.
+   O_BINARY is usually declared in <fcntl.h>. */
+#if !defined O_BINARY && defined _O_BINARY
+  /* For MSC-compatible compilers.  */
+# define O_BINARY _O_BINARY
+# define O_TEXT _O_TEXT
+#endif
+#ifdef __BEOS__
+  /* BeOS 5 has O_BINARY and O_TEXT, but they have no effect.  */
+# undef O_BINARY
+# undef O_TEXT
+#endif
+/* On reasonable systems, binary I/O is the default.  */
+#ifndef O_BINARY
+# define O_BINARY 0
+#endif
+
+
+/* Prototypes for local functions.  Needed to ensure compiler checking of
+   function argument counts despite of K&R C function definition syntax.  */
+static const char *get_sysdep_segment_value PARAMS ((const char *name));
+
+
+/* We need a sign, whether a new catalog was loaded, which can be associated
+   with all translations.  This is important if the translations are
+   cached by one of GCC's features.  */
+int _nl_msg_cat_cntr;
+
+
+/* Expand a system dependent string segment.  Return NULL if unsupported.  */
+static const char *
+get_sysdep_segment_value (name)
+     const char *name;
+{
+  /* Test for an ISO C 99 section 7.8.1 format string directive.
+     Syntax:
+     P R I { d | i | o | u | x | X }
+     { { | LEAST | FAST } { 8 | 16 | 32 | 64 } | MAX | PTR }  */
+  /* We don't use a table of 14 times 6 'const char *' strings here, because
+     data relocations cost startup time.  */
+  if (name[0] == 'P' && name[1] == 'R' && name[2] == 'I')
+    {
+      if (name[3] == 'd' || name[3] == 'i' || name[3] == 'o' || name[3] == 'u'
+	  || name[3] == 'x' || name[3] == 'X')
+	{
+	  if (name[4] == '8' && name[5] == '\0')
+	    {
+	      if (name[3] == 'd')
+		return PRId8;
+	      if (name[3] == 'i')
+		return PRIi8;
+	      if (name[3] == 'o')
+		return PRIo8;
+	      if (name[3] == 'u')
+		return PRIu8;
+	      if (name[3] == 'x')
+		return PRIx8;
+	      if (name[3] == 'X')
+		return PRIX8;
+	      abort ();
+	    }
+	  if (name[4] == '1' && name[5] == '6' && name[6] == '\0')
+	    {
+	      if (name[3] == 'd')
+		return PRId16;
+	      if (name[3] == 'i')
+		return PRIi16;
+	      if (name[3] == 'o')
+		return PRIo16;
+	      if (name[3] == 'u')
+		return PRIu16;
+	      if (name[3] == 'x')
+		return PRIx16;
+	      if (name[3] == 'X')
+		return PRIX16;
+	      abort ();
+	    }
+	  if (name[4] == '3' && name[5] == '2' && name[6] == '\0')
+	    {
+	      if (name[3] == 'd')
+		return PRId32;
+	      if (name[3] == 'i')
+		return PRIi32;
+	      if (name[3] == 'o')
+		return PRIo32;
+	      if (name[3] == 'u')
+		return PRIu32;
+	      if (name[3] == 'x')
+		return PRIx32;
+	      if (name[3] == 'X')
+		return PRIX32;
+	      abort ();
+	    }
+	  if (name[4] == '6' && name[5] == '4' && name[6] == '\0')
+	    {
+	      if (name[3] == 'd')
+		return PRId64;
+	      if (name[3] == 'i')
+		return PRIi64;
+	      if (name[3] == 'o')
+		return PRIo64;
+	      if (name[3] == 'u')
+		return PRIu64;
+	      if (name[3] == 'x')
+		return PRIx64;
+	      if (name[3] == 'X')
+		return PRIX64;
+	      abort ();
+	    }
+	  if (name[4] == 'L' && name[5] == 'E' && name[6] == 'A'
+	      && name[7] == 'S' && name[8] == 'T')
+	    {
+	      if (name[9] == '8' && name[10] == '\0')
+		{
+		  if (name[3] == 'd')
+		    return PRIdLEAST8;
+		  if (name[3] == 'i')
+		    return PRIiLEAST8;
+		  if (name[3] == 'o')
+		    return PRIoLEAST8;
+		  if (name[3] == 'u')
+		    return PRIuLEAST8;
+		  if (name[3] == 'x')
+		    return PRIxLEAST8;
+		  if (name[3] == 'X')
+		    return PRIXLEAST8;
+		  abort ();
+		}
+	      if (name[9] == '1' && name[10] == '6' && name[11] == '\0')
+		{
+		  if (name[3] == 'd')
+		    return PRIdLEAST16;
+		  if (name[3] == 'i')
+		    return PRIiLEAST16;
+		  if (name[3] == 'o')
+		    return PRIoLEAST16;
+		  if (name[3] == 'u')
+		    return PRIuLEAST16;
+		  if (name[3] == 'x')
+		    return PRIxLEAST16;
+		  if (name[3] == 'X')
+		    return PRIXLEAST16;
+		  abort ();
+		}
+	      if (name[9] == '3' && name[10] == '2' && name[11] == '\0')
+		{
+		  if (name[3] == 'd')
+		    return PRIdLEAST32;
+		  if (name[3] == 'i')
+		    return PRIiLEAST32;
+		  if (name[3] == 'o')
+		    return PRIoLEAST32;
+		  if (name[3] == 'u')
+		    return PRIuLEAST32;
+		  if (name[3] == 'x')
+		    return PRIxLEAST32;
+		  if (name[3] == 'X')
+		    return PRIXLEAST32;
+		  abort ();
+		}
+	      if (name[9] == '6' && name[10] == '4' && name[11] == '\0')
+		{
+		  if (name[3] == 'd')
+		    return PRIdLEAST64;
+		  if (name[3] == 'i')
+		    return PRIiLEAST64;
+		  if (name[3] == 'o')
+		    return PRIoLEAST64;
+		  if (name[3] == 'u')
+		    return PRIuLEAST64;
+		  if (name[3] == 'x')
+		    return PRIxLEAST64;
+		  if (name[3] == 'X')
+		    return PRIXLEAST64;
+		  abort ();
+		}
+	    }
+	  if (name[4] == 'F' && name[5] == 'A' && name[6] == 'S'
+	      && name[7] == 'T')
+	    {
+	      if (name[8] == '8' && name[9] == '\0')
+		{
+		  if (name[3] == 'd')
+		    return PRIdFAST8;
+		  if (name[3] == 'i')
+		    return PRIiFAST8;
+		  if (name[3] == 'o')
+		    return PRIoFAST8;
+		  if (name[3] == 'u')
+		    return PRIuFAST8;
+		  if (name[3] == 'x')
+		    return PRIxFAST8;
+		  if (name[3] == 'X')
+		    return PRIXFAST8;
+		  abort ();
+		}
+	      if (name[8] == '1' && name[9] == '6' && name[10] == '\0')
+		{
+		  if (name[3] == 'd')
+		    return PRIdFAST16;
+		  if (name[3] == 'i')
+		    return PRIiFAST16;
+		  if (name[3] == 'o')
+		    return PRIoFAST16;
+		  if (name[3] == 'u')
+		    return PRIuFAST16;
+		  if (name[3] == 'x')
+		    return PRIxFAST16;
+		  if (name[3] == 'X')
+		    return PRIXFAST16;
+		  abort ();
+		}
+	      if (name[8] == '3' && name[9] == '2' && name[10] == '\0')
+		{
+		  if (name[3] == 'd')
+		    return PRIdFAST32;
+		  if (name[3] == 'i')
+		    return PRIiFAST32;
+		  if (name[3] == 'o')
+		    return PRIoFAST32;
+		  if (name[3] == 'u')
+		    return PRIuFAST32;
+		  if (name[3] == 'x')
+		    return PRIxFAST32;
+		  if (name[3] == 'X')
+		    return PRIXFAST32;
+		  abort ();
+		}
+	      if (name[8] == '6' && name[9] == '4' && name[10] == '\0')
+		{
+		  if (name[3] == 'd')
+		    return PRIdFAST64;
+		  if (name[3] == 'i')
+		    return PRIiFAST64;
+		  if (name[3] == 'o')
+		    return PRIoFAST64;
+		  if (name[3] == 'u')
+		    return PRIuFAST64;
+		  if (name[3] == 'x')
+		    return PRIxFAST64;
+		  if (name[3] == 'X')
+		    return PRIXFAST64;
+		  abort ();
+		}
+	    }
+	  if (name[4] == 'M' && name[5] == 'A' && name[6] == 'X'
+	      && name[7] == '\0')
+	    {
+	      if (name[3] == 'd')
+		return PRIdMAX;
+	      if (name[3] == 'i')
+		return PRIiMAX;
+	      if (name[3] == 'o')
+		return PRIoMAX;
+	      if (name[3] == 'u')
+		return PRIuMAX;
+	      if (name[3] == 'x')
+		return PRIxMAX;
+	      if (name[3] == 'X')
+		return PRIXMAX;
+	      abort ();
+	    }
+	  if (name[4] == 'P' && name[5] == 'T' && name[6] == 'R'
+	      && name[7] == '\0')
+	    {
+	      if (name[3] == 'd')
+		return PRIdPTR;
+	      if (name[3] == 'i')
+		return PRIiPTR;
+	      if (name[3] == 'o')
+		return PRIoPTR;
+	      if (name[3] == 'u')
+		return PRIuPTR;
+	      if (name[3] == 'x')
+		return PRIxPTR;
+	      if (name[3] == 'X')
+		return PRIXPTR;
+	      abort ();
+	    }
+	}
+    }
+  /* Other system dependent strings are not valid.  */
+  return NULL;
+}
+
+/* Initialize the codeset dependent parts of an opened message catalog.
+   Return the header entry.  */
+const char *
+internal_function
+_nl_init_domain_conv (domain_file, domain, domainbinding)
+     struct loaded_l10nfile *domain_file;
+     struct loaded_domain *domain;
+     struct binding *domainbinding;
+{
+  /* Find out about the character set the file is encoded with.
+     This can be found (in textual form) in the entry "".  If this
+     entry does not exist or if this does not contain the `charset='
+     information, we will assume the charset matches the one the
+     current locale and we don't have to perform any conversion.  */
+  char *nullentry;
+  size_t nullentrylen;
+
+  /* Preinitialize fields, to avoid recursion during _nl_find_msg.  */
+  domain->codeset_cntr =
+    (domainbinding != NULL ? domainbinding->codeset_cntr : 0);
+#ifdef _LIBC
+  domain->conv = (__gconv_t) -1;
+#else
+# if HAVE_ICONV
+  domain->conv = (iconv_t) -1;
+# endif
+#endif
+  domain->conv_tab = NULL;
+
+  /* Get the header entry.  */
+  nullentry = _nl_find_msg (domain_file, domainbinding, "", &nullentrylen);
+
+  if (nullentry != NULL)
+    {
+#if defined _LIBC || HAVE_ICONV
+      const char *charsetstr;
+
+      charsetstr = strstr (nullentry, "charset=");
+      if (charsetstr != NULL)
+	{
+	  size_t len;
+	  char *charset;
+	  const char *outcharset;
+
+	  charsetstr += strlen ("charset=");
+	  len = strcspn (charsetstr, " \t\n");
+
+	  charset = (char *) alloca (len + 1);
+# if defined _LIBC || HAVE_MEMPCPY
+	  *((char *) mempcpy (charset, charsetstr, len)) = '\0';
+# else
+	  memcpy (charset, charsetstr, len);
+	  charset[len] = '\0';
+# endif
+
+	  /* The output charset should normally be determined by the
+	     locale.  But sometimes the locale is not used or not correctly
+	     set up, so we provide a possibility for the user to override
+	     this.  Moreover, the value specified through
+	     bind_textdomain_codeset overrides both.  */
+	  if (domainbinding != NULL && domainbinding->codeset != NULL)
+	    outcharset = domainbinding->codeset;
+	  else
+	    {
+	      outcharset = getenv ("OUTPUT_CHARSET");
+	      if (outcharset == NULL || outcharset[0] == '\0')
+		{
+# ifdef _LIBC
+		  outcharset = (*_nl_current[LC_CTYPE])->values[_NL_ITEM_INDEX (CODESET)].string;
+# else
+#  if HAVE_ICONV
+		  extern const char *locale_charset PARAMS ((void));
+		  outcharset = locale_charset ();
+#  endif
+# endif
+		}
+	    }
+
+# ifdef _LIBC
+	  /* We always want to use transliteration.  */
+	  outcharset = norm_add_slashes (outcharset, "TRANSLIT");
+	  charset = norm_add_slashes (charset, NULL);
+	  if (__gconv_open (outcharset, charset, &domain->conv,
+			    GCONV_AVOID_NOCONV)
+	      != __GCONV_OK)
+	    domain->conv = (__gconv_t) -1;
+# else
+#  if HAVE_ICONV
+	  /* When using GNU libc >= 2.2 or GNU libiconv >= 1.5,
+	     we want to use transliteration.  */
+#   if (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 2) || __GLIBC__ > 2 \
+       || _LIBICONV_VERSION >= 0x0105
+	  if (strchr (outcharset, '/') == NULL)
+	    {
+	      char *tmp;
+
+	      len = strlen (outcharset);
+	      tmp = (char *) alloca (len + 10 + 1);
+	      memcpy (tmp, outcharset, len);
+	      memcpy (tmp + len, "//TRANSLIT", 10 + 1);
+	      outcharset = tmp;
+
+	      domain->conv = iconv_open (outcharset, charset);
+
+	      freea (outcharset);
+	    }
+	  else
+#   endif
+	    domain->conv = iconv_open (outcharset, charset);
+#  endif
+# endif
+
+	  freea (charset);
+	}
+#endif /* _LIBC || HAVE_ICONV */
+    }
+
+  return nullentry;
+}
+
+/* Frees the codeset dependent parts of an opened message catalog.  */
+void
+internal_function
+_nl_free_domain_conv (domain)
+     struct loaded_domain *domain;
+{
+  if (domain->conv_tab != NULL && domain->conv_tab != (char **) -1)
+    free (domain->conv_tab);
+
+#ifdef _LIBC
+  if (domain->conv != (__gconv_t) -1)
+    __gconv_close (domain->conv);
+#else
+# if HAVE_ICONV
+  if (domain->conv != (iconv_t) -1)
+    iconv_close (domain->conv);
+# endif
+#endif
+}
+
+/* Load the message catalogs specified by FILENAME.  If it is no valid
+   message catalog do nothing.  */
+void
+internal_function
+_nl_load_domain (domain_file, domainbinding)
+     struct loaded_l10nfile *domain_file;
+     struct binding *domainbinding;
+{
+  int fd;
+  size_t size;
+#ifdef _LIBC
+  struct stat64 st;
+#else
+  struct stat st;
+#endif
+  struct mo_file_header *data = (struct mo_file_header *) -1;
+  int use_mmap = 0;
+  struct loaded_domain *domain;
+  int revision;
+  const char *nullentry;
+
+  domain_file->decided = 1;
+  domain_file->data = NULL;
+
+  /* Note that it would be useless to store domainbinding in domain_file
+     because domainbinding might be == NULL now but != NULL later (after
+     a call to bind_textdomain_codeset).  */
+
+  /* If the record does not represent a valid locale the FILENAME
+     might be NULL.  This can happen when according to the given
+     specification the locale file name is different for XPG and CEN
+     syntax.  */
+  if (domain_file->filename == NULL)
+    return;
+
+  /* Try to open the addressed file.  */
+  fd = open (domain_file->filename, O_RDONLY | O_BINARY);
+  if (fd == -1)
+    return;
+
+  /* We must know about the size of the file.  */
+  if (
+#ifdef _LIBC
+      __builtin_expect (fstat64 (fd, &st) != 0, 0)
+#else
+      __builtin_expect (fstat (fd, &st) != 0, 0)
+#endif
+      || __builtin_expect ((size = (size_t) st.st_size) != st.st_size, 0)
+      || __builtin_expect (size < sizeof (struct mo_file_header), 0))
+    {
+      /* Something went wrong.  */
+      close (fd);
+      return;
+    }
+
+#ifdef HAVE_MMAP
+  /* Now we are ready to load the file.  If mmap() is available we try
+     this first.  If not available or it failed we try to load it.  */
+  data = (struct mo_file_header *) mmap (NULL, size, PROT_READ,
+					 MAP_PRIVATE, fd, 0);
+
+  if (__builtin_expect (data != (struct mo_file_header *) -1, 1))
+    {
+      /* mmap() call was successful.  */
+      close (fd);
+      use_mmap = 1;
+    }
+#endif
+
+  /* If the data is not yet available (i.e. mmap'ed) we try to load
+     it manually.  */
+  if (data == (struct mo_file_header *) -1)
+    {
+      size_t to_read;
+      char *read_ptr;
+
+      data = (struct mo_file_header *) malloc (size);
+      if (data == NULL)
+	return;
+
+      to_read = size;
+      read_ptr = (char *) data;
+      do
+	{
+	  long int nb = (long int) read (fd, read_ptr, to_read);
+	  if (nb <= 0)
+	    {
+#ifdef EINTR
+	      if (nb == -1 && errno == EINTR)
+		continue;
+#endif
+	      close (fd);
+	      return;
+	    }
+	  read_ptr += nb;
+	  to_read -= nb;
+	}
+      while (to_read > 0);
+
+      close (fd);
+    }
+
+  /* Using the magic number we can test whether it really is a message
+     catalog file.  */
+  if (__builtin_expect (data->magic != _MAGIC && data->magic != _MAGIC_SWAPPED,
+			0))
+    {
+      /* The magic number is wrong: not a message catalog file.  */
+#ifdef HAVE_MMAP
+      if (use_mmap)
+	munmap ((caddr_t) data, size);
+      else
+#endif
+	free (data);
+      return;
+    }
+
+  domain = (struct loaded_domain *) malloc (sizeof (struct loaded_domain));
+  if (domain == NULL)
+    return;
+  domain_file->data = domain;
+
+  domain->data = (char *) data;
+  domain->use_mmap = use_mmap;
+  domain->mmap_size = size;
+  domain->must_swap = data->magic != _MAGIC;
+  domain->malloced = NULL;
+
+  /* Fill in the information about the available tables.  */
+  revision = W (domain->must_swap, data->revision);
+  /* We support only the major revision 0.  */
+  switch (revision >> 16)
+    {
+    case 0:
+      domain->nstrings = W (domain->must_swap, data->nstrings);
+      domain->orig_tab = (const struct string_desc *)
+	((char *) data + W (domain->must_swap, data->orig_tab_offset));
+      domain->trans_tab = (const struct string_desc *)
+	((char *) data + W (domain->must_swap, data->trans_tab_offset));
+      domain->hash_size = W (domain->must_swap, data->hash_tab_size);
+      domain->hash_tab =
+	(domain->hash_size > 2
+	 ? (const nls_uint32 *)
+	   ((char *) data + W (domain->must_swap, data->hash_tab_offset))
+	 : NULL);
+      domain->must_swap_hash_tab = domain->must_swap;
+
+      /* Now dispatch on the minor revision.  */
+      switch (revision & 0xffff)
+	{
+	case 0:
+	  domain->n_sysdep_strings = 0;
+	  domain->orig_sysdep_tab = NULL;
+	  domain->trans_sysdep_tab = NULL;
+	  break;
+	case 1:
+	default:
+	  {
+	    nls_uint32 n_sysdep_strings;
+
+	    if (domain->hash_tab == NULL)
+	      /* This is invalid.  These minor revisions need a hash table.  */
+	      goto invalid;
+
+	    n_sysdep_strings =
+	      W (domain->must_swap, data->n_sysdep_strings);
+	    if (n_sysdep_strings > 0)
+	      {
+		nls_uint32 n_sysdep_segments;
+		const struct sysdep_segment *sysdep_segments;
+		const char **sysdep_segment_values;
+		const nls_uint32 *orig_sysdep_tab;
+		const nls_uint32 *trans_sysdep_tab;
+		size_t memneed;
+		char *mem;
+		struct sysdep_string_desc *inmem_orig_sysdep_tab;
+		struct sysdep_string_desc *inmem_trans_sysdep_tab;
+		nls_uint32 *inmem_hash_tab;
+		unsigned int i;
+
+		/* Get the values of the system dependent segments.  */
+		n_sysdep_segments =
+		  W (domain->must_swap, data->n_sysdep_segments);
+		sysdep_segments = (const struct sysdep_segment *)
+		  ((char *) data
+		   + W (domain->must_swap, data->sysdep_segments_offset));
+		sysdep_segment_values =
+		  alloca (n_sysdep_segments * sizeof (const char *));
+		for (i = 0; i < n_sysdep_segments; i++)
+		  {
+		    const char *name =
+		      (char *) data
+		      + W (domain->must_swap, sysdep_segments[i].offset);
+		    nls_uint32 namelen =
+		      W (domain->must_swap, sysdep_segments[i].length);
+
+		    if (!(namelen > 0 && name[namelen - 1] == '\0'))
+		      {
+			freea (sysdep_segment_values);
+			goto invalid;
+		      }
+
+		    sysdep_segment_values[i] = get_sysdep_segment_value (name);
+		  }
+
+		orig_sysdep_tab = (const nls_uint32 *)
+		  ((char *) data
+		   + W (domain->must_swap, data->orig_sysdep_tab_offset));
+		trans_sysdep_tab = (const nls_uint32 *)
+		  ((char *) data
+		   + W (domain->must_swap, data->trans_sysdep_tab_offset));
+
+		/* Compute the amount of additional memory needed for the
+		   system dependent strings and the augmented hash table.  */
+		memneed = 2 * n_sysdep_strings
+			  * sizeof (struct sysdep_string_desc)
+			  + domain->hash_size * sizeof (nls_uint32);
+		for (i = 0; i < 2 * n_sysdep_strings; i++)
+		  {
+		    const struct sysdep_string *sysdep_string =
+		      (const struct sysdep_string *)
+		      ((char *) data
+		       + W (domain->must_swap,
+			    i < n_sysdep_strings
+			    ? orig_sysdep_tab[i]
+			    : trans_sysdep_tab[i - n_sysdep_strings]));
+		    size_t need = 0;
+		    const struct segment_pair *p = sysdep_string->segments;
+
+		    if (W (domain->must_swap, p->sysdepref) != SEGMENTS_END)
+		      for (p = sysdep_string->segments;; p++)
+			{
+			  nls_uint32 sysdepref;
+
+			  need += W (domain->must_swap, p->segsize);
+
+			  sysdepref = W (domain->must_swap, p->sysdepref);
+			  if (sysdepref == SEGMENTS_END)
+			    break;
+
+			  if (sysdepref >= n_sysdep_segments)
+			    {
+			      /* Invalid.  */
+			      freea (sysdep_segment_values);
+			      goto invalid;
+			    }
+
+			  need += strlen (sysdep_segment_values[sysdepref]);
+			}
+
+		    memneed += need;
+		  }
+
+		/* Allocate additional memory.  */
+		mem = (char *) malloc (memneed);
+		if (mem == NULL)
+		  goto invalid;
+
+		domain->malloced = mem;
+		inmem_orig_sysdep_tab = (struct sysdep_string_desc *) mem;
+		mem += n_sysdep_strings * sizeof (struct sysdep_string_desc);
+		inmem_trans_sysdep_tab = (struct sysdep_string_desc *) mem;
+		mem += n_sysdep_strings * sizeof (struct sysdep_string_desc);
+		inmem_hash_tab = (nls_uint32 *) mem;
+		mem += domain->hash_size * sizeof (nls_uint32);
+
+		/* Compute the system dependent strings.  */
+		for (i = 0; i < 2 * n_sysdep_strings; i++)
+		  {
+		    const struct sysdep_string *sysdep_string =
+		      (const struct sysdep_string *)
+		      ((char *) data
+		       + W (domain->must_swap,
+			    i < n_sysdep_strings
+			    ? orig_sysdep_tab[i]
+			    : trans_sysdep_tab[i - n_sysdep_strings]));
+		    const char *static_segments =
+		      (char *) data
+		      + W (domain->must_swap, sysdep_string->offset);
+		    const struct segment_pair *p = sysdep_string->segments;
+
+		    /* Concatenate the segments, and fill
+		       inmem_orig_sysdep_tab[i] (for i < n_sysdep_strings) and
+		       inmem_trans_sysdep_tab[i-n_sysdep_strings] (for
+		       i >= n_sysdep_strings).  */
+
+		    if (W (domain->must_swap, p->sysdepref) == SEGMENTS_END)
+		      {
+			/* Only one static segment.  */
+			inmem_orig_sysdep_tab[i].length =
+			  W (domain->must_swap, p->segsize);
+			inmem_orig_sysdep_tab[i].pointer = static_segments;
+		      }
+		    else
+		      {
+			inmem_orig_sysdep_tab[i].pointer = mem;
+
+			for (p = sysdep_string->segments;; p++)
+			  {
+			    nls_uint32 segsize =
+			      W (domain->must_swap, p->segsize);
+			    nls_uint32 sysdepref =
+			      W (domain->must_swap, p->sysdepref);
+			    size_t n;
+
+			    if (segsize > 0)
+			      {
+				memcpy (mem, static_segments, segsize);
+				mem += segsize;
+				static_segments += segsize;
+			      }
+
+			    if (sysdepref == SEGMENTS_END)
+			      break;
+
+			    n = strlen (sysdep_segment_values[sysdepref]);
+			    memcpy (mem, sysdep_segment_values[sysdepref], n);
+			    mem += n;
+			  }
+
+			inmem_orig_sysdep_tab[i].length =
+			  mem - inmem_orig_sysdep_tab[i].pointer;
+		      }
+		  }
+
+		/* Compute the augmented hash table.  */
+		for (i = 0; i < domain->hash_size; i++)
+		  inmem_hash_tab[i] =
+		    W (domain->must_swap_hash_tab, domain->hash_tab[i]);
+		for (i = 0; i < n_sysdep_strings; i++)
+		  {
+		    const char *msgid = inmem_orig_sysdep_tab[i].pointer;
+		    nls_uint32 hash_val = hash_string (msgid);
+		    nls_uint32 idx = hash_val % domain->hash_size;
+		    nls_uint32 incr = 1 + (hash_val % (domain->hash_size - 2));
+
+		    for (;;)
+		      {
+			if (inmem_hash_tab[idx] == 0)
+			  {
+			    /* Hash table entry is empty.  Use it.  */
+			    inmem_hash_tab[idx] = 1 + domain->nstrings + i;
+			    break;
+			  }
+
+			if (idx >= domain->hash_size - incr)
+			  idx -= domain->hash_size - incr;
+			else
+			  idx += incr;
+		      }
+		  }
+
+		freea (sysdep_segment_values);
+
+		domain->n_sysdep_strings = n_sysdep_strings;
+		domain->orig_sysdep_tab = inmem_orig_sysdep_tab;
+		domain->trans_sysdep_tab = inmem_trans_sysdep_tab;
+
+		domain->hash_tab = inmem_hash_tab;
+		domain->must_swap_hash_tab = 0;
+	      }
+	    else
+	      {
+		domain->n_sysdep_strings = 0;
+		domain->orig_sysdep_tab = NULL;
+		domain->trans_sysdep_tab = NULL;
+	      }
+	  }
+	  break;
+	}
+      break;
+    default:
+      /* This is an invalid revision.  */
+    invalid:
+      /* This is an invalid .mo file.  */
+      if (domain->malloced)
+	free (domain->malloced);
+#ifdef HAVE_MMAP
+      if (use_mmap)
+	munmap ((caddr_t) data, size);
+      else
+#endif
+	free (data);
+      free (domain);
+      domain_file->data = NULL;
+      return;
+    }
+
+  /* Now initialize the character set converter from the character set
+     the file is encoded with (found in the header entry) to the domain's
+     specified character set or the locale's character set.  */
+  nullentry = _nl_init_domain_conv (domain_file, domain, domainbinding);
+
+  /* Also look for a plural specification.  */
+  EXTRACT_PLURAL_EXPRESSION (nullentry, &domain->plural, &domain->nplurals);
+}
+
+
+#ifdef _LIBC
+void
+internal_function
+_nl_unload_domain (domain)
+     struct loaded_domain *domain;
+{
+  if (domain->plural != &__gettext_germanic_plural)
+    __gettext_free_exp (domain->plural);
+
+  _nl_free_domain_conv (domain);
+
+  if (domain->malloced)
+    free (domain->malloced);
+
+# ifdef _POSIX_MAPPED_FILES
+  if (domain->use_mmap)
+    munmap ((caddr_t) domain->data, domain->mmap_size);
+  else
+# endif	/* _POSIX_MAPPED_FILES */
+    free ((void *) domain->data);
+
+  free (domain);
+}
+#endif
diff -Nur dillo-0.8.0/intl/localcharset.c dillo-0.8.0.new/intl/localcharset.c
--- dillo-0.8.0/intl/localcharset.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/localcharset.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,369 @@
+/* Determine a canonical name for the current locale's character encoding.
+
+   Copyright (C) 2000-2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+/* Written by Bruno Haible <bruno@clisp.org>.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#if HAVE_STDDEF_H
+# include <stddef.h>
+#endif
+
+#include <stdio.h>
+#if HAVE_STRING_H
+# include <string.h>
+#else
+# include <strings.h>
+#endif
+#if HAVE_STDLIB_H
+# include <stdlib.h>
+#endif
+
+#if defined _WIN32 || defined __WIN32__
+# undef WIN32   /* avoid warning on mingw32 */
+# define WIN32
+#endif
+
+#if defined __EMX__
+/* Assume EMX program runs on OS/2, even if compiled under DOS.  */
+# define OS2
+#endif
+
+#if !defined WIN32
+# if HAVE_LANGINFO_CODESET
+#  include <langinfo.h>
+# else
+#  if HAVE_SETLOCALE
+#   include <locale.h>
+#  endif
+# endif
+#elif defined WIN32
+# define WIN32_LEAN_AND_MEAN
+# include <windows.h>
+#endif
+#if defined OS2
+# define INCL_DOS
+# include <os2.h>
+#endif
+
+#if defined _WIN32 || defined __WIN32__ || defined __EMX__ || defined __DJGPP__
+  /* Win32, OS/2, DOS */
+# define ISSLASH(C) ((C) == '/' || (C) == '\\')
+#endif
+
+#ifndef DIRECTORY_SEPARATOR
+# define DIRECTORY_SEPARATOR '/'
+#endif
+
+#ifndef ISSLASH
+# define ISSLASH(C) ((C) == DIRECTORY_SEPARATOR)
+#endif
+
+#ifdef HAVE_GETC_UNLOCKED
+# undef getc
+# define getc getc_unlocked
+#endif
+
+#ifdef __cplusplus
+/* When compiling with "gcc -x c++", produce a function with C linkage.  */
+extern "C" const char * locale_charset (void);
+#endif
+
+/* The following static variable is declared 'volatile' to avoid a
+   possible multithread problem in the function get_charset_aliases. If we
+   are running in a threaded environment, and if two threads initialize
+   'charset_aliases' simultaneously, both will produce the same value,
+   and everything will be ok if the two assignments to 'charset_aliases'
+   are atomic. But I don't know what will happen if the two assignments mix.  */
+#if __STDC__ != 1
+# define volatile /* empty */
+#endif
+/* Pointer to the contents of the charset.alias file, if it has already been
+   read, else NULL.  Its format is:
+   ALIAS_1 '\0' CANONICAL_1 '\0' ... ALIAS_n '\0' CANONICAL_n '\0' '\0'  */
+static const char * volatile charset_aliases;
+
+/* Return a pointer to the contents of the charset.alias file.  */
+static const char *
+get_charset_aliases ()
+{
+  const char *cp;
+
+  cp = charset_aliases;
+  if (cp == NULL)
+    {
+#if !defined WIN32
+      FILE *fp;
+      const char *dir = LIBDIR;
+      const char *base = "charset.alias";
+      char *file_name;
+
+      /* Concatenate dir and base into freshly allocated file_name.  */
+      {
+	size_t dir_len = strlen (dir);
+	size_t base_len = strlen (base);
+	int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));
+	file_name = (char *) malloc (dir_len + add_slash + base_len + 1);
+	if (file_name != NULL)
+	  {
+	    memcpy (file_name, dir, dir_len);
+	    if (add_slash)
+	      file_name[dir_len] = DIRECTORY_SEPARATOR;
+	    memcpy (file_name + dir_len + add_slash, base, base_len + 1);
+	  }
+      }
+
+      if (file_name == NULL || (fp = fopen (file_name, "r")) == NULL)
+	/* Out of memory or file not found, treat it as empty.  */
+	cp = "";
+      else
+	{
+	  /* Parse the file's contents.  */
+	  int c;
+	  char buf1[50+1];
+	  char buf2[50+1];
+	  char *res_ptr = NULL;
+	  size_t res_size = 0;
+	  size_t l1, l2;
+
+	  for (;;)
+	    {
+	      c = getc (fp);
+	      if (c == EOF)
+		break;
+	      if (c == '\n' || c == ' ' || c == '\t')
+		continue;
+	      if (c == '#')
+		{
+		  /* Skip comment, to end of line.  */
+		  do
+		    c = getc (fp);
+		  while (!(c == EOF || c == '\n'));
+		  if (c == EOF)
+		    break;
+		  continue;
+		}
+	      ungetc (c, fp);
+	      if (fscanf (fp, "%50s %50s", buf1, buf2) < 2)
+		break;
+	      l1 = strlen (buf1);
+	      l2 = strlen (buf2);
+	      if (res_size == 0)
+		{
+		  res_size = l1 + 1 + l2 + 1;
+		  res_ptr = (char *) malloc (res_size + 1);
+		}
+	      else
+		{
+		  res_size += l1 + 1 + l2 + 1;
+		  res_ptr = (char *) realloc (res_ptr, res_size + 1);
+		}
+	      if (res_ptr == NULL)
+		{
+		  /* Out of memory. */
+		  res_size = 0;
+		  break;
+		}
+	      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
+	      strcpy (res_ptr + res_size - (l2 + 1), buf2);
+	    }
+	  fclose (fp);
+	  if (res_size == 0)
+	    cp = "";
+	  else
+	    {
+	      *(res_ptr + res_size) = '\0';
+	      cp = res_ptr;
+	    }
+	}
+
+      if (file_name != NULL)
+	free (file_name);
+
+#else
+
+      /* To avoid the troubles of installing a separate file in the same
+	 directory as the DLL and of retrieving the DLL's directory at
+	 runtime, simply inline the aliases here.  */
+
+# if defined WIN32
+      cp = "CP936" "\0" "GBK" "\0"
+	   "CP1361" "\0" "JOHAB" "\0"
+	   "CP20127" "\0" "ASCII" "\0"
+	   "CP20866" "\0" "KOI8-R" "\0"
+	   "CP21866" "\0" "KOI8-RU" "\0"
+	   "CP28591" "\0" "ISO-8859-1" "\0"
+	   "CP28592" "\0" "ISO-8859-2" "\0"
+	   "CP28593" "\0" "ISO-8859-3" "\0"
+	   "CP28594" "\0" "ISO-8859-4" "\0"
+	   "CP28595" "\0" "ISO-8859-5" "\0"
+	   "CP28596" "\0" "ISO-8859-6" "\0"
+	   "CP28597" "\0" "ISO-8859-7" "\0"
+	   "CP28598" "\0" "ISO-8859-8" "\0"
+	   "CP28599" "\0" "ISO-8859-9" "\0"
+	   "CP28605" "\0" "ISO-8859-15" "\0";
+# endif
+#endif
+
+      charset_aliases = cp;
+    }
+
+  return cp;
+}
+
+/* Determine the current locale's character encoding, and canonicalize it
+   into one of the canonical names listed in config.charset.
+   The result must not be freed; it is statically allocated.
+   If the canonical name cannot be determined, the result is a non-canonical
+   name.  */
+
+#ifdef STATIC
+STATIC
+#endif
+const char *
+locale_charset ()
+{
+  const char *codeset;
+  const char *aliases;
+
+#if !(defined WIN32 || defined OS2)
+
+# if HAVE_LANGINFO_CODESET
+
+  /* Most systems support nl_langinfo (CODESET) nowadays.  */
+  codeset = nl_langinfo (CODESET);
+
+# else
+
+  /* On old systems which lack it, use setlocale or getenv.  */
+  const char *locale = NULL;
+
+  /* But most old systems don't have a complete set of locales.  Some
+     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't
+     use setlocale here; it would return "C" when it doesn't support the
+     locale name the user has set.  */
+#  if HAVE_SETLOCALE && 0
+  locale = setlocale (LC_CTYPE, NULL);
+#  endif
+  if (locale == NULL || locale[0] == '\0')
+    {
+      locale = getenv ("LC_ALL");
+      if (locale == NULL || locale[0] == '\0')
+	{
+	  locale = getenv ("LC_CTYPE");
+	  if (locale == NULL || locale[0] == '\0')
+	    locale = getenv ("LANG");
+	}
+    }
+
+  /* On some old systems, one used to set locale = "iso8859_1". On others,
+     you set it to "language_COUNTRY.charset". In any case, we resolve it
+     through the charset.alias file.  */
+  codeset = locale;
+
+# endif
+
+#elif defined WIN32
+
+  static char buf[2 + 10 + 1];
+
+  /* Woe32 has a function returning the locale's codepage as a number.  */
+  sprintf (buf, "CP%u", GetACP ());
+  codeset = buf;
+
+#elif defined OS2
+
+  const char *locale;
+  static char buf[2 + 10 + 1];
+  ULONG cp[3];
+  ULONG cplen;
+
+  /* Allow user to override the codeset, as set in the operating system,
+     with standard language environment variables.  */
+  locale = getenv ("LC_ALL");
+  if (locale == NULL || locale[0] == '\0')
+    {
+      locale = getenv ("LC_CTYPE");
+      if (locale == NULL || locale[0] == '\0')
+	locale = getenv ("LANG");
+    }
+  if (locale != NULL && locale[0] != '\0')
+    {
+      /* If the locale name contains an encoding after the dot, return it.  */
+      const char *dot = strchr (locale, '.');
+
+      if (dot != NULL)
+	{
+	  const char *modifier;
+
+	  dot++;
+	  /* Look for the possible @... trailer and remove it, if any.  */
+	  modifier = strchr (dot, '@');
+	  if (modifier == NULL)
+	    return dot;
+	  if (modifier - dot < sizeof (buf))
+	    {
+	      memcpy (buf, dot, modifier - dot);
+	      buf [modifier - dot] = '\0';
+	      return buf;
+	    }
+	}
+
+      /* Resolve through the charset.alias file.  */
+      codeset = locale;
+    }
+  else
+    {
+      /* OS/2 has a function returning the locale's codepage as a number.  */
+      if (DosQueryCp (sizeof (cp), cp, &cplen))
+	codeset = "";
+      else
+	{
+	  sprintf (buf, "CP%u", cp[0]);
+	  codeset = buf;
+	}
+    }
+
+#endif
+
+  if (codeset == NULL)
+    /* The canonical name cannot be determined.  */
+    codeset = "";
+
+  /* Resolve alias. */
+  for (aliases = get_charset_aliases ();
+       *aliases != '\0';
+       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)
+    if (strcmp (codeset, aliases) == 0
+	|| (aliases[0] == '*' && aliases[1] == '\0'))
+      {
+	codeset = aliases + strlen (aliases) + 1;
+	break;
+      }
+
+  /* Don't return an empty string.  GNU libc and GNU libiconv interpret
+     the empty string as denoting "the locale's character encoding",
+     thus GNU libiconv would call this function a second time.  */
+  if (codeset[0] == '\0')
+    codeset = "ASCII";
+
+  return codeset;
+}
diff -Nur dillo-0.8.0/intl/locale.alias dillo-0.8.0.new/intl/locale.alias
--- dillo-0.8.0/intl/locale.alias	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/locale.alias	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,78 @@
+# Locale name alias data base.
+# Copyright (C) 1996,1997,1998,1999,2000,2001 Free Software Foundation, Inc.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU Library General Public License as published
+# by the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Library General Public License for more details.
+#
+# You should have received a copy of the GNU Library General Public
+# License along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+# USA.
+
+# The format of this file is the same as for the corresponding file of
+# the X Window System, which normally can be found in
+#	/usr/lib/X11/locale/locale.alias
+# A single line contains two fields: an alias and a substitution value.
+# All entries are case independent.
+
+# Note: This file is far from being complete.  If you have a value for
+# your own site which you think might be useful for others too, share
+# it with the rest of us.  Send it using the `glibcbug' script to
+# bugs@gnu.org.
+
+# Packages using this file: 
+
+bokmal		no_NO.ISO-8859-1
+bokml		no_NO.ISO-8859-1
+catalan		ca_ES.ISO-8859-1
+croatian	hr_HR.ISO-8859-2
+czech		cs_CZ.ISO-8859-2
+danish          da_DK.ISO-8859-1
+dansk		da_DK.ISO-8859-1
+deutsch		de_DE.ISO-8859-1
+dutch		nl_NL.ISO-8859-1
+eesti		et_EE.ISO-8859-1
+estonian	et_EE.ISO-8859-1
+finnish         fi_FI.ISO-8859-1
+franais	fr_FR.ISO-8859-1
+french		fr_FR.ISO-8859-1
+galego		gl_ES.ISO-8859-1
+galician	gl_ES.ISO-8859-1
+german		de_DE.ISO-8859-1
+greek           el_GR.ISO-8859-7
+hebrew          he_IL.ISO-8859-8
+hrvatski	hr_HR.ISO-8859-2
+hungarian       hu_HU.ISO-8859-2
+icelandic       is_IS.ISO-8859-1
+italian         it_IT.ISO-8859-1
+japanese	ja_JP.eucJP
+japanese.euc	ja_JP.eucJP
+ja_JP		ja_JP.eucJP
+ja_JP.ujis	ja_JP.eucJP
+japanese.sjis	ja_JP.SJIS
+korean		ko_KR.eucKR
+korean.euc 	ko_KR.eucKR
+ko_KR		ko_KR.eucKR
+lithuanian      lt_LT.ISO-8859-13
+nb_NO		no_NO.ISO-8859-1
+nb_NO.ISO-8859-1 no_NO.ISO-8859-1
+norwegian       no_NO.ISO-8859-1
+nynorsk		nn_NO.ISO-8859-1
+polish          pl_PL.ISO-8859-2
+portuguese      pt_PT.ISO-8859-1
+romanian        ro_RO.ISO-8859-2
+russian         ru_RU.ISO-8859-5
+slovak          sk_SK.ISO-8859-2
+slovene         sl_SI.ISO-8859-2
+slovenian       sl_SI.ISO-8859-2
+spanish         es_ES.ISO-8859-1
+swedish         sv_SE.ISO-8859-1
+thai		th_TH.TIS-620
+turkish         tr_TR.ISO-8859-9
diff -Nur dillo-0.8.0/intl/localealias.c dillo-0.8.0.new/intl/localealias.c
--- dillo-0.8.0/intl/localealias.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/localealias.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,419 @@
+/* Handle aliases for locale names.
+   Copyright (C) 1995-1999, 2000, 2001 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+/* Tell glibc's <string.h> to provide a prototype for mempcpy().
+   This must come before <config.h> because <config.h> may include
+   <features.h>, and once <features.h> has been included, it's too late.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE    1
+#endif
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <ctype.h>
+#include <stdio.h>
+#if defined _LIBC || defined HAVE___FSETLOCKING
+# include <stdio_ext.h>
+#endif
+#include <sys/types.h>
+
+#ifdef __GNUC__
+# define alloca __builtin_alloca
+# define HAVE_ALLOCA 1
+#else
+# if defined HAVE_ALLOCA_H || defined _LIBC
+#  include <alloca.h>
+# else
+#  ifdef _AIX
+ #pragma alloca
+#  else
+#   ifndef alloca
+char *alloca ();
+#   endif
+#  endif
+# endif
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "gettextP.h"
+
+/* @@ end of prolog @@ */
+
+#ifdef _LIBC
+/* Rename the non ANSI C functions.  This is required by the standard
+   because some ANSI C functions will require linking with this object
+   file and the name space must not be polluted.  */
+# define strcasecmp __strcasecmp
+
+# ifndef mempcpy
+#  define mempcpy __mempcpy
+# endif
+# define HAVE_MEMPCPY	1
+# define HAVE___FSETLOCKING	1
+
+/* We need locking here since we can be called from different places.  */
+# include <bits/libc-lock.h>
+
+__libc_lock_define_initialized (static, lock);
+#endif
+
+#ifndef internal_function
+# define internal_function
+#endif
+
+/* Some optimizations for glibc.  */
+#ifdef _LIBC
+# define FEOF(fp)		feof_unlocked (fp)
+# define FGETS(buf, n, fp)	fgets_unlocked (buf, n, fp)
+#else
+# define FEOF(fp)		feof (fp)
+# define FGETS(buf, n, fp)	fgets (buf, n, fp)
+#endif
+
+/* For those losing systems which don't have `alloca' we have to add
+   some additional code emulating it.  */
+#ifdef HAVE_ALLOCA
+# define freea(p) /* nothing */
+#else
+# define alloca(n) malloc (n)
+# define freea(p) free (p)
+#endif
+
+#if defined _LIBC_REENTRANT || defined HAVE_FGETS_UNLOCKED
+# undef fgets
+# define fgets(buf, len, s) fgets_unlocked (buf, len, s)
+#endif
+#if defined _LIBC_REENTRANT || defined HAVE_FEOF_UNLOCKED
+# undef feof
+# define feof(s) feof_unlocked (s)
+#endif
+
+
+struct alias_map
+{
+  const char *alias;
+  const char *value;
+};
+
+
+static char *string_space;
+static size_t string_space_act;
+static size_t string_space_max;
+static struct alias_map *map;
+static size_t nmap;
+static size_t maxmap;
+
+
+/* Prototypes for local functions.  */
+static size_t read_alias_file PARAMS ((const char *fname, int fname_len))
+     internal_function;
+static int extend_alias_table PARAMS ((void));
+static int alias_compare PARAMS ((const struct alias_map *map1,
+				  const struct alias_map *map2));
+
+
+const char *
+_nl_expand_alias (name)
+    const char *name;
+{
+  static const char *locale_alias_path;
+  struct alias_map *retval;
+  const char *result = NULL;
+  size_t added;
+
+#ifdef _LIBC
+  __libc_lock_lock (lock);
+#endif
+
+  if (locale_alias_path == NULL)
+    locale_alias_path = LOCALE_ALIAS_PATH;
+
+  do
+    {
+      struct alias_map item;
+
+      item.alias = name;
+
+      if (nmap > 0)
+	retval = (struct alias_map *) bsearch (&item, map, nmap,
+					       sizeof (struct alias_map),
+					       (int (*) PARAMS ((const void *,
+								 const void *))
+						) alias_compare);
+      else
+	retval = NULL;
+
+      /* We really found an alias.  Return the value.  */
+      if (retval != NULL)
+	{
+	  result = retval->value;
+	  break;
+	}
+
+      /* Perhaps we can find another alias file.  */
+      added = 0;
+      while (added == 0 && locale_alias_path[0] != '\0')
+	{
+	  const char *start;
+
+	  while (locale_alias_path[0] == PATH_SEPARATOR)
+	    ++locale_alias_path;
+	  start = locale_alias_path;
+
+	  while (locale_alias_path[0] != '\0'
+		 && locale_alias_path[0] != PATH_SEPARATOR)
+	    ++locale_alias_path;
+
+	  if (start < locale_alias_path)
+	    added = read_alias_file (start, locale_alias_path - start);
+	}
+    }
+  while (added != 0);
+
+#ifdef _LIBC
+  __libc_lock_unlock (lock);
+#endif
+
+  return result;
+}
+
+
+static size_t
+internal_function
+read_alias_file (fname, fname_len)
+     const char *fname;
+     int fname_len;
+{
+  FILE *fp;
+  char *full_fname;
+  size_t added;
+  static const char aliasfile[] = "/locale.alias";
+
+  full_fname = (char *) alloca (fname_len + sizeof aliasfile);
+#ifdef HAVE_MEMPCPY
+  mempcpy (mempcpy (full_fname, fname, fname_len),
+	   aliasfile, sizeof aliasfile);
+#else
+  memcpy (full_fname, fname, fname_len);
+  memcpy (&full_fname[fname_len], aliasfile, sizeof aliasfile);
+#endif
+
+  fp = fopen (full_fname, "r");
+  freea (full_fname);
+  if (fp == NULL)
+    return 0;
+
+#ifdef HAVE___FSETLOCKING
+  /* No threads present.  */
+  __fsetlocking (fp, FSETLOCKING_BYCALLER);
+#endif
+
+  added = 0;
+  while (!FEOF (fp))
+    {
+      /* It is a reasonable approach to use a fix buffer here because
+	 a) we are only interested in the first two fields
+	 b) these fields must be usable as file names and so must not
+	    be that long
+       */
+      char buf[BUFSIZ];
+      char *alias;
+      char *value;
+      char *cp;
+
+      if (FGETS (buf, sizeof buf, fp) == NULL)
+	/* EOF reached.  */
+	break;
+
+      /* Possibly not the whole line fits into the buffer.  Ignore
+	 the rest of the line.  */
+      if (strchr (buf, '\n') == NULL)
+	{
+	  char altbuf[BUFSIZ];
+	  do
+	    if (FGETS (altbuf, sizeof altbuf, fp) == NULL)
+	      /* Make sure the inner loop will be left.  The outer loop
+		 will exit at the `feof' test.  */
+	      break;
+	  while (strchr (altbuf, '\n') == NULL);
+	}
+
+      cp = buf;
+      /* Ignore leading white space.  */
+      while (isspace ((unsigned char) cp[0]))
+	++cp;
+
+      /* A leading '#' signals a comment line.  */
+      if (cp[0] != '\0' && cp[0] != '#')
+	{
+	  alias = cp++;
+	  while (cp[0] != '\0' && !isspace ((unsigned char) cp[0]))
+	    ++cp;
+	  /* Terminate alias name.  */
+	  if (cp[0] != '\0')
+	    *cp++ = '\0';
+
+	  /* Now look for the beginning of the value.  */
+	  while (isspace ((unsigned char) cp[0]))
+	    ++cp;
+
+	  if (cp[0] != '\0')
+	    {
+	      size_t alias_len;
+	      size_t value_len;
+
+	      value = cp++;
+	      while (cp[0] != '\0' && !isspace ((unsigned char) cp[0]))
+		++cp;
+	      /* Terminate value.  */
+	      if (cp[0] == '\n')
+		{
+		  /* This has to be done to make the following test
+		     for the end of line possible.  We are looking for
+		     the terminating '\n' which do not overwrite here.  */
+		  *cp++ = '\0';
+		  *cp = '\n';
+		}
+	      else if (cp[0] != '\0')
+		*cp++ = '\0';
+
+	      if (nmap >= maxmap)
+		if (__builtin_expect (extend_alias_table (), 0))
+		  return added;
+
+	      alias_len = strlen (alias) + 1;
+	      value_len = strlen (value) + 1;
+
+	      if (string_space_act + alias_len + value_len > string_space_max)
+		{
+		  /* Increase size of memory pool.  */
+		  size_t new_size = (string_space_max
+				     + (alias_len + value_len > 1024
+					? alias_len + value_len : 1024));
+		  char *new_pool = (char *) realloc (string_space, new_size);
+		  if (new_pool == NULL)
+		    return added;
+
+		  if (__builtin_expect (string_space != new_pool, 0))
+		    {
+		      size_t i;
+
+		      for (i = 0; i < nmap; i++)
+			{
+			  map[i].alias += new_pool - string_space;
+			  map[i].value += new_pool - string_space;
+			}
+		    }
+
+		  string_space = new_pool;
+		  string_space_max = new_size;
+		}
+
+	      map[nmap].alias = memcpy (&string_space[string_space_act],
+					alias, alias_len);
+	      string_space_act += alias_len;
+
+	      map[nmap].value = memcpy (&string_space[string_space_act],
+					value, value_len);
+	      string_space_act += value_len;
+
+	      ++nmap;
+	      ++added;
+	    }
+	}
+    }
+
+  /* Should we test for ferror()?  I think we have to silently ignore
+     errors.  --drepper  */
+  fclose (fp);
+
+  if (added > 0)
+    qsort (map, nmap, sizeof (struct alias_map),
+	   (int (*) PARAMS ((const void *, const void *))) alias_compare);
+
+  return added;
+}
+
+
+static int
+extend_alias_table ()
+{
+  size_t new_size;
+  struct alias_map *new_map;
+
+  new_size = maxmap == 0 ? 100 : 2 * maxmap;
+  new_map = (struct alias_map *) realloc (map, (new_size
+						* sizeof (struct alias_map)));
+  if (new_map == NULL)
+    /* Simply don't extend: we don't have any more core.  */
+    return -1;
+
+  map = new_map;
+  maxmap = new_size;
+  return 0;
+}
+
+
+#ifdef _LIBC
+static void __attribute__ ((unused))
+free_mem (void)
+{
+  if (string_space != NULL)
+    free (string_space);
+  if (map != NULL)
+    free (map);
+}
+text_set_element (__libc_subfreeres, free_mem);
+#endif
+
+
+static int
+alias_compare (map1, map2)
+     const struct alias_map *map1;
+     const struct alias_map *map2;
+{
+#if defined _LIBC || defined HAVE_STRCASECMP
+  return strcasecmp (map1->alias, map2->alias);
+#else
+  const unsigned char *p1 = (const unsigned char *) map1->alias;
+  const unsigned char *p2 = (const unsigned char *) map2->alias;
+  unsigned char c1, c2;
+
+  if (p1 == p2)
+    return 0;
+
+  do
+    {
+      /* I know this seems to be odd but the tolower() function in
+	 some systems libc cannot handle nonalpha characters.  */
+      c1 = isupper (*p1) ? tolower (*p1) : *p1;
+      c2 = isupper (*p2) ? tolower (*p2) : *p2;
+      if (c1 == '\0')
+	break;
+      ++p1;
+      ++p2;
+    }
+  while (c1 == c2);
+
+  return c1 - c2;
+#endif
+}
diff -Nur dillo-0.8.0/intl/localename.c dillo-0.8.0.new/intl/localename.c
--- dillo-0.8.0/intl/localename.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/localename.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,772 @@
+/* Determine the current selected locale.
+   Copyright (C) 1995-1999, 2000-2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+/* Written by Ulrich Drepper <drepper@gnu.org>, 1995.  */
+/* Win32 code written by Tor Lillqvist <tml@iki.fi>.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <locale.h>
+
+#if defined _WIN32 || defined __WIN32__
+# undef WIN32   /* avoid warning on mingw32 */
+# define WIN32
+#endif
+
+#ifdef WIN32
+# define WIN32_LEAN_AND_MEAN
+# include <windows.h>
+/* Mingw headers don't have latest language and sublanguage codes.  */
+# ifndef LANG_AFRIKAANS
+# define LANG_AFRIKAANS 0x36
+# endif
+# ifndef LANG_ALBANIAN
+# define LANG_ALBANIAN 0x1c
+# endif
+# ifndef LANG_ARABIC
+# define LANG_ARABIC 0x01
+# endif
+# ifndef LANG_ARMENIAN
+# define LANG_ARMENIAN 0x2b
+# endif
+# ifndef LANG_ASSAMESE
+# define LANG_ASSAMESE 0x4d
+# endif
+# ifndef LANG_AZERI
+# define LANG_AZERI 0x2c
+# endif
+# ifndef LANG_BASQUE
+# define LANG_BASQUE 0x2d
+# endif
+# ifndef LANG_BELARUSIAN
+# define LANG_BELARUSIAN 0x23
+# endif
+# ifndef LANG_BENGALI
+# define LANG_BENGALI 0x45
+# endif
+# ifndef LANG_CATALAN
+# define LANG_CATALAN 0x03
+# endif
+# ifndef LANG_DIVEHI
+# define LANG_DIVEHI 0x65
+# endif
+# ifndef LANG_ESTONIAN
+# define LANG_ESTONIAN 0x25
+# endif
+# ifndef LANG_FAEROESE
+# define LANG_FAEROESE 0x38
+# endif
+# ifndef LANG_FARSI
+# define LANG_FARSI 0x29
+# endif
+# ifndef LANG_GALICIAN
+# define LANG_GALICIAN 0x56
+# endif
+# ifndef LANG_GEORGIAN
+# define LANG_GEORGIAN 0x37
+# endif
+# ifndef LANG_GUJARATI
+# define LANG_GUJARATI 0x47
+# endif
+# ifndef LANG_HEBREW
+# define LANG_HEBREW 0x0d
+# endif
+# ifndef LANG_HINDI
+# define LANG_HINDI 0x39
+# endif
+# ifndef LANG_INDONESIAN
+# define LANG_INDONESIAN 0x21
+# endif
+# ifndef LANG_KANNADA
+# define LANG_KANNADA 0x4b
+# endif
+# ifndef LANG_KASHMIRI
+# define LANG_KASHMIRI 0x60
+# endif
+# ifndef LANG_KAZAK
+# define LANG_KAZAK 0x3f
+# endif
+# ifndef LANG_KONKANI
+# define LANG_KONKANI 0x57
+# endif
+# ifndef LANG_KYRGYZ
+# define LANG_KYRGYZ 0x40
+# endif
+# ifndef LANG_LATVIAN
+# define LANG_LATVIAN 0x26
+# endif
+# ifndef LANG_LITHUANIAN
+# define LANG_LITHUANIAN 0x27
+# endif
+# ifndef LANG_MACEDONIAN
+# define LANG_MACEDONIAN 0x2f
+# endif
+# ifndef LANG_MALAY
+# define LANG_MALAY 0x3e
+# endif
+# ifndef LANG_MALAYALAM
+# define LANG_MALAYALAM 0x4c
+# endif
+# ifndef LANG_MANIPURI
+# define LANG_MANIPURI 0x58
+# endif
+# ifndef LANG_MARATHI
+# define LANG_MARATHI 0x4e
+# endif
+# ifndef LANG_MONGOLIAN
+# define LANG_MONGOLIAN 0x50
+# endif
+# ifndef LANG_NEPALI
+# define LANG_NEPALI 0x61
+# endif
+# ifndef LANG_ORIYA
+# define LANG_ORIYA 0x48
+# endif
+# ifndef LANG_PUNJABI
+# define LANG_PUNJABI 0x46
+# endif
+# ifndef LANG_SANSKRIT
+# define LANG_SANSKRIT 0x4f
+# endif
+# ifndef LANG_SERBIAN
+# define LANG_SERBIAN 0x1a
+# endif
+# ifndef LANG_SINDHI
+# define LANG_SINDHI 0x59
+# endif
+# ifndef LANG_SLOVAK
+# define LANG_SLOVAK 0x1b
+# endif
+# ifndef LANG_SORBIAN
+# define LANG_SORBIAN 0x2e
+# endif
+# ifndef LANG_SWAHILI
+# define LANG_SWAHILI 0x41
+# endif
+# ifndef LANG_SYRIAC
+# define LANG_SYRIAC 0x5a
+# endif
+# ifndef LANG_TAMIL
+# define LANG_TAMIL 0x49
+# endif
+# ifndef LANG_TATAR
+# define LANG_TATAR 0x44
+# endif
+# ifndef LANG_TELUGU
+# define LANG_TELUGU 0x4a
+# endif
+# ifndef LANG_THAI
+# define LANG_THAI 0x1e
+# endif
+# ifndef LANG_UKRAINIAN
+# define LANG_UKRAINIAN 0x22
+# endif
+# ifndef LANG_URDU
+# define LANG_URDU 0x20
+# endif
+# ifndef LANG_UZBEK
+# define LANG_UZBEK 0x43
+# endif
+# ifndef LANG_VIETNAMESE
+# define LANG_VIETNAMESE 0x2a
+# endif
+# ifndef SUBLANG_ARABIC_SAUDI_ARABIA
+# define SUBLANG_ARABIC_SAUDI_ARABIA 0x01
+# endif
+# ifndef SUBLANG_ARABIC_IRAQ
+# define SUBLANG_ARABIC_IRAQ 0x02
+# endif
+# ifndef SUBLANG_ARABIC_EGYPT
+# define SUBLANG_ARABIC_EGYPT 0x03
+# endif
+# ifndef SUBLANG_ARABIC_LIBYA
+# define SUBLANG_ARABIC_LIBYA 0x04
+# endif
+# ifndef SUBLANG_ARABIC_ALGERIA
+# define SUBLANG_ARABIC_ALGERIA 0x05
+# endif
+# ifndef SUBLANG_ARABIC_MOROCCO
+# define SUBLANG_ARABIC_MOROCCO 0x06
+# endif
+# ifndef SUBLANG_ARABIC_TUNISIA
+# define SUBLANG_ARABIC_TUNISIA 0x07
+# endif
+# ifndef SUBLANG_ARABIC_OMAN
+# define SUBLANG_ARABIC_OMAN 0x08
+# endif
+# ifndef SUBLANG_ARABIC_YEMEN
+# define SUBLANG_ARABIC_YEMEN 0x09
+# endif
+# ifndef SUBLANG_ARABIC_SYRIA
+# define SUBLANG_ARABIC_SYRIA 0x0a
+# endif
+# ifndef SUBLANG_ARABIC_JORDAN
+# define SUBLANG_ARABIC_JORDAN 0x0b
+# endif
+# ifndef SUBLANG_ARABIC_LEBANON
+# define SUBLANG_ARABIC_LEBANON 0x0c
+# endif
+# ifndef SUBLANG_ARABIC_KUWAIT
+# define SUBLANG_ARABIC_KUWAIT 0x0d
+# endif
+# ifndef SUBLANG_ARABIC_UAE
+# define SUBLANG_ARABIC_UAE 0x0e
+# endif
+# ifndef SUBLANG_ARABIC_BAHRAIN
+# define SUBLANG_ARABIC_BAHRAIN 0x0f
+# endif
+# ifndef SUBLANG_ARABIC_QATAR
+# define SUBLANG_ARABIC_QATAR 0x10
+# endif
+# ifndef SUBLANG_AZERI_LATIN
+# define SUBLANG_AZERI_LATIN 0x01
+# endif
+# ifndef SUBLANG_AZERI_CYRILLIC
+# define SUBLANG_AZERI_CYRILLIC 0x02
+# endif
+# ifndef SUBLANG_CHINESE_MACAU
+# define SUBLANG_CHINESE_MACAU 0x05
+# endif
+# ifndef SUBLANG_ENGLISH_SOUTH_AFRICA
+# define SUBLANG_ENGLISH_SOUTH_AFRICA 0x07
+# endif
+# ifndef SUBLANG_ENGLISH_JAMAICA
+# define SUBLANG_ENGLISH_JAMAICA 0x08
+# endif
+# ifndef SUBLANG_ENGLISH_CARIBBEAN
+# define SUBLANG_ENGLISH_CARIBBEAN 0x09
+# endif
+# ifndef SUBLANG_ENGLISH_BELIZE
+# define SUBLANG_ENGLISH_BELIZE 0x0a
+# endif
+# ifndef SUBLANG_ENGLISH_TRINIDAD
+# define SUBLANG_ENGLISH_TRINIDAD 0x0b
+# endif
+# ifndef SUBLANG_ENGLISH_ZIMBABWE
+# define SUBLANG_ENGLISH_ZIMBABWE 0x0c
+# endif
+# ifndef SUBLANG_ENGLISH_PHILIPPINES
+# define SUBLANG_ENGLISH_PHILIPPINES 0x0d
+# endif
+# ifndef SUBLANG_FRENCH_LUXEMBOURG
+# define SUBLANG_FRENCH_LUXEMBOURG 0x05
+# endif
+# ifndef SUBLANG_FRENCH_MONACO
+# define SUBLANG_FRENCH_MONACO 0x06
+# endif
+# ifndef SUBLANG_GERMAN_LUXEMBOURG
+# define SUBLANG_GERMAN_LUXEMBOURG 0x04
+# endif
+# ifndef SUBLANG_GERMAN_LIECHTENSTEIN
+# define SUBLANG_GERMAN_LIECHTENSTEIN 0x05
+# endif
+# ifndef SUBLANG_KASHMIRI_INDIA
+# define SUBLANG_KASHMIRI_INDIA 0x02
+# endif
+# ifndef SUBLANG_MALAY_MALAYSIA
+# define SUBLANG_MALAY_MALAYSIA 0x01
+# endif
+# ifndef SUBLANG_MALAY_BRUNEI_DARUSSALAM
+# define SUBLANG_MALAY_BRUNEI_DARUSSALAM 0x02
+# endif
+# ifndef SUBLANG_NEPALI_INDIA
+# define SUBLANG_NEPALI_INDIA 0x02
+# endif
+# ifndef SUBLANG_SERBIAN_LATIN
+# define SUBLANG_SERBIAN_LATIN 0x02
+# endif
+# ifndef SUBLANG_SERBIAN_CYRILLIC
+# define SUBLANG_SERBIAN_CYRILLIC 0x03
+# endif
+# ifndef SUBLANG_SPANISH_GUATEMALA
+# define SUBLANG_SPANISH_GUATEMALA 0x04
+# endif
+# ifndef SUBLANG_SPANISH_COSTA_RICA
+# define SUBLANG_SPANISH_COSTA_RICA 0x05
+# endif
+# ifndef SUBLANG_SPANISH_PANAMA
+# define SUBLANG_SPANISH_PANAMA 0x06
+# endif
+# ifndef SUBLANG_SPANISH_DOMINICAN_REPUBLIC
+# define SUBLANG_SPANISH_DOMINICAN_REPUBLIC 0x07
+# endif
+# ifndef SUBLANG_SPANISH_VENEZUELA
+# define SUBLANG_SPANISH_VENEZUELA 0x08
+# endif
+# ifndef SUBLANG_SPANISH_COLOMBIA
+# define SUBLANG_SPANISH_COLOMBIA 0x09
+# endif
+# ifndef SUBLANG_SPANISH_PERU
+# define SUBLANG_SPANISH_PERU 0x0a
+# endif
+# ifndef SUBLANG_SPANISH_ARGENTINA
+# define SUBLANG_SPANISH_ARGENTINA 0x0b
+# endif
+# ifndef SUBLANG_SPANISH_ECUADOR
+# define SUBLANG_SPANISH_ECUADOR 0x0c
+# endif
+# ifndef SUBLANG_SPANISH_CHILE
+# define SUBLANG_SPANISH_CHILE 0x0d
+# endif
+# ifndef SUBLANG_SPANISH_URUGUAY
+# define SUBLANG_SPANISH_URUGUAY 0x0e
+# endif
+# ifndef SUBLANG_SPANISH_PARAGUAY
+# define SUBLANG_SPANISH_PARAGUAY 0x0f
+# endif
+# ifndef SUBLANG_SPANISH_BOLIVIA
+# define SUBLANG_SPANISH_BOLIVIA 0x10
+# endif
+# ifndef SUBLANG_SPANISH_EL_SALVADOR
+# define SUBLANG_SPANISH_EL_SALVADOR 0x11
+# endif
+# ifndef SUBLANG_SPANISH_HONDURAS
+# define SUBLANG_SPANISH_HONDURAS 0x12
+# endif
+# ifndef SUBLANG_SPANISH_NICARAGUA
+# define SUBLANG_SPANISH_NICARAGUA 0x13
+# endif
+# ifndef SUBLANG_SPANISH_PUERTO_RICO
+# define SUBLANG_SPANISH_PUERTO_RICO 0x14
+# endif
+# ifndef SUBLANG_SWEDISH_FINLAND
+# define SUBLANG_SWEDISH_FINLAND 0x02
+# endif
+# ifndef SUBLANG_URDU_PAKISTAN
+# define SUBLANG_URDU_PAKISTAN 0x01
+# endif
+# ifndef SUBLANG_URDU_INDIA
+# define SUBLANG_URDU_INDIA 0x02
+# endif
+# ifndef SUBLANG_UZBEK_LATIN
+# define SUBLANG_UZBEK_LATIN 0x01
+# endif
+# ifndef SUBLANG_UZBEK_CYRILLIC
+# define SUBLANG_UZBEK_CYRILLIC 0x02
+# endif
+#endif
+
+/* XPG3 defines the result of 'setlocale (category, NULL)' as:
+   "Directs 'setlocale()' to query 'category' and return the current
+    setting of 'local'."
+   However it does not specify the exact format.  Neither do SUSV2 and
+   ISO C 99.  So we can use this feature only on selected systems (e.g.
+   those using GNU C Library).  */
+#if defined _LIBC || (defined __GNU_LIBRARY__ && __GNU_LIBRARY__ >= 2)
+# define HAVE_LOCALE_NULL
+#endif
+
+/* Determine the current locale's name, and canonicalize it into XPG syntax
+     language[_territory[.codeset]][@modifier]
+   The codeset part in the result is not reliable; the locale_charset()
+   should be used for codeset information instead.
+   The result must not be freed; it is statically allocated.  */
+
+const char *
+_nl_locale_name (category, categoryname)
+     int category;
+     const char *categoryname;
+{
+  const char *retval;
+
+#ifndef WIN32
+
+  /* Use the POSIX methods of looking to 'LC_ALL', 'LC_xxx', and 'LANG'.
+     On some systems this can be done by the 'setlocale' function itself.  */
+# if defined HAVE_SETLOCALE && defined HAVE_LC_MESSAGES && defined HAVE_LOCALE_NULL
+  retval = setlocale (category, NULL);
+# else
+  /* Setting of LC_ALL overwrites all other.  */
+  retval = getenv ("LC_ALL");
+  if (retval == NULL || retval[0] == '\0')
+    {
+      /* Next comes the name of the desired category.  */
+      retval = getenv (categoryname);
+      if (retval == NULL || retval[0] == '\0')
+	{
+	  /* Last possibility is the LANG environment variable.  */
+	  retval = getenv ("LANG");
+	  if (retval == NULL || retval[0] == '\0')
+	    /* We use C as the default domain.  POSIX says this is
+	       implementation defined.  */
+	    retval = "C";
+	}
+    }
+# endif
+
+  return retval;
+
+#else /* WIN32 */
+
+  /* Return an XPG style locale name language[_territory][@modifier].
+     Don't even bother determining the codeset; it's not useful in this
+     context, because message catalogs are not specific to a single
+     codeset.  */
+
+  LCID lcid;
+  LANGID langid;
+  int primary, sub;
+
+  /* Let the user override the system settings through environment
+     variables, as on POSIX systems.  */
+  retval = getenv ("LC_ALL");
+  if (retval != NULL && retval[0] != '\0')
+    return retval;
+  retval = getenv (categoryname);
+  if (retval != NULL && retval[0] != '\0')
+    return retval;
+  retval = getenv ("LANG");
+  if (retval != NULL && retval[0] != '\0')
+    return retval;
+
+  /* Use native Win32 API locale ID.  */
+  lcid = GetThreadLocale ();
+
+  /* Strip off the sorting rules, keep only the language part.  */
+  langid = LANGIDFROMLCID (lcid);
+
+  /* Split into language and territory part.  */
+  primary = PRIMARYLANGID (langid);
+  sub = SUBLANGID (langid);
+
+  /* Dispatch on language.
+     See also http://www.unicode.org/unicode/onlinedat/languages.html .
+     For details about languages, see http://www.ethnologue.com/ .  */
+  switch (primary)
+    {
+    case LANG_AFRIKAANS: return "af_ZA";
+    case LANG_ALBANIAN: return "sq_AL";
+    case 0x5e: /* AMHARIC */ return "am_ET";
+    case LANG_ARABIC:
+      switch (sub)
+	{
+	case SUBLANG_ARABIC_SAUDI_ARABIA: return "ar_SA";
+	case SUBLANG_ARABIC_IRAQ: return "ar_IQ";
+	case SUBLANG_ARABIC_EGYPT: return "ar_EG";
+	case SUBLANG_ARABIC_LIBYA: return "ar_LY";
+	case SUBLANG_ARABIC_ALGERIA: return "ar_DZ";
+	case SUBLANG_ARABIC_MOROCCO: return "ar_MA";
+	case SUBLANG_ARABIC_TUNISIA: return "ar_TN";
+	case SUBLANG_ARABIC_OMAN: return "ar_OM";
+	case SUBLANG_ARABIC_YEMEN: return "ar_YE";
+	case SUBLANG_ARABIC_SYRIA: return "ar_SY";
+	case SUBLANG_ARABIC_JORDAN: return "ar_JO";
+	case SUBLANG_ARABIC_LEBANON: return "ar_LB";
+	case SUBLANG_ARABIC_KUWAIT: return "ar_KW";
+	case SUBLANG_ARABIC_UAE: return "ar_AE";
+	case SUBLANG_ARABIC_BAHRAIN: return "ar_BH";
+	case SUBLANG_ARABIC_QATAR: return "ar_QA";
+	}
+      return "ar";
+    case LANG_ARMENIAN: return "hy_AM";
+    case LANG_ASSAMESE: return "as_IN";
+    case LANG_AZERI:
+      switch (sub)
+	{
+	/* FIXME: Adjust this when Azerbaijani locales appear on Unix.  */
+	case SUBLANG_AZERI_LATIN: return "az_AZ@latin";
+	case SUBLANG_AZERI_CYRILLIC: return "az_AZ@cyrillic";
+	}
+      return "az";
+    case LANG_BASQUE:
+      return "eu"; /* Ambiguous: could be "eu_ES" or "eu_FR".  */
+    case LANG_BELARUSIAN: return "be_BY";
+    case LANG_BENGALI: return "bn_IN";
+    case LANG_BULGARIAN: return "bg_BG";
+    case 0x55: /* BURMESE */ return "my_MM";
+    case 0x53: /* CAMBODIAN */ return "km_KH";
+    case LANG_CATALAN: return "ca_ES";
+    case 0x5c: /* CHEROKEE */ return "chr_US";
+    case LANG_CHINESE:
+      switch (sub)
+	{
+	case SUBLANG_CHINESE_TRADITIONAL: return "zh_TW";
+	case SUBLANG_CHINESE_SIMPLIFIED: return "zh_CN";
+	case SUBLANG_CHINESE_HONGKONG: return "zh_HK";
+	case SUBLANG_CHINESE_SINGAPORE: return "zh_SG";
+	case SUBLANG_CHINESE_MACAU: return "zh_MO";
+	}
+      return "zh";
+    case LANG_CROATIAN:		/* LANG_CROATIAN == LANG_SERBIAN
+				 * What used to be called Serbo-Croatian
+				 * should really now be two separate
+				 * languages because of political reasons.
+				 * (Says tml, who knows nothing about Serbian
+				 * or Croatian.)
+				 * (I can feel those flames coming already.)
+				 */
+      switch (sub)
+	{
+	case SUBLANG_DEFAULT: return "hr_HR";
+	case SUBLANG_SERBIAN_LATIN: return "sr_YU";
+	case SUBLANG_SERBIAN_CYRILLIC: return "sr_YU@cyrillic";
+	}
+      return "hr";
+    case LANG_CZECH: return "cs_CZ";
+    case LANG_DANISH: return "da_DK";
+    case LANG_DIVEHI: return "div_MV";
+    case LANG_DUTCH:
+      switch (sub)
+	{
+	case SUBLANG_DUTCH: return "nl_NL";
+	case SUBLANG_DUTCH_BELGIAN: /* FLEMISH, VLAAMS */ return "nl_BE";
+	}
+      return "nl";
+    case 0x66: /* EDO */ return "bin_NG";
+    case LANG_ENGLISH:
+      switch (sub)
+	{
+	/* SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. Heh. I thought
+	 * English was the language spoken in England.
+	 * Oh well.
+	 */
+	case SUBLANG_ENGLISH_US: return "en_US";
+	case SUBLANG_ENGLISH_UK: return "en_GB";
+	case SUBLANG_ENGLISH_AUS: return "en_AU";
+	case SUBLANG_ENGLISH_CAN: return "en_CA";
+	case SUBLANG_ENGLISH_NZ: return "en_NZ";
+	case SUBLANG_ENGLISH_EIRE: return "en_IE";
+	case SUBLANG_ENGLISH_SOUTH_AFRICA: return "en_ZA";
+	case SUBLANG_ENGLISH_JAMAICA: return "en_JM";
+	case SUBLANG_ENGLISH_CARIBBEAN: return "en_GD"; /* Grenada? */
+	case SUBLANG_ENGLISH_BELIZE: return "en_BZ";
+	case SUBLANG_ENGLISH_TRINIDAD: return "en_TT";
+	case SUBLANG_ENGLISH_ZIMBABWE: return "en_ZW";
+	case SUBLANG_ENGLISH_PHILIPPINES: return "en_PH";
+	}
+      return "en";
+    case LANG_ESTONIAN: return "et_EE";
+    case LANG_FAEROESE: return "fo_FO";
+    case LANG_FARSI: return "fa_IR";
+    case LANG_FINNISH: return "fi_FI";
+    case LANG_FRENCH:
+      switch (sub)
+	{
+	case SUBLANG_FRENCH: return "fr_FR";
+	case SUBLANG_FRENCH_BELGIAN: /* WALLOON */ return "fr_BE";
+	case SUBLANG_FRENCH_CANADIAN: return "fr_CA";
+	case SUBLANG_FRENCH_SWISS: return "fr_CH";
+	case SUBLANG_FRENCH_LUXEMBOURG: return "fr_LU";
+	case SUBLANG_FRENCH_MONACO: return "fr_MC";
+	}
+      return "fr";
+    case 0x62: /* FRISIAN */ return "fy_NL";
+    case 0x67: /* FULFULDE */ return "ful_NG";
+    case 0x3c: /* GAELIC */
+      switch (sub)
+	{
+	case 0x01: /* SCOTTISH */ return "gd_GB";
+	case 0x02: /* IRISH */ return "ga_IE";
+	}
+      return "C";
+    case LANG_GALICIAN: return "gl_ES";
+    case LANG_GEORGIAN: return "ka_GE";
+    case LANG_GERMAN:
+      switch (sub)
+	{
+	case SUBLANG_GERMAN: return "de_DE";
+	case SUBLANG_GERMAN_SWISS: return "de_CH";
+	case SUBLANG_GERMAN_AUSTRIAN: return "de_AT";
+	case SUBLANG_GERMAN_LUXEMBOURG: return "de_LU";
+	case SUBLANG_GERMAN_LIECHTENSTEIN: return "de_LI";
+	}
+      return "de";
+    case LANG_GREEK: return "el_GR";
+    case 0x74: /* GUARANI */ return "gn_PY";
+    case LANG_GUJARATI: return "gu_IN";
+    case 0x68: /* HAUSA */ return "ha_NG";
+    case 0x75: /* HAWAIIAN */
+      /* FIXME: Do they mean Hawaiian ("haw_US", 1000 speakers)
+	 or Hawaii Creole English ("cpe_US", 600000 speakers)?  */
+      return "cpe_US";
+    case LANG_HEBREW: return "he_IL";
+    case LANG_HINDI: return "hi_IN";
+    case LANG_HUNGARIAN: return "hu_HU";
+    case 0x69: /* IBIBIO */ return "nic_NG";
+    case LANG_ICELANDIC: return "is_IS";
+    case 0x70: /* IGBO */ return "ibo_NG";
+    case LANG_INDONESIAN: return "id_ID";
+    case 0x5d: /* INUKTITUT */ return "iu_CA";
+    case LANG_ITALIAN:
+      switch (sub)
+	{
+	case SUBLANG_ITALIAN: return "it_IT";
+	case SUBLANG_ITALIAN_SWISS: return "it_CH";
+	}
+      return "it";
+    case LANG_JAPANESE: return "ja_JP";
+    case LANG_KANNADA: return "kn_IN";
+    case 0x71: /* KANURI */ return "kau_NG";
+    case LANG_KASHMIRI:
+      switch (sub)
+	{
+	case SUBLANG_DEFAULT: return "ks_PK";
+	case SUBLANG_KASHMIRI_INDIA: return "ks_IN";
+	}
+      return "ks";
+    case LANG_KAZAK: return "kk_KZ";
+    case LANG_KONKANI:
+      /* FIXME: Adjust this when such locales appear on Unix.  */
+      return "kok_IN";
+    case LANG_KOREAN: return "ko_KR";
+    case LANG_KYRGYZ: return "ky_KG";
+    case 0x54: /* LAO */ return "lo_LA";
+    case 0x76: /* LATIN */ return "la_VA";
+    case LANG_LATVIAN: return "lv_LV";
+    case LANG_LITHUANIAN: return "lt_LT";
+    case LANG_MACEDONIAN: return "mk_MK";
+    case LANG_MALAY:
+      switch (sub)
+	{
+	case SUBLANG_MALAY_MALAYSIA: return "ms_MY";
+	case SUBLANG_MALAY_BRUNEI_DARUSSALAM: return "ms_BN";
+	}
+      return "ms";
+    case LANG_MALAYALAM: return "ml_IN";
+    case 0x3a: /* MALTESE */ return "mt_MT";
+    case LANG_MANIPURI:
+      /* FIXME: Adjust this when such locales appear on Unix.  */
+      return "mni_IN";
+    case LANG_MARATHI: return "mr_IN";
+    case LANG_MONGOLIAN:
+      return "mn"; /* Ambiguous: could be "mn_CN" or "mn_MN".  */
+    case LANG_NEPALI:
+      switch (sub)
+	{
+	case SUBLANG_DEFAULT: return "ne_NP";
+	case SUBLANG_NEPALI_INDIA: return "ne_IN";
+	}
+      return "ne";
+    case LANG_NORWEGIAN:
+      switch (sub)
+	{
+	case SUBLANG_NORWEGIAN_BOKMAL: return "no_NO";
+	case SUBLANG_NORWEGIAN_NYNORSK: return "nn_NO";
+	}
+      return "no";
+    case LANG_ORIYA: return "or_IN";
+    case 0x72: /* OROMO */ return "om_ET";
+    case 0x79: /* PAPIAMENTU */ return "pap_AN";
+    case 0x63: /* PASHTO */
+      return "ps"; /* Ambiguous: could be "ps_PK" or "ps_AF".  */
+    case LANG_POLISH: return "pl_PL";
+    case LANG_PORTUGUESE:
+      switch (sub)
+	{
+	case SUBLANG_PORTUGUESE: return "pt_PT";
+	/* Hmm. SUBLANG_PORTUGUESE_BRAZILIAN == SUBLANG_DEFAULT.
+	   Same phenomenon as SUBLANG_ENGLISH_US == SUBLANG_DEFAULT. */
+	case SUBLANG_PORTUGUESE_BRAZILIAN: return "pt_BR";
+	}
+      return "pt";
+    case LANG_PUNJABI: return "pa_IN";
+    case 0x17: /* RHAETO-ROMANCE */ return "rm_CH";
+    case LANG_ROMANIAN: return "ro_RO";
+    case LANG_RUSSIAN:
+      return "ru"; /* Ambiguous: could be "ru_RU" or "ru_UA".  */
+    case 0x3b: /* SAMI */ return "se_NO";
+    case LANG_SANSKRIT: return "sa_IN";
+    case LANG_SINDHI: return "sd";
+    case 0x5b: /* SINHALESE */ return "si_LK";
+    case LANG_SLOVAK: return "sk_SK";
+    case LANG_SLOVENIAN: return "sl_SI";
+    case 0x77: /* SOMALI */ return "so_SO";
+    case LANG_SORBIAN:
+      /* FIXME: Adjust this when such locales appear on Unix.  */
+      return "wen_DE";
+    case LANG_SPANISH:
+      switch (sub)
+	{
+	case SUBLANG_SPANISH: return "es_ES";
+	case SUBLANG_SPANISH_MEXICAN: return "es_MX";
+	case SUBLANG_SPANISH_MODERN:
+	  return "es_ES@modern";	/* not seen on Unix */
+	case SUBLANG_SPANISH_GUATEMALA: return "es_GT";
+	case SUBLANG_SPANISH_COSTA_RICA: return "es_CR";
+	case SUBLANG_SPANISH_PANAMA: return "es_PA";
+	case SUBLANG_SPANISH_DOMINICAN_REPUBLIC: return "es_DO";
+	case SUBLANG_SPANISH_VENEZUELA: return "es_VE";
+	case SUBLANG_SPANISH_COLOMBIA: return "es_CO";
+	case SUBLANG_SPANISH_PERU: return "es_PE";
+	case SUBLANG_SPANISH_ARGENTINA: return "es_AR";
+	case SUBLANG_SPANISH_ECUADOR: return "es_EC";
+	case SUBLANG_SPANISH_CHILE: return "es_CL";
+	case SUBLANG_SPANISH_URUGUAY: return "es_UY";
+	case SUBLANG_SPANISH_PARAGUAY: return "es_PY";
+	case SUBLANG_SPANISH_BOLIVIA: return "es_BO";
+	case SUBLANG_SPANISH_EL_SALVADOR: return "es_SV";
+	case SUBLANG_SPANISH_HONDURAS: return "es_HN";
+	case SUBLANG_SPANISH_NICARAGUA: return "es_NI";
+	case SUBLANG_SPANISH_PUERTO_RICO: return "es_PR";
+	}
+      return "es";
+    case 0x30: /* SUTU */ return "bnt_TZ";
+    case LANG_SWAHILI: return "sw_KE";
+    case LANG_SWEDISH:
+      switch (sub)
+	{
+	case SUBLANG_DEFAULT: return "sv_SE";
+	case SUBLANG_SWEDISH_FINLAND: return "sv_FI";
+	}
+      return "sv";
+    case LANG_SYRIAC: return "syr_TR"; /* An extinct language.  */
+    case 0x64: /* TAGALOG */ return "tl_PH";
+    case 0x28: /* TAJIK */ return "tg_TJ";
+    case 0x5f: /* TAMAZIGHT */ return "ber_MA";
+    case LANG_TAMIL:
+      return "ta"; /* Ambiguous: could be "ta_IN" or "ta_LK" or "ta_SG".  */
+    case LANG_TATAR: return "tt_RU";
+    case LANG_TELUGU: return "te_IN";
+    case LANG_THAI: return "th_TH";
+    case 0x51: /* TIBETAN */ return "bo_CN";
+    case 0x73: /* TIGRINYA */ return "ti_ET";
+    case 0x31: /* TSONGA */ return "ts_ZA";
+    case LANG_TURKISH: return "tr_TR";
+    case 0x42: /* TURKMEN */ return "tk_TM";
+    case LANG_UKRAINIAN: return "uk_UA";
+    case LANG_URDU:
+      switch (sub)
+	{
+	case SUBLANG_URDU_PAKISTAN: return "ur_PK";
+	case SUBLANG_URDU_INDIA: return "ur_IN";
+	}
+      return "ur";
+    case LANG_UZBEK:
+      switch (sub)
+	{
+	/* FIXME: Adjust this when Uzbek locales appear on Unix.  */
+	case SUBLANG_UZBEK_LATIN: return "uz_UZ@latin";
+	case SUBLANG_UZBEK_CYRILLIC: return "uz_UZ@cyrillic";
+	}
+      return "uz";
+    case 0x33: /* VENDA */ return "ven_ZA";
+    case LANG_VIETNAMESE: return "vi_VN";
+    case 0x52: /* WELSH */ return "cy_GB";
+    case 0x34: /* XHOSA */ return "xh_ZA";
+    case 0x78: /* YI */ return "sit_CN";
+    case 0x3d: /* YIDDISH */ return "yi_IL";
+    case 0x6a: /* YORUBA */ return "yo_NG";
+    case 0x35: /* ZULU */ return "zu_ZA";
+    default: return "C";
+    }
+
+#endif
+}
diff -Nur dillo-0.8.0/intl/Makefile.in dillo-0.8.0.new/intl/Makefile.in
--- dillo-0.8.0/intl/Makefile.in	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/Makefile.in	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,337 @@
+# Makefile for directory with message catalog handling in GNU NLS Utilities.
+# Copyright (C) 1995-1998, 2000-2002 Free Software Foundation, Inc.
+#
+# This program is free software; you can redistribute it and/or modify it
+# under the terms of the GNU Library General Public License as published
+# by the Free Software Foundation; either version 2, or (at your option)
+# any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Library General Public License for more details.
+#
+# You should have received a copy of the GNU Library General Public
+# License along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+# USA.
+
+PACKAGE = @PACKAGE@
+VERSION = @VERSION@
+
+SHELL = /bin/sh
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+top_builddir = ..
+VPATH = @srcdir@
+
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+transform = @program_transform_name@
+libdir = @libdir@
+includedir = @includedir@
+datadir = @datadir@
+localedir = $(datadir)/locale
+gettextsrcdir = $(datadir)/gettext/intl
+aliaspath = $(localedir)
+subdir = intl
+
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+MKINSTALLDIRS = @MKINSTALLDIRS@
+mkinstalldirs = $(SHELL) `case "$(MKINSTALLDIRS)" in /*) echo "$(MKINSTALLDIRS)" ;; *) echo "$(top_builddir)/$(MKINSTALLDIRS)" ;; esac`
+
+l = @INTL_LIBTOOL_SUFFIX_PREFIX@
+
+AR = ar
+CC = @CC@
+LIBTOOL = @LIBTOOL@
+RANLIB = @RANLIB@
+YACC = @INTLBISON@ -y -d
+YFLAGS = --name-prefix=__gettext
+
+DEFS = -DLOCALEDIR=\"$(localedir)\" -DLOCALE_ALIAS_PATH=\"$(aliaspath)\" \
+-DLIBDIR=\"$(libdir)\" -DIN_LIBINTL @DEFS@
+CPPFLAGS = @CPPFLAGS@
+CFLAGS = @CFLAGS@
+LDFLAGS = @LDFLAGS@
+
+COMPILE = $(CC) -c $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS) $(XCFLAGS)
+
+HEADERS = $(COMHDRS) libgnuintl.h loadinfo.h
+COMHDRS = gmo.h gettextP.h hash-string.h plural-exp.h eval-plural.h os2compat.h
+SOURCES = $(COMSRCS) intl-compat.c
+COMSRCS = bindtextdom.c dcgettext.c dgettext.c gettext.c \
+finddomain.c loadmsgcat.c localealias.c textdomain.c l10nflist.c \
+explodename.c dcigettext.c dcngettext.c dngettext.c ngettext.c plural.y \
+plural-exp.c localcharset.c localename.c osdep.c os2compat.c
+OBJECTS = @INTLOBJS@ bindtextdom.$lo dcgettext.$lo dgettext.$lo gettext.$lo \
+finddomain.$lo loadmsgcat.$lo localealias.$lo textdomain.$lo l10nflist.$lo \
+explodename.$lo dcigettext.$lo dcngettext.$lo dngettext.$lo ngettext.$lo \
+plural.$lo plural-exp.$lo localcharset.$lo localename.$lo osdep.$lo
+GETTOBJS = intl-compat.$lo
+DISTFILES.common = Makefile.in \
+config.charset locale.alias ref-add.sin ref-del.sin $(HEADERS) $(SOURCES)
+DISTFILES.generated = plural.c
+DISTFILES.normal = VERSION
+DISTFILES.gettext = COPYING.LIB-2.0 COPYING.LIB-2.1 libintl.glibc
+DISTFILES.obsolete = xopen-msg.sed linux-msg.sed po2tbl.sed.in cat-compat.c \
+COPYING.LIB-2 gettext.h libgettext.h plural-eval.c
+
+# Libtool's library version information for libintl.
+# Before making a gettext release, the gettext maintainer must change this
+# according to the libtool documentation, section "Library interface versions".
+# Maintainers of other packages that include the intl directory must *not*
+# change these values.
+LTV_CURRENT=4
+LTV_REVISION=0
+LTV_AGE=2
+
+.SUFFIXES:
+.SUFFIXES: .c .y .o .lo .sin .sed
+.c.o:
+	$(COMPILE) $<
+.c.lo:
+	$(LIBTOOL) --mode=compile $(COMPILE) $<
+
+.y.c:
+	$(YACC) $(YFLAGS) --output $@ $<
+	rm -f $*.h
+
+.sin.sed:
+	sed -e '/^#/d' -e 's/@''PACKAGE''@/@PACKAGE@/g' $< > t-$@
+	mv t-$@ $@
+
+INCLUDES = -I.. -I. -I$(top_srcdir)/intl
+
+all: all-@USE_INCLUDED_LIBINTL@
+all-yes: libintl.$la libintl.h charset.alias ref-add.sed ref-del.sed
+all-no: all-no-@BUILD_INCLUDED_LIBINTL@
+all-no-yes: libgnuintl.$la
+all-no-no:
+
+libintl.a libgnuintl.a: $(OBJECTS)
+	rm -f $@
+	$(AR) cru $@ $(OBJECTS)
+	$(RANLIB) $@
+
+libintl.la libgnuintl.la: $(OBJECTS)
+	$(LIBTOOL) --mode=link \
+	  $(CC) $(CPPFLAGS) $(CFLAGS) $(XCFLAGS) $(LDFLAGS) -o $@ \
+	  $(OBJECTS) @LTLIBICONV@ -lc \
+	  -version-info $(LTV_CURRENT):$(LTV_REVISION):$(LTV_AGE) \
+	  -rpath $(libdir) \
+	  -no-undefined
+
+libintl.h: libgnuintl.h
+	cp $(srcdir)/libgnuintl.h libintl.h
+
+charset.alias: config.charset
+	$(SHELL) $(srcdir)/config.charset '@host@' > t-$@
+	mv t-$@ $@
+
+check: all
+
+# This installation goal is only used in GNU gettext.  Packages which
+# only use the library should use install instead.
+
+# We must not install the libintl.h/libintl.a files if we are on a
+# system which has the GNU gettext() function in its C library or in a
+# separate library.
+# If you want to use the one which comes with this version of the
+# package, you have to use `configure --with-included-gettext'.
+install: install-exec install-data
+install-exec: all
+	if test "$(PACKAGE)" = "gettext" \
+	   && test '@INTLOBJS@' = '$(GETTOBJS)'; then \
+	  $(mkinstalldirs) $(DESTDIR)$(libdir) $(DESTDIR)$(includedir); \
+	  $(INSTALL_DATA) libintl.h $(DESTDIR)$(includedir)/libintl.h; \
+	  $(LIBTOOL) --mode=install \
+	    $(INSTALL_DATA) libintl.$la $(DESTDIR)$(libdir)/libintl.$la; \
+	else \
+	  : ; \
+	fi
+	if test '@USE_INCLUDED_LIBINTL@' = yes; then \
+	  test @GLIBC21@ != no || $(mkinstalldirs) $(DESTDIR)$(libdir); \
+	  temp=$(DESTDIR)$(libdir)/t-charset.alias; \
+	  dest=$(DESTDIR)$(libdir)/charset.alias; \
+	  if test -f $(DESTDIR)$(libdir)/charset.alias; then \
+	    orig=$(DESTDIR)$(libdir)/charset.alias; \
+	    sed -f ref-add.sed $$orig > $$temp; \
+	    $(INSTALL_DATA) $$temp $$dest; \
+	    rm -f $$temp; \
+	  else \
+	    if test @GLIBC21@ = no; then \
+	      orig=charset.alias; \
+	      sed -f ref-add.sed $$orig > $$temp; \
+	      $(INSTALL_DATA) $$temp $$dest; \
+	      rm -f $$temp; \
+	    fi; \
+	  fi; \
+	  $(mkinstalldirs) $(DESTDIR)$(localedir); \
+	  test -f $(DESTDIR)$(localedir)/locale.alias \
+	    && orig=$(DESTDIR)$(localedir)/locale.alias \
+	    || orig=$(srcdir)/locale.alias; \
+	  temp=$(DESTDIR)$(localedir)/t-locale.alias; \
+	  dest=$(DESTDIR)$(localedir)/locale.alias; \
+	  sed -f ref-add.sed $$orig > $$temp; \
+	  $(INSTALL_DATA) $$temp $$dest; \
+	  rm -f $$temp; \
+	else \
+	  : ; \
+	fi
+install-data: all
+	if test "$(PACKAGE)" = "gettext"; then \
+	  $(mkinstalldirs) $(DESTDIR)$(gettextsrcdir); \
+	  $(INSTALL_DATA) VERSION $(DESTDIR)$(gettextsrcdir)/VERSION; \
+	  $(INSTALL_DATA) ChangeLog.inst $(DESTDIR)$(gettextsrcdir)/ChangeLog; \
+	  dists="COPYING.LIB-2.0 COPYING.LIB-2.1 $(DISTFILES.common)"; \
+	  for file in $$dists; do \
+	    $(INSTALL_DATA) $(srcdir)/$$file \
+			    $(DESTDIR)$(gettextsrcdir)/$$file; \
+	  done; \
+	  chmod a+x $(DESTDIR)$(gettextsrcdir)/config.charset; \
+	  dists="$(DISTFILES.generated)"; \
+	  for file in $$dists; do \
+	    if test -f $$file; then dir=.; else dir=$(srcdir); fi; \
+	    $(INSTALL_DATA) $$dir/$$file \
+			    $(DESTDIR)$(gettextsrcdir)/$$file; \
+	  done; \
+	  dists="$(DISTFILES.obsolete)"; \
+	  for file in $$dists; do \
+	    rm -f $(DESTDIR)$(gettextsrcdir)/$$file; \
+	  done; \
+	else \
+	  : ; \
+	fi
+
+install-strip: install
+
+installdirs:
+	if test "$(PACKAGE)" = "gettext" \
+	   && test '@INTLOBJS@' = '$(GETTOBJS)'; then \
+	  $(mkinstalldirs) $(DESTDIR)$(libdir) $(DESTDIR)$(includedir); \
+	else \
+	  : ; \
+	fi
+	if test '@USE_INCLUDED_LIBINTL@' = yes; then \
+	  test @GLIBC21@ != no || $(mkinstalldirs) $(DESTDIR)$(libdir); \
+	  $(mkinstalldirs) $(DESTDIR)$(localedir); \
+	else \
+	  : ; \
+	fi
+	if test "$(PACKAGE)" = "gettext"; then \
+	  $(mkinstalldirs) $(DESTDIR)$(gettextsrcdir); \
+	else \
+	  : ; \
+	fi
+
+# Define this as empty until I found a useful application.
+installcheck:
+
+uninstall:
+	if test "$(PACKAGE)" = "gettext" \
+	   && test '@INTLOBJS@' = '$(GETTOBJS)'; then \
+	  rm -f $(DESTDIR)$(includedir)/libintl.h; \
+	  $(LIBTOOL) --mode=uninstall \
+	    rm -f $(DESTDIR)$(libdir)/libintl.$la; \
+	else \
+	  : ; \
+	fi
+	if test '@USE_INCLUDED_LIBINTL@' = yes; then \
+	  if test -f $(DESTDIR)$(libdir)/charset.alias; then \
+	    temp=$(DESTDIR)$(libdir)/t-charset.alias; \
+	    dest=$(DESTDIR)$(libdir)/charset.alias; \
+	    sed -f ref-del.sed $$dest > $$temp; \
+	    if grep '^# Packages using this file: $$' $$temp > /dev/null; then \
+	      rm -f $$dest; \
+	    else \
+	      $(INSTALL_DATA) $$temp $$dest; \
+	    fi; \
+	    rm -f $$temp; \
+	  fi; \
+	  if test -f $(DESTDIR)$(localedir)/locale.alias; then \
+	    temp=$(DESTDIR)$(localedir)/t-locale.alias; \
+	    dest=$(DESTDIR)$(localedir)/locale.alias; \
+	    sed -f ref-del.sed $$dest > $$temp; \
+	    if grep '^# Packages using this file: $$' $$temp > /dev/null; then \
+	      rm -f $$dest; \
+	    else \
+	      $(INSTALL_DATA) $$temp $$dest; \
+	    fi; \
+	    rm -f $$temp; \
+	  fi; \
+	else \
+	  : ; \
+	fi
+	if test "$(PACKAGE)" = "gettext"; then \
+	  for file in VERSION ChangeLog COPYING.LIB-2.0 COPYING.LIB-2.1 $(DISTFILES.common) $(DISTFILES.generated); do \
+	    rm -f $(DESTDIR)$(gettextsrcdir)/$$file; \
+	  done; \
+	else \
+	  : ; \
+	fi
+
+info dvi:
+
+$(OBJECTS): ../config.h libgnuintl.h
+bindtextdom.$lo dcgettext.$lo dcigettext.$lo dcngettext.$lo dgettext.$lo dngettext.$lo finddomain.$lo gettext.$lo intl-compat.$lo loadmsgcat.$lo localealias.$lo ngettext.$lo textdomain.$lo: gettextP.h gmo.h loadinfo.h
+dcigettext.$lo: hash-string.h
+explodename.$lo l10nflist.$lo: loadinfo.h
+dcigettext.$lo loadmsgcat.$lo plural.$lo plural-exp.$lo: plural-exp.h
+dcigettext.$lo: eval-plural.h
+
+tags: TAGS
+
+TAGS: $(HEADERS) $(SOURCES)
+	here=`pwd`; cd $(srcdir) && etags -o $$here/TAGS $(HEADERS) $(SOURCES)
+
+id: ID
+
+ID: $(HEADERS) $(SOURCES)
+	here=`pwd`; cd $(srcdir) && mkid -f$$here/ID $(HEADERS) $(SOURCES)
+
+
+mostlyclean:
+	rm -f *.a *.la *.o *.lo core core.*
+	rm -f libintl.h charset.alias ref-add.sed ref-del.sed
+	rm -f -r .libs _libs
+
+clean: mostlyclean
+
+distclean: clean
+	rm -f Makefile ID TAGS
+	if test "$(PACKAGE)" = gettext; then \
+	  rm -f ChangeLog.inst $(DISTFILES.normal); \
+	else \
+	  : ; \
+	fi
+
+maintainer-clean: distclean
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+
+
+# GNU gettext needs not contain the file `VERSION' but contains some
+# other files which should not be distributed in other packages.
+distdir = ../$(PACKAGE)-$(VERSION)/$(subdir)
+dist distdir: Makefile
+	if test "$(PACKAGE)" = gettext; then \
+	  additional="$(DISTFILES.gettext)"; \
+	else \
+	  additional="$(DISTFILES.normal)"; \
+	fi; \
+	$(MAKE) $(DISTFILES.common) $(DISTFILES.generated) $$additional; \
+	for file in ChangeLog $(DISTFILES.common) $(DISTFILES.generated) $$additional; do \
+	  if test -f $$file; then dir=.; else dir=$(srcdir); fi; \
+	  cp -p $$dir/$$file $(distdir); \
+	done
+
+Makefile: Makefile.in ../config.status
+	cd .. \
+	  && CONFIG_FILES=$(subdir)/$@ CONFIG_HEADERS= $(SHELL) ./config.status
+
+# Tell versions [3.59,3.63) of GNU make not to export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -Nur dillo-0.8.0/intl/ngettext.c dillo-0.8.0.new/intl/ngettext.c
--- dillo-0.8.0/intl/ngettext.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/ngettext.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,68 @@
+/* Implementation of ngettext(3) function.
+   Copyright (C) 1995, 1997, 2000, 2001, 2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#ifdef _LIBC
+# define __need_NULL
+# include <stddef.h>
+#else
+# include <stdlib.h>		/* Just for NULL.  */
+#endif
+
+#include "gettextP.h"
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+
+#include <locale.h>
+
+/* @@ end of prolog @@ */
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define NGETTEXT __ngettext
+# define DCNGETTEXT INTUSE(__dcngettext)
+#else
+# define NGETTEXT libintl_ngettext
+# define DCNGETTEXT libintl_dcngettext
+#endif
+
+/* Look up MSGID in the current default message catalog for the current
+   LC_MESSAGES locale.  If not found, returns MSGID itself (the default
+   text).  */
+char *
+NGETTEXT (msgid1, msgid2, n)
+     const char *msgid1;
+     const char *msgid2;
+     unsigned long int n;
+{
+  return DCNGETTEXT (NULL, msgid1, msgid2, n, LC_MESSAGES);
+}
+
+#ifdef _LIBC
+/* Alias for function name in GNU C Library.  */
+weak_alias (__ngettext, ngettext);
+#endif
diff -Nur dillo-0.8.0/intl/os2compat.c dillo-0.8.0.new/intl/os2compat.c
--- dillo-0.8.0/intl/os2compat.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/os2compat.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,98 @@
+/* OS/2 compatibility functions.
+   Copyright (C) 2001-2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#define OS2_AWARE
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+#include <sys/param.h>
+
+/* A version of getenv() that works from DLLs */
+extern unsigned long DosScanEnv (const unsigned char *pszName, unsigned char **ppszValue);
+
+char *
+_nl_getenv (const char *name)
+{
+  unsigned char *value;
+  if (DosScanEnv (name, &value))
+    return NULL;
+  else
+    return value;
+}
+
+/* A fixed size buffer.  */
+char libintl_nl_default_dirname[MAXPATHLEN+1];
+
+char *_nlos2_libdir = NULL;
+char *_nlos2_localealiaspath = NULL;
+char *_nlos2_localedir = NULL;
+
+static __attribute__((constructor)) void
+nlos2_initialize ()
+{
+  char *root = getenv ("UNIXROOT");
+  char *gnulocaledir = getenv ("GNULOCALEDIR");
+
+  _nlos2_libdir = gnulocaledir;
+  if (!_nlos2_libdir)
+    {
+      if (root)
+        {
+          size_t sl = strlen (root);
+          _nlos2_libdir = (char *) malloc (sl + strlen (LIBDIR) + 1);
+          memcpy (_nlos2_libdir, root, sl);
+          memcpy (_nlos2_libdir + sl, LIBDIR, strlen (LIBDIR) + 1);
+        }
+      else
+        _nlos2_libdir = LIBDIR;
+    }
+
+  _nlos2_localealiaspath = gnulocaledir;
+  if (!_nlos2_localealiaspath)
+    {
+      if (root)
+        {
+          size_t sl = strlen (root);
+          _nlos2_localealiaspath = (char *) malloc (sl + strlen (LOCALE_ALIAS_PATH) + 1);
+          memcpy (_nlos2_localealiaspath, root, sl);
+          memcpy (_nlos2_localealiaspath + sl, LOCALE_ALIAS_PATH, strlen (LOCALE_ALIAS_PATH) + 1);
+        }
+     else
+        _nlos2_localealiaspath = LOCALE_ALIAS_PATH;
+    }
+
+  _nlos2_localedir = gnulocaledir;
+  if (!_nlos2_localedir)
+    {
+      if (root)
+        {
+          size_t sl = strlen (root);
+          _nlos2_localedir = (char *) malloc (sl + strlen (LOCALEDIR) + 1);
+          memcpy (_nlos2_localedir, root, sl);
+          memcpy (_nlos2_localedir + sl, LOCALEDIR, strlen (LOCALEDIR) + 1);
+        }
+      else
+        _nlos2_localedir = LOCALEDIR;
+    }
+
+  if (strlen (_nlos2_localedir) <= MAXPATHLEN)
+    strcpy (libintl_nl_default_dirname, _nlos2_localedir);
+}
diff -Nur dillo-0.8.0/intl/os2compat.h dillo-0.8.0.new/intl/os2compat.h
--- dillo-0.8.0/intl/os2compat.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/os2compat.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,46 @@
+/* OS/2 compatibility defines.
+   This file is intended to be included from config.h
+   Copyright (C) 2001-2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+/* When included from os2compat.h we need all the original definitions */
+#ifndef OS2_AWARE
+
+#undef LIBDIR
+#define LIBDIR			_nlos2_libdir
+extern char *_nlos2_libdir;
+
+#undef LOCALEDIR
+#define LOCALEDIR		_nlos2_localedir
+extern char *_nlos2_localedir;
+
+#undef LOCALE_ALIAS_PATH
+#define LOCALE_ALIAS_PATH	_nlos2_localealiaspath
+extern char *_nlos2_localealiaspath;
+
+#endif
+
+#undef HAVE_STRCASECMP
+#define HAVE_STRCASECMP 1
+#define strcasecmp stricmp
+#define strncasecmp strnicmp
+
+/* We have our own getenv() which works even if library is compiled as DLL */
+#define getenv _nl_getenv
+
+/* Older versions of gettext used -1 as the value of LC_MESSAGES */
+#define LC_MESSAGES_COMPAT (-1)
diff -Nur dillo-0.8.0/intl/osdep.c dillo-0.8.0.new/intl/osdep.c
--- dillo-0.8.0/intl/osdep.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/osdep.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,24 @@
+/* OS dependent parts of libintl.
+   Copyright (C) 2001-2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#if defined __EMX__
+# include "os2compat.c"
+#else
+/* Avoid AIX compiler warning.  */
+typedef int dummy;
+#endif
diff -Nur dillo-0.8.0/intl/plural.c dillo-0.8.0.new/intl/plural.c
--- dillo-0.8.0/intl/plural.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/plural.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,1322 @@
+
+/*  A Bison parser, made from plural.y
+    by GNU Bison version 1.28  */
+
+#define YYBISON 1  /* Identify Bison output.  */
+
+#define yyparse __gettextparse
+#define yylex __gettextlex
+#define yyerror __gettexterror
+#define yylval __gettextlval
+#define yychar __gettextchar
+#define yydebug __gettextdebug
+#define yynerrs __gettextnerrs
+#define	EQUOP2	257
+#define	CMPOP2	258
+#define	ADDOP2	259
+#define	MULOP2	260
+#define	NUMBER	261
+
+#line 1 "plural.y"
+
+/* Expression parsing for plural form selection.
+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   Written by Ulrich Drepper <drepper@cygnus.com>, 2000.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+/* The bison generated parser uses alloca.  AIX 3 forces us to put this
+   declaration at the beginning of the file.  The declaration in bison's
+   skeleton file comes too late.  This must come before <config.h>
+   because <config.h> may include arbitrary system headers.  */
+#if defined _AIX && !defined __GNUC__
+ #pragma alloca
+#endif
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <stddef.h>
+#include <stdlib.h>
+#include "plural-exp.h"
+
+/* The main function generated by the parser is called __gettextparse,
+   but we want it to be called PLURAL_PARSE.  */
+#ifndef _LIBC
+# define __gettextparse PLURAL_PARSE
+#endif
+
+#define YYLEX_PARAM	&((struct parse_args *) arg)->cp
+#define YYPARSE_PARAM	arg
+
+#line 49 "plural.y"
+typedef union {
+  unsigned long int num;
+  enum operator op;
+  struct expression *exp;
+} YYSTYPE;
+#line 55 "plural.y"
+
+/* Prototypes for local functions.  */
+static struct expression *new_exp PARAMS ((int nargs, enum operator op,
+					   struct expression * const *args));
+static inline struct expression *new_exp_0 PARAMS ((enum operator op));
+static inline struct expression *new_exp_1 PARAMS ((enum operator op,
+						   struct expression *right));
+static struct expression *new_exp_2 PARAMS ((enum operator op,
+					     struct expression *left,
+					     struct expression *right));
+static inline struct expression *new_exp_3 PARAMS ((enum operator op,
+						   struct expression *bexp,
+						   struct expression *tbranch,
+						   struct expression *fbranch));
+static int yylex PARAMS ((YYSTYPE *lval, const char **pexp));
+static void yyerror PARAMS ((const char *str));
+
+/* Allocation of expressions.  */
+
+static struct expression *
+new_exp (nargs, op, args)
+     int nargs;
+     enum operator op;
+     struct expression * const *args;
+{
+  int i;
+  struct expression *newp;
+
+  /* If any of the argument could not be malloc'ed, just return NULL.  */
+  for (i = nargs - 1; i >= 0; i--)
+    if (args[i] == NULL)
+      goto fail;
+
+  /* Allocate a new expression.  */
+  newp = (struct expression *) malloc (sizeof (*newp));
+  if (newp != NULL)
+    {
+      newp->nargs = nargs;
+      newp->operation = op;
+      for (i = nargs - 1; i >= 0; i--)
+	newp->val.args[i] = args[i];
+      return newp;
+    }
+
+ fail:
+  for (i = nargs - 1; i >= 0; i--)
+    FREE_EXPRESSION (args[i]);
+
+  return NULL;
+}
+
+static inline struct expression *
+new_exp_0 (op)
+     enum operator op;
+{
+  return new_exp (0, op, NULL);
+}
+
+static inline struct expression *
+new_exp_1 (op, right)
+     enum operator op;
+     struct expression *right;
+{
+  struct expression *args[1];
+
+  args[0] = right;
+  return new_exp (1, op, args);
+}
+
+static struct expression *
+new_exp_2 (op, left, right)
+     enum operator op;
+     struct expression *left;
+     struct expression *right;
+{
+  struct expression *args[2];
+
+  args[0] = left;
+  args[1] = right;
+  return new_exp (2, op, args);
+}
+
+static inline struct expression *
+new_exp_3 (op, bexp, tbranch, fbranch)
+     enum operator op;
+     struct expression *bexp;
+     struct expression *tbranch;
+     struct expression *fbranch;
+{
+  struct expression *args[3];
+
+  args[0] = bexp;
+  args[1] = tbranch;
+  args[2] = fbranch;
+  return new_exp (3, op, args);
+}
+
+#include <stdio.h>
+
+#ifndef __cplusplus
+#ifndef __STDC__
+#define const
+#endif
+#endif
+
+
+
+#define	YYFINAL		27
+#define	YYFLAG		-32768
+#define	YYNTBASE	16
+
+#define YYTRANSLATE(x) ((unsigned)(x) <= 261 ? yytranslate[x] : 18)
+
+static const char yytranslate[] = {     0,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,    10,     2,     2,     2,     2,     5,     2,    14,
+    15,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,    12,     2,     2,
+     2,     2,     3,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,    13,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     4,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
+     2,     2,     2,     2,     2,     1,     6,     7,     8,     9,
+    11
+};
+
+#if YYDEBUG != 0
+static const short yyprhs[] = {     0,
+     0,     2,     8,    12,    16,    20,    24,    28,    32,    35,
+    37,    39
+};
+
+static const short yyrhs[] = {    17,
+     0,    17,     3,    17,    12,    17,     0,    17,     4,    17,
+     0,    17,     5,    17,     0,    17,     6,    17,     0,    17,
+     7,    17,     0,    17,     8,    17,     0,    17,     9,    17,
+     0,    10,    17,     0,    13,     0,    11,     0,    14,    17,
+    15,     0
+};
+
+#endif
+
+#if YYDEBUG != 0
+static const short yyrline[] = { 0,
+   174,   182,   186,   190,   194,   198,   202,   206,   210,   214,
+   218,   223
+};
+#endif
+
+
+#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
+
+static const char * const yytname[] = {   "$","error","$undefined.","'?'","'|'",
+"'&'","EQUOP2","CMPOP2","ADDOP2","MULOP2","'!'","NUMBER","':'","'n'","'('","')'",
+"start","exp", NULL
+};
+#endif
+
+static const short yyr1[] = {     0,
+    16,    17,    17,    17,    17,    17,    17,    17,    17,    17,
+    17,    17
+};
+
+static const short yyr2[] = {     0,
+     1,     5,     3,     3,     3,     3,     3,     3,     2,     1,
+     1,     3
+};
+
+static const short yydefact[] = {     0,
+     0,    11,    10,     0,     1,     9,     0,     0,     0,     0,
+     0,     0,     0,     0,    12,     0,     3,     4,     5,     6,
+     7,     8,     0,     2,     0,     0,     0
+};
+
+static const short yydefgoto[] = {    25,
+     5
+};
+
+static const short yypact[] = {    -9,
+    -9,-32768,-32768,    -9,    34,-32768,    11,    -9,    -9,    -9,
+    -9,    -9,    -9,    -9,-32768,    24,    39,    43,    16,    26,
+    -3,-32768,    -9,    34,    21,    53,-32768
+};
+
+static const short yypgoto[] = {-32768,
+    -1
+};
+
+
+#define	YYLAST		53
+
+
+static const short yytable[] = {     6,
+     1,     2,     7,     3,     4,    14,    16,    17,    18,    19,
+    20,    21,    22,     8,     9,    10,    11,    12,    13,    14,
+    26,    24,    12,    13,    14,    15,     8,     9,    10,    11,
+    12,    13,    14,    13,    14,    23,     8,     9,    10,    11,
+    12,    13,    14,    10,    11,    12,    13,    14,    11,    12,
+    13,    14,    27
+};
+
+static const short yycheck[] = {     1,
+    10,    11,     4,    13,    14,     9,     8,     9,    10,    11,
+    12,    13,    14,     3,     4,     5,     6,     7,     8,     9,
+     0,    23,     7,     8,     9,    15,     3,     4,     5,     6,
+     7,     8,     9,     8,     9,    12,     3,     4,     5,     6,
+     7,     8,     9,     5,     6,     7,     8,     9,     6,     7,
+     8,     9,     0
+};
+#define YYPURE 1
+
+/* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */
+#line 3 "/usr/local/share/bison.simple"
+/* This file comes from bison-1.28.  */
+
+/* Skeleton output parser for bison,
+   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+/* As a special exception, when this file is copied by Bison into a
+   Bison output file, you may use that output file without restriction.
+   This special exception was added by the Free Software Foundation
+   in version 1.24 of Bison.  */
+
+/* This is the parser code that is written into each bison parser
+  when the %semantic_parser declaration is not specified in the grammar.
+  It was written by Richard Stallman by simplifying the hairy parser
+  used when %semantic_parser is specified.  */
+
+#ifndef YYSTACK_USE_ALLOCA
+#ifdef alloca
+#define YYSTACK_USE_ALLOCA
+#else /* alloca not defined */
+#ifdef __GNUC__
+#define YYSTACK_USE_ALLOCA
+#define alloca __builtin_alloca
+#else /* not GNU C.  */
+#if (!defined (__STDC__) && defined (sparc)) || defined (__sparc__) || defined (__sparc) || defined (__sgi) || (defined (__sun) && defined (__i386))
+#define YYSTACK_USE_ALLOCA
+#include <alloca.h>
+#else /* not sparc */
+/* We think this test detects Watcom and Microsoft C.  */
+/* This used to test MSDOS, but that is a bad idea
+   since that symbol is in the user namespace.  */
+#if (defined (_MSDOS) || defined (_MSDOS_)) && !defined (__TURBOC__)
+#if 0 /* No need for malloc.h, which pollutes the namespace;
+	 instead, just don't use alloca.  */
+#include <malloc.h>
+#endif
+#else /* not MSDOS, or __TURBOC__ */
+#if defined(_AIX)
+/* I don't know what this was needed for, but it pollutes the namespace.
+   So I turned it off.   rms, 2 May 1997.  */
+/* #include <malloc.h>  */
+ #pragma alloca
+#define YYSTACK_USE_ALLOCA
+#else /* not MSDOS, or __TURBOC__, or _AIX */
+#if 0
+#ifdef __hpux /* haible@ilog.fr says this works for HPUX 9.05 and up,
+		 and on HPUX 10.  Eventually we can turn this on.  */
+#define YYSTACK_USE_ALLOCA
+#define alloca __builtin_alloca
+#endif /* __hpux */
+#endif
+#endif /* not _AIX */
+#endif /* not MSDOS, or __TURBOC__ */
+#endif /* not sparc */
+#endif /* not GNU C */
+#endif /* alloca not defined */
+#endif /* YYSTACK_USE_ALLOCA not defined */
+
+#ifdef YYSTACK_USE_ALLOCA
+#define YYSTACK_ALLOC alloca
+#else
+#define YYSTACK_ALLOC malloc
+#endif
+
+/* Note: there must be only one dollar sign in this file.
+   It is replaced by the list of actions, each action
+   as one case of the switch.  */
+
+#define yyerrok		(yyerrstatus = 0)
+#define yyclearin	(yychar = YYEMPTY)
+#define YYEMPTY		-2
+#define YYEOF		0
+#define YYACCEPT	goto yyacceptlab
+#define YYABORT 	goto yyabortlab
+#define YYERROR		goto yyerrlab1
+/* Like YYERROR except do call yyerror.
+   This remains here temporarily to ease the
+   transition to the new meaning of YYERROR, for GCC.
+   Once GCC version 2 has supplanted version 1, this can go.  */
+#define YYFAIL		goto yyerrlab
+#define YYRECOVERING()  (!!yyerrstatus)
+#define YYBACKUP(token, value) \
+do								\
+  if (yychar == YYEMPTY && yylen == 1)				\
+    { yychar = (token), yylval = (value);			\
+      yychar1 = YYTRANSLATE (yychar);				\
+      YYPOPSTACK;						\
+      goto yybackup;						\
+    }								\
+  else								\
+    { yyerror ("syntax error: cannot back up"); YYERROR; }	\
+while (0)
+
+#define YYTERROR	1
+#define YYERRCODE	256
+
+#ifndef YYPURE
+#define YYLEX		yylex()
+#endif
+
+#ifdef YYPURE
+#ifdef YYLSP_NEEDED
+#ifdef YYLEX_PARAM
+#define YYLEX		yylex(&yylval, &yylloc, YYLEX_PARAM)
+#else
+#define YYLEX		yylex(&yylval, &yylloc)
+#endif
+#else /* not YYLSP_NEEDED */
+#ifdef YYLEX_PARAM
+#define YYLEX		yylex(&yylval, YYLEX_PARAM)
+#else
+#define YYLEX		yylex(&yylval)
+#endif
+#endif /* not YYLSP_NEEDED */
+#endif
+
+/* If nonreentrant, generate the variables here */
+
+#ifndef YYPURE
+
+int	yychar;			/*  the lookahead symbol		*/
+YYSTYPE	yylval;			/*  the semantic value of the		*/
+				/*  lookahead symbol			*/
+
+#ifdef YYLSP_NEEDED
+YYLTYPE yylloc;			/*  location data for the lookahead	*/
+				/*  symbol				*/
+#endif
+
+int yynerrs;			/*  number of parse errors so far       */
+#endif  /* not YYPURE */
+
+#if YYDEBUG != 0
+int yydebug;			/*  nonzero means print parse trace	*/
+/* Since this is uninitialized, it does not stop multiple parsers
+   from coexisting.  */
+#endif
+
+/*  YYINITDEPTH indicates the initial size of the parser's stacks	*/
+
+#ifndef	YYINITDEPTH
+#define YYINITDEPTH 200
+#endif
+
+/*  YYMAXDEPTH is the maximum size the stacks can grow to
+    (effective only if the built-in stack extension method is used).  */
+
+#if YYMAXDEPTH == 0
+#undef YYMAXDEPTH
+#endif
+
+#ifndef YYMAXDEPTH
+#define YYMAXDEPTH 10000
+#endif
+
+/* Define __yy_memcpy.  Note that the size argument
+   should be passed with type unsigned int, because that is what the non-GCC
+   definitions require.  With GCC, __builtin_memcpy takes an arg
+   of type size_t, but it can handle unsigned int.  */
+
+#if __GNUC__ > 1		/* GNU C and GNU C++ define this.  */
+#define __yy_memcpy(TO,FROM,COUNT)	__builtin_memcpy(TO,FROM,COUNT)
+#else				/* not GNU C or C++ */
+#ifndef __cplusplus
+
+/* This is the most reliable way to avoid incompatibilities
+   in available built-in functions on various systems.  */
+static void
+__yy_memcpy (to, from, count)
+     char *to;
+     char *from;
+     unsigned int count;
+{
+  register char *f = from;
+  register char *t = to;
+  register int i = count;
+
+  while (i-- > 0)
+    *t++ = *f++;
+}
+
+#else /* __cplusplus */
+
+/* This is the most reliable way to avoid incompatibilities
+   in available built-in functions on various systems.  */
+static void
+__yy_memcpy (char *to, char *from, unsigned int count)
+{
+  register char *t = to;
+  register char *f = from;
+  register int i = count;
+
+  while (i-- > 0)
+    *t++ = *f++;
+}
+
+#endif
+#endif
+
+#line 217 "/usr/local/share/bison.simple"
+
+/* The user can define YYPARSE_PARAM as the name of an argument to be passed
+   into yyparse.  The argument should have type void *.
+   It should actually point to an object.
+   Grammar actions can access the variable by casting it
+   to the proper pointer type.  */
+
+#ifdef YYPARSE_PARAM
+#ifdef __cplusplus
+#define YYPARSE_PARAM_ARG void *YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL
+#else /* not __cplusplus */
+#define YYPARSE_PARAM_ARG YYPARSE_PARAM
+#define YYPARSE_PARAM_DECL void *YYPARSE_PARAM;
+#endif /* not __cplusplus */
+#else /* not YYPARSE_PARAM */
+#define YYPARSE_PARAM_ARG
+#define YYPARSE_PARAM_DECL
+#endif /* not YYPARSE_PARAM */
+
+/* Prevent warning if -Wstrict-prototypes.  */
+#ifdef __GNUC__
+#ifdef YYPARSE_PARAM
+int yyparse (void *);
+#else
+int yyparse (void);
+#endif
+#endif
+
+int
+yyparse(YYPARSE_PARAM_ARG)
+     YYPARSE_PARAM_DECL
+{
+  register int yystate;
+  register int yyn;
+  register short *yyssp;
+  register YYSTYPE *yyvsp;
+  int yyerrstatus;	/*  number of tokens to shift before error messages enabled */
+  int yychar1 = 0;		/*  lookahead token as an internal (translated) token number */
+
+  short	yyssa[YYINITDEPTH];	/*  the state stack			*/
+  YYSTYPE yyvsa[YYINITDEPTH];	/*  the semantic value stack		*/
+
+  short *yyss = yyssa;		/*  refer to the stacks thru separate pointers */
+  YYSTYPE *yyvs = yyvsa;	/*  to allow yyoverflow to reallocate them elsewhere */
+
+#ifdef YYLSP_NEEDED
+  YYLTYPE yylsa[YYINITDEPTH];	/*  the location stack			*/
+  YYLTYPE *yyls = yylsa;
+  YYLTYPE *yylsp;
+
+#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
+#else
+#define YYPOPSTACK   (yyvsp--, yyssp--)
+#endif
+
+  int yystacksize = YYINITDEPTH;
+  int yyfree_stacks = 0;
+
+#ifdef YYPURE
+  int yychar;
+  YYSTYPE yylval;
+  int yynerrs;
+#ifdef YYLSP_NEEDED
+  YYLTYPE yylloc;
+#endif
+#endif
+
+  YYSTYPE yyval;		/*  the variable used to return		*/
+				/*  semantic values from the action	*/
+				/*  routines				*/
+
+  int yylen;
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Starting parse\n");
+#endif
+
+  yystate = 0;
+  yyerrstatus = 0;
+  yynerrs = 0;
+  yychar = YYEMPTY;		/* Cause a token to be read.  */
+
+  /* Initialize stack pointers.
+     Waste one element of value and location stack
+     so that they stay on the same level as the state stack.
+     The wasted elements are never initialized.  */
+
+  yyssp = yyss - 1;
+  yyvsp = yyvs;
+#ifdef YYLSP_NEEDED
+  yylsp = yyls;
+#endif
+
+/* Push a new state, which is found in  yystate  .  */
+/* In all cases, when you get here, the value and location stacks
+   have just been pushed. so pushing a state here evens the stacks.  */
+yynewstate:
+
+  *++yyssp = yystate;
+
+  if (yyssp >= yyss + yystacksize - 1)
+    {
+      /* Give user a chance to reallocate the stack */
+      /* Use copies of these so that the &'s don't force the real ones into memory. */
+      YYSTYPE *yyvs1 = yyvs;
+      short *yyss1 = yyss;
+#ifdef YYLSP_NEEDED
+      YYLTYPE *yyls1 = yyls;
+#endif
+
+      /* Get the current used size of the three stacks, in elements.  */
+      int size = yyssp - yyss + 1;
+
+#ifdef yyoverflow
+      /* Each stack pointer address is followed by the size of
+	 the data in use in that stack, in bytes.  */
+#ifdef YYLSP_NEEDED
+      /* This used to be a conditional around just the two extra args,
+	 but that might be undefined if yyoverflow is a macro.  */
+      yyoverflow("parser stack overflow",
+		 &yyss1, size * sizeof (*yyssp),
+		 &yyvs1, size * sizeof (*yyvsp),
+		 &yyls1, size * sizeof (*yylsp),
+		 &yystacksize);
+#else
+      yyoverflow("parser stack overflow",
+		 &yyss1, size * sizeof (*yyssp),
+		 &yyvs1, size * sizeof (*yyvsp),
+		 &yystacksize);
+#endif
+
+      yyss = yyss1; yyvs = yyvs1;
+#ifdef YYLSP_NEEDED
+      yyls = yyls1;
+#endif
+#else /* no yyoverflow */
+      /* Extend the stack our own way.  */
+      if (yystacksize >= YYMAXDEPTH)
+	{
+	  yyerror("parser stack overflow");
+	  if (yyfree_stacks)
+	    {
+	      free (yyss);
+	      free (yyvs);
+#ifdef YYLSP_NEEDED
+	      free (yyls);
+#endif
+	    }
+	  return 2;
+	}
+      yystacksize *= 2;
+      if (yystacksize > YYMAXDEPTH)
+	yystacksize = YYMAXDEPTH;
+#ifndef YYSTACK_USE_ALLOCA
+      yyfree_stacks = 1;
+#endif
+      yyss = (short *) YYSTACK_ALLOC (yystacksize * sizeof (*yyssp));
+      __yy_memcpy ((char *)yyss, (char *)yyss1,
+		   size * (unsigned int) sizeof (*yyssp));
+      yyvs = (YYSTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yyvsp));
+      __yy_memcpy ((char *)yyvs, (char *)yyvs1,
+		   size * (unsigned int) sizeof (*yyvsp));
+#ifdef YYLSP_NEEDED
+      yyls = (YYLTYPE *) YYSTACK_ALLOC (yystacksize * sizeof (*yylsp));
+      __yy_memcpy ((char *)yyls, (char *)yyls1,
+		   size * (unsigned int) sizeof (*yylsp));
+#endif
+#endif /* no yyoverflow */
+
+      yyssp = yyss + size - 1;
+      yyvsp = yyvs + size - 1;
+#ifdef YYLSP_NEEDED
+      yylsp = yyls + size - 1;
+#endif
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Stack size increased to %d\n", yystacksize);
+#endif
+
+      if (yyssp >= yyss + yystacksize - 1)
+	YYABORT;
+    }
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Entering state %d\n", yystate);
+#endif
+
+  goto yybackup;
+ yybackup:
+
+/* Do appropriate processing given the current state.  */
+/* Read a lookahead token if we need one and don't already have one.  */
+/* yyresume: */
+
+  /* First try to decide what to do without reference to lookahead token.  */
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yydefault;
+
+  /* Not known => get a lookahead token if don't already have one.  */
+
+  /* yychar is either YYEMPTY or YYEOF
+     or a valid token in external form.  */
+
+  if (yychar == YYEMPTY)
+    {
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Reading a token: ");
+#endif
+      yychar = YYLEX;
+    }
+
+  /* Convert token to internal form (in yychar1) for indexing tables with */
+
+  if (yychar <= 0)		/* This means end of input. */
+    {
+      yychar1 = 0;
+      yychar = YYEOF;		/* Don't call YYLEX any more */
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Now at end of input.\n");
+#endif
+    }
+  else
+    {
+      yychar1 = YYTRANSLATE(yychar);
+
+#if YYDEBUG != 0
+      if (yydebug)
+	{
+	  fprintf (stderr, "Next token is %d (%s", yychar, yytname[yychar1]);
+	  /* Give the individual parser a way to print the precise meaning
+	     of a token, for further debugging info.  */
+#ifdef YYPRINT
+	  YYPRINT (stderr, yychar, yylval);
+#endif
+	  fprintf (stderr, ")\n");
+	}
+#endif
+    }
+
+  yyn += yychar1;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
+    goto yydefault;
+
+  yyn = yytable[yyn];
+
+  /* yyn is what to do for this token type in this state.
+     Negative => reduce, -yyn is rule number.
+     Positive => shift, yyn is new state.
+       New state is final state => don't bother to shift,
+       just return success.
+     0, or most negative number => error.  */
+
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrlab;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrlab;
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+  /* Shift the lookahead token.  */
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Shifting token %d (%s), ", yychar, yytname[yychar1]);
+#endif
+
+  /* Discard the token being shifted unless it is eof.  */
+  if (yychar != YYEOF)
+    yychar = YYEMPTY;
+
+  *++yyvsp = yylval;
+#ifdef YYLSP_NEEDED
+  *++yylsp = yylloc;
+#endif
+
+  /* count tokens shifted since error; after three, turn off error status.  */
+  if (yyerrstatus) yyerrstatus--;
+
+  yystate = yyn;
+  goto yynewstate;
+
+/* Do the default action for the current state.  */
+yydefault:
+
+  yyn = yydefact[yystate];
+  if (yyn == 0)
+    goto yyerrlab;
+
+/* Do a reduction.  yyn is the number of a rule to reduce with.  */
+yyreduce:
+  yylen = yyr2[yyn];
+  if (yylen > 0)
+    yyval = yyvsp[1-yylen]; /* implement default value of the action */
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      int i;
+
+      fprintf (stderr, "Reducing via rule %d (line %d), ",
+	       yyn, yyrline[yyn]);
+
+      /* Print the symbols being reduced, and their result.  */
+      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++)
+	fprintf (stderr, "%s ", yytname[yyrhs[i]]);
+      fprintf (stderr, " -> %s\n", yytname[yyr1[yyn]]);
+    }
+#endif
+
+
+  switch (yyn) {
+
+case 1:
+#line 175 "plural.y"
+{
+	    if (yyvsp[0].exp == NULL)
+	      YYABORT;
+	    ((struct parse_args *) arg)->res = yyvsp[0].exp;
+	  ;
+    break;}
+case 2:
+#line 183 "plural.y"
+{
+	    yyval.exp = new_exp_3 (qmop, yyvsp[-4].exp, yyvsp[-2].exp, yyvsp[0].exp);
+	  ;
+    break;}
+case 3:
+#line 187 "plural.y"
+{
+	    yyval.exp = new_exp_2 (lor, yyvsp[-2].exp, yyvsp[0].exp);
+	  ;
+    break;}
+case 4:
+#line 191 "plural.y"
+{
+	    yyval.exp = new_exp_2 (land, yyvsp[-2].exp, yyvsp[0].exp);
+	  ;
+    break;}
+case 5:
+#line 195 "plural.y"
+{
+	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
+	  ;
+    break;}
+case 6:
+#line 199 "plural.y"
+{
+	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
+	  ;
+    break;}
+case 7:
+#line 203 "plural.y"
+{
+	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
+	  ;
+    break;}
+case 8:
+#line 207 "plural.y"
+{
+	    yyval.exp = new_exp_2 (yyvsp[-1].op, yyvsp[-2].exp, yyvsp[0].exp);
+	  ;
+    break;}
+case 9:
+#line 211 "plural.y"
+{
+	    yyval.exp = new_exp_1 (lnot, yyvsp[0].exp);
+	  ;
+    break;}
+case 10:
+#line 215 "plural.y"
+{
+	    yyval.exp = new_exp_0 (var);
+	  ;
+    break;}
+case 11:
+#line 219 "plural.y"
+{
+	    if ((yyval.exp = new_exp_0 (num)) != NULL)
+	      yyval.exp->val.num = yyvsp[0].num;
+	  ;
+    break;}
+case 12:
+#line 224 "plural.y"
+{
+	    yyval.exp = yyvsp[-1].exp;
+	  ;
+    break;}
+}
+   /* the action file gets copied in in place of this dollarsign */
+#line 543 "/usr/local/share/bison.simple"
+
+  yyvsp -= yylen;
+  yyssp -= yylen;
+#ifdef YYLSP_NEEDED
+  yylsp -= yylen;
+#endif
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      short *ssp1 = yyss - 1;
+      fprintf (stderr, "state stack now");
+      while (ssp1 != yyssp)
+	fprintf (stderr, " %d", *++ssp1);
+      fprintf (stderr, "\n");
+    }
+#endif
+
+  *++yyvsp = yyval;
+
+#ifdef YYLSP_NEEDED
+  yylsp++;
+  if (yylen == 0)
+    {
+      yylsp->first_line = yylloc.first_line;
+      yylsp->first_column = yylloc.first_column;
+      yylsp->last_line = (yylsp-1)->last_line;
+      yylsp->last_column = (yylsp-1)->last_column;
+      yylsp->text = 0;
+    }
+  else
+    {
+      yylsp->last_line = (yylsp+yylen-1)->last_line;
+      yylsp->last_column = (yylsp+yylen-1)->last_column;
+    }
+#endif
+
+  /* Now "shift" the result of the reduction.
+     Determine what state that goes to,
+     based on the state we popped back to
+     and the rule number reduced by.  */
+
+  yyn = yyr1[yyn];
+
+  yystate = yypgoto[yyn - YYNTBASE] + *yyssp;
+  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == *yyssp)
+    yystate = yytable[yystate];
+  else
+    yystate = yydefgoto[yyn - YYNTBASE];
+
+  goto yynewstate;
+
+yyerrlab:   /* here on detecting error */
+
+  if (! yyerrstatus)
+    /* If not already recovering from an error, report this error.  */
+    {
+      ++yynerrs;
+
+#ifdef YYERROR_VERBOSE
+      yyn = yypact[yystate];
+
+      if (yyn > YYFLAG && yyn < YYLAST)
+	{
+	  int size = 0;
+	  char *msg;
+	  int x, count;
+
+	  count = 0;
+	  /* Start X at -yyn if nec to avoid negative indexes in yycheck.  */
+	  for (x = (yyn < 0 ? -yyn : 0);
+	       x < (sizeof(yytname) / sizeof(char *)); x++)
+	    if (yycheck[x + yyn] == x)
+	      size += strlen(yytname[x]) + 15, count++;
+	  msg = (char *) malloc(size + 15);
+	  if (msg != 0)
+	    {
+	      strcpy(msg, "parse error");
+
+	      if (count < 5)
+		{
+		  count = 0;
+		  for (x = (yyn < 0 ? -yyn : 0);
+		       x < (sizeof(yytname) / sizeof(char *)); x++)
+		    if (yycheck[x + yyn] == x)
+		      {
+			strcat(msg, count == 0 ? ", expecting `" : " or `");
+			strcat(msg, yytname[x]);
+			strcat(msg, "'");
+			count++;
+		      }
+		}
+	      yyerror(msg);
+	      free(msg);
+	    }
+	  else
+	    yyerror ("parse error; also virtual memory exceeded");
+	}
+      else
+#endif /* YYERROR_VERBOSE */
+	yyerror("parse error");
+    }
+
+  goto yyerrlab1;
+yyerrlab1:   /* here on error raised explicitly by an action */
+
+  if (yyerrstatus == 3)
+    {
+      /* if just tried and failed to reuse lookahead token after an error, discard it.  */
+
+      /* return failure if at end of input */
+      if (yychar == YYEOF)
+	YYABORT;
+
+#if YYDEBUG != 0
+      if (yydebug)
+	fprintf(stderr, "Discarding token %d (%s).\n", yychar, yytname[yychar1]);
+#endif
+
+      yychar = YYEMPTY;
+    }
+
+  /* Else will try to reuse lookahead token
+     after shifting the error token.  */
+
+  yyerrstatus = 3;		/* Each real token shifted decrements this */
+
+  goto yyerrhandle;
+
+yyerrdefault:  /* current state does not do anything special for the error token. */
+
+#if 0
+  /* This is wrong; only states that explicitly want error tokens
+     should shift them.  */
+  yyn = yydefact[yystate];  /* If its default is to accept any token, ok.  Otherwise pop it.*/
+  if (yyn) goto yydefault;
+#endif
+
+yyerrpop:   /* pop the current state because it cannot handle the error token */
+
+  if (yyssp == yyss) YYABORT;
+  yyvsp--;
+  yystate = *--yyssp;
+#ifdef YYLSP_NEEDED
+  yylsp--;
+#endif
+
+#if YYDEBUG != 0
+  if (yydebug)
+    {
+      short *ssp1 = yyss - 1;
+      fprintf (stderr, "Error: state stack now");
+      while (ssp1 != yyssp)
+	fprintf (stderr, " %d", *++ssp1);
+      fprintf (stderr, "\n");
+    }
+#endif
+
+yyerrhandle:
+
+  yyn = yypact[yystate];
+  if (yyn == YYFLAG)
+    goto yyerrdefault;
+
+  yyn += YYTERROR;
+  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
+    goto yyerrdefault;
+
+  yyn = yytable[yyn];
+  if (yyn < 0)
+    {
+      if (yyn == YYFLAG)
+	goto yyerrpop;
+      yyn = -yyn;
+      goto yyreduce;
+    }
+  else if (yyn == 0)
+    goto yyerrpop;
+
+  if (yyn == YYFINAL)
+    YYACCEPT;
+
+#if YYDEBUG != 0
+  if (yydebug)
+    fprintf(stderr, "Shifting error token, ");
+#endif
+
+  *++yyvsp = yylval;
+#ifdef YYLSP_NEEDED
+  *++yylsp = yylloc;
+#endif
+
+  yystate = yyn;
+  goto yynewstate;
+
+ yyacceptlab:
+  /* YYACCEPT comes here.  */
+  if (yyfree_stacks)
+    {
+      free (yyss);
+      free (yyvs);
+#ifdef YYLSP_NEEDED
+      free (yyls);
+#endif
+    }
+  return 0;
+
+ yyabortlab:
+  /* YYABORT comes here.  */
+  if (yyfree_stacks)
+    {
+      free (yyss);
+      free (yyvs);
+#ifdef YYLSP_NEEDED
+      free (yyls);
+#endif
+    }
+  return 1;
+}
+#line 229 "plural.y"
+
+
+void
+internal_function
+FREE_EXPRESSION (exp)
+     struct expression *exp;
+{
+  if (exp == NULL)
+    return;
+
+  /* Handle the recursive case.  */
+  switch (exp->nargs)
+    {
+    case 3:
+      FREE_EXPRESSION (exp->val.args[2]);
+      /* FALLTHROUGH */
+    case 2:
+      FREE_EXPRESSION (exp->val.args[1]);
+      /* FALLTHROUGH */
+    case 1:
+      FREE_EXPRESSION (exp->val.args[0]);
+      /* FALLTHROUGH */
+    default:
+      break;
+    }
+
+  free (exp);
+}
+
+
+static int
+yylex (lval, pexp)
+     YYSTYPE *lval;
+     const char **pexp;
+{
+  const char *exp = *pexp;
+  int result;
+
+  while (1)
+    {
+      if (exp[0] == '\0')
+	{
+	  *pexp = exp;
+	  return YYEOF;
+	}
+
+      if (exp[0] != ' ' && exp[0] != '\t')
+	break;
+
+      ++exp;
+    }
+
+  result = *exp++;
+  switch (result)
+    {
+    case '0': case '1': case '2': case '3': case '4':
+    case '5': case '6': case '7': case '8': case '9':
+      {
+	unsigned long int n = result - '0';
+	while (exp[0] >= '0' && exp[0] <= '9')
+	  {
+	    n *= 10;
+	    n += exp[0] - '0';
+	    ++exp;
+	  }
+	lval->num = n;
+	result = NUMBER;
+      }
+      break;
+
+    case '=':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = equal;
+	  result = EQUOP2;
+	}
+      else
+	result = YYERRCODE;
+      break;
+
+    case '!':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = not_equal;
+	  result = EQUOP2;
+	}
+      break;
+
+    case '&':
+    case '|':
+      if (exp[0] == result)
+	++exp;
+      else
+	result = YYERRCODE;
+      break;
+
+    case '<':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = less_or_equal;
+	}
+      else
+	lval->op = less_than;
+      result = CMPOP2;
+      break;
+
+    case '>':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = greater_or_equal;
+	}
+      else
+	lval->op = greater_than;
+      result = CMPOP2;
+      break;
+
+    case '*':
+      lval->op = mult;
+      result = MULOP2;
+      break;
+
+    case '/':
+      lval->op = divide;
+      result = MULOP2;
+      break;
+
+    case '%':
+      lval->op = module;
+      result = MULOP2;
+      break;
+
+    case '+':
+      lval->op = plus;
+      result = ADDOP2;
+      break;
+
+    case '-':
+      lval->op = minus;
+      result = ADDOP2;
+      break;
+
+    case 'n':
+    case '?':
+    case ':':
+    case '(':
+    case ')':
+      /* Nothing, just return the character.  */
+      break;
+
+    case ';':
+    case '\n':
+    case '\0':
+      /* Be safe and let the user call this function again.  */
+      --exp;
+      result = YYEOF;
+      break;
+
+    default:
+      result = YYERRCODE;
+#if YYDEBUG != 0
+      --exp;
+#endif
+      break;
+    }
+
+  *pexp = exp;
+
+  return result;
+}
+
+
+static void
+yyerror (str)
+     const char *str;
+{
+  /* Do nothing.  We don't print error messages here.  */
+}
diff -Nur dillo-0.8.0/intl/plural-exp.c dillo-0.8.0.new/intl/plural-exp.c
--- dillo-0.8.0/intl/plural-exp.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/plural-exp.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,156 @@
+/* Expression parsing for plural form selection.
+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   Written by Ulrich Drepper <drepper@cygnus.com>, 2000.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <ctype.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "plural-exp.h"
+
+#if (defined __GNUC__ && !defined __APPLE_CC__) \
+    || (defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L)
+
+/* These structs are the constant expression for the germanic plural
+   form determination.  It represents the expression  "n != 1".  */
+static const struct expression plvar =
+{
+  .nargs = 0,
+  .operation = var,
+};
+static const struct expression plone =
+{
+  .nargs = 0,
+  .operation = num,
+  .val =
+  {
+    .num = 1
+  }
+};
+struct expression GERMANIC_PLURAL =
+{
+  .nargs = 2,
+  .operation = not_equal,
+  .val =
+  {
+    .args =
+    {
+      [0] = (struct expression *) &plvar,
+      [1] = (struct expression *) &plone
+    }
+  }
+};
+
+# define INIT_GERMANIC_PLURAL()
+
+#else
+
+/* For compilers without support for ISO C 99 struct/union initializers:
+   Initialization at run-time.  */
+
+static struct expression plvar;
+static struct expression plone;
+struct expression GERMANIC_PLURAL;
+
+static void
+init_germanic_plural ()
+{
+  if (plone.val.num == 0)
+    {
+      plvar.nargs = 0;
+      plvar.operation = var;
+
+      plone.nargs = 0;
+      plone.operation = num;
+      plone.val.num = 1;
+
+      GERMANIC_PLURAL.nargs = 2;
+      GERMANIC_PLURAL.operation = not_equal;
+      GERMANIC_PLURAL.val.args[0] = &plvar;
+      GERMANIC_PLURAL.val.args[1] = &plone;
+    }
+}
+
+# define INIT_GERMANIC_PLURAL() init_germanic_plural ()
+
+#endif
+
+void
+internal_function
+EXTRACT_PLURAL_EXPRESSION (nullentry, pluralp, npluralsp)
+     const char *nullentry;
+     struct expression **pluralp;
+     unsigned long int *npluralsp;
+{
+  if (nullentry != NULL)
+    {
+      const char *plural;
+      const char *nplurals;
+
+      plural = strstr (nullentry, "plural=");
+      nplurals = strstr (nullentry, "nplurals=");
+      if (plural == NULL || nplurals == NULL)
+	goto no_plural;
+      else
+	{
+	  char *endp;
+	  unsigned long int n;
+	  struct parse_args args;
+
+	  /* First get the number.  */
+	  nplurals += 9;
+	  while (*nplurals != '\0' && isspace ((unsigned char) *nplurals))
+	    ++nplurals;
+	  if (!(*nplurals >= '0' && *nplurals <= '9'))
+	    goto no_plural;
+#if defined HAVE_STRTOUL || defined _LIBC
+	  n = strtoul (nplurals, &endp, 10);
+#else
+	  for (endp = nplurals, n = 0; *endp >= '0' && *endp <= '9'; endp++)
+	    n = n * 10 + (*endp - '0');
+#endif
+	  if (nplurals == endp)
+	    goto no_plural;
+	  *npluralsp = n;
+
+	  /* Due to the restrictions bison imposes onto the interface of the
+	     scanner function we have to put the input string and the result
+	     passed up from the parser into the same structure which address
+	     is passed down to the parser.  */
+	  plural += 7;
+	  args.cp = plural;
+	  if (PLURAL_PARSE (&args) != 0)
+	    goto no_plural;
+	  *pluralp = args.res;
+	}
+    }
+  else
+    {
+      /* By default we are using the Germanic form: singular form only
+         for `one', the plural form otherwise.  Yes, this is also what
+         English is using since English is a Germanic language.  */
+    no_plural:
+      INIT_GERMANIC_PLURAL ();
+      *pluralp = &GERMANIC_PLURAL;
+      *npluralsp = 2;
+    }
+}
diff -Nur dillo-0.8.0/intl/plural-exp.h dillo-0.8.0.new/intl/plural-exp.h
--- dillo-0.8.0/intl/plural-exp.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/plural-exp.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,126 @@
+/* Expression parsing and evaluation for plural form selection.
+   Copyright (C) 2000, 2001, 2002 Free Software Foundation, Inc.
+   Written by Ulrich Drepper <drepper@cygnus.com>, 2000.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifndef _PLURAL_EXP_H
+#define _PLURAL_EXP_H
+
+#ifndef PARAMS
+# if __STDC__ || defined __GNUC__ || defined __SUNPRO_C || defined __cplusplus || __PROTOTYPES
+#  define PARAMS(args) args
+# else
+#  define PARAMS(args) ()
+# endif
+#endif
+
+#ifndef internal_function
+# define internal_function
+#endif
+
+#ifndef attribute_hidden
+# define attribute_hidden
+#endif
+
+
+/* This is the representation of the expressions to determine the
+   plural form.  */
+struct expression
+{
+  int nargs;			/* Number of arguments.  */
+  enum operator
+  {
+    /* Without arguments:  */
+    var,			/* The variable "n".  */
+    num,			/* Decimal number.  */
+    /* Unary operators:  */
+    lnot,			/* Logical NOT.  */
+    /* Binary operators:  */
+    mult,			/* Multiplication.  */
+    divide,			/* Division.  */
+    module,			/* Modulo operation.  */
+    plus,			/* Addition.  */
+    minus,			/* Subtraction.  */
+    less_than,			/* Comparison.  */
+    greater_than,		/* Comparison.  */
+    less_or_equal,		/* Comparison.  */
+    greater_or_equal,		/* Comparison.  */
+    equal,			/* Comparison for equality.  */
+    not_equal,			/* Comparison for inequality.  */
+    land,			/* Logical AND.  */
+    lor,			/* Logical OR.  */
+    /* Ternary operators:  */
+    qmop			/* Question mark operator.  */
+  } operation;
+  union
+  {
+    unsigned long int num;	/* Number value for `num'.  */
+    struct expression *args[3];	/* Up to three arguments.  */
+  } val;
+};
+
+/* This is the data structure to pass information to the parser and get
+   the result in a thread-safe way.  */
+struct parse_args
+{
+  const char *cp;
+  struct expression *res;
+};
+
+
+/* Names for the libintl functions are a problem.  This source code is used
+   1. in the GNU C Library library,
+   2. in the GNU libintl library,
+   3. in the GNU gettext tools.
+   The function names in each situation must be different, to allow for
+   binary incompatible changes in 'struct expression'.  Furthermore,
+   1. in the GNU C Library library, the names have a __ prefix,
+   2.+3. in the GNU libintl library and in the GNU gettext tools, the names
+         must follow ANSI C and not start with __.
+   So we have to distinguish the three cases.  */
+#ifdef _LIBC
+# define FREE_EXPRESSION __gettext_free_exp
+# define PLURAL_PARSE __gettextparse
+# define GERMANIC_PLURAL __gettext_germanic_plural
+# define EXTRACT_PLURAL_EXPRESSION __gettext_extract_plural
+#elif defined (IN_LIBINTL)
+# define FREE_EXPRESSION libintl_gettext_free_exp
+# define PLURAL_PARSE libintl_gettextparse
+# define GERMANIC_PLURAL libintl_gettext_germanic_plural
+# define EXTRACT_PLURAL_EXPRESSION libintl_gettext_extract_plural
+#else
+# define FREE_EXPRESSION free_plural_expression
+# define PLURAL_PARSE parse_plural_expression
+# define GERMANIC_PLURAL germanic_plural
+# define EXTRACT_PLURAL_EXPRESSION extract_plural_expression
+#endif
+
+extern void FREE_EXPRESSION PARAMS ((struct expression *exp))
+     internal_function;
+extern int PLURAL_PARSE PARAMS ((void *arg));
+extern struct expression GERMANIC_PLURAL attribute_hidden;
+extern void EXTRACT_PLURAL_EXPRESSION PARAMS ((const char *nullentry,
+					       struct expression **pluralp,
+					       unsigned long int *npluralsp))
+     internal_function;
+
+#if !defined (_LIBC) && !defined (IN_LIBINTL)
+extern unsigned long int plural_eval PARAMS ((struct expression *pexp,
+					      unsigned long int n));
+#endif
+
+#endif /* _PLURAL_EXP_H */
diff -Nur dillo-0.8.0/intl/plural.y dillo-0.8.0.new/intl/plural.y
--- dillo-0.8.0/intl/plural.y	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/plural.y	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,409 @@
+%{
+/* Expression parsing for plural form selection.
+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
+   Written by Ulrich Drepper <drepper@cygnus.com>, 2000.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+/* The bison generated parser uses alloca.  AIX 3 forces us to put this
+   declaration at the beginning of the file.  The declaration in bison's
+   skeleton file comes too late.  This must come before <config.h>
+   because <config.h> may include arbitrary system headers.  */
+#if defined _AIX && !defined __GNUC__
+ #pragma alloca
+#endif
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <stddef.h>
+#include <stdlib.h>
+#include "plural-exp.h"
+
+/* The main function generated by the parser is called __gettextparse,
+   but we want it to be called PLURAL_PARSE.  */
+#ifndef _LIBC
+# define __gettextparse PLURAL_PARSE
+#endif
+
+#define YYLEX_PARAM	&((struct parse_args *) arg)->cp
+#define YYPARSE_PARAM	arg
+%}
+%pure_parser
+%expect 7
+
+%union {
+  unsigned long int num;
+  enum operator op;
+  struct expression *exp;
+}
+
+%{
+/* Prototypes for local functions.  */
+static struct expression *new_exp PARAMS ((int nargs, enum operator op,
+					   struct expression * const *args));
+static inline struct expression *new_exp_0 PARAMS ((enum operator op));
+static inline struct expression *new_exp_1 PARAMS ((enum operator op,
+						   struct expression *right));
+static struct expression *new_exp_2 PARAMS ((enum operator op,
+					     struct expression *left,
+					     struct expression *right));
+static inline struct expression *new_exp_3 PARAMS ((enum operator op,
+						   struct expression *bexp,
+						   struct expression *tbranch,
+						   struct expression *fbranch));
+static int yylex PARAMS ((YYSTYPE *lval, const char **pexp));
+static void yyerror PARAMS ((const char *str));
+
+/* Allocation of expressions.  */
+
+static struct expression *
+new_exp (nargs, op, args)
+     int nargs;
+     enum operator op;
+     struct expression * const *args;
+{
+  int i;
+  struct expression *newp;
+
+  /* If any of the argument could not be malloc'ed, just return NULL.  */
+  for (i = nargs - 1; i >= 0; i--)
+    if (args[i] == NULL)
+      goto fail;
+
+  /* Allocate a new expression.  */
+  newp = (struct expression *) malloc (sizeof (*newp));
+  if (newp != NULL)
+    {
+      newp->nargs = nargs;
+      newp->operation = op;
+      for (i = nargs - 1; i >= 0; i--)
+	newp->val.args[i] = args[i];
+      return newp;
+    }
+
+ fail:
+  for (i = nargs - 1; i >= 0; i--)
+    FREE_EXPRESSION (args[i]);
+
+  return NULL;
+}
+
+static inline struct expression *
+new_exp_0 (op)
+     enum operator op;
+{
+  return new_exp (0, op, NULL);
+}
+
+static inline struct expression *
+new_exp_1 (op, right)
+     enum operator op;
+     struct expression *right;
+{
+  struct expression *args[1];
+
+  args[0] = right;
+  return new_exp (1, op, args);
+}
+
+static struct expression *
+new_exp_2 (op, left, right)
+     enum operator op;
+     struct expression *left;
+     struct expression *right;
+{
+  struct expression *args[2];
+
+  args[0] = left;
+  args[1] = right;
+  return new_exp (2, op, args);
+}
+
+static inline struct expression *
+new_exp_3 (op, bexp, tbranch, fbranch)
+     enum operator op;
+     struct expression *bexp;
+     struct expression *tbranch;
+     struct expression *fbranch;
+{
+  struct expression *args[3];
+
+  args[0] = bexp;
+  args[1] = tbranch;
+  args[2] = fbranch;
+  return new_exp (3, op, args);
+}
+
+%}
+
+/* This declares that all operators have the same associativity and the
+   precedence order as in C.  See [Harbison, Steele: C, A Reference Manual].
+   There is no unary minus and no bitwise operators.
+   Operators with the same syntactic behaviour have been merged into a single
+   token, to save space in the array generated by bison.  */
+%right '?'		/*   ?		*/
+%left '|'		/*   ||		*/
+%left '&'		/*   &&		*/
+%left EQUOP2		/*   == !=	*/
+%left CMPOP2		/*   < > <= >=	*/
+%left ADDOP2		/*   + -	*/
+%left MULOP2		/*   * / %	*/
+%right '!'		/*   !		*/
+
+%token <op> EQUOP2 CMPOP2 ADDOP2 MULOP2
+%token <num> NUMBER
+%type <exp> exp
+
+%%
+
+start:	  exp
+	  {
+	    if ($1 == NULL)
+	      YYABORT;
+	    ((struct parse_args *) arg)->res = $1;
+	  }
+	;
+
+exp:	  exp '?' exp ':' exp
+	  {
+	    $$ = new_exp_3 (qmop, $1, $3, $5);
+	  }
+	| exp '|' exp
+	  {
+	    $$ = new_exp_2 (lor, $1, $3);
+	  }
+	| exp '&' exp
+	  {
+	    $$ = new_exp_2 (land, $1, $3);
+	  }
+	| exp EQUOP2 exp
+	  {
+	    $$ = new_exp_2 ($2, $1, $3);
+	  }
+	| exp CMPOP2 exp
+	  {
+	    $$ = new_exp_2 ($2, $1, $3);
+	  }
+	| exp ADDOP2 exp
+	  {
+	    $$ = new_exp_2 ($2, $1, $3);
+	  }
+	| exp MULOP2 exp
+	  {
+	    $$ = new_exp_2 ($2, $1, $3);
+	  }
+	| '!' exp
+	  {
+	    $$ = new_exp_1 (lnot, $2);
+	  }
+	| 'n'
+	  {
+	    $$ = new_exp_0 (var);
+	  }
+	| NUMBER
+	  {
+	    if (($$ = new_exp_0 (num)) != NULL)
+	      $$->val.num = $1;
+	  }
+	| '(' exp ')'
+	  {
+	    $$ = $2;
+	  }
+	;
+
+%%
+
+void
+internal_function
+FREE_EXPRESSION (exp)
+     struct expression *exp;
+{
+  if (exp == NULL)
+    return;
+
+  /* Handle the recursive case.  */
+  switch (exp->nargs)
+    {
+    case 3:
+      FREE_EXPRESSION (exp->val.args[2]);
+      /* FALLTHROUGH */
+    case 2:
+      FREE_EXPRESSION (exp->val.args[1]);
+      /* FALLTHROUGH */
+    case 1:
+      FREE_EXPRESSION (exp->val.args[0]);
+      /* FALLTHROUGH */
+    default:
+      break;
+    }
+
+  free (exp);
+}
+
+
+static int
+yylex (lval, pexp)
+     YYSTYPE *lval;
+     const char **pexp;
+{
+  const char *exp = *pexp;
+  int result;
+
+  while (1)
+    {
+      if (exp[0] == '\0')
+	{
+	  *pexp = exp;
+	  return YYEOF;
+	}
+
+      if (exp[0] != ' ' && exp[0] != '\t')
+	break;
+
+      ++exp;
+    }
+
+  result = *exp++;
+  switch (result)
+    {
+    case '0': case '1': case '2': case '3': case '4':
+    case '5': case '6': case '7': case '8': case '9':
+      {
+	unsigned long int n = result - '0';
+	while (exp[0] >= '0' && exp[0] <= '9')
+	  {
+	    n *= 10;
+	    n += exp[0] - '0';
+	    ++exp;
+	  }
+	lval->num = n;
+	result = NUMBER;
+      }
+      break;
+
+    case '=':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = equal;
+	  result = EQUOP2;
+	}
+      else
+	result = YYERRCODE;
+      break;
+
+    case '!':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = not_equal;
+	  result = EQUOP2;
+	}
+      break;
+
+    case '&':
+    case '|':
+      if (exp[0] == result)
+	++exp;
+      else
+	result = YYERRCODE;
+      break;
+
+    case '<':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = less_or_equal;
+	}
+      else
+	lval->op = less_than;
+      result = CMPOP2;
+      break;
+
+    case '>':
+      if (exp[0] == '=')
+	{
+	  ++exp;
+	  lval->op = greater_or_equal;
+	}
+      else
+	lval->op = greater_than;
+      result = CMPOP2;
+      break;
+
+    case '*':
+      lval->op = mult;
+      result = MULOP2;
+      break;
+
+    case '/':
+      lval->op = divide;
+      result = MULOP2;
+      break;
+
+    case '%':
+      lval->op = module;
+      result = MULOP2;
+      break;
+
+    case '+':
+      lval->op = plus;
+      result = ADDOP2;
+      break;
+
+    case '-':
+      lval->op = minus;
+      result = ADDOP2;
+      break;
+
+    case 'n':
+    case '?':
+    case ':':
+    case '(':
+    case ')':
+      /* Nothing, just return the character.  */
+      break;
+
+    case ';':
+    case '\n':
+    case '\0':
+      /* Be safe and let the user call this function again.  */
+      --exp;
+      result = YYEOF;
+      break;
+
+    default:
+      result = YYERRCODE;
+#if YYDEBUG != 0
+      --exp;
+#endif
+      break;
+    }
+
+  *pexp = exp;
+
+  return result;
+}
+
+
+static void
+yyerror (str)
+     const char *str;
+{
+  /* Do nothing.  We don't print error messages here.  */
+}
diff -Nur dillo-0.8.0/intl/ref-add.sin dillo-0.8.0.new/intl/ref-add.sin
--- dillo-0.8.0/intl/ref-add.sin	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/ref-add.sin	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,31 @@
+# Add this package to a list of references stored in a text file.
+#
+#   Copyright (C) 2000 Free Software Foundation, Inc.
+#
+#   This program is free software; you can redistribute it and/or modify it
+#   under the terms of the GNU Library General Public License as published
+#   by the Free Software Foundation; either version 2, or (at your option)
+#   any later version.
+#
+#   This program is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Library General Public License for more details.
+#
+#   You should have received a copy of the GNU Library General Public
+#   License along with this program; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+#   USA.
+#
+# Written by Bruno Haible <haible@clisp.cons.org>.
+#
+/^# Packages using this file: / {
+  s/# Packages using this file://
+  ta
+  :a
+  s/ @PACKAGE@ / @PACKAGE@ /
+  tb
+  s/ $/ @PACKAGE@ /
+  :b
+  s/^/# Packages using this file:/
+}
diff -Nur dillo-0.8.0/intl/ref-del.sin dillo-0.8.0.new/intl/ref-del.sin
--- dillo-0.8.0/intl/ref-del.sin	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/ref-del.sin	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,26 @@
+# Remove this package from a list of references stored in a text file.
+#
+#   Copyright (C) 2000 Free Software Foundation, Inc.
+#
+#   This program is free software; you can redistribute it and/or modify it
+#   under the terms of the GNU Library General Public License as published
+#   by the Free Software Foundation; either version 2, or (at your option)
+#   any later version.
+#
+#   This program is distributed in the hope that it will be useful,
+#   but WITHOUT ANY WARRANTY; without even the implied warranty of
+#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+#   Library General Public License for more details.
+#
+#   You should have received a copy of the GNU Library General Public
+#   License along with this program; if not, write to the Free Software
+#   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+#   USA.
+#
+# Written by Bruno Haible <haible@clisp.cons.org>.
+#
+/^# Packages using this file: / {
+  s/# Packages using this file://
+  s/ @PACKAGE@ / /
+  s/^/# Packages using this file:/
+}
diff -Nur dillo-0.8.0/intl/textdomain.c dillo-0.8.0.new/intl/textdomain.c
--- dillo-0.8.0/intl/textdomain.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/textdomain.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,142 @@
+/* Implementation of the textdomain(3) function.
+   Copyright (C) 1995-1998, 2000, 2001, 2002 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Library General Public License as published
+   by the Free Software Foundation; either version 2, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+   USA.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef _LIBC
+# include <libintl.h>
+#else
+# include "libgnuintl.h"
+#endif
+#include "gettextP.h"
+
+#ifdef _LIBC
+/* We have to handle multi-threaded applications.  */
+# include <bits/libc-lock.h>
+#else
+/* Provide dummy implementation if this is outside glibc.  */
+# define __libc_rwlock_define(CLASS, NAME)
+# define __libc_rwlock_wrlock(NAME)
+# define __libc_rwlock_unlock(NAME)
+#endif
+
+/* The internal variables in the standalone libintl.a must have different
+   names than the internal variables in GNU libc, otherwise programs
+   using libintl.a cannot be linked statically.  */
+#if !defined _LIBC
+# define _nl_default_default_domain libintl_nl_default_default_domain
+# define _nl_current_default_domain libintl_nl_current_default_domain
+#endif
+
+/* @@ end of prolog @@ */
+
+/* Name of the default text domain.  */
+extern const char _nl_default_default_domain[] attribute_hidden;
+
+/* Default text domain in which entries for gettext(3) are to be found.  */
+extern const char *_nl_current_default_domain attribute_hidden;
+
+
+/* Names for the libintl functions are a problem.  They must not clash
+   with existing names and they should follow ANSI C.  But this source
+   code is also used in GNU C Library where the names have a __
+   prefix.  So we have to make a difference here.  */
+#ifdef _LIBC
+# define TEXTDOMAIN __textdomain
+# ifndef strdup
+#  define strdup(str) __strdup (str)
+# endif
+#else
+# define TEXTDOMAIN libintl_textdomain
+#endif
+
+/* Lock variable to protect the global data in the gettext implementation.  */
+__libc_rwlock_define (extern, _nl_state_lock attribute_hidden)
+
+/* Set the current default message catalog to DOMAINNAME.
+   If DOMAINNAME is null, return the current default.
+   If DOMAINNAME is "", reset to the default of "messages".  */
+char *
+TEXTDOMAIN (domainname)
+     const char *domainname;
+{
+  char *new_domain;
+  char *old_domain;
+
+  /* A NULL pointer requests the current setting.  */
+  if (domainname == NULL)
+    return (char *) _nl_current_default_domain;
+
+  __libc_rwlock_wrlock (_nl_state_lock);
+
+  old_domain = (char *) _nl_current_default_domain;
+
+  /* If domain name is the null string set to default domain "messages".  */
+  if (domainname[0] == '\0'
+      || strcmp (domainname, _nl_default_default_domain) == 0)
+    {
+      _nl_current_default_domain = _nl_default_default_domain;
+      new_domain = (char *) _nl_current_default_domain;
+    }
+  else if (strcmp (domainname, old_domain) == 0)
+    /* This can happen and people will use it to signal that some
+       environment variable changed.  */
+    new_domain = old_domain;
+  else
+    {
+      /* If the following malloc fails `_nl_current_default_domain'
+	 will be NULL.  This value will be returned and so signals we
+	 are out of core.  */
+#if defined _LIBC || defined HAVE_STRDUP
+      new_domain = strdup (domainname);
+#else
+      size_t len = strlen (domainname) + 1;
+      new_domain = (char *) malloc (len);
+      if (new_domain != NULL)
+	memcpy (new_domain, domainname, len);
+#endif
+
+      if (new_domain != NULL)
+	_nl_current_default_domain = new_domain;
+    }
+
+  /* We use this possibility to signal a change of the loaded catalogs
+     since this is most likely the case and there is no other easy we
+     to do it.  Do it only when the call was successful.  */
+  if (new_domain != NULL)
+    {
+      ++_nl_msg_cat_cntr;
+
+      if (old_domain != new_domain && old_domain != _nl_default_default_domain)
+	free (old_domain);
+    }
+
+  __libc_rwlock_unlock (_nl_state_lock);
+
+  return new_domain;
+}
+
+#ifdef _LIBC
+/* Alias for function name in GNU C Library.  */
+weak_alias (__textdomain, textdomain);
+#endif
diff -Nur dillo-0.8.0/intl/VERSION dillo-0.8.0.new/intl/VERSION
--- dillo-0.8.0/intl/VERSION	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/intl/VERSION	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1 @@
+GNU gettext library from gettext-0.11.4
diff -Nur dillo-0.8.0/m4/ChangeLog dillo-0.8.0.new/m4/ChangeLog
--- dillo-0.8.0/m4/ChangeLog	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/m4/ChangeLog	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,20 @@
+2003-10-01  gettextize  <bug-gnu-gettext@gnu.org>
+
+	* codeset.m4: New file, from gettext-0.11.4.
+	* gettext.m4: New file, from gettext-0.11.4.
+	* glibc21.m4: New file, from gettext-0.11.4.
+	* iconv.m4: New file, from gettext-0.11.4.
+	* intdiv0.m4: New file, from gettext-0.11.4.
+	* inttypes.m4: New file, from gettext-0.11.4.
+	* inttypes_h.m4: New file, from gettext-0.11.4.
+	* inttypes-pri.m4: New file, from gettext-0.11.4.
+	* isc-posix.m4: New file, from gettext-0.11.4.
+	* lcmessage.m4: New file, from gettext-0.11.4.
+	* lib-ld.m4: New file, from gettext-0.11.4.
+	* lib-link.m4: New file, from gettext-0.11.4.
+	* lib-prefix.m4: New file, from gettext-0.11.4.
+	* progtest.m4: New file, from gettext-0.11.4.
+	* stdint_h.m4: New file, from gettext-0.11.4.
+	* uintmax_t.m4: New file, from gettext-0.11.4.
+	* Makefile.am: New file.
+
diff -Nur dillo-0.8.0/m4/codeset.m4 dillo-0.8.0.new/m4/codeset.m4
--- dillo-0.8.0/m4/codeset.m4	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/m4/codeset.m4	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,23 @@
+# codeset.m4 serial AM1 (gettext-0.10.40)
+dnl Copyright (C) 2000-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Bruno Haible.
+
+AC_DEFUN([AM_LANGINFO_CODESET],
+[
+  AC_CACHE_CHECK([for nl_langinfo and CODESET], am_cv_langinfo_codeset,
+    [AC_TRY_LINK([#include <langinfo.h>],
+      [char* cs = nl_langinfo(CODESET);],
+      am_cv_langinfo_codeset=yes,
+      am_cv_langinfo_codeset=no)
+    ])
+  if test $am_cv_langinfo_codeset = yes; then
+    AC_DEFINE(HAVE_LANGINFO_CODESET, 1,
+      [Define if you have <langinfo.h> and nl_langinfo(CODESET).])
+  fi
+])
diff -Nur dillo-0.8.0/m4/gettext.m4 dillo-0.8.0.new/m4/gettext.m4
--- dillo-0.8.0/m4/gettext.m4	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/m4/gettext.m4	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,587 @@
+# gettext.m4 serial 16 (gettext-0.11.4)
+dnl Copyright (C) 1995-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+dnl
+dnl This file can can be used in projects which are not available under
+dnl the GNU General Public License or the GNU Library General Public
+dnl License but which still want to provide support for the GNU gettext
+dnl functionality.
+dnl Please note that the actual code of the GNU gettext library is covered
+dnl by the GNU Library General Public License, and the rest of the GNU
+dnl gettext package package is covered by the GNU General Public License.
+dnl They are *not* in the public domain.
+
+dnl Authors:
+dnl   Ulrich Drepper <drepper@cygnus.com>, 1995-2000.
+dnl   Bruno Haible <haible@clisp.cons.org>, 2000-2002.
+
+dnl Macro to add for using GNU gettext.
+
+dnl Usage: AM_GNU_GETTEXT([INTLSYMBOL], [NEEDSYMBOL], [INTLDIR]).
+dnl INTLSYMBOL can be one of 'external', 'no-libtool', 'use-libtool'. The
+dnl    default (if it is not specified or empty) is 'no-libtool'.
+dnl    INTLSYMBOL should be 'external' for packages with no intl directory,
+dnl    and 'no-libtool' or 'use-libtool' for packages with an intl directory.
+dnl    If INTLSYMBOL is 'use-libtool', then a libtool library
+dnl    $(top_builddir)/intl/libintl.la will be created (shared and/or static,
+dnl    depending on --{enable,disable}-{shared,static} and on the presence of
+dnl    AM-DISABLE-SHARED). If INTLSYMBOL is 'no-libtool', a static library
+dnl    $(top_builddir)/intl/libintl.a will be created.
+dnl If NEEDSYMBOL is specified and is 'need-ngettext', then GNU gettext
+dnl    implementations (in libc or libintl) without the ngettext() function
+dnl    will be ignored.  If NEEDSYMBOL is specified and is
+dnl    'need-formatstring-macros', then GNU gettext implementations that don't
+dnl    support the ISO C 99 <inttypes.h> formatstring macros will be ignored.
+dnl INTLDIR is used to find the intl libraries.  If empty,
+dnl    the value `$(top_builddir)/intl/' is used.
+dnl
+dnl The result of the configuration is one of three cases:
+dnl 1) GNU gettext, as included in the intl subdirectory, will be compiled
+dnl    and used.
+dnl    Catalog format: GNU --> install in $(datadir)
+dnl    Catalog extension: .mo after installation, .gmo in source tree
+dnl 2) GNU gettext has been found in the system's C library.
+dnl    Catalog format: GNU --> install in $(datadir)
+dnl    Catalog extension: .mo after installation, .gmo in source tree
+dnl 3) No internationalization, always use English msgid.
+dnl    Catalog format: none
+dnl    Catalog extension: none
+dnl If INTLSYMBOL is 'external', only cases 2 and 3 can occur.
+dnl The use of .gmo is historical (it was needed to avoid overwriting the
+dnl GNU format catalogs when building on a platform with an X/Open gettext),
+dnl but we keep it in order not to force irrelevant filename changes on the
+dnl maintainers.
+dnl
+AC_DEFUN([AM_GNU_GETTEXT],
+[
+  dnl Argument checking.
+  ifelse([$1], [], , [ifelse([$1], [external], , [ifelse([$1], [no-libtool], , [ifelse([$1], [use-libtool], ,
+    [errprint([ERROR: invalid first argument to AM_GNU_GETTEXT
+])])])])])
+  ifelse([$2], [], , [ifelse([$2], [need-ngettext], , [ifelse([$2], [need-formatstring-macros], ,
+    [errprint([ERROR: invalid second argument to AM_GNU_GETTEXT
+])])])])
+  define(gt_included_intl, ifelse([$1], [external], [no], [yes]))
+  define(gt_libtool_suffix_prefix, ifelse([$1], [use-libtool], [l], []))
+
+  AC_REQUIRE([AM_PO_SUBDIRS])dnl
+  ifelse(gt_included_intl, yes, [
+    AC_REQUIRE([AM_INTL_SUBDIR])dnl
+  ])
+
+  dnl Prerequisites of AC_LIB_LINKFLAGS_BODY.
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+
+  dnl Sometimes libintl requires libiconv, so first search for libiconv.
+  dnl Ideally we would do this search only after the
+  dnl      if test "$USE_NLS" = "yes"; then
+  dnl        if test "$gt_cv_func_gnugettext_libc" != "yes"; then
+  dnl tests. But if configure.in invokes AM_ICONV after AM_GNU_GETTEXT
+  dnl the configure script would need to contain the same shell code
+  dnl again, outside any 'if'. There are two solutions:
+  dnl - Invoke AM_ICONV_LINKFLAGS_BODY here, outside any 'if'.
+  dnl - Control the expansions in more detail using AC_PROVIDE_IFELSE.
+  dnl Since AC_PROVIDE_IFELSE is only in autoconf >= 2.52 and not
+  dnl documented, we avoid it.
+  ifelse(gt_included_intl, yes, , [
+    AC_REQUIRE([AM_ICONV_LINKFLAGS_BODY])
+  ])
+
+  AC_MSG_CHECKING([whether NLS is requested])
+  dnl Default is enabled NLS
+  AC_ARG_ENABLE(nls,
+    [  --disable-nls           do not use Native Language Support],
+    USE_NLS=$enableval, USE_NLS=yes)
+  AC_MSG_RESULT($USE_NLS)
+  AC_SUBST(USE_NLS)
+
+  ifelse(gt_included_intl, yes, [
+    BUILD_INCLUDED_LIBINTL=no
+    USE_INCLUDED_LIBINTL=no
+  ])
+  LIBINTL=
+  LTLIBINTL=
+  POSUB=
+
+  dnl If we use NLS figure out what method
+  if test "$USE_NLS" = "yes"; then
+    gt_use_preinstalled_gnugettext=no
+    ifelse(gt_included_intl, yes, [
+      AC_MSG_CHECKING([whether included gettext is requested])
+      AC_ARG_WITH(included-gettext,
+        [  --with-included-gettext use the GNU gettext library included here],
+        nls_cv_force_use_gnu_gettext=$withval,
+        nls_cv_force_use_gnu_gettext=no)
+      AC_MSG_RESULT($nls_cv_force_use_gnu_gettext)
+
+      nls_cv_use_gnu_gettext="$nls_cv_force_use_gnu_gettext"
+      if test "$nls_cv_force_use_gnu_gettext" != "yes"; then
+    ])
+        dnl User does not insist on using GNU NLS library.  Figure out what
+        dnl to use.  If GNU gettext is available we use this.  Else we have
+        dnl to fall back to GNU NLS library.
+
+        dnl Add a version number to the cache macros.
+        define([gt_api_version], ifelse([$2], [need-formatstring-macros], 3, ifelse([$2], [need-ngettext], 2, 1)))
+        define([gt_cv_func_gnugettext_libc], [gt_cv_func_gnugettext]gt_api_version[_libc])
+        define([gt_cv_func_gnugettext_libintl], [gt_cv_func_gnugettext]gt_api_version[_libintl])
+
+        AC_CACHE_CHECK([for GNU gettext in libc], gt_cv_func_gnugettext_libc,
+         [AC_TRY_LINK([#include <libintl.h>
+]ifelse([$2], [need-formatstring-macros],
+[#ifndef __GNU_GETTEXT_SUPPORTED_REVISION
+#define __GNU_GETTEXT_SUPPORTED_REVISION(major) ((major) == 0 ? 0 : -1)
+#endif
+changequote(,)dnl
+typedef int array [2 * (__GNU_GETTEXT_SUPPORTED_REVISION(0) >= 1) - 1];
+changequote([,])dnl
+], [])[extern int _nl_msg_cat_cntr;
+extern int *_nl_domain_bindings;],
+            [bindtextdomain ("", "");
+return (int) gettext ("")]ifelse([$2], [need-ngettext], [ + (int) ngettext ("", "", 0)], [])[ + _nl_msg_cat_cntr + *_nl_domain_bindings],
+            gt_cv_func_gnugettext_libc=yes,
+            gt_cv_func_gnugettext_libc=no)])
+
+        if test "$gt_cv_func_gnugettext_libc" != "yes"; then
+          dnl Sometimes libintl requires libiconv, so first search for libiconv.
+          ifelse(gt_included_intl, yes, , [
+            AM_ICONV_LINK
+          ])
+          dnl Search for libintl and define LIBINTL, LTLIBINTL and INCINTL
+          dnl accordingly. Don't use AC_LIB_LINKFLAGS_BODY([intl],[iconv])
+          dnl because that would add "-liconv" to LIBINTL and LTLIBINTL
+          dnl even if libiconv doesn't exist.
+          AC_LIB_LINKFLAGS_BODY([intl])
+          AC_CACHE_CHECK([for GNU gettext in libintl],
+            gt_cv_func_gnugettext_libintl,
+           [gt_save_CPPFLAGS="$CPPFLAGS"
+            CPPFLAGS="$CPPFLAGS $INCINTL"
+            gt_save_LIBS="$LIBS"
+            LIBS="$LIBS $LIBINTL"
+            dnl Now see whether libintl exists and does not depend on libiconv.
+            AC_TRY_LINK([#include <libintl.h>
+]ifelse([$2], [need-formatstring-macros],
+[#ifndef __GNU_GETTEXT_SUPPORTED_REVISION
+#define __GNU_GETTEXT_SUPPORTED_REVISION(major) ((major) == 0 ? 0 : -1)
+#endif
+changequote(,)dnl
+typedef int array [2 * (__GNU_GETTEXT_SUPPORTED_REVISION(0) >= 1) - 1];
+changequote([,])dnl
+], [])[extern int _nl_msg_cat_cntr;
+extern
+#ifdef __cplusplus
+"C"
+#endif
+const char *_nl_expand_alias ();],
+              [bindtextdomain ("", "");
+return (int) gettext ("")]ifelse([$2], [need-ngettext], [ + (int) ngettext ("", "", 0)], [])[ + _nl_msg_cat_cntr + *_nl_expand_alias (0)],
+              gt_cv_func_gnugettext_libintl=yes,
+              gt_cv_func_gnugettext_libintl=no)
+            dnl Now see whether libintl exists and depends on libiconv.
+            if test "$gt_cv_func_gnugettext_libintl" != yes && test -n "$LIBICONV"; then
+              LIBS="$LIBS $LIBICONV"
+              AC_TRY_LINK([#include <libintl.h>
+]ifelse([$2], [need-formatstring-macros],
+[#ifndef __GNU_GETTEXT_SUPPORTED_REVISION
+#define __GNU_GETTEXT_SUPPORTED_REVISION(major) ((major) == 0 ? 0 : -1)
+#endif
+changequote(,)dnl
+typedef int array [2 * (__GNU_GETTEXT_SUPPORTED_REVISION(0) >= 1) - 1];
+changequote([,])dnl
+], [])[extern int _nl_msg_cat_cntr;
+extern
+#ifdef __cplusplus
+"C"
+#endif
+const char *_nl_expand_alias ();],
+                [bindtextdomain ("", "");
+return (int) gettext ("")]ifelse([$2], [need-ngettext], [ + (int) ngettext ("", "", 0)], [])[ + _nl_msg_cat_cntr + *_nl_expand_alias (0)],
+               [LIBINTL="$LIBINTL $LIBICONV"
+                LTLIBINTL="$LTLIBINTL $LTLIBICONV"
+                gt_cv_func_gnugettext_libintl=yes
+               ])
+            fi
+            CPPFLAGS="$gt_save_CPPFLAGS"
+            LIBS="$gt_save_LIBS"])
+        fi
+
+        dnl If an already present or preinstalled GNU gettext() is found,
+        dnl use it.  But if this macro is used in GNU gettext, and GNU
+        dnl gettext is already preinstalled in libintl, we update this
+        dnl libintl.  (Cf. the install rule in intl/Makefile.in.)
+        if test "$gt_cv_func_gnugettext_libc" = "yes" \
+           || { test "$gt_cv_func_gnugettext_libintl" = "yes" \
+                && test "$PACKAGE" != gettext; }; then
+          gt_use_preinstalled_gnugettext=yes
+        else
+          dnl Reset the values set by searching for libintl.
+          LIBINTL=
+          LTLIBINTL=
+          INCINTL=
+        fi
+
+    ifelse(gt_included_intl, yes, [
+        if test "$gt_use_preinstalled_gnugettext" != "yes"; then
+          dnl GNU gettext is not found in the C library.
+          dnl Fall back on included GNU gettext library.
+          nls_cv_use_gnu_gettext=yes
+        fi
+      fi
+
+      if test "$nls_cv_use_gnu_gettext" = "yes"; then
+        dnl Mark actions used to generate GNU NLS library.
+        INTLOBJS="\$(GETTOBJS)"
+        BUILD_INCLUDED_LIBINTL=yes
+        USE_INCLUDED_LIBINTL=yes
+        LIBINTL="ifelse([$3],[],\${top_builddir}/intl,[$3])/libintl.[]gt_libtool_suffix_prefix[]a $LIBICONV"
+        LTLIBINTL="ifelse([$3],[],\${top_builddir}/intl,[$3])/libintl.[]gt_libtool_suffix_prefix[]a $LTLIBICONV"
+        LIBS=`echo " $LIBS " | sed -e 's/ -lintl / /' -e 's/^ //' -e 's/ $//'`
+      fi
+
+      if test "$gt_use_preinstalled_gnugettext" = "yes" \
+         || test "$nls_cv_use_gnu_gettext" = "yes"; then
+        dnl Mark actions to use GNU gettext tools.
+        CATOBJEXT=.gmo
+      fi
+    ])
+
+    if test "$gt_use_preinstalled_gnugettext" = "yes" \
+       || test "$nls_cv_use_gnu_gettext" = "yes"; then
+      AC_DEFINE(ENABLE_NLS, 1,
+        [Define to 1 if translation of program messages to the user's native language
+   is requested.])
+    else
+      USE_NLS=no
+    fi
+  fi
+
+  if test "$USE_NLS" = "yes"; then
+
+    if test "$gt_use_preinstalled_gnugettext" = "yes"; then
+      if test "$gt_cv_func_gnugettext_libintl" = "yes"; then
+        AC_MSG_CHECKING([how to link with libintl])
+        AC_MSG_RESULT([$LIBINTL])
+        AC_LIB_APPENDTOVAR([CPPFLAGS], [$INCINTL])
+      fi
+
+      dnl For backward compatibility. Some packages may be using this.
+      AC_DEFINE(HAVE_GETTEXT, 1,
+       [Define if the GNU gettext() function is already present or preinstalled.])
+      AC_DEFINE(HAVE_DCGETTEXT, 1,
+       [Define if the GNU dcgettext() function is already present or preinstalled.])
+    fi
+
+    dnl We need to process the po/ directory.
+    POSUB=po
+  fi
+
+  ifelse(gt_included_intl, yes, [
+    dnl If this is used in GNU gettext we have to set BUILD_INCLUDED_LIBINTL
+    dnl to 'yes' because some of the testsuite requires it.
+    if test "$PACKAGE" = gettext; then
+      BUILD_INCLUDED_LIBINTL=yes
+    fi
+
+    dnl Make all variables we use known to autoconf.
+    AC_SUBST(BUILD_INCLUDED_LIBINTL)
+    AC_SUBST(USE_INCLUDED_LIBINTL)
+    AC_SUBST(CATOBJEXT)
+    AC_SUBST(INTLOBJS)
+
+    dnl For backward compatibility. Some configure.ins may be using this.
+    nls_cv_header_intl=
+    nls_cv_header_libgt=
+
+    dnl For backward compatibility. Some Makefiles may be using this.
+    DATADIRNAME=share
+    AC_SUBST(DATADIRNAME)
+
+    dnl For backward compatibility. Some Makefiles may be using this.
+    INSTOBJEXT=.mo
+    AC_SUBST(INSTOBJEXT)
+
+    dnl For backward compatibility. Some Makefiles may be using this.
+    GENCAT=gencat
+    AC_SUBST(GENCAT)
+
+    dnl Enable libtool support if the surrounding package wishes it.
+    INTL_LIBTOOL_SUFFIX_PREFIX=gt_libtool_suffix_prefix
+    AC_SUBST(INTL_LIBTOOL_SUFFIX_PREFIX)
+  ])
+
+  dnl For backward compatibility. Some Makefiles may be using this.
+  INTLLIBS="$LIBINTL"
+  AC_SUBST(INTLLIBS)
+
+  dnl Make all documented variables known to autoconf.
+  AC_SUBST(LIBINTL)
+  AC_SUBST(LTLIBINTL)
+  AC_SUBST(POSUB)
+])
+
+
+dnl Checks for all prerequisites of the po subdirectory,
+dnl except for USE_NLS.
+AC_DEFUN([AM_PO_SUBDIRS],
+[
+  AC_REQUIRE([AC_PROG_MAKE_SET])dnl
+  AC_REQUIRE([AC_PROG_INSTALL])dnl
+  AC_REQUIRE([AM_MKINSTALLDIRS])dnl
+
+  dnl Perform the following tests also if --disable-nls has been given,
+  dnl because they are needed for "make dist" to work.
+
+  dnl Search for GNU msgfmt in the PATH.
+  dnl The first test excludes Solaris msgfmt and early GNU msgfmt versions.
+  dnl The second test excludes FreeBSD msgfmt.
+  AM_PATH_PROG_WITH_TEST(MSGFMT, msgfmt,
+    [$ac_dir/$ac_word --statistics /dev/null >/dev/null 2>&1 &&
+     (if $ac_dir/$ac_word --statistics /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi)],
+    :)
+  AC_PATH_PROG(GMSGFMT, gmsgfmt, $MSGFMT)
+
+  dnl Search for GNU xgettext 0.11 or newer in the PATH.
+  dnl The first test excludes Solaris xgettext and early GNU xgettext versions.
+  dnl The second test excludes FreeBSD xgettext.
+  AM_PATH_PROG_WITH_TEST(XGETTEXT, xgettext,
+    [$ac_dir/$ac_word --omit-header --copyright-holder= /dev/null >/dev/null 2>&1 &&
+     (if $ac_dir/$ac_word --omit-header --copyright-holder= /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi)],
+    :)
+  dnl Remove leftover from FreeBSD xgettext call.
+  rm -f messages.po
+
+  dnl Search for GNU msgmerge 0.11 or newer in the PATH.
+  AM_PATH_PROG_WITH_TEST(MSGMERGE, msgmerge,
+    [$ac_dir/$ac_word --update -q /dev/null /dev/null >/dev/null 2>&1], :)
+
+  dnl This could go away some day; the PATH_PROG_WITH_TEST already does it.
+  dnl Test whether we really found GNU msgfmt.
+  if test "$GMSGFMT" != ":"; then
+    dnl If it is no GNU msgfmt we define it as : so that the
+    dnl Makefiles still can work.
+    if $GMSGFMT --statistics /dev/null >/dev/null 2>&1 &&
+       (if $GMSGFMT --statistics /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi); then
+      : ;
+    else
+      GMSGFMT=`echo "$GMSGFMT" | sed -e 's,^.*/,,'`
+      AC_MSG_RESULT(
+        [found $GMSGFMT program is not GNU msgfmt; ignore it])
+      GMSGFMT=":"
+    fi
+  fi
+
+  dnl This could go away some day; the PATH_PROG_WITH_TEST already does it.
+  dnl Test whether we really found GNU xgettext.
+  if test "$XGETTEXT" != ":"; then
+    dnl If it is no GNU xgettext we define it as : so that the
+    dnl Makefiles still can work.
+    if $XGETTEXT --omit-header --copyright-holder= /dev/null >/dev/null 2>&1 &&
+       (if $XGETTEXT --omit-header --copyright-holder= /dev/null 2>&1 >/dev/null | grep usage >/dev/null; then exit 1; else exit 0; fi); then
+      : ;
+    else
+      AC_MSG_RESULT(
+        [found xgettext program is not GNU xgettext; ignore it])
+      XGETTEXT=":"
+    fi
+    dnl Remove leftover from FreeBSD xgettext call.
+    rm -f messages.po
+  fi
+
+  AC_OUTPUT_COMMANDS([
+    for ac_file in $CONFIG_FILES; do
+      # Support "outfile[:infile[:infile...]]"
+      case "$ac_file" in
+        *:*) ac_file=`echo "$ac_file"|sed 's%:.*%%'` ;;
+      esac
+      # PO directories have a Makefile.in generated from Makefile.in.in.
+      case "$ac_file" in */Makefile.in)
+        # Adjust a relative srcdir.
+        ac_dir=`echo "$ac_file"|sed 's%/[^/][^/]*$%%'`
+        ac_dir_suffix="/`echo "$ac_dir"|sed 's%^\./%%'`"
+        ac_dots=`echo "$ac_dir_suffix"|sed 's%/[^/]*%../%g'`
+        # In autoconf-2.13 it is called $ac_given_srcdir.
+        # In autoconf-2.50 it is called $srcdir.
+        test -n "$ac_given_srcdir" || ac_given_srcdir="$srcdir"
+        case "$ac_given_srcdir" in
+          .)  top_srcdir=`echo $ac_dots|sed 's%/$%%'` ;;
+          /*) top_srcdir="$ac_given_srcdir" ;;
+          *)  top_srcdir="$ac_dots$ac_given_srcdir" ;;
+        esac
+        if test -f "$ac_given_srcdir/$ac_dir/POTFILES.in"; then
+          rm -f "$ac_dir/POTFILES"
+          test -n "$as_me" && echo "$as_me: creating $ac_dir/POTFILES" || echo "creating $ac_dir/POTFILES"
+          cat "$ac_given_srcdir/$ac_dir/POTFILES.in" | sed -e "/^#/d" -e "/^[ 	]*\$/d" -e "s,.*,     $top_srcdir/& \\\\," | sed -e "\$s/\(.*\) \\\\/\1/" > "$ac_dir/POTFILES"
+          # ALL_LINGUAS, POFILES, GMOFILES, UPDATEPOFILES, DUMMYPOFILES depend
+          # on $ac_dir but don't depend on user-specified configuration
+          # parameters.
+          if test -f "$ac_given_srcdir/$ac_dir/LINGUAS"; then
+            # The LINGUAS file contains the set of available languages.
+            if test -n "$ALL_LINGUAS"; then
+              test -n "$as_me" && echo "$as_me: setting ALL_LINGUAS in configure.in is obsolete" || echo "setting ALL_LINGUAS in configure.in is obsolete"
+            fi
+            ALL_LINGUAS_=`sed -e "/^#/d" "$ac_given_srcdir/$ac_dir/LINGUAS"`
+            # Hide the ALL_LINGUAS assigment from automake.
+            eval 'ALL_LINGUAS''=$ALL_LINGUAS_'
+          fi
+          case "$ac_given_srcdir" in
+            .) srcdirpre= ;;
+            *) srcdirpre='$(srcdir)/' ;;
+          esac
+          POFILES=
+          GMOFILES=
+          UPDATEPOFILES=
+          DUMMYPOFILES=
+          for lang in $ALL_LINGUAS; do
+            POFILES="$POFILES $srcdirpre$lang.po"
+            GMOFILES="$GMOFILES $srcdirpre$lang.gmo"
+            UPDATEPOFILES="$UPDATEPOFILES $lang.po-update"
+            DUMMYPOFILES="$DUMMYPOFILES $lang.nop"
+          done
+          # CATALOGS depends on both $ac_dir and the user's LINGUAS
+          # environment variable.
+          INST_LINGUAS=
+          if test -n "$ALL_LINGUAS"; then
+            for presentlang in $ALL_LINGUAS; do
+              useit=no
+              if test "%UNSET%" != "$LINGUAS"; then
+                desiredlanguages="$LINGUAS"
+              else
+                desiredlanguages="$ALL_LINGUAS"
+              fi
+              for desiredlang in $desiredlanguages; do
+                # Use the presentlang catalog if desiredlang is
+                #   a. equal to presentlang, or
+                #   b. a variant of presentlang (because in this case,
+                #      presentlang can be used as a fallback for messages
+                #      which are not translated in the desiredlang catalog).
+                case "$desiredlang" in
+                  "$presentlang"*) useit=yes;;
+                esac
+              done
+              if test $useit = yes; then
+                INST_LINGUAS="$INST_LINGUAS $presentlang"
+              fi
+            done
+          fi
+          CATALOGS=
+          if test -n "$INST_LINGUAS"; then
+            for lang in $INST_LINGUAS; do
+              CATALOGS="$CATALOGS $lang.gmo"
+            done
+          fi
+          test -n "$as_me" && echo "$as_me: creating $ac_dir/Makefile" || echo "creating $ac_dir/Makefile"
+          sed -e "/^POTFILES =/r $ac_dir/POTFILES" -e "/^# Makevars/r $ac_given_srcdir/$ac_dir/Makevars" -e "s|@POFILES@|$POFILES|g" -e "s|@GMOFILES@|$GMOFILES|g" -e "s|@UPDATEPOFILES@|$UPDATEPOFILES|g" -e "s|@DUMMYPOFILES@|$DUMMYPOFILES|g" -e "s|@CATALOGS@|$CATALOGS|g" "$ac_dir/Makefile.in" > "$ac_dir/Makefile"
+          for f in "$ac_given_srcdir/$ac_dir"/Rules-*; do
+            if test -f "$f"; then
+              case "$f" in
+                *.orig | *.bak | *~) ;;
+                *) cat "$f" >> "$ac_dir/Makefile" ;;
+              esac
+            fi
+          done
+        fi
+        ;;
+      esac
+    done],
+   [# Capture the value of obsolete $ALL_LINGUAS because we need it to compute
+    # POFILES, GMOFILES, UPDATEPOFILES, DUMMYPOFILES, CATALOGS. But hide it
+    # from automake.
+    eval 'ALL_LINGUAS''="$ALL_LINGUAS"'
+    # Capture the value of LINGUAS because we need it to compute CATALOGS.
+    LINGUAS="${LINGUAS-%UNSET%}"
+   ])
+])
+
+
+dnl Checks for all prerequisites of the intl subdirectory,
+dnl except for INTL_LIBTOOL_SUFFIX_PREFIX (and possibly LIBTOOL), INTLOBJS,
+dnl            USE_INCLUDED_LIBINTL, BUILD_INCLUDED_LIBINTL.
+AC_DEFUN([AM_INTL_SUBDIR],
+[
+  AC_REQUIRE([AC_PROG_INSTALL])dnl
+  AC_REQUIRE([AM_MKINSTALLDIRS])dnl
+  AC_REQUIRE([AC_PROG_CC])dnl
+  AC_REQUIRE([AC_CANONICAL_HOST])dnl
+  AC_REQUIRE([AC_PROG_RANLIB])dnl
+  AC_REQUIRE([AC_ISC_POSIX])dnl
+  AC_REQUIRE([AC_HEADER_STDC])dnl
+  AC_REQUIRE([AC_C_CONST])dnl
+  AC_REQUIRE([AC_C_INLINE])dnl
+  AC_REQUIRE([AC_TYPE_OFF_T])dnl
+  AC_REQUIRE([AC_TYPE_SIZE_T])dnl
+  AC_REQUIRE([AC_FUNC_ALLOCA])dnl
+  AC_REQUIRE([AC_FUNC_MMAP])dnl
+  AC_REQUIRE([jm_GLIBC21])dnl
+  AC_REQUIRE([gt_INTDIV0])dnl
+  AC_REQUIRE([jm_AC_TYPE_UINTMAX_T])dnl
+  AC_REQUIRE([gt_HEADER_INTTYPES_H])dnl
+  AC_REQUIRE([gt_INTTYPES_PRI])dnl
+
+  AC_CHECK_HEADERS([argz.h limits.h locale.h nl_types.h malloc.h stddef.h \
+stdlib.h string.h unistd.h sys/param.h])
+  AC_CHECK_FUNCS([feof_unlocked fgets_unlocked getc_unlocked getcwd getegid \
+geteuid getgid getuid mempcpy munmap putenv setenv setlocale stpcpy \
+strcasecmp strdup strtoul tsearch __argz_count __argz_stringify __argz_next])
+
+  AM_ICONV
+  AM_LANGINFO_CODESET
+  if test $ac_cv_header_locale_h = yes; then
+    AM_LC_MESSAGES
+  fi
+
+  dnl intl/plural.c is generated from intl/plural.y. It requires bison,
+  dnl because plural.y uses bison specific features. It requires at least
+  dnl bison-1.26 because earlier versions generate a plural.c that doesn't
+  dnl compile.
+  dnl bison is only needed for the maintainer (who touches plural.y). But in
+  dnl order to avoid separate Makefiles or --enable-maintainer-mode, we put
+  dnl the rule in general Makefile. Now, some people carelessly touch the
+  dnl files or have a broken "make" program, hence the plural.c rule will
+  dnl sometimes fire. To avoid an error, defines BISON to ":" if it is not
+  dnl present or too old.
+  AC_CHECK_PROGS([INTLBISON], [bison])
+  if test -z "$INTLBISON"; then
+    ac_verc_fail=yes
+  else
+    dnl Found it, now check the version.
+    AC_MSG_CHECKING([version of bison])
+changequote(<<,>>)dnl
+    ac_prog_version=`$INTLBISON --version 2>&1 | sed -n 's/^.*GNU Bison.* \([0-9]*\.[0-9.]*\).*$/\1/p'`
+    case $ac_prog_version in
+      '') ac_prog_version="v. ?.??, bad"; ac_verc_fail=yes;;
+      1.2[6-9]* | 1.[3-9][0-9]* | [2-9].*)
+changequote([,])dnl
+         ac_prog_version="$ac_prog_version, ok"; ac_verc_fail=no;;
+      *) ac_prog_version="$ac_prog_version, bad"; ac_verc_fail=yes;;
+    esac
+    AC_MSG_RESULT([$ac_prog_version])
+  fi
+  if test $ac_verc_fail = yes; then
+    INTLBISON=:
+  fi
+])
+
+
+AC_DEFUN([AM_MKINSTALLDIRS],
+[
+  dnl If the AC_CONFIG_AUX_DIR macro for autoconf is used we possibly
+  dnl find the mkinstalldirs script in another subdir but $(top_srcdir).
+  dnl Try to locate is.
+  MKINSTALLDIRS=
+  if test -n "$ac_aux_dir"; then
+    MKINSTALLDIRS="$ac_aux_dir/mkinstalldirs"
+  fi
+  if test -z "$MKINSTALLDIRS"; then
+    MKINSTALLDIRS="\$(top_srcdir)/mkinstalldirs"
+  fi
+  AC_SUBST(MKINSTALLDIRS)
+])
+
+
+dnl Usage: AM_GNU_GETTEXT_VERSION([gettext-version])
+AC_DEFUN([AM_GNU_GETTEXT_VERSION], [])
diff -Nur dillo-0.8.0/m4/glibc21.m4 dillo-0.8.0.new/m4/glibc21.m4
--- dillo-0.8.0/m4/glibc21.m4	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/m4/glibc21.m4	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,32 @@
+# glibc21.m4 serial 2 (fileutils-4.1.3, gettext-0.10.40)
+dnl Copyright (C) 2000-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+# Test for the GNU C Library, version 2.1 or newer.
+# From Bruno Haible.
+
+AC_DEFUN([jm_GLIBC21],
+  [
+    AC_CACHE_CHECK(whether we are using the GNU C Library 2.1 or newer,
+      ac_cv_gnu_library_2_1,
+      [AC_EGREP_CPP([Lucky GNU user],
+	[
+#include <features.h>
+#ifdef __GNU_LIBRARY__
+ #if (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 1) || (__GLIBC__ > 2)
+  Lucky GNU user
+ #endif
+#endif
+	],
+	ac_cv_gnu_library_2_1=yes,
+	ac_cv_gnu_library_2_1=no)
+      ]
+    )
+    AC_SUBST(GLIBC21)
+    GLIBC21="$ac_cv_gnu_library_2_1"
+  ]
+)
diff -Nur dillo-0.8.0/m4/iconv.m4 dillo-0.8.0.new/m4/iconv.m4
--- dillo-0.8.0/m4/iconv.m4	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/m4/iconv.m4	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,103 @@
+# iconv.m4 serial AM4 (gettext-0.11.3)
+dnl Copyright (C) 2000-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Bruno Haible.
+
+AC_DEFUN([AM_ICONV_LINKFLAGS_BODY],
+[
+  dnl Prerequisites of AC_LIB_LINKFLAGS_BODY.
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+
+  dnl Search for libiconv and define LIBICONV, LTLIBICONV and INCICONV
+  dnl accordingly.
+  AC_LIB_LINKFLAGS_BODY([iconv])
+])
+
+AC_DEFUN([AM_ICONV_LINK],
+[
+  dnl Some systems have iconv in libc, some have it in libiconv (OSF/1 and
+  dnl those with the standalone portable GNU libiconv installed).
+
+  dnl Search for libiconv and define LIBICONV, LTLIBICONV and INCICONV
+  dnl accordingly.
+  AC_REQUIRE([AM_ICONV_LINKFLAGS_BODY])
+
+  dnl Add $INCICONV to CPPFLAGS before performing the following checks,
+  dnl because if the user has installed libiconv and not disabled its use
+  dnl via --without-libiconv-prefix, he wants to use it. The first
+  dnl AC_TRY_LINK will then fail, the second AC_TRY_LINK will succeed.
+  am_save_CPPFLAGS="$CPPFLAGS"
+  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INCICONV])
+
+  AC_CACHE_CHECK(for iconv, am_cv_func_iconv, [
+    am_cv_func_iconv="no, consider installing GNU libiconv"
+    am_cv_lib_iconv=no
+    AC_TRY_LINK([#include <stdlib.h>
+#include <iconv.h>],
+      [iconv_t cd = iconv_open("","");
+       iconv(cd,NULL,NULL,NULL,NULL);
+       iconv_close(cd);],
+      am_cv_func_iconv=yes)
+    if test "$am_cv_func_iconv" != yes; then
+      am_save_LIBS="$LIBS"
+      LIBS="$LIBS $LIBICONV"
+      AC_TRY_LINK([#include <stdlib.h>
+#include <iconv.h>],
+        [iconv_t cd = iconv_open("","");
+         iconv(cd,NULL,NULL,NULL,NULL);
+         iconv_close(cd);],
+        am_cv_lib_iconv=yes
+        am_cv_func_iconv=yes)
+      LIBS="$am_save_LIBS"
+    fi
+  ])
+  if test "$am_cv_func_iconv" = yes; then
+    AC_DEFINE(HAVE_ICONV, 1, [Define if you have the iconv() function.])
+  fi
+  if test "$am_cv_lib_iconv" = yes; then
+    AC_MSG_CHECKING([how to link with libiconv])
+    AC_MSG_RESULT([$LIBICONV])
+  else
+    dnl If $LIBICONV didn't lead to a usable library, we don't need $INCICONV
+    dnl either.
+    CPPFLAGS="$am_save_CPPFLAGS"
+    LIBICONV=
+    LTLIBICONV=
+  fi
+  AC_SUBST(LIBICONV)
+  AC_SUBST(LTLIBICONV)
+])
+
+AC_DEFUN([AM_ICONV],
+[
+  AM_ICONV_LINK
+  if test "$am_cv_func_iconv" = yes; then
+    AC_MSG_CHECKING([for iconv declaration])
+    AC_CACHE_VAL(am_cv_proto_iconv, [
+      AC_TRY_COMPILE([
+#include <stdlib.h>
+#include <iconv.h>
+extern
+#ifdef __cplusplus
+"C"
+#endif
+#if defined(__STDC__) || defined(__cplusplus)
+size_t iconv (iconv_t cd, char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);
+#else
+size_t iconv();
+#endif
+], [], am_cv_proto_iconv_arg1="", am_cv_proto_iconv_arg1="const")
+      am_cv_proto_iconv="extern size_t iconv (iconv_t cd, $am_cv_proto_iconv_arg1 char * *inbuf, size_t *inbytesleft, char * *outbuf, size_t *outbytesleft);"])
+    am_cv_proto_iconv=`echo "[$]am_cv_proto_iconv" | tr -s ' ' | sed -e 's/( /(/'`
+    AC_MSG_RESULT([$]{ac_t:-
+         }[$]am_cv_proto_iconv)
+    AC_DEFINE_UNQUOTED(ICONV_CONST, $am_cv_proto_iconv_arg1,
+      [Define as const if the declaration of iconv() needs const.])
+  fi
+])
diff -Nur dillo-0.8.0/m4/intdiv0.m4 dillo-0.8.0.new/m4/intdiv0.m4
--- dillo-0.8.0/m4/intdiv0.m4	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/m4/intdiv0.m4	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,72 @@
+# intdiv0.m4 serial 1 (gettext-0.11.3)
+dnl Copyright (C) 2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Bruno Haible.
+
+AC_DEFUN([gt_INTDIV0],
+[
+  AC_REQUIRE([AC_PROG_CC])dnl
+  AC_REQUIRE([AC_CANONICAL_HOST])dnl
+
+  AC_CACHE_CHECK([whether integer division by zero raises SIGFPE],
+    gt_cv_int_divbyzero_sigfpe,
+    [
+      AC_TRY_RUN([
+#include <stdlib.h>
+#include <signal.h>
+
+static void
+#ifdef __cplusplus
+sigfpe_handler (int sig)
+#else
+sigfpe_handler (sig) int sig;
+#endif
+{
+  /* Exit with code 0 if SIGFPE, with code 1 if any other signal.  */
+  exit (sig != SIGFPE);
+}
+
+int x = 1;
+int y = 0;
+int z;
+int nan;
+
+int main ()
+{
+  signal (SIGFPE, sigfpe_handler);
+/* IRIX and AIX (when "xlc -qcheck" is used) yield signal SIGTRAP.  */
+#if (defined (__sgi) || defined (_AIX)) && defined (SIGTRAP)
+  signal (SIGTRAP, sigfpe_handler);
+#endif
+/* Linux/SPARC yields signal SIGILL.  */
+#if defined (__sparc__) && defined (__linux__)
+  signal (SIGILL, sigfpe_handler);
+#endif
+
+  z = x / y;
+  nan = y / y;
+  exit (1);
+}
+], gt_cv_int_divbyzero_sigfpe=yes, gt_cv_int_divbyzero_sigfpe=no,
+        [
+          # Guess based on the CPU.
+          case "$host_cpu" in
+            alpha* | i[34567]86 | m68k | s390*)
+              gt_cv_int_divbyzero_sigfpe="guessing yes";;
+            *)
+              gt_cv_int_divbyzero_sigfpe="guessing no";;
+          esac
+        ])
+    ])
+  case "$gt_cv_int_divbyzero_sigfpe" in
+    *yes) value=1;;
+    *) value=0;;
+  esac
+  AC_DEFINE_UNQUOTED(INTDIV0_RAISES_SIGFPE, $value,
+    [Define if integer division by zero raises signal SIGFPE.])
+])
diff -Nur dillo-0.8.0/m4/inttypes_h.m4 dillo-0.8.0.new/m4/inttypes_h.m4
--- dillo-0.8.0/m4/inttypes_h.m4	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/m4/inttypes_h.m4	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,28 @@
+# inttypes_h.m4 serial 4 (gettext-0.11.4)
+dnl Copyright (C) 1997-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Paul Eggert.
+
+# Define HAVE_INTTYPES_H_WITH_UINTMAX if <inttypes.h> exists,
+# doesn't clash with <sys/types.h>, and declares uintmax_t.
+
+AC_DEFUN([jm_AC_HEADER_INTTYPES_H],
+[
+  AC_CACHE_CHECK([for inttypes.h], jm_ac_cv_header_inttypes_h,
+  [AC_TRY_COMPILE(
+    [#include <sys/types.h>
+#include <inttypes.h>],
+    [uintmax_t i = (uintmax_t) -1;],
+    jm_ac_cv_header_inttypes_h=yes,
+    jm_ac_cv_header_inttypes_h=no)])
+  if test $jm_ac_cv_header_inttypes_h = yes; then
+    AC_DEFINE_UNQUOTED(HAVE_INTTYPES_H_WITH_UINTMAX, 1,
+[Define if <inttypes.h> exists, doesn't clash with <sys/types.h>,
+   and declares uintmax_t. ])
+  fi
+])
diff -Nur dillo-0.8.0/m4/inttypes.m4 dillo-0.8.0.new/m4/inttypes.m4
--- dillo-0.8.0/m4/inttypes.m4	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/m4/inttypes.m4	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,27 @@
+# inttypes.m4 serial 1 (gettext-0.11.4)
+dnl Copyright (C) 1997-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Paul Eggert.
+
+# Define HAVE_INTTYPES_H if <inttypes.h> exists and doesn't clash with
+# <sys/types.h>.
+
+AC_DEFUN([gt_HEADER_INTTYPES_H],
+[
+  AC_CACHE_CHECK([for inttypes.h], gt_cv_header_inttypes_h,
+  [
+    AC_TRY_COMPILE(
+      [#include <sys/types.h>
+#include <inttypes.h>],
+      [], gt_cv_header_inttypes_h=yes, gt_cv_header_inttypes_h=no)
+  ])
+  if test $gt_cv_header_inttypes_h = yes; then
+    AC_DEFINE_UNQUOTED(HAVE_INTTYPES_H, 1,
+      [Define if <inttypes.h> exists and doesn't clash with <sys/types.h>.])
+  fi
+])
diff -Nur dillo-0.8.0/m4/inttypes-pri.m4 dillo-0.8.0.new/m4/inttypes-pri.m4
--- dillo-0.8.0/m4/inttypes-pri.m4	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/m4/inttypes-pri.m4	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,32 @@
+# inttypes-pri.m4 serial 1 (gettext-0.11.4)
+dnl Copyright (C) 1997-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Bruno Haible.
+
+# Define PRI_MACROS_BROKEN if <inttypes.h> exists and defines the PRI*
+# macros to non-string values.  This is the case on AIX 4.3.3.
+
+AC_DEFUN([gt_INTTYPES_PRI],
+[
+  AC_REQUIRE([gt_HEADER_INTTYPES_H])
+  if test $gt_cv_header_inttypes_h = yes; then
+    AC_CACHE_CHECK([whether the inttypes.h PRIxNN macros are broken],
+      gt_cv_inttypes_pri_broken,
+      [
+        AC_TRY_COMPILE([#include <inttypes.h>
+#ifdef PRId32
+char *p = PRId32;
+#endif
+], [], gt_cv_inttypes_pri_broken=no, gt_cv_inttypes_pri_broken=yes)
+      ])
+  fi
+  if test "$gt_cv_inttypes_pri_broken" = yes; then
+    AC_DEFINE_UNQUOTED(PRI_MACROS_BROKEN, 1,
+      [Define if <inttypes.h> exists and defines unusable PRI* macros.])
+  fi
+])
diff -Nur dillo-0.8.0/m4/isc-posix.m4 dillo-0.8.0.new/m4/isc-posix.m4
--- dillo-0.8.0/m4/isc-posix.m4	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/m4/isc-posix.m4	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,26 @@
+# isc-posix.m4 serial 2 (gettext-0.11.2)
+dnl Copyright (C) 1995-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+# This file is not needed with autoconf-2.53 and newer.  Remove it in 2005.
+
+# This test replaces the one in autoconf.
+# Currently this macro should have the same name as the autoconf macro
+# because gettext's gettext.m4 (distributed in the automake package)
+# still uses it.  Otherwise, the use in gettext.m4 makes autoheader
+# give these diagnostics:
+#   configure.in:556: AC_TRY_COMPILE was called before AC_ISC_POSIX
+#   configure.in:556: AC_TRY_RUN was called before AC_ISC_POSIX
+
+undefine([AC_ISC_POSIX])
+
+AC_DEFUN([AC_ISC_POSIX],
+  [
+    dnl This test replaces the obsolescent AC_ISC_POSIX kludge.
+    AC_CHECK_LIB(cposix, strerror, [LIBS="$LIBS -lcposix"])
+  ]
+)
diff -Nur dillo-0.8.0/m4/lcmessage.m4 dillo-0.8.0.new/m4/lcmessage.m4
--- dillo-0.8.0/m4/lcmessage.m4	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/m4/lcmessage.m4	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,32 @@
+# lcmessage.m4 serial 3 (gettext-0.11.3)
+dnl Copyright (C) 1995-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+dnl
+dnl This file can can be used in projects which are not available under
+dnl the GNU General Public License or the GNU Library General Public
+dnl License but which still want to provide support for the GNU gettext
+dnl functionality.
+dnl Please note that the actual code of the GNU gettext library is covered
+dnl by the GNU Library General Public License, and the rest of the GNU
+dnl gettext package package is covered by the GNU General Public License.
+dnl They are *not* in the public domain.
+
+dnl Authors:
+dnl   Ulrich Drepper <drepper@cygnus.com>, 1995.
+
+# Check whether LC_MESSAGES is available in <locale.h>.
+
+AC_DEFUN([AM_LC_MESSAGES],
+[
+  AC_CACHE_CHECK([for LC_MESSAGES], am_cv_val_LC_MESSAGES,
+    [AC_TRY_LINK([#include <locale.h>], [return LC_MESSAGES],
+       am_cv_val_LC_MESSAGES=yes, am_cv_val_LC_MESSAGES=no)])
+  if test $am_cv_val_LC_MESSAGES = yes; then
+    AC_DEFINE(HAVE_LC_MESSAGES, 1,
+      [Define if your <locale.h> file defines LC_MESSAGES.])
+  fi
+])
diff -Nur dillo-0.8.0/m4/lib-ld.m4 dillo-0.8.0.new/m4/lib-ld.m4
--- dillo-0.8.0/m4/lib-ld.m4	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/m4/lib-ld.m4	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,97 @@
+# lib-ld.m4 serial 1 (gettext-0.11)
+dnl Copyright (C) 1996-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl Subroutines of libtool.m4,
+dnl with replacements s/AC_/AC_LIB/ and s/lt_cv/acl_cv/ to avoid collision
+dnl with libtool.m4.
+
+dnl From libtool-1.4. Sets the variable with_gnu_ld to yes or no.
+AC_DEFUN([AC_LIB_PROG_LD_GNU],
+[AC_CACHE_CHECK([if the linker ($LD) is GNU ld], acl_cv_prog_gnu_ld,
+[# I'd rather use --version here, but apparently some GNU ld's only accept -v.
+if $LD -v 2>&1 </dev/null | egrep '(GNU|with BFD)' 1>&5; then
+  acl_cv_prog_gnu_ld=yes
+else
+  acl_cv_prog_gnu_ld=no
+fi])
+with_gnu_ld=$acl_cv_prog_gnu_ld
+])
+
+dnl From libtool-1.4. Sets the variable LD.
+AC_DEFUN([AC_LIB_PROG_LD],
+[AC_ARG_WITH(gnu-ld,
+[  --with-gnu-ld           assume the C compiler uses GNU ld [default=no]],
+test "$withval" = no || with_gnu_ld=yes, with_gnu_ld=no)
+AC_REQUIRE([AC_PROG_CC])dnl
+AC_REQUIRE([AC_CANONICAL_HOST])dnl
+ac_prog=ld
+if test "$GCC" = yes; then
+  # Check if gcc -print-prog-name=ld gives a path.
+  AC_MSG_CHECKING([for ld used by GCC])
+  case $host in
+  *-*-mingw*)
+    # gcc leaves a trailing carriage return which upsets mingw
+    ac_prog=`($CC -print-prog-name=ld) 2>&5 | tr -d '\015'` ;;
+  *)
+    ac_prog=`($CC -print-prog-name=ld) 2>&5` ;;
+  esac
+  case $ac_prog in
+    # Accept absolute paths.
+    [[\\/]* | [A-Za-z]:[\\/]*)]
+      [re_direlt='/[^/][^/]*/\.\./']
+      # Canonicalize the path of ld
+      ac_prog=`echo $ac_prog| sed 's%\\\\%/%g'`
+      while echo $ac_prog | grep "$re_direlt" > /dev/null 2>&1; do
+	ac_prog=`echo $ac_prog| sed "s%$re_direlt%/%"`
+      done
+      test -z "$LD" && LD="$ac_prog"
+      ;;
+  "")
+    # If it fails, then pretend we aren't using GCC.
+    ac_prog=ld
+    ;;
+  *)
+    # If it is relative, then search for the first ld in PATH.
+    with_gnu_ld=unknown
+    ;;
+  esac
+elif test "$with_gnu_ld" = yes; then
+  AC_MSG_CHECKING([for GNU ld])
+else
+  AC_MSG_CHECKING([for non-GNU ld])
+fi
+AC_CACHE_VAL(acl_cv_path_LD,
+[if test -z "$LD"; then
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}${PATH_SEPARATOR-:}"
+  for ac_dir in $PATH; do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f "$ac_dir/$ac_prog" || test -f "$ac_dir/$ac_prog$ac_exeext"; then
+      acl_cv_path_LD="$ac_dir/$ac_prog"
+      # Check to see if the program is GNU ld.  I'd rather use --version,
+      # but apparently some GNU ld's only accept -v.
+      # Break only if it was the GNU/non-GNU ld that we prefer.
+      if "$acl_cv_path_LD" -v 2>&1 < /dev/null | egrep '(GNU|with BFD)' > /dev/null; then
+	test "$with_gnu_ld" != no && break
+      else
+	test "$with_gnu_ld" != yes && break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+else
+  acl_cv_path_LD="$LD" # Let the user override the test with a path.
+fi])
+LD="$acl_cv_path_LD"
+if test -n "$LD"; then
+  AC_MSG_RESULT($LD)
+else
+  AC_MSG_RESULT(no)
+fi
+test -z "$LD" && AC_MSG_ERROR([no acceptable ld found in \$PATH])
+AC_LIB_PROG_LD_GNU
+])
diff -Nur dillo-0.8.0/m4/lib-link.m4 dillo-0.8.0.new/m4/lib-link.m4
--- dillo-0.8.0/m4/lib-link.m4	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/m4/lib-link.m4	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,554 @@
+# lib-link.m4 serial 3 (gettext-0.11.3)
+dnl Copyright (C) 2001-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Bruno Haible.
+
+dnl AC_LIB_LINKFLAGS(name [, dependencies]) searches for libname and
+dnl the libraries corresponding to explicit and implicit dependencies.
+dnl Sets and AC_SUBSTs the LIB${NAME} and LTLIB${NAME} variables and
+dnl augments the CPPFLAGS variable.
+AC_DEFUN([AC_LIB_LINKFLAGS],
+[
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+  define([Name],[translit([$1],[./-], [___])])
+  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],
+                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])
+  AC_CACHE_CHECK([how to link with lib[]$1], [ac_cv_lib[]Name[]_libs], [
+    AC_LIB_LINKFLAGS_BODY([$1], [$2])
+    ac_cv_lib[]Name[]_libs="$LIB[]NAME"
+    ac_cv_lib[]Name[]_ltlibs="$LTLIB[]NAME"
+    ac_cv_lib[]Name[]_cppflags="$INC[]NAME"
+  ])
+  LIB[]NAME="$ac_cv_lib[]Name[]_libs"
+  LTLIB[]NAME="$ac_cv_lib[]Name[]_ltlibs"
+  INC[]NAME="$ac_cv_lib[]Name[]_cppflags"
+  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)
+  AC_SUBST([LIB]NAME)
+  AC_SUBST([LTLIB]NAME)
+  dnl Also set HAVE_LIB[]NAME so that AC_LIB_HAVE_LINKFLAGS can reuse the
+  dnl results of this search when this library appears as a dependency.
+  HAVE_LIB[]NAME=yes
+  undefine([Name])
+  undefine([NAME])
+])
+
+dnl AC_LIB_HAVE_LINKFLAGS(name, dependencies, includes, testcode)
+dnl searches for libname and the libraries corresponding to explicit and
+dnl implicit dependencies, together with the specified include files and
+dnl the ability to compile and link the specified testcode. If found, it
+dnl sets and AC_SUBSTs HAVE_LIB${NAME}=yes and the LIB${NAME} and
+dnl LTLIB${NAME} variables and augments the CPPFLAGS variable, and
+dnl #defines HAVE_LIB${NAME} to 1. Otherwise, it sets and AC_SUBSTs
+dnl HAVE_LIB${NAME}=no and LIB${NAME} and LTLIB${NAME} to empty.
+AC_DEFUN([AC_LIB_HAVE_LINKFLAGS],
+[
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  AC_REQUIRE([AC_LIB_RPATH])
+  define([Name],[translit([$1],[./-], [___])])
+  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],
+                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])
+
+  dnl Search for lib[]Name and define LIB[]NAME, LTLIB[]NAME and INC[]NAME
+  dnl accordingly.
+  AC_LIB_LINKFLAGS_BODY([$1], [$2])
+
+  dnl Add $INC[]NAME to CPPFLAGS before performing the following checks,
+  dnl because if the user has installed lib[]Name and not disabled its use
+  dnl via --without-lib[]Name-prefix, he wants to use it.
+  ac_save_CPPFLAGS="$CPPFLAGS"
+  AC_LIB_APPENDTOVAR([CPPFLAGS], [$INC]NAME)
+
+  AC_CACHE_CHECK([for lib[]$1], [ac_cv_lib[]Name], [
+    ac_save_LIBS="$LIBS"
+    LIBS="$LIBS $LIB[]NAME"
+    AC_TRY_LINK([$3], [$4], [ac_cv_lib[]Name=yes], [ac_cv_lib[]Name=no])
+    LIBS="$ac_save_LIBS"
+  ])
+  if test "$ac_cv_lib[]Name" = yes; then
+    HAVE_LIB[]NAME=yes
+    AC_DEFINE([HAVE_LIB]NAME, 1, [Define if you have the $1 library.])
+    AC_MSG_CHECKING([how to link with lib[]$1])
+    AC_MSG_RESULT([$LIB[]NAME])
+  else
+    HAVE_LIB[]NAME=no
+    dnl If $LIB[]NAME didn't lead to a usable library, we don't need
+    dnl $INC[]NAME either.
+    CPPFLAGS="$ac_save_CPPFLAGS"
+    LIB[]NAME=
+    LTLIB[]NAME=
+  fi
+  AC_SUBST([HAVE_LIB]NAME)
+  AC_SUBST([LIB]NAME)
+  AC_SUBST([LTLIB]NAME)
+  undefine([Name])
+  undefine([NAME])
+])
+
+dnl Determine the platform dependent parameters needed to use rpath:
+dnl libext, shlibext, hardcode_libdir_flag_spec, hardcode_libdir_separator,
+dnl hardcode_direct, hardcode_minus_L,
+dnl sys_lib_search_path_spec, sys_lib_dlsearch_path_spec.
+AC_DEFUN([AC_LIB_RPATH],
+[
+  AC_REQUIRE([AC_PROG_CC])                dnl we use $CC, $GCC, $LDFLAGS
+  AC_REQUIRE([AC_LIB_PROG_LD])            dnl we use $LD, $with_gnu_ld
+  AC_REQUIRE([AC_CANONICAL_HOST])         dnl we use $host
+  AC_REQUIRE([AC_CONFIG_AUX_DIR_DEFAULT]) dnl we use $ac_aux_dir
+  AC_CACHE_CHECK([for shared library run path origin], acl_cv_rpath, [
+    CC="$CC" GCC="$GCC" LDFLAGS="$LDFLAGS" LD="$LD" with_gnu_ld="$with_gnu_ld" \
+    ${CONFIG_SHELL-/bin/sh} "$ac_aux_dir/config.rpath" "$host" > conftest.sh
+    . ./conftest.sh
+    rm -f ./conftest.sh
+    acl_cv_rpath=done
+  ])
+  wl="$acl_cv_wl"
+  libext="$acl_cv_libext"
+  shlibext="$acl_cv_shlibext"
+  hardcode_libdir_flag_spec="$acl_cv_hardcode_libdir_flag_spec"
+  hardcode_libdir_separator="$acl_cv_hardcode_libdir_separator"
+  hardcode_direct="$acl_cv_hardcode_direct"
+  hardcode_minus_L="$acl_cv_hardcode_minus_L"
+  sys_lib_search_path_spec="$acl_cv_sys_lib_search_path_spec"
+  sys_lib_dlsearch_path_spec="$acl_cv_sys_lib_dlsearch_path_spec"
+  dnl Determine whether the user wants rpath handling at all.
+  AC_ARG_ENABLE(rpath,
+    [  --disable-rpath         do not hardcode runtime library paths],
+    :, enable_rpath=yes)
+])
+
+dnl AC_LIB_LINKFLAGS_BODY(name [, dependencies]) searches for libname and
+dnl the libraries corresponding to explicit and implicit dependencies.
+dnl Sets the LIB${NAME}, LTLIB${NAME} and INC${NAME} variables.
+AC_DEFUN([AC_LIB_LINKFLAGS_BODY],
+[
+  define([NAME],[translit([$1],[abcdefghijklmnopqrstuvwxyz./-],
+                               [ABCDEFGHIJKLMNOPQRSTUVWXYZ___])])
+  dnl By default, look in $includedir and $libdir.
+  use_additional=yes
+  AC_LIB_WITH_FINAL_PREFIX([
+    eval additional_includedir=\"$includedir\"
+    eval additional_libdir=\"$libdir\"
+  ])
+  AC_ARG_WITH([lib$1-prefix],
+[  --with-lib$1-prefix[=DIR]  search for lib$1 in DIR/include and DIR/lib
+  --without-lib$1-prefix     don't search for lib$1 in includedir and libdir],
+[
+    if test "X$withval" = "Xno"; then
+      use_additional=no
+    else
+      if test "X$withval" = "X"; then
+        AC_LIB_WITH_FINAL_PREFIX([
+          eval additional_includedir=\"$includedir\"
+          eval additional_libdir=\"$libdir\"
+        ])
+      else
+        additional_includedir="$withval/include"
+        additional_libdir="$withval/lib"
+      fi
+    fi
+])
+  dnl Search the library and its dependencies in $additional_libdir and
+  dnl $LDFLAGS. Using breadth-first-seach.
+  LIB[]NAME=
+  LTLIB[]NAME=
+  INC[]NAME=
+  rpathdirs=
+  ltrpathdirs=
+  names_already_handled=
+  names_next_round='$1 $2'
+  while test -n "$names_next_round"; do
+    names_this_round="$names_next_round"
+    names_next_round=
+    for name in $names_this_round; do
+      already_handled=
+      for n in $names_already_handled; do
+        if test "$n" = "$name"; then
+          already_handled=yes
+          break
+        fi
+      done
+      if test -z "$already_handled"; then
+        names_already_handled="$names_already_handled $name"
+        dnl See if it was already located by an earlier AC_LIB_LINKFLAGS
+        dnl or AC_LIB_HAVE_LINKFLAGS call.
+        uppername=`echo "$name" | sed -e 'y|abcdefghijklmnopqrstuvwxyz./-|ABCDEFGHIJKLMNOPQRSTUVWXYZ___|'`
+        eval value=\"\$HAVE_LIB$uppername\"
+        if test -n "$value"; then
+          if test "$value" = yes; then
+            eval value=\"\$LIB$uppername\"
+            test -z "$value" || LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$value"
+            eval value=\"\$LTLIB$uppername\"
+            test -z "$value" || LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }$value"
+          else
+            dnl An earlier call to AC_LIB_HAVE_LINKFLAGS has determined
+            dnl that this library doesn't exist. So just drop it.
+            :
+          fi
+        else
+          dnl Search the library lib$name in $additional_libdir and $LDFLAGS
+          dnl and the already constructed $LIBNAME/$LTLIBNAME.
+          found_dir=
+          found_la=
+          found_so=
+          found_a=
+          if test $use_additional = yes; then
+            if test -n "$shlibext" && test -f "$additional_libdir/lib$name.$shlibext"; then
+              found_dir="$additional_libdir"
+              found_so="$additional_libdir/lib$name.$shlibext"
+              if test -f "$additional_libdir/lib$name.la"; then
+                found_la="$additional_libdir/lib$name.la"
+              fi
+            else
+              if test -f "$additional_libdir/lib$name.$libext"; then
+                found_dir="$additional_libdir"
+                found_a="$additional_libdir/lib$name.$libext"
+                if test -f "$additional_libdir/lib$name.la"; then
+                  found_la="$additional_libdir/lib$name.la"
+                fi
+              fi
+            fi
+          fi
+          if test "X$found_dir" = "X"; then
+            for x in $LDFLAGS $LTLIB[]NAME; do
+              AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+              case "$x" in
+                -L*)
+                  dir=`echo "X$x" | sed -e 's/^X-L//'`
+                  if test -n "$shlibext" && test -f "$dir/lib$name.$shlibext"; then
+                    found_dir="$dir"
+                    found_so="$dir/lib$name.$shlibext"
+                    if test -f "$dir/lib$name.la"; then
+                      found_la="$dir/lib$name.la"
+                    fi
+                  else
+                    if test -f "$dir/lib$name.$libext"; then
+                      found_dir="$dir"
+                      found_a="$dir/lib$name.$libext"
+                      if test -f "$dir/lib$name.la"; then
+                        found_la="$dir/lib$name.la"
+                      fi
+                    fi
+                  fi
+                  ;;
+              esac
+              if test "X$found_dir" != "X"; then
+                break
+              fi
+            done
+          fi
+          if test "X$found_dir" != "X"; then
+            dnl Found the library.
+            LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$found_dir -l$name"
+            if test "X$found_so" != "X"; then
+              dnl Linking with a shared library. We attempt to hardcode its
+              dnl directory into the executable's runpath, unless it's the
+              dnl standard /usr/lib.
+              if test "$enable_rpath" = no || test "X$found_dir" = "X/usr/lib"; then
+                dnl No hardcoding is needed.
+                LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+              else
+                dnl Use an explicit option to hardcode DIR into the resulting
+                dnl binary.
+                dnl Potentially add DIR to ltrpathdirs.
+                dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.
+                haveit=
+                for x in $ltrpathdirs; do
+                  if test "X$x" = "X$found_dir"; then
+                    haveit=yes
+                    break
+                  fi
+                done
+                if test -z "$haveit"; then
+                  ltrpathdirs="$ltrpathdirs $found_dir"
+                fi
+                dnl The hardcoding into $LIBNAME is system dependent.
+                if test "$hardcode_direct" = yes; then
+                  dnl Using DIR/libNAME.so during linking hardcodes DIR into the
+                  dnl resulting binary.
+                  LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+                else
+                  if test -n "$hardcode_libdir_flag_spec" && test "$hardcode_minus_L" = no; then
+                    dnl Use an explicit option to hardcode DIR into the resulting
+                    dnl binary.
+                    LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+                    dnl Potentially add DIR to rpathdirs.
+                    dnl The rpathdirs will be appended to $LIBNAME at the end.
+                    haveit=
+                    for x in $rpathdirs; do
+                      if test "X$x" = "X$found_dir"; then
+                        haveit=yes
+                        break
+                      fi
+                    done
+                    if test -z "$haveit"; then
+                      rpathdirs="$rpathdirs $found_dir"
+                    fi
+                  else
+                    dnl Rely on "-L$found_dir".
+                    dnl But don't add it if it's already contained in the LDFLAGS
+                    dnl or the already constructed $LIBNAME
+                    haveit=
+                    for x in $LDFLAGS $LIB[]NAME; do
+                      AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                      if test "X$x" = "X-L$found_dir"; then
+                        haveit=yes
+                        break
+                      fi
+                    done
+                    if test -z "$haveit"; then
+                      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir"
+                    fi
+                    if test "$hardcode_minus_L" != no; then
+                      dnl FIXME: Not sure whether we should use
+                      dnl "-L$found_dir -l$name" or "-L$found_dir $found_so"
+                      dnl here.
+                      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_so"
+                    else
+                      dnl We cannot use $hardcode_runpath_var and LD_RUN_PATH
+                      dnl here, because this doesn't fit in flags passed to the
+                      dnl compiler. So give up. No hardcoding. This affects only
+                      dnl very old systems.
+                      dnl FIXME: Not sure whether we should use
+                      dnl "-L$found_dir -l$name" or "-L$found_dir $found_so"
+                      dnl here.
+                      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-l$name"
+                    fi
+                  fi
+                fi
+              fi
+            else
+              if test "X$found_a" != "X"; then
+                dnl Linking with a static library.
+                LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$found_a"
+              else
+                dnl We shouldn't come here, but anyway it's good to have a
+                dnl fallback.
+                LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-L$found_dir -l$name"
+              fi
+            fi
+            dnl Assume the include files are nearby.
+            additional_includedir=
+            case "$found_dir" in
+              */lib | */lib/)
+                basedir=`echo "X$found_dir" | sed -e 's,^X,,' -e 's,/lib/*$,,'`
+                additional_includedir="$basedir/include"
+                ;;
+            esac
+            if test "X$additional_includedir" != "X"; then
+              dnl Potentially add $additional_includedir to $INCNAME.
+              dnl But don't add it
+              dnl   1. if it's the standard /usr/include,
+              dnl   2. if it's /usr/local/include and we are using GCC on Linux,
+              dnl   3. if it's already present in $CPPFLAGS or the already
+              dnl      constructed $INCNAME,
+              dnl   4. if it doesn't exist as a directory.
+              if test "X$additional_includedir" != "X/usr/include"; then
+                haveit=
+                if test "X$additional_includedir" = "X/usr/local/include"; then
+                  if test -n "$GCC"; then
+                    case $host_os in
+                      linux*) haveit=yes;;
+                    esac
+                  fi
+                fi
+                if test -z "$haveit"; then
+                  for x in $CPPFLAGS $INC[]NAME; do
+                    AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                    if test "X$x" = "X-I$additional_includedir"; then
+                      haveit=yes
+                      break
+                    fi
+                  done
+                  if test -z "$haveit"; then
+                    if test -d "$additional_includedir"; then
+                      dnl Really add $additional_includedir to $INCNAME.
+                      INC[]NAME="${INC[]NAME}${INC[]NAME:+ }-I$additional_includedir"
+                    fi
+                  fi
+                fi
+              fi
+            fi
+            dnl Look for dependencies.
+            if test -n "$found_la"; then
+              dnl Read the .la file. It defines the variables
+              dnl dlname, library_names, old_library, dependency_libs, current,
+              dnl age, revision, installed, dlopen, dlpreopen, libdir.
+              save_libdir="$libdir"
+              case "$found_la" in
+                */* | *\\*) . "$found_la" ;;
+                *) . "./$found_la" ;;
+              esac
+              libdir="$save_libdir"
+              dnl We use only dependency_libs.
+              for dep in $dependency_libs; do
+                case "$dep" in
+                  -L*)
+                    additional_libdir=`echo "X$dep" | sed -e 's/^X-L//'`
+                    dnl Potentially add $additional_libdir to $LIBNAME and $LTLIBNAME.
+                    dnl But don't add it
+                    dnl   1. if it's the standard /usr/lib,
+                    dnl   2. if it's /usr/local/lib and we are using GCC on Linux,
+                    dnl   3. if it's already present in $LDFLAGS or the already
+                    dnl      constructed $LIBNAME,
+                    dnl   4. if it doesn't exist as a directory.
+                    if test "X$additional_libdir" != "X/usr/lib"; then
+                      haveit=
+                      if test "X$additional_libdir" = "X/usr/local/lib"; then
+                        if test -n "$GCC"; then
+                          case $host_os in
+                            linux*) haveit=yes;;
+                          esac
+                        fi
+                      fi
+                      if test -z "$haveit"; then
+                        haveit=
+                        for x in $LDFLAGS $LIB[]NAME; do
+                          AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                          if test "X$x" = "X-L$additional_libdir"; then
+                            haveit=yes
+                            break
+                          fi
+                        done
+                        if test -z "$haveit"; then
+                          if test -d "$additional_libdir"; then
+                            dnl Really add $additional_libdir to $LIBNAME.
+                            LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-L$additional_libdir"
+                          fi
+                        fi
+                        haveit=
+                        for x in $LDFLAGS $LTLIB[]NAME; do
+                          AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+                          if test "X$x" = "X-L$additional_libdir"; then
+                            haveit=yes
+                            break
+                          fi
+                        done
+                        if test -z "$haveit"; then
+                          if test -d "$additional_libdir"; then
+                            dnl Really add $additional_libdir to $LTLIBNAME.
+                            LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-L$additional_libdir"
+                          fi
+                        fi
+                      fi
+                    fi
+                    ;;
+                  -R*)
+                    dir=`echo "X$dep" | sed -e 's/^X-R//'`
+                    if test "$enable_rpath" != no; then
+                      dnl Potentially add DIR to rpathdirs.
+                      dnl The rpathdirs will be appended to $LIBNAME at the end.
+                      haveit=
+                      for x in $rpathdirs; do
+                        if test "X$x" = "X$dir"; then
+                          haveit=yes
+                          break
+                        fi
+                      done
+                      if test -z "$haveit"; then
+                        rpathdirs="$rpathdirs $dir"
+                      fi
+                      dnl Potentially add DIR to ltrpathdirs.
+                      dnl The ltrpathdirs will be appended to $LTLIBNAME at the end.
+                      haveit=
+                      for x in $ltrpathdirs; do
+                        if test "X$x" = "X$dir"; then
+                          haveit=yes
+                          break
+                        fi
+                      done
+                      if test -z "$haveit"; then
+                        ltrpathdirs="$ltrpathdirs $dir"
+                      fi
+                    fi
+                    ;;
+                  -l*)
+                    dnl Handle this in the next round.
+                    names_next_round="$names_next_round "`echo "X$dep" | sed -e 's/^X-l//'`
+                    ;;
+                  *.la)
+                    dnl Handle this in the next round. Throw away the .la's
+                    dnl directory; it is already contained in a preceding -L
+                    dnl option.
+                    names_next_round="$names_next_round "`echo "X$dep" | sed -e 's,^X.*/,,' -e 's,^lib,,' -e 's,\.la$,,'`
+                    ;;
+                  *)
+                    dnl Most likely an immediate library name.
+                    LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$dep"
+                    LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }$dep"
+                    ;;
+                esac
+              done
+            fi
+          else
+            dnl Didn't find the library; assume it is in the system directories
+            dnl known to the linker and runtime loader. (All the system
+            dnl directories known to the linker should also be known to the
+            dnl runtime loader, otherwise the system is severely misconfigured.)
+            LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }-l$name"
+            LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-l$name"
+          fi
+        fi
+      fi
+    done
+  done
+  if test "X$rpathdirs" != "X"; then
+    if test -n "$hardcode_libdir_separator"; then
+      dnl Weird platform: only the last -rpath option counts, the user must
+      dnl pass all path elements in one option. We can arrange that for a
+      dnl single library, but not when more than one $LIBNAMEs are used.
+      alldirs=
+      for found_dir in $rpathdirs; do
+        alldirs="${alldirs}${alldirs:+$hardcode_libdir_separator}$found_dir"
+      done
+      dnl Note: hardcode_libdir_flag_spec uses $libdir and $wl.
+      acl_save_libdir="$libdir"
+      libdir="$alldirs"
+      eval flag=\"$hardcode_libdir_flag_spec\"
+      libdir="$acl_save_libdir"
+      LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$flag"
+    else
+      dnl The -rpath options are cumulative.
+      for found_dir in $rpathdirs; do
+        acl_save_libdir="$libdir"
+        libdir="$found_dir"
+        eval flag=\"$hardcode_libdir_flag_spec\"
+        libdir="$acl_save_libdir"
+        LIB[]NAME="${LIB[]NAME}${LIB[]NAME:+ }$flag"
+      done
+    fi
+  fi
+  if test "X$ltrpathdirs" != "X"; then
+    dnl When using libtool, the option that works for both libraries and
+    dnl executables is -R. The -R options are cumulative.
+    for found_dir in $ltrpathdirs; do
+      LTLIB[]NAME="${LTLIB[]NAME}${LTLIB[]NAME:+ }-R$found_dir"
+    done
+  fi
+])
+
+dnl AC_LIB_APPENDTOVAR(VAR, CONTENTS) appends the elements of CONTENTS to VAR,
+dnl unless already present in VAR.
+dnl Works only for CPPFLAGS, not for LIB* variables because that sometimes
+dnl contains two or three consecutive elements that belong together.
+AC_DEFUN([AC_LIB_APPENDTOVAR],
+[
+  for element in [$2]; do
+    haveit=
+    for x in $[$1]; do
+      AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+      if test "X$x" = "X$element"; then
+        haveit=yes
+        break
+      fi
+    done
+    if test -z "$haveit"; then
+      [$1]="${[$1]}${[$1]:+ }$element"
+    fi
+  done
+])
diff -Nur dillo-0.8.0/m4/lib-prefix.m4 dillo-0.8.0.new/m4/lib-prefix.m4
--- dillo-0.8.0/m4/lib-prefix.m4	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/m4/lib-prefix.m4	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,148 @@
+# lib-prefix.m4 serial 1 (gettext-0.11)
+dnl Copyright (C) 2001-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Bruno Haible.
+
+dnl AC_LIB_PREFIX adds to the CPPFLAGS and LDFLAGS the flags that are needed
+dnl to access previously installed libraries. The basic assumption is that
+dnl a user will want packages to use other packages he previously installed
+dnl with the same --prefix option.
+dnl This macro is not needed if only AC_LIB_LINKFLAGS is used to locate
+dnl libraries, but is otherwise very convenient.
+AC_DEFUN([AC_LIB_PREFIX],
+[
+  AC_BEFORE([$0], [AC_LIB_LINKFLAGS])
+  AC_REQUIRE([AC_PROG_CC])
+  AC_REQUIRE([AC_CANONICAL_HOST])
+  AC_REQUIRE([AC_LIB_PREPARE_PREFIX])
+  dnl By default, look in $includedir and $libdir.
+  use_additional=yes
+  AC_LIB_WITH_FINAL_PREFIX([
+    eval additional_includedir=\"$includedir\"
+    eval additional_libdir=\"$libdir\"
+  ])
+  AC_ARG_WITH([lib-prefix],
+[  --with-lib-prefix[=DIR] search for libraries in DIR/include and DIR/lib
+  --without-lib-prefix    don't search for libraries in includedir and libdir],
+[
+    if test "X$withval" = "Xno"; then
+      use_additional=no
+    else
+      if test "X$withval" = "X"; then
+        AC_LIB_WITH_FINAL_PREFIX([
+          eval additional_includedir=\"$includedir\"
+          eval additional_libdir=\"$libdir\"
+        ])
+      else
+        additional_includedir="$withval/include"
+        additional_libdir="$withval/lib"
+      fi
+    fi
+])
+  if test $use_additional = yes; then
+    dnl Potentially add $additional_includedir to $CPPFLAGS.
+    dnl But don't add it
+    dnl   1. if it's the standard /usr/include,
+    dnl   2. if it's already present in $CPPFLAGS,
+    dnl   3. if it's /usr/local/include and we are using GCC on Linux,
+    dnl   4. if it doesn't exist as a directory.
+    if test "X$additional_includedir" != "X/usr/include"; then
+      haveit=
+      for x in $CPPFLAGS; do
+        AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+        if test "X$x" = "X-I$additional_includedir"; then
+          haveit=yes
+          break
+        fi
+      done
+      if test -z "$haveit"; then
+        if test "X$additional_includedir" = "X/usr/local/include"; then
+          if test -n "$GCC"; then
+            case $host_os in
+              linux*) haveit=yes;;
+            esac
+          fi
+        fi
+        if test -z "$haveit"; then
+          if test -d "$additional_includedir"; then
+            dnl Really add $additional_includedir to $CPPFLAGS.
+            CPPFLAGS="${CPPFLAGS}${CPPFLAGS:+ }-I$additional_includedir"
+          fi
+        fi
+      fi
+    fi
+    dnl Potentially add $additional_libdir to $LDFLAGS.
+    dnl But don't add it
+    dnl   1. if it's the standard /usr/lib,
+    dnl   2. if it's already present in $LDFLAGS,
+    dnl   3. if it's /usr/local/lib and we are using GCC on Linux,
+    dnl   4. if it doesn't exist as a directory.
+    if test "X$additional_libdir" != "X/usr/lib"; then
+      haveit=
+      for x in $LDFLAGS; do
+        AC_LIB_WITH_FINAL_PREFIX([eval x=\"$x\"])
+        if test "X$x" = "X-L$additional_libdir"; then
+          haveit=yes
+          break
+        fi
+      done
+      if test -z "$haveit"; then
+        if test "X$additional_libdir" = "X/usr/local/lib"; then
+          if test -n "$GCC"; then
+            case $host_os in
+              linux*) haveit=yes;;
+            esac
+          fi
+        fi
+        if test -z "$haveit"; then
+          if test -d "$additional_libdir"; then
+            dnl Really add $additional_libdir to $LDFLAGS.
+            LDFLAGS="${LDFLAGS}${LDFLAGS:+ }-L$additional_libdir"
+          fi
+        fi
+      fi
+    fi
+  fi
+])
+
+dnl AC_LIB_PREPARE_PREFIX creates variables acl_final_prefix,
+dnl acl_final_exec_prefix, containing the values to which $prefix and
+dnl $exec_prefix will expand at the end of the configure script.
+AC_DEFUN([AC_LIB_PREPARE_PREFIX],
+[
+  dnl Unfortunately, prefix and exec_prefix get only finally determined
+  dnl at the end of configure.
+  if test "X$prefix" = "XNONE"; then
+    acl_final_prefix="$ac_default_prefix"
+  else
+    acl_final_prefix="$prefix"
+  fi
+  if test "X$exec_prefix" = "XNONE"; then
+    acl_final_exec_prefix='${prefix}'
+  else
+    acl_final_exec_prefix="$exec_prefix"
+  fi
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  eval acl_final_exec_prefix=\"$acl_final_exec_prefix\"
+  prefix="$acl_save_prefix"
+])
+
+dnl AC_LIB_WITH_FINAL_PREFIX([statement]) evaluates statement, with the
+dnl variables prefix and exec_prefix bound to the values they will have
+dnl at the end of the configure script.
+AC_DEFUN([AC_LIB_WITH_FINAL_PREFIX],
+[
+  acl_save_prefix="$prefix"
+  prefix="$acl_final_prefix"
+  acl_save_exec_prefix="$exec_prefix"
+  exec_prefix="$acl_final_exec_prefix"
+  $1
+  exec_prefix="$acl_save_exec_prefix"
+  prefix="$acl_save_prefix"
+])
diff -Nur dillo-0.8.0/m4/Makefile.am dillo-0.8.0.new/m4/Makefile.am
--- dillo-0.8.0/m4/Makefile.am	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/m4/Makefile.am	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1 @@
+EXTRA_DIST = codeset.m4 gettext.m4 glibc21.m4 iconv.m4 intdiv0.m4 inttypes.m4 inttypes_h.m4 inttypes-pri.m4 isc-posix.m4 lcmessage.m4 lib-ld.m4 lib-link.m4 lib-prefix.m4 progtest.m4 stdint_h.m4 uintmax_t.m4
diff -Nur dillo-0.8.0/m4/Makefile.in dillo-0.8.0.new/m4/Makefile.in
--- dillo-0.8.0/m4/Makefile.in	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/m4/Makefile.in	2004-10-13 01:20:01.000000000 +0000
@@ -0,0 +1,302 @@
+# Makefile.in generated by automake 1.7.3 from Makefile.am.
+# @configure_input@
+
+# Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
+# Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+top_builddir = ..
+
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+INSTALL = @INSTALL@
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+ACLOCAL = @ACLOCAL@
+ALLOCA = @ALLOCA@
+AMDEP_FALSE = @AMDEP_FALSE@
+AMDEP_TRUE = @AMDEP_TRUE@
+AMTAR = @AMTAR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+BUILD_INCLUDED_LIBINTL = @BUILD_INCLUDED_LIBINTL@
+CATOBJEXT = @CATOBJEXT@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DATADIRNAME = @DATADIRNAME@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+GENCAT = @GENCAT@
+GLIBC21 = @GLIBC21@
+GLIB_CFLAGS = @GLIB_CFLAGS@
+GLIB_CONFIG = @GLIB_CONFIG@
+GLIB_LIBS = @GLIB_LIBS@
+GMSGFMT = @GMSGFMT@
+GTK_CFLAGS = @GTK_CFLAGS@
+GTK_CONFIG = @GTK_CONFIG@
+GTK_LIBS = @GTK_LIBS@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+INSTOBJEXT = @INSTOBJEXT@
+INTLBISON = @INTLBISON@
+INTLLIBS = @INTLLIBS@
+INTLOBJS = @INTLOBJS@
+INTL_LIBTOOL_SUFFIX_PREFIX = @INTL_LIBTOOL_SUFFIX_PREFIX@
+KRB5_CONFIG = @KRB5_CONFIG@
+LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBICONV_CFLAGS = @LIBICONV_CFLAGS@
+LIBICONV_LIBS = @LIBICONV_LIBS@
+LIBINTL = @LIBINTL@
+LIBJPEG_CPPFLAGS = @LIBJPEG_CPPFLAGS@
+LIBJPEG_LDFLAGS = @LIBJPEG_LDFLAGS@
+LIBJPEG_LIBS = @LIBJPEG_LIBS@
+LIBOBJS = @LIBOBJS@
+LIBPNG_CFLAGS = @LIBPNG_CFLAGS@
+LIBPNG_LIBS = @LIBPNG_LIBS@
+LIBS = @LIBS@
+LIBZ_LIBS = @LIBZ_LIBS@
+LTLIBICONV = @LTLIBICONV@
+LTLIBINTL = @LTLIBINTL@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+MKINSTALLDIRS = @MKINSTALLDIRS@
+MSGFMT = @MSGFMT@
+MSGMERGE = @MSGMERGE@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+POSUB = @POSUB@
+RANLIB = @RANLIB@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+USE_INCLUDED_LIBINTL = @USE_INCLUDED_LIBINTL@
+USE_NLS = @USE_NLS@
+VERSION = @VERSION@
+XFT_CONFIG = @XFT_CONFIG@
+XGETTEXT = @XGETTEXT@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_RANLIB = @ac_ct_RANLIB@
+ac_ct_STRIP = @ac_ct_STRIP@
+am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
+am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+datadir = @datadir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+oldincludedir = @oldincludedir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+EXTRA_DIST = codeset.m4 gettext.m4 glibc21.m4 iconv.m4 intdiv0.m4 inttypes.m4 inttypes_h.m4 inttypes-pri.m4 isc-posix.m4 lcmessage.m4 lib-ld.m4 lib-link.m4 lib-prefix.m4 progtest.m4 stdint_h.m4 uintmax_t.m4
+subdir = m4
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+DIST_SOURCES =
+DIST_COMMON = ChangeLog Makefile.am Makefile.in
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  Makefile.am  $(top_srcdir)/configure.in $(ACLOCAL_M4)
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  m4/Makefile
+Makefile:  $(srcdir)/Makefile.in  $(top_builddir)/config.status
+	cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)
+uninstall-info-am:
+tags: TAGS
+TAGS:
+
+ctags: CTAGS
+CTAGS:
+
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+
+top_distdir = ..
+distdir = $(top_distdir)/$(PACKAGE)-$(VERSION)
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
+	list='$(DISTFILES)'; for file in $$list; do \
+	  case $$file in \
+	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
+	    $(top_srcdir)/*) file=`echo "$$file" | sed "s|^$$topsrcdirstrip/|$(top_builddir)/|"`;; \
+	  esac; \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  dir=`echo "$$file" | sed -e 's,/[^/]*$$,,'`; \
+	  if test "$$dir" != "$$file" && test "$$dir" != "."; then \
+	    dir="/$$dir"; \
+	    $(mkinstalldirs) "$(distdir)$$dir"; \
+	  else \
+	    dir=''; \
+	  fi; \
+	  if test -d $$d/$$file; then \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile
+
+installdirs:
+
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic mostlyclean-am
+
+distclean: distclean-am
+
+distclean-am: clean-am distclean-generic
+
+dvi: dvi-am
+
+dvi-am:
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-exec-am:
+
+install-info: install-info-am
+
+install-man:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-info-am
+
+.PHONY: all all-am check check-am clean clean-generic distclean \
+	distclean-generic distdir dvi dvi-am info info-am install \
+	install-am install-data install-data-am install-exec \
+	install-exec-am install-info install-info-am install-man \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic pdf pdf-am ps ps-am uninstall uninstall-am \
+	uninstall-info-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -Nur dillo-0.8.0/m4/progtest.m4 dillo-0.8.0.new/m4/progtest.m4
--- dillo-0.8.0/m4/progtest.m4	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/m4/progtest.m4	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,59 @@
+# progtest.m4 serial 2 (gettext-0.10.40)
+dnl Copyright (C) 1996-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+dnl
+dnl This file can can be used in projects which are not available under
+dnl the GNU General Public License or the GNU Library General Public
+dnl License but which still want to provide support for the GNU gettext
+dnl functionality.
+dnl Please note that the actual code of the GNU gettext library is covered
+dnl by the GNU Library General Public License, and the rest of the GNU
+dnl gettext package package is covered by the GNU General Public License.
+dnl They are *not* in the public domain.
+
+dnl Authors:
+dnl   Ulrich Drepper <drepper@cygnus.com>, 1996.
+
+# Search path for a program which passes the given test.
+
+dnl AM_PATH_PROG_WITH_TEST(VARIABLE, PROG-TO-CHECK-FOR,
+dnl   TEST-PERFORMED-ON-FOUND_PROGRAM [, VALUE-IF-NOT-FOUND [, PATH]])
+AC_DEFUN([AM_PATH_PROG_WITH_TEST],
+[# Extract the first word of "$2", so it can be a program name with args.
+set dummy $2; ac_word=[$]2
+AC_MSG_CHECKING([for $ac_word])
+AC_CACHE_VAL(ac_cv_path_$1,
+[case "[$]$1" in
+  /*)
+  ac_cv_path_$1="[$]$1" # Let the user override the test with a path.
+  ;;
+  *)
+  IFS="${IFS= 	}"; ac_save_ifs="$IFS"; IFS="${IFS}:"
+  for ac_dir in ifelse([$5], , $PATH, [$5]); do
+    test -z "$ac_dir" && ac_dir=.
+    if test -f $ac_dir/$ac_word; then
+      if [$3]; then
+	ac_cv_path_$1="$ac_dir/$ac_word"
+	break
+      fi
+    fi
+  done
+  IFS="$ac_save_ifs"
+dnl If no 4th arg is given, leave the cache variable unset,
+dnl so AC_PATH_PROGS will keep looking.
+ifelse([$4], , , [  test -z "[$]ac_cv_path_$1" && ac_cv_path_$1="$4"
+])dnl
+  ;;
+esac])dnl
+$1="$ac_cv_path_$1"
+if test ifelse([$4], , [-n "[$]$1"], ["[$]$1" != "$4"]); then
+  AC_MSG_RESULT([$]$1)
+else
+  AC_MSG_RESULT(no)
+fi
+AC_SUBST($1)dnl
+])
diff -Nur dillo-0.8.0/m4/stdint_h.m4 dillo-0.8.0.new/m4/stdint_h.m4
--- dillo-0.8.0/m4/stdint_h.m4	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/m4/stdint_h.m4	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,28 @@
+# stdint_h.m4 serial 2 (gettext-0.11.4)
+dnl Copyright (C) 1997-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Paul Eggert.
+
+# Define HAVE_STDINT_H_WITH_UINTMAX if <stdint.h> exists,
+# doesn't clash with <sys/types.h>, and declares uintmax_t.
+
+AC_DEFUN([jm_AC_HEADER_STDINT_H],
+[
+  AC_CACHE_CHECK([for stdint.h], jm_ac_cv_header_stdint_h,
+  [AC_TRY_COMPILE(
+    [#include <sys/types.h>
+#include <stdint.h>],
+    [uintmax_t i = (uintmax_t) -1;],
+    jm_ac_cv_header_stdint_h=yes,
+    jm_ac_cv_header_stdint_h=no)])
+  if test $jm_ac_cv_header_stdint_h = yes; then
+    AC_DEFINE_UNQUOTED(HAVE_STDINT_H_WITH_UINTMAX, 1,
+[Define if <stdint.h> exists, doesn't clash with <sys/types.h>,
+   and declares uintmax_t. ])
+  fi
+])
diff -Nur dillo-0.8.0/m4/uintmax_t.m4 dillo-0.8.0.new/m4/uintmax_t.m4
--- dillo-0.8.0/m4/uintmax_t.m4	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/m4/uintmax_t.m4	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,29 @@
+# uintmax_t.m4 serial 6 (gettext-0.11)
+dnl Copyright (C) 1997-2002 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl From Paul Eggert.
+
+AC_PREREQ(2.13)
+
+# Define uintmax_t to `unsigned long' or `unsigned long long'
+# if <inttypes.h> does not exist.
+
+AC_DEFUN([jm_AC_TYPE_UINTMAX_T],
+[
+  AC_REQUIRE([jm_AC_HEADER_INTTYPES_H])
+  AC_REQUIRE([jm_AC_HEADER_STDINT_H])
+  if test $jm_ac_cv_header_inttypes_h = no && test $jm_ac_cv_header_stdint_h = no; then
+    AC_REQUIRE([jm_AC_TYPE_UNSIGNED_LONG_LONG])
+    test $ac_cv_type_unsigned_long_long = yes \
+      && ac_type='unsigned long long' \
+      || ac_type='unsigned long'
+    AC_DEFINE_UNQUOTED(uintmax_t, $ac_type,
+  [Define to unsigned long or unsigned long long
+   if <inttypes.h> and <stdint.h> don't define.])
+  fi
+])
diff -Nur dillo-0.8.0/Makefile.am dillo-0.8.0.new/Makefile.am
--- dillo-0.8.0/Makefile.am	2004-02-06 17:43:24.000000000 +0000
+++ dillo-0.8.0.new/Makefile.am	2004-10-13 01:13:29.000000000 +0000
@@ -1,5 +1,9 @@
-SUBDIRS = doc src dpid dpi
+AM_CPPFLAGS=-DDILLORC_SYS='"$(sysconfdir)/dillorc"' -DLOCALEDIR='"$(localedir)"'
+
+SUBDIRS = m4  doc src dpid dpi config po intl
   
-EXTRA_DIST = ChangeLog.old dillorc install-dpi-local
+EXTRA_DIST = config.rpath  ChangeLog.old dillorc install-dpi-local autogen.sh
 
 sysconf_DATA = dillorc
+
+ACLOCAL_AMFLAGS = -I m4
diff -Nur dillo-0.8.0/Makefile.in dillo-0.8.0.new/Makefile.in
--- dillo-0.8.0/Makefile.in	2004-02-08 12:56:10.000000000 +0000
+++ dillo-0.8.0.new/Makefile.in	2004-10-13 01:20:00.000000000 +0000
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.7 from Makefile.am.
+# Makefile.in generated by automake 1.7.3 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -39,6 +39,7 @@
 host_triplet = @host@
 target_triplet = @target@
 ACLOCAL = @ACLOCAL@
+ALLOCA = @ALLOCA@
 AMDEP_FALSE = @AMDEP_FALSE@
 AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
@@ -46,12 +47,15 @@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
+BUILD_INCLUDED_LIBINTL = @BUILD_INCLUDED_LIBINTL@
+CATOBJEXT = @CATOBJEXT@
 CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CYGPATH_W = @CYGPATH_W@
+DATADIRNAME = @DATADIRNAME@
 DEFS = @DEFS@
 DEPDIR = @DEPDIR@
 ECHO_C = @ECHO_C@
@@ -59,9 +63,12 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+GENCAT = @GENCAT@
+GLIBC21 = @GLIBC21@
 GLIB_CFLAGS = @GLIB_CFLAGS@
 GLIB_CONFIG = @GLIB_CONFIG@
 GLIB_LIBS = @GLIB_LIBS@
+GMSGFMT = @GMSGFMT@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_CONFIG = @GTK_CONFIG@
 GTK_LIBS = @GTK_LIBS@
@@ -69,7 +76,17 @@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+INSTOBJEXT = @INSTOBJEXT@
+INTLBISON = @INTLBISON@
+INTLLIBS = @INTLLIBS@
+INTLOBJS = @INTLOBJS@
+INTL_LIBTOOL_SUFFIX_PREFIX = @INTL_LIBTOOL_SUFFIX_PREFIX@
+KRB5_CONFIG = @KRB5_CONFIG@
 LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBICONV_CFLAGS = @LIBICONV_CFLAGS@
+LIBICONV_LIBS = @LIBICONV_LIBS@
+LIBINTL = @LIBINTL@
 LIBJPEG_CPPFLAGS = @LIBJPEG_CPPFLAGS@
 LIBJPEG_LDFLAGS = @LIBJPEG_LDFLAGS@
 LIBJPEG_LIBS = @LIBJPEG_LIBS@
@@ -78,8 +95,13 @@
 LIBPNG_LIBS = @LIBPNG_LIBS@
 LIBS = @LIBS@
 LIBZ_LIBS = @LIBZ_LIBS@
+LTLIBICONV = @LTLIBICONV@
+LTLIBINTL = @LTLIBINTL@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
+MKINSTALLDIRS = @MKINSTALLDIRS@
+MSGFMT = @MSGFMT@
+MSGMERGE = @MSGMERGE@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -88,11 +110,16 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+POSUB = @POSUB@
 RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
+USE_INCLUDED_LIBINTL = @USE_INCLUDED_LIBINTL@
+USE_NLS = @USE_NLS@
 VERSION = @VERSION@
+XFT_CONFIG = @XFT_CONFIG@
+XGETTEXT = @XGETTEXT@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
@@ -119,6 +146,7 @@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 oldincludedir = @oldincludedir@
@@ -132,16 +160,20 @@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-SUBDIRS = doc src dpid dpi
+AM_CPPFLAGS = -DDILLORC_SYS='"$(sysconfdir)/dillorc"' -DLOCALEDIR='"$(localedir)"'
 
-EXTRA_DIST = ChangeLog.old dillorc install-dpi-local
+SUBDIRS = m4  doc src dpid dpi config po intl
+
+EXTRA_DIST = config.rpath  ChangeLog.old dillorc install-dpi-local autogen.sh
 
 sysconf_DATA = dillorc
+
+ACLOCAL_AMFLAGS = -I m4
 subdir = .
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
 CONFIG_HEADER = config.h
-CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_FILES = intl/Makefile
 DIST_SOURCES =
 DATA = $(sysconf_DATA)
 
@@ -151,9 +183,9 @@
 	all-recursive install-data-recursive install-exec-recursive \
 	installdirs-recursive install-recursive uninstall-recursive \
 	check-recursive installcheck-recursive
-DIST_COMMON = README $(srcdir)/Makefile.in $(srcdir)/configure AUTHORS \
-	COPYING ChangeLog INSTALL Makefile.am NEWS aclocal.m4 \
-	config.guess config.h.in config.sub configure configure.in \
+DIST_COMMON = README ABOUT-NLS AUTHORS COPYING ChangeLog INSTALL \
+	Makefile.am Makefile.in NEWS aclocal.m4 config.guess \
+	config.h.in config.rpath config.sub configure configure.in \
 	depcomp install-sh missing mkinstalldirs
 DIST_SUBDIRS = $(SUBDIRS)
 all: config.h
@@ -174,7 +206,7 @@
 $(srcdir)/configure:  $(srcdir)/configure.in $(ACLOCAL_M4) $(CONFIGURE_DEPENDENCIES)
 	cd $(srcdir) && $(AUTOCONF)
 
-$(ACLOCAL_M4):  configure.in 
+$(ACLOCAL_M4):  configure.in m4/codeset.m4 m4/gettext.m4 m4/glibc21.m4 m4/iconv.m4 m4/intdiv0.m4 m4/inttypes-pri.m4 m4/inttypes.m4 m4/inttypes_h.m4 m4/isc-posix.m4 m4/lcmessage.m4 m4/lib-ld.m4 m4/lib-link.m4 m4/lib-prefix.m4 m4/progtest.m4 m4/stdint_h.m4 m4/uintmax_t.m4
 	cd $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
 
 config.h: stamp-h1
@@ -193,6 +225,8 @@
 
 distclean-hdr:
 	-rm -f config.h stamp-h1
+intl/Makefile: $(top_builddir)/config.status $(top_srcdir)/intl/Makefile.in
+	cd $(top_builddir) && $(SHELL) ./config.status $@
 uninstall-info-am:
 sysconfDATA_INSTALL = $(INSTALL_DATA)
 install-sysconfDATA: $(sysconf_DATA)
@@ -293,15 +327,9 @@
 		$(TAGS_FILES) $(LISP)
 	tags=; \
 	here=`pwd`; \
-	if (etags --etags-include --version) >/dev/null 2>&1; then \
-	  include_option=--etags-include; \
-	else \
-	  include_option=--include; \
-	fi; \
 	list='$(SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
-	    test -f $$subdir/TAGS && \
-	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	    test -f $$subdir/TAGS && tags="$$tags -i $$here/$$subdir/TAGS"; \
 	  fi; \
 	done; \
 	list='$(SOURCES) $(HEADERS) config.h.in $(LISP) $(TAGS_FILES)'; \
@@ -353,6 +381,7 @@
 distdir: $(DISTFILES)
 	$(am__remove_distdir)
 	mkdir $(distdir)
+	$(mkinstalldirs) $(distdir)/intl $(distdir)/po
 	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
 	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's|.|.|g'`; \
 	list='$(DISTFILES)'; for file in $$list; do \
@@ -419,6 +448,7 @@
 	  && dc_destdir="$${TMPDIR-/tmp}/am-dc-$$$$/" \
 	  && cd $(distdir)/_build \
 	  && ../configure --srcdir=.. --prefix="$$dc_install_base" \
+	    --with-included-gettext \
 	    $(DISTCHECK_CONFIGURE_FLAGS) \
 	  && $(MAKE) $(AM_MAKEFLAGS) \
 	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
@@ -444,7 +474,7 @@
 	@echo "$(distdir).tar.gz is ready for distribution" | \
 	  sed 'h;s/./=/g;p;x;p;x'
 distuninstallcheck:
-	@cd $(distuninstallcheck_dir) \
+	cd $(distuninstallcheck_dir) \
 	&& test `$(distuninstallcheck_listfiles) | wc -l` -le 1 \
 	   || { echo "ERROR: files left after uninstall:" ; \
 	        if test -n "$(DESTDIR)"; then \
@@ -453,11 +483,11 @@
 	        $(distuninstallcheck_listfiles) ; \
 	        exit 1; } >&2
 distcleancheck: distclean
-	@if test '$(srcdir)' = . ; then \
+	if test '$(srcdir)' = . ; then \
 	  echo "ERROR: distcleancheck can only run from a VPATH build" ; \
 	  exit 1 ; \
 	fi
-	@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \
+	test `$(distcleancheck_listfiles) | wc -l` -eq 0 \
 	  || { echo "ERROR: files left in build directory after distclean:" ; \
 	       $(distcleancheck_listfiles) ; \
 	       exit 1; } >&2
@@ -487,7 +517,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f $(CONFIG_CLEAN_FILES)
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -498,8 +528,6 @@
 
 distclean: distclean-recursive
 	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
-
-	-rm -f Makefile
 distclean-am: clean-am distclean-generic distclean-hdr distclean-tags
 
 dvi: dvi-recursive
@@ -522,9 +550,7 @@
 
 maintainer-clean: maintainer-clean-recursive
 	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
-	-rm -rf $(top_srcdir)/autom4te.cache
-
-	-rm -f Makefile
+	-rm -rf autom4te.cache
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-recursive
diff -Nur dillo-0.8.0/missing dillo-0.8.0.new/missing
--- dillo-0.8.0/missing	2003-09-21 23:02:39.000000000 +0000
+++ dillo-0.8.0.new/missing	2004-10-13 01:13:29.000000000 +0000
@@ -1,6 +1,6 @@
 #! /bin/sh
 # Common stub for a few missing GNU programs while installing.
-# Copyright (C) 1996, 1997, 1999, 2000, 2002, 2003 Free Software Foundation, Inc.
+# Copyright (C) 1996, 1997, 1999, 2000, 2002 Free Software Foundation, Inc.
 # Originally by Fran,cois Pinard <pinard@iro.umontreal.ca>, 1996.
 
 # This program is free software; you can redistribute it and/or modify
@@ -165,7 +165,7 @@
 WARNING: \`$1' is needed, and you do not seem to have it handy on your
          system.  You might have modified some files without having the
          proper tools for further handling them.
-         You can get \`$1' as part of \`Autoconf' from any GNU
+         You can get \`$1Help2man' as part of \`Autoconf' from any GNU
          archive site."
 
     file=`echo "$*" | sed -n 's/.*--output[ =]*\([^ ]*\).*/\1/p'`
@@ -326,7 +326,7 @@
 WARNING: \`$1' is needed, and you do not seem to have it handy on your
          system.  You might have modified some files without having the
          proper tools for further handling them.  Check the \`README' file,
-         it often tells you about the needed prerequisites for installing
+         it often tells you about the needed prerequirements for installing
          this package.  You may also peek at any GNU archive site, in case
          some other package would contain this missing \`$1' program."
     exit 1
diff -Nur dillo-0.8.0/mkinstalldirs dillo-0.8.0.new/mkinstalldirs
--- dillo-0.8.0/mkinstalldirs	2003-09-21 23:02:39.000000000 +0000
+++ dillo-0.8.0.new/mkinstalldirs	2004-10-13 01:13:29.000000000 +0000
@@ -4,108 +4,37 @@
 # Created: 1993-05-16
 # Public domain
 
-errstatus=0
-dirmode=""
-
-usage="\
-Usage: mkinstalldirs [-h] [--help] [-m mode] dir ..."
+# $Id: mkinstalldirs,v 1.13 1999/01/05 03:18:55 bje Exp $
 
-# process command line arguments
-while test $# -gt 0 ; do
-  case $1 in
-    -h | --help | --h*)         # -h for help
-      echo "$usage" 1>&2
-      exit 0
-      ;;
-    -m)                         # -m PERM arg
-      shift
-      test $# -eq 0 && { echo "$usage" 1>&2; exit 1; }
-      dirmode=$1
-      shift
-      ;;
-    --)                         # stop option processing
-      shift
-      break
-      ;;
-    -*)                         # unknown option
-      echo "$usage" 1>&2
-      exit 1
-      ;;
-    *)                          # first non-opt arg
-      break
-      ;;
-  esac
-done
-
-for file
-do
-  if test -d "$file"; then
-    shift
-  else
-    break
-  fi
-done
-
-case $# in
-  0) exit 0 ;;
-esac
-
-case $dirmode in
-  '')
-    if mkdir -p -- . 2>/dev/null; then
-      echo "mkdir -p -- $*"
-      exec mkdir -p -- "$@"
-    fi
-    ;;
-  *)
-    if mkdir -m "$dirmode" -p -- . 2>/dev/null; then
-      echo "mkdir -m $dirmode -p -- $*"
-      exec mkdir -m "$dirmode" -p -- "$@"
-    fi
-    ;;
-esac
+errstatus=0
 
 for file
 do
-  set fnord `echo ":$file" | sed -ne 's/^:\//#/;s/^://;s/\// /g;s/^#/\//;p'`
-  shift
+   set fnord `echo ":$file" | sed -ne 's/^:\//#/;s/^://;s/\// /g;s/^#/\//;p'`
+   shift
 
-  pathcomp=
-  for d
-  do
-    pathcomp="$pathcomp$d"
-    case $pathcomp in
-      -*) pathcomp=./$pathcomp ;;
-    esac
-
-    if test ! -d "$pathcomp"; then
-      echo "mkdir $pathcomp"
-
-      mkdir "$pathcomp" || lasterr=$?
-
-      if test ! -d "$pathcomp"; then
-  	errstatus=$lasterr
-      else
-  	if test ! -z "$dirmode"; then
-	  echo "chmod $dirmode $pathcomp"
-    	  lasterr=""
-  	  chmod "$dirmode" "$pathcomp" || lasterr=$?
-
-  	  if test ! -z "$lasterr"; then
-  	    errstatus=$lasterr
-  	  fi
-  	fi
-      fi
-    fi
+   pathcomp=
+   for d
+   do
+     pathcomp="$pathcomp$d"
+     case "$pathcomp" in
+       -* ) pathcomp=./$pathcomp ;;
+     esac
+
+     if test ! -d "$pathcomp"; then
+        echo "mkdir $pathcomp"
+
+        mkdir "$pathcomp" || lasterr=$?
+
+        if test ! -d "$pathcomp"; then
+  	  errstatus=$lasterr
+        fi
+     fi
 
-    pathcomp="$pathcomp/"
-  done
+     pathcomp="$pathcomp/"
+   done
 done
 
 exit $errstatus
 
-# Local Variables:
-# mode: shell-script
-# sh-indentation: 2
-# End:
 # mkinstalldirs ends here
diff -Nur dillo-0.8.0/po/boldquot.sed dillo-0.8.0.new/po/boldquot.sed
--- dillo-0.8.0/po/boldquot.sed	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/po/boldquot.sed	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,10 @@
+s/"\([^"]*\)"/\1/g
+s/`\([^`']*\)'/\1/g
+s/ '\([^`']*\)' / \1 /g
+s/ '\([^`']*\)'$/ \1/g
+s/^'\([^`']*\)' /\1 /g
+s//""/g
+s//[1m/g
+s//[0m/g
+s//[1m/g
+s//[0m/g
diff -Nur dillo-0.8.0/po/ChangeLog dillo-0.8.0.new/po/ChangeLog
--- dillo-0.8.0/po/ChangeLog	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/po/ChangeLog	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,11 @@
+2003-10-01  gettextize  <bug-gnu-gettext@gnu.org>
+
+	* Makefile.in.in: New file, from gettext-0.11.4.
+	* Rules-quot: New file, from gettext-0.11.4.
+	* boldquot.sed: New file, from gettext-0.11.4.
+	* en@boldquot.header: New file, from gettext-0.11.4.
+	* en@quot.header: New file, from gettext-0.11.4.
+	* insert-header.sin: New file, from gettext-0.11.4.
+	* quot.sed: New file, from gettext-0.11.4.
+	* remove-potcdate.sin: New file, from gettext-0.11.4.
+
diff -Nur dillo-0.8.0/po/dillo.pot dillo-0.8.0.new/po/dillo.pot
--- dillo-0.8.0/po/dillo.pot	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/po/dillo.pot	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,2139 @@
+# SOME DESCRIPTIVE TITLE.
+# Copyright (C) YEAR Free Software Foundation, Inc.
+# This file is distributed under the same license as the PACKAGE package.
+# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
+#
+#, fuzzy
+msgid ""
+msgstr ""
+"Project-Id-Version: PACKAGE VERSION\n"
+"POT-Creation-Date: 2004-06-02 23:54+0900\n"
+"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
+"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
+"Language-Team: LANGUAGE <LL@li.org>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=CHARSET\n"
+"Content-Transfer-Encoding: 8bit\n"
+
+#: config/dillocfg.c:78 src/html.c:4033
+msgid "Reset"
+msgstr ""
+
+#: config/dillocfg.c:79 src/interface.c:350
+msgid "Reload"
+msgstr ""
+
+#: config/dillocfg.c:80 src/interface.c:363
+msgid "Save"
+msgstr ""
+
+#: config/dillocfg.c:81
+msgid "Quit"
+msgstr ""
+
+#: config/dillocfg.c:83 config/dillocfg.c:89
+msgid "Dillo Preferences"
+msgstr ""
+
+#: config/dillocfg.c:112
+msgid "Interface"
+msgstr ""
+
+#: config/dillocfg.c:113
+msgid "  Font  "
+msgstr ""
+
+#: config/dillocfg.c:114
+msgid "  Color "
+msgstr ""
+
+#: config/dillocfg.c:115
+msgid " Network "
+msgstr ""
+
+#: config/dillocfg.c:117
+msgid "   Tab   "
+msgstr ""
+
+#: config/dillocfg.c:120
+msgid "  Other  "
+msgstr ""
+
+#: config/dillocfg.c:317
+msgid "Add"
+msgstr ""
+
+#: config/dillocfg.c:318
+msgid "Delete"
+msgstr ""
+
+#: config/dillocfg.c:324
+msgid "Address"
+msgstr ""
+
+#: config/dillocfg.c:325
+msgid "Rule"
+msgstr ""
+
+#: config/dillocfg.c:351 config/dillocfg.c:357
+#, c-format
+msgid "Read failed <%s>\n"
+msgstr ""
+
+#: config/dillocfg.c:438 config/dillocfg.c:446
+#, c-format
+msgid "can't write <%s>\n"
+msgstr ""
+
+#: config/dillocfg_token.c:61
+msgid "Window Size"
+msgstr ""
+
+#: config/dillocfg_token.c:69
+msgid "HTTP Proxy"
+msgstr ""
+
+#: config/dillocfg_token.c:77
+msgid "NO Proxy"
+msgstr ""
+
+#: config/dillocfg_token.c:85
+msgid "User-Agent"
+msgstr ""
+
+#: config/dillocfg_token.c:93
+msgid "Link color"
+msgstr ""
+
+#: config/dillocfg_token.c:101
+msgid "Visited color"
+msgstr ""
+
+#: config/dillocfg_token.c:109
+msgid "BackGround color"
+msgstr ""
+
+#: config/dillocfg_token.c:117
+msgid "Allow white bg"
+msgstr ""
+
+#: config/dillocfg_token.c:125
+msgid "Force my colors"
+msgstr ""
+
+#: config/dillocfg_token.c:133
+msgid "Force visited color"
+msgstr ""
+
+#: config/dillocfg_token.c:141
+msgid "Text color"
+msgstr ""
+
+#: config/dillocfg_token.c:149
+msgid "Use oblique"
+msgstr ""
+
+#: config/dillocfg_token.c:157
+msgid "STARTUP"
+msgstr ""
+
+#: config/dillocfg_token.c:165
+msgid "HOMEPAGE"
+msgstr ""
+
+#: config/dillocfg_token.c:173
+msgid "Search-engine's URL"
+msgstr ""
+
+#: config/dillocfg_token.c:181
+msgid "Search-engine's charset"
+msgstr ""
+
+#: config/dillocfg_token.c:189
+msgid "Show Tooltip"
+msgstr ""
+
+#: config/dillocfg_token.c:197
+msgid "Panel Size"
+msgstr ""
+
+#: config/dillocfg_token.c:205
+msgid "Small icons"
+msgstr ""
+
+#: config/dillocfg_token.c:213
+msgid "Limit text width"
+msgstr ""
+
+#: config/dillocfg_token.c:221
+msgid "Limit font decoration"
+msgstr ""
+
+#: config/dillocfg_token.c:229
+msgid "Font factor"
+msgstr ""
+
+#: config/dillocfg_token.c:237
+msgid "Font Sizes"
+msgstr ""
+
+#: config/dillocfg_token.c:245
+msgid "Use dicache"
+msgstr ""
+
+#: config/dillocfg_token.c:253
+msgid "Show Back"
+msgstr ""
+
+#: config/dillocfg_token.c:261
+msgid "Show Forw"
+msgstr ""
+
+#: config/dillocfg_token.c:269
+msgid "Show Home"
+msgstr ""
+
+#: config/dillocfg_token.c:277
+msgid "Show Reload"
+msgstr ""
+
+#: config/dillocfg_token.c:285
+msgid "Show Save"
+msgstr ""
+
+#: config/dillocfg_token.c:293
+msgid "Show Stop"
+msgstr ""
+
+#: config/dillocfg_token.c:301
+msgid "Show Bookmarks"
+msgstr ""
+
+#: config/dillocfg_token.c:309
+msgid "Show Menubar"
+msgstr ""
+
+#: config/dillocfg_token.c:317
+msgid "Show ClearURL"
+msgstr ""
+
+#: config/dillocfg_token.c:325
+msgid "Show URL box"
+msgstr ""
+
+#: config/dillocfg_token.c:333
+msgid "Show Search box"
+msgstr ""
+
+#: config/dillocfg_token.c:341
+msgid "Show Progress box"
+msgstr ""
+
+#: config/dillocfg_token.c:349
+msgid "Show Popup navigation"
+msgstr ""
+
+#: config/dillocfg_token.c:357
+msgid "Show User-Agent"
+msgstr ""
+
+#: config/dillocfg_token.c:365
+msgid "Fullwindow start"
+msgstr ""
+
+#: config/dillocfg_token.c:373
+msgid "Transient dialogs"
+msgstr ""
+
+#: config/dillocfg_token.c:381
+msgid "vw_aafontname"
+msgstr ""
+
+#: config/dillocfg_token.c:389
+msgid "fw_aafontname"
+msgstr ""
+
+#: config/dillocfg_token.c:397
+msgid "vw_fontname"
+msgstr ""
+
+#: config/dillocfg_token.c:405
+msgid "fw_fontname"
+msgstr ""
+
+#: config/dillocfg_token.c:413
+msgid "Generate submit"
+msgstr ""
+
+#: config/dillocfg_token.c:421
+msgid "Enterpress forces submit"
+msgstr ""
+
+#: config/dillocfg_token.c:429
+msgid "Show debugging messsages"
+msgstr ""
+
+#: config/dillocfg_token.c:437
+msgid "Use old parser"
+msgstr ""
+
+#: config/dillocfg_token.c:445
+msgid "Focus location on new"
+msgstr ""
+
+#: config/dillocfg_token.c:453
+msgid "Accept Language"
+msgstr ""
+
+#: config/dillocfg_token.c:462
+msgid "Tab load in background"
+msgstr ""
+
+#: config/dillocfg_token.c:470
+msgid "Tab close middle click"
+msgstr ""
+
+#: config/dillocfg_token.c:478
+msgid "Tab instead of window"
+msgstr ""
+
+#: config/dillocfg_token.c:486
+msgid "Tab bar show fullscreen"
+msgstr ""
+
+#: config/dillocfg_token.c:494
+msgid "Tab bar show single tab"
+msgstr ""
+
+#: config/dillocfg_token.c:502
+msgid "Tab bar scroller"
+msgstr ""
+
+#: config/dillocfg_token.c:510
+msgid "Tab bar homogeneous"
+msgstr ""
+
+#: config/dillocfg_token.c:518
+msgid "Tab title compress"
+msgstr ""
+
+#: config/dillocfg_token.c:526
+msgid "Compress vowels"
+msgstr ""
+
+#: config/dillocfg_token.c:534
+msgid "Compress_common_prefixes"
+msgstr ""
+
+#: config/dillocfg_token.c:543
+msgid "Default"
+msgstr ""
+
+#: dpi/bookmarks.c:86
+msgid ""
+"<html>\n"
+"<head>\n"
+"<title>Bookmarks</title>\n"
+"</head>\n"
+"<body bgcolor='#778899' link='black' vlink='gray'>\n"
+"<table border='1' cellpadding='0' width='100%'>\n"
+" <tr><td>\n"
+"  <table width='100%' bgcolor='#b4b4b4'>\n"
+"   <tr>\n"
+"    <td>&nbsp;Bookmarks::</td>\n"
+"    <td width='100%' align='right'>\n"
+"     [<a href='dpi:/bm/modify'>modify</a>]\n"
+"    </td></tr>\n"
+"  </table></td></tr>\n"
+"</table>\n"
+"<br>\n"
+msgstr ""
+
+#: dpi/bookmarks.c:104
+msgid ""
+"<html>\n"
+"<head>\n"
+"<title>Bookmarks</title>\n"
+"</head>\n"
+"<body bgcolor='#778899' link='black' vlink='gray'>\n"
+"<table border='1' cellpadding='0' width='100%'>\n"
+" <tr><td>\n"
+"  <table width='100%' bgcolor='#b4b4b4'>\n"
+"   <tr>\n"
+"    <td>&nbsp;Bookmarks :: modify</td></tr>\n"
+"  </table></td></tr>                            \n"
+"</table>                                        \n"
+"\n"
+"<form>\n"
+"<table width='100%' border='1' cellpadding='0'>\n"
+" <tr><td>\n"
+"  <table width='100%' bgcolor='teal'>\n"
+"   <tr><b>\n"
+"    <td>Select&nbsp;an&nbsp;operation&nbsp;</td>\n"
+"    <td><select name='operation'>\n"
+"     <option value='none' selected>--\n"
+"     <option value='delete'>Delete\n"
+"     <option value='move'>Move\n"
+"     <option value='modify'>Modify\n"
+"     <option value='add_sec'>Add Section\n"
+"     <option value='add_url'>Add URL\n"
+"     </select></td>\n"
+"    <td>,&nbsp;mark&nbsp;its&nbsp;operands,&nbsp;and&nbsp;</td>\n"
+"    <td><input type='submit' name='submit' value='submit.'></td>\n"
+"    <td width='100%'></td>\n"
+"    </b></tr>\n"
+"  </table></td></tr>\n"
+"</table>\n"
+msgstr ""
+
+#: dpi/bookmarks.c:139
+msgid ""
+"<table border='1' cellpadding='0' cellspacing='20' width='100%'>\n"
+" <tr valign='top'>\n"
+"  <td>\n"
+"   <table bgcolor='#b4b4b4' border='1' cellpadding='4' cellspacing='1'>\n"
+"    <tr><td>\n"
+"     <table width='100%' bgcolor='#b4b4b4'>\n"
+"      <tr><td><small>Sections:</small></td></tr></table></td></tr>\n"
+msgstr ""
+
+#: dpi/bookmarks.c:148
+msgid ""
+"<table border='1' cellpadding='0' cellspacing='20' width='100%'>\n"
+" <tr valign='top'>\n"
+"  <td>\n"
+"   <table bgcolor='#b4b4b4' border='1'>\n"
+"    <tr><td>\n"
+"     <table width='100%' bgcolor='#b4b4b4'>\n"
+"      <tr><td><small>Sections:</small></td></tr></table></td></tr>\n"
+msgstr ""
+
+#: dpi/bookmarks.c:157
+#, c-format
+msgid ""
+"    <tr><td>\n"
+"     <table width='100%%' bgcolor='#b4b4b4'>\n"
+"      <tr><td><b><a href='#s%d'>%s</a></b></td></tr></table></td></tr>\n"
+msgstr ""
+
+#: dpi/bookmarks.c:162
+#, c-format
+msgid ""
+"    <tr><td>\n"
+"     <table width='100%%' bgcolor='#b4b4b4'>\n"
+"      <tr><td width='1%%'><input type='checkbox' name='s%d'></td>\n"
+"       <td><b><a href='#s%d'>%s</a></b></td></tr></table></td></tr>\n"
+msgstr ""
+
+#: dpi/bookmarks.c:182 dpi/bookmarks.c:190
+#, c-format
+msgid ""
+"   <a name='s%d'></a>\n"
+"   <table bgcolor='#bfbfbf' width='100%%' cellspacing='2'>\n"
+"    <tr>\n"
+"     <td bgcolor='#bf0c0c'><font color='white'><b>\n"
+"      &nbsp;&nbsp;&nbsp;%s&nbsp;&nbsp;&nbsp;</b></font></td>\n"
+"     <td bgcolor='white' width='100%%'>&nbsp;</td></tr>\n"
+msgstr ""
+
+#: dpi/bookmarks.c:231
+msgid ""
+"<html>\n"
+"<head>\n"
+"<title>Bookmarks</title>\n"
+"</head>\n"
+"<body bgcolor='#778899' link='black' vlink='gray'>\n"
+"<table border='1' cellpadding='0' width='100%'>\n"
+" <tr><td colspan='2'>\n"
+"  <table bgcolor='#b4b4b4' width='100%'>\n"
+"   <tr><td bgcolor='#b4b4b4'>&nbsp;Modify bookmarks:: add section\n"
+"   </td></tr></table></td></tr>\n"
+"</table>\n"
+"<br>\n"
+"<form>\n"
+" <input type='hidden' name='operation' value='add_section'>\n"
+"<table border='1' width='100%'>\n"
+" <tr>\n"
+"  <td bgcolor='olive'><b>New&nbsp;section:</b></td>\n"
+"  <td bgcolor='white' width='100%'></td></tr>\n"
+"</table>\n"
+"<table width='100%' cellpadding='10'>\n"
+"<tr><td>\n"
+" <table width='100%' bgcolor='teal'>\n"
+"  <tr>\n"
+"   <td>Title:</td>\n"
+"   <td><input type='text' name='title' size='64'></td></tr>\n"
+" </table>\n"
+" </td></tr>\n"
+"</table>\n"
+"<table width='100%' cellpadding='4' border='0'>\n"
+"<tr><td bgcolor='#a0a0a0'>\n"
+" <input type='submit' name='submit' value='submit.'></td></tr>\n"
+"</table>\n"
+"</form>\n"
+"</body>\n"
+"</html>\n"
+"\n"
+msgstr ""
+
+#: dpi/bookmarks.c:270
+msgid ""
+"<html>\n"
+"<head>\n"
+"<title>Bookmarks</title>\n"
+"</head>\n"
+"<body bgcolor='#778899' link='black' vlink='gray'>\n"
+"<table border='1' cellpadding='0' width='100%'>\n"
+" <tr><td colspan='2'>\n"
+"  <table bgcolor='#b4b4b4' width='100%'>\n"
+"   <tr><td bgcolor='#b4b4b4'>&nbsp;Modify bookmarks:: update\n"
+"   </td></tr></table></td></tr>\n"
+"</table>\n"
+"<br>\n"
+"<form>\n"
+"<input type='hidden' name='operation' value='modify2'>\n"
+msgstr ""
+
+#: dpi/bookmarks.c:296
+#, c-format
+msgid ""
+"<tr><td>\n"
+" <table width='100%%' bgcolor='teal'>\n"
+"  <tr>\n"
+"   <td>Title:</td>\n"
+"   <td><input type='text' name='title%d' size='64'\n"
+"        value='%s'></td></tr>\n"
+"  <tr>\n"
+"   <td>URL:</td>\n"
+"   <td>%s</td></tr>\n"
+" </table>\n"
+" </td></tr>\n"
+msgstr ""
+
+#: dpi/bookmarks.c:309
+#, c-format
+msgid ""
+"<tr><td>\n"
+" <table width='100%%' bgcolor='teal'>\n"
+"  <tr>\n"
+"   <td>Title:</td>\n"
+"   <td><input type='text' name='s%d' size='64'\n"
+"        value='%s'></td></tr>\n"
+" </table>\n"
+" </td></tr>\n"
+msgstr ""
+
+#: dpi/bookmarks.c:322
+#, c-format
+msgid ""
+"<table width='100%' cellpadding='4' border='0'>\n"
+"<tr><td bgcolor='#a0a0a0'>\n"
+" <input type='submit' name='submit' value='submit.'></td></tr>\n"
+"</table>\n"
+"</form>\n"
+"</body>\n"
+"</html>\n"
+msgstr ""
+
+#: dpi/bookmarks.c:332
+msgid ""
+"<html>\n"
+"<head>\n"
+"<title>Bookmarks</title>\n"
+"</head>\n"
+"<body bgcolor='#778899' link='black' vlink='gray'>\n"
+"<table border='1' cellpadding='0' width='100%'>\n"
+" <tr><td colspan='2'>\n"
+"  <table bgcolor='#b4b4b4' width='100%'>\n"
+"   <tr><td bgcolor='#b4b4b4'>&nbsp;Modify bookmarks:: add url\n"
+"   </td></tr></table></td></tr>\n"
+"</table>\n"
+"<br>\n"
+"<form>\n"
+"<input type='hidden' name='operation' value='add_url2'>\n"
+"<table border='1' width='100%'>\n"
+" <tr>\n"
+"  <td bgcolor='olive'><b>Add&nbsp;url:</b></td>\n"
+"  <td bgcolor='white' width='100%'></td></tr>\n"
+"</table>\n"
+"<table width='100%' cellpadding='10'>\n"
+"<tr><td>\n"
+" <table width='100%' bgcolor='teal'>\n"
+"  <tr>\n"
+"   <td>Title:</td>\n"
+"   <td><input type='text' name='title' size='64'></td></tr>\n"
+"  <tr>\n"
+"   <td>URL:</td>\n"
+"   <td><input type='text' name='url' size='64'></td></tr>\n"
+" </table>\n"
+" </td></tr>\n"
+"</table>\n"
+"<table width='100%' cellpadding='4' border='0'>\n"
+"<tr><td bgcolor='#a0a0a0'>\n"
+" <input type='submit' name='submit' value='submit.'></td></tr>\n"
+"</table>\n"
+"</form>\n"
+"</body>\n"
+"</html>\n"
+msgstr ""
+
+#: dpi/bookmarks.c:757
+msgid "Unclassified"
+msgstr ""
+
+#: dpi/bookmarks.c:790
+#, c-format
+msgid "echo \":s0: Unclassified\" > %s"
+msgstr ""
+
+#: dpi/bookmarks.c:851
+#, c-format
+msgid ""
+"Syntax error in bookmarks file:\n"
+" %s"
+msgstr ""
+
+#: dpi/bookmarks.c:958
+msgid "Added bookmark!"
+msgstr ""
+
+#: dpi/bookmarks.c:1154
+msgid "Update&nbsp;sections:"
+msgstr ""
+
+#: dpi/bookmarks.c:1174
+msgid "Update&nbsp;titles:"
+msgstr ""
+
+#: dpi/bookmarks.c:1474
+msgid "Delete: you must mark what to delete!"
+msgstr ""
+
+#: dpi/bookmarks.c:1480
+msgid "Move: you must mark a target section!"
+msgstr ""
+
+#: dpi/bookmarks.c:1482
+msgid "Move: can not move a section (yet)."
+msgstr ""
+
+#: dpi/bookmarks.c:1484
+msgid "Move: you must mark some urls, and a target section!"
+msgstr ""
+
+#: dpi/bookmarks.c:1489
+msgid "Modify: you must mark what to update!"
+msgstr ""
+
+#: dpi/bookmarks.c:1506
+msgid "Add url: only one target section is allowed!"
+msgstr ""
+
+#: dpi/bookmarks.c:1513
+msgid "No operation, just do nothing!"
+msgstr ""
+
+#: dpi/bookmarks.c:1516
+msgid "Sorry, not implemented yet."
+msgstr ""
+
+#: dpi/bookmarks.c:1680
+msgid "Haven't got a full tag!\n"
+msgstr ""
+
+#: dpi/bookmarks.c:1720 src/tab.c:293 src/tab.c:425
+msgid "(Untitled)"
+msgstr ""
+
+#: dpi/bookmarks.c:1761
+msgid "<HTML><body> Error on the bookmarks server...</body></html>"
+msgstr ""
+
+#: dpid/dpi_socket_dir.c:105
+msgid "The dpi_socket_dir file does not exist\n"
+msgstr ""
+
+#: dpid/dpi_socket_dir.c:109 dpid/dpi_socket_dir.c:113
+msgid "debug_msg - init_sockdir: The socket directory "
+msgstr ""
+
+#: dpid/dpi_socket_dir.c:110
+#, c-format
+msgid "%s exists and is OK\n"
+msgstr ""
+
+#: dpid/dpi_socket_dir.c:114
+#, c-format
+msgid "%s does not exist or is not a directory\n"
+msgstr ""
+
+#: dpid/dpi_socket_dir.c:123
+msgid " - Failed to create dpi socket directory\n"
+msgstr ""
+
+#: dpid/dpi_socket_dir.c:126
+#, c-format
+msgid " - failed to save %s\n"
+msgstr ""
+
+#: dpid/main.c:57 dpid/main.c:64 dpid/main.c:75 dpid/main.c:83 dpid/main.c:97
+#: dpid/main.c:102 dpid/main.c:107
+#, c-format
+msgid "ERROR in child proc for %s\n"
+msgstr ""
+
+#: dpid/main.c:164
+#, c-format
+msgid ": dpid failed to parse cmd in %s\n"
+msgstr ""
+
+#: dpid/main.c:242
+msgid "Failed to create socket directory\n"
+msgstr ""
+
+#: dpid/main.c:252
+msgid "dpid refuses to start, possibly because:\n"
+msgstr ""
+
+#: dpid/main.c:253
+msgid "\t1) An instance of dpid is already running.\n"
+msgstr ""
+
+#: dpid/main.c:254
+msgid "\t2) A previous dpid didn't clean up on exit.\n"
+msgstr ""
+
+#: dpid/main.c:257
+msgid "init_srs_sockets failed\n"
+msgstr ""
+
+#: dpid/main.c:270
+msgid "dpid started\n"
+msgstr ""
+
+#: dpid/main.c:309
+msgid "accept on srs socket failed\n"
+msgstr ""
+
+#: dpid/main.c:310
+msgid "service pending connections, and continue\n"
+msgstr ""
+
+#: dpid/main.c:334
+msgid "get_command failed\n"
+msgstr ""
+
+#: src/commands.c:162
+msgid "View Source"
+msgstr ""
+
+#: src/commands.c:179
+msgid "Detected HTML errors"
+msgstr ""
+
+#: src/commands.c:264
+msgid "Stopped"
+msgstr ""
+
+#: src/cache.c:243
+msgid "WARNING: Cache_entry_add, leaking an entry.\n"
+msgstr ""
+
+#: src/cache.c:354
+msgid "Cache_prepare_reload: ERROR, entry still has clients\n"
+msgstr ""
+
+#: src/cache.c:392
+msgid "ERROR: unsupported protocol"
+msgstr ""
+
+#: src/cache.c:474
+#, c-format
+msgid "Redirect loop for URL: >%s<\n"
+msgstr ""
+
+#: src/cache.c:726
+#, c-format
+msgid "Cache_decode_data: got all data -- decodinging %s\n"
+msgstr ""
+
+#: src/cache.c:735
+msgid "Cache_decode_data: not gzip data!\n"
+msgstr ""
+
+#: src/cache.c:741
+msgid "Cache_decode_data: invalid gzip data!\n"
+msgstr ""
+
+#: src/cache.c:794
+msgid "not x-gzip\n"
+msgstr ""
+
+#: src/cache.c:846
+msgid "Cache_process_io Op = IOAbort; not implemented yet\n"
+msgstr ""
+
+#: src/cache.c:895
+#, c-format
+msgid "ERROR: redirect loop for: %s"
+msgstr ""
+
+#: src/cache.c:905
+#, c-format
+msgid ""
+">>>Redirect from: %s\n"
+" to %s\n"
+msgstr ""
+
+#: src/cache.c:923
+msgid ">>>Image redirection without entity-content<<<\n"
+msgstr ""
+
+#: src/cache.c:925
+msgid ">>>Image redirection with entity-content<<<\n"
+msgstr ""
+
+#: src/cache.c:961
+msgid "FATAL!:*** >>>> Cache_process_queue Caught busy!!!\n"
+msgstr ""
+
+#: src/cache.c:1006
+msgid "Client Callback is NULL"
+msgstr ""
+
+#: src/cache.c:1081
+msgid "WARNING: Cache_stop_client, inexistent client\n"
+msgstr ""
+
+#: src/cache.c:1223 src/capi.c:391 src/capi.c:444 src/capi.c:492
+#: src/capi.c:526 src/IO/dpi.c:660 src/IO/dpi.c:672 src/IO/dpi.c:723
+msgid " Not implemented\n"
+msgstr ""
+
+#: src/capi.c:219
+msgid "Capi_verify_dpi_url_request: Permission Denied!\n"
+msgstr ""
+
+#: src/capi.c:265
+#, c-format
+msgid "  a_Capi_open_url:: web->Image=%p\n"
+msgstr ""
+
+#: src/capi.c:269
+#, c-format
+msgid "  url_str = %s\n"
+msgstr ""
+
+#: src/capi.c:284
+#, c-format
+msgid "  reload=%d URL_E2EReload=%d\n"
+msgstr ""
+
+#: src/capi.c:354
+msgid " ERROR: [a_Capi_dpi_send_cmd] No open connection found\n"
+msgstr ""
+
+#: src/capi.c:420
+msgid "ERROR: can't start dpid daemon!"
+msgstr ""
+
+#: src/capi.c:508
+msgid " Error with pipe\n"
+msgstr ""
+
+#: src/dillo.c:103
+msgid ""
+"  -x, --xid XID          Open first Dillo window in an existing\n"
+"                         GtkSocket which window ID is XID (decimal)."
+msgstr ""
+
+#: src/dillo.c:106
+msgid "  -v, --version          Display version info and exit."
+msgstr ""
+
+#: src/dillo.c:108
+msgid "  -h, --help             Display this help text and exit."
+msgstr ""
+
+#: src/dillo.c:110
+msgid "  -f, --fullwindow       Start in full window mode."
+msgstr ""
+
+#: src/dillo.c:112
+msgid "  -l, --local            Don't follow links for this URL(s)."
+msgstr ""
+
+#: src/dillo.c:114
+msgid ""
+"  -g, -geometry GEO      Set initial window position where GEO is\n"
+"                         <width>x<height>{+-}<x>{+-}<y>"
+msgstr ""
+
+#: src/dillo.c:118
+msgid ""
+"  -D, --debug-rendering  Draw additionaly several lines in a web page,\n"
+"                         representing its structure. For debugging. "
+msgstr ""
+
+#: src/dillo.c:247
+#, c-format
+msgid ""
+"Error: the XID must be an unsigned decimal numerical value.\n"
+"The offending value was: %s\n"
+msgstr ""
+
+#: src/dillo.c:262
+msgid "Error in command line options.\n"
+msgstr ""
+
+#: src/dillo.c:270
+#, c-format
+msgid "Setting gtk charset to %s...\n"
+msgstr ""
+
+#: src/dillo.c:375
+#, c-format
+msgid "Dillo: error creating directory %s: %s\n"
+msgstr ""
+
+#: src/dillo.c:378
+#, c-format
+msgid "Dillo: error reading %s: %s\n"
+msgstr ""
+
+#: src/dillo.c:427
+#, c-format
+msgid "Option %s requires %d argument(s)\n"
+msgstr ""
+
+#: src/dillo.c:462
+msgid ""
+"\n"
+"Usage: dillo [OPTIONS] [URL|FILE]...\n"
+"Options:\n"
+msgstr ""
+
+#: src/dillo.c:469
+#, c-format
+msgid "  %s, %s   *Undocumented*\n"
+msgstr ""
+
+#: src/dillo.c:472
+msgid ""
+"  URL                   URL to browse.\n"
+"  FILE                  Local FILE to view.\n"
+msgstr ""
+
+#: src/dillo.c:474
+msgid ""
+"  URL                    URL to browse.\n"
+"  FILE                   Local FILE to view.\n"
+msgstr ""
+
+#: src/html.c:155
+#, c-format
+msgid "HTML warning: line %d, "
+msgstr ""
+
+#: src/html.c:183
+#, c-format
+msgid "URL has %d illegal character%s (00-1F, 7F or space)\n"
+msgstr ""
+
+#: src/html.c:1179
+msgid "TAB character inside <PRE>\n"
+msgstr ""
+
+#: src/html.c:1418
+#, c-format
+msgid "unexpected closing tag: %s. -- expected </%s>\n"
+msgstr ""
+
+#: src/html.c:1497
+#, c-format
+msgid "Garbage after length: %s\n"
+msgstr ""
+
+#: src/html.c:1550
+msgid "color is not in \"#RRGGBB\" format\n"
+msgstr ""
+
+#: src/html.c:1561
+msgid "HEAD element must go before the BODY section\n"
+msgstr ""
+
+#: src/html.c:1598
+msgid "the TITLE element must be inside the HEAD section\n"
+msgstr ""
+
+#: src/html.c:1841
+msgid "<td> or <th> outside <table>\n"
+msgstr ""
+
+#: src/html.c:1845
+msgid "<td> or <th> outside <tr>\n"
+msgstr ""
+
+#: src/html.c:2035
+msgid "<noframes> outside of <frameset>!!!\n"
+msgstr ""
+
+#: src/html.c:2043
+msgid "<noframe> is illegal tag !!! use <noframes>.\n"
+msgstr ""
+
+#: src/html.c:2223
+msgid "<frame> outside of <frameset>\n"
+msgstr ""
+
+#: src/html.c:2226
+msgid "<frame> inside of <noframes>\n"
+msgstr ""
+
+#: src/html.c:2229
+msgid "<frame> inside of <iframe>\n"
+msgstr ""
+
+#: src/html.c:2281
+msgid "incorrectly placed <frameset>\n"
+msgstr ""
+
+#: src/html.c:2297
+msgid "<frameset> inside of <noframes>\n"
+msgstr ""
+
+#: src/html.c:2302
+msgid "<frameset> inside of <iframe>\n"
+msgstr ""
+
+#: src/html.c:2624
+#, c-format
+msgid "IMG tag only specifies <%s>\n"
+msgstr ""
+
+#: src/html.c:2757
+msgid "  Html_tag_open_img: server-side map (ISMAP)\n"
+msgstr ""
+
+#: src/html.c:2785
+msgid "nested <map>\n"
+msgstr ""
+
+#: src/html.c:2837
+msgid "usemap coords MUST be separated with ','\n"
+msgstr ""
+
+#: src/html.c:2881
+msgid "nohref"
+msgstr ""
+
+#: src/html.c:2968
+#, c-format
+msgid "Registering ANCHOR: %s\n"
+msgstr ""
+
+#: src/html.c:3137
+msgid "<li> outside <ul> or <ol>\n"
+msgstr ""
+
+#: src/html.c:3298
+msgid "nested forms\n"
+msgstr ""
+
+#: src/html.c:3346
+msgid " (added a submit button internally)\n"
+msgstr ""
+
+#: src/html.c:3445
+msgid "META elements must be inside the HEAD section\n"
+msgstr ""
+
+#: src/html.c:3500
+#, c-format
+msgid ""
+"The NON-STANDARD meta refresh tag. The HTML 4.01 SPEC (sec 7.4.4) recommends "
+"explicitly to avoid it. The author wanted you to go <%s>\n"
+msgstr ""
+
+#: src/html.c:3877
+msgid "Html_submit_form: Method unknown\n"
+msgstr ""
+
+#: src/html.c:3948
+msgid "Html_input_image: unable to create image submit.\n"
+msgstr ""
+
+#: src/html.c:3970
+msgid "input camp outside <form>\n"
+msgstr ""
+
+#: src/html.c:4026
+msgid "submit"
+msgstr ""
+
+#: src/html.c:4043
+msgid "Submit"
+msgstr ""
+
+#: src/html.c:4060
+msgid "An input of the type \"file\" wasn't rendered!\n"
+msgstr ""
+
+#: src/html.c:4237
+msgid "<textarea> outside <form>\n"
+msgstr ""
+
+#: src/html.c:4241
+msgid "nested <textarea>\n"
+msgstr ""
+
+#: src/html.c:4314
+msgid "<select> outside <form>\n"
+msgstr ""
+
+#: src/html.c:4318
+msgid "nested <select>\n"
+msgstr ""
+
+#: src/html.c:4549
+msgid "base URI is relative (it MUST be absolute)\n"
+msgstr ""
+
+#: src/html.c:4556
+msgid "the BASE element must appear in the HEAD section\n"
+msgstr ""
+
+#: src/html.c:5045
+msgid "Html_write_raw : bufsize is negative!\n"
+msgstr ""
+
+#: src/html.c:5123
+msgid "attribute lacks closing quote\n"
+msgstr ""
+
+#: src/html.c:5362
+msgid "could not allocate character encoding converter"
+msgstr ""
+
+#: src/misc.c:356
+msgid "Untitled"
+msgstr ""
+
+#: src/interface.c:265
+msgid "Clear the url-box!"
+msgstr ""
+
+#: src/interface.c:279
+msgid "Search the Web"
+msgstr ""
+
+#: src/interface.c:311 src/menu.c:248
+msgid "Back"
+msgstr ""
+
+#: src/interface.c:312
+msgid "Go to previous page"
+msgstr ""
+
+#: src/interface.c:325 src/menu.c:250
+msgid "Forward"
+msgstr ""
+
+#: src/interface.c:326
+msgid "Go to next page"
+msgstr ""
+
+#: src/interface.c:339
+msgid "Home"
+msgstr ""
+
+#: src/interface.c:340
+msgid "Go to the Home page"
+msgstr ""
+
+#: src/interface.c:351
+msgid "Reload this page"
+msgstr ""
+
+#: src/interface.c:364
+msgid "Save this page"
+msgstr ""
+
+#: src/interface.c:371 src/menu.c:252
+msgid "Stop"
+msgstr ""
+
+#: src/interface.c:372
+msgid "Stop the current transfer"
+msgstr ""
+
+#: src/interface.c:383
+msgid "Book"
+msgstr ""
+
+#: src/interface.c:384
+msgid "View bookmarks"
+msgstr ""
+
+#: src/interface.c:546 src/interface.c:731
+msgid "Hide Controls"
+msgstr ""
+
+#: src/interface.c:546 src/interface.c:731
+msgid "Show Controls"
+msgstr ""
+
+#: src/interface.c:820
+msgid "Show HTML bugs"
+msgstr ""
+
+#: src/interface.c:1167
+msgid "Dillo: Open File"
+msgstr ""
+
+#: src/interface.c:1237
+msgid "Clear"
+msgstr ""
+
+#: src/interface.c:1245 src/interface.c:1296 src/interface.c:1370
+msgid "Cancel"
+msgstr ""
+
+#: src/interface.c:1289 src/interface.c:1363 src/interface.c:1434
+msgid "OK"
+msgstr ""
+
+#: src/interface.c:1345
+msgid "User Name:"
+msgstr ""
+
+#: src/interface.c:1354
+msgid "Password:"
+msgstr ""
+
+#: src/interface.c:1400
+msgid "Dillo: Enter Authentication"
+msgstr ""
+
+#: src/interface.c:1418
+msgid "Dillo: Question"
+msgstr ""
+
+#: src/interface.c:1432
+msgid "Dillo: Open URL"
+msgstr ""
+
+#: src/interface.c:1456
+#, c-format
+msgid "File saved (%d Bytes)"
+msgstr ""
+
+#: src/interface.c:1533
+#, c-format
+msgid "Error trying to save: %s\n"
+msgstr ""
+
+#: src/interface.c:1562
+msgid "Dillo: Save URL as File..."
+msgstr ""
+
+#: src/interface.c:1589
+msgid "Dillo: Save link as File..."
+msgstr ""
+
+#: src/interface.c:1631 src/interface.c:1634
+msgid "Dillo: Find text"
+msgstr ""
+
+#: src/interface.c:1632
+#, c-format
+msgid "Cannot find \"%s\"."
+msgstr ""
+
+#: src/interface.c:1635
+#, c-format
+msgid "No further occurence of \"%s\". Restarting from the beginning."
+msgstr ""
+
+#: src/interface.c:1645
+msgid ""
+"Unexpected return from a_Dw_gtk_scrolled_window_search(), in interface."
+"c:1621...\n"
+msgstr ""
+
+#: src/interface.c:1693
+msgid "Dillo: Find text in page"
+msgstr ""
+
+#: src/interface.c:1695
+msgid "Case sensitive"
+msgstr ""
+
+#: src/interface.c:1696
+msgid "Find"
+msgstr ""
+
+#: src/interface.c:1743
+msgid "Dillo"
+msgstr ""
+
+#: src/interface.c:1743
+msgid "Dillo: Search the Web"
+msgstr ""
+
+#: src/interface.c:1745
+msgid "Search"
+msgstr ""
+
+#: src/interface.c:1821
+msgid "Close"
+msgstr ""
+
+#: src/interface.c:1895
+msgid "close"
+msgstr ""
+
+#: src/nav.c:387
+#, c-format
+msgid "Unhandled switch type %d in a_Nav_jump_callback in src/nav.c\n"
+msgstr ""
+
+#: src/nav.c:450
+msgid "Repost form data?"
+msgstr ""
+
+#: src/menu.c:190
+msgid "_File"
+msgstr ""
+
+#: src/menu.c:191
+msgid "_New Window"
+msgstr ""
+
+#: src/menu.c:194
+msgid "New _Tab"
+msgstr ""
+
+#: src/menu.c:198
+msgid "_Open File..."
+msgstr ""
+
+#: src/menu.c:200
+msgid "Open _URL..."
+msgstr ""
+
+#: src/menu.c:206
+msgid "Close Window"
+msgstr ""
+
+#: src/menu.c:209 src/menu.c:536
+msgid "Close Tab"
+msgstr ""
+
+#: src/menu.c:213
+msgid "Exit Dillo"
+msgstr ""
+
+#: src/menu.c:217
+msgid "_View"
+msgstr ""
+
+#: src/menu.c:219
+msgid "Previous tab"
+msgstr ""
+
+#: src/menu.c:221
+msgid "Next tab"
+msgstr ""
+
+#: src/menu.c:225
+msgid "_Options..."
+msgstr ""
+
+#: src/menu.c:254
+msgid "_Reload"
+msgstr ""
+
+#: src/menu.c:258
+msgid "View page So_urce"
+msgstr ""
+
+#: src/menu.c:260
+msgid "View page Bugs"
+msgstr ""
+
+#: src/menu.c:261
+msgid "_Bookmark this Page"
+msgstr ""
+
+#: src/menu.c:264
+msgid "Duplicate this Page"
+msgstr ""
+
+#: src/menu.c:267
+msgid "Duplicate this tab"
+msgstr ""
+
+#: src/menu.c:271
+msgid "_Find Text"
+msgstr ""
+
+#: src/menu.c:274
+msgid "Jump to..."
+msgstr ""
+
+#: src/menu.c:276
+msgid "This Frame..."
+msgstr ""
+
+#: src/menu.c:277
+msgid "This Frameset..."
+msgstr ""
+
+#: src/menu.c:281
+msgid "Save Page As..."
+msgstr ""
+
+#: src/menu.c:299
+msgid "View frame Source"
+msgstr ""
+
+#: src/menu.c:301
+msgid "Bookmark this Frame"
+msgstr ""
+
+#: src/menu.c:303
+msgid "Reload this Frame"
+msgstr ""
+
+#: src/menu.c:306
+msgid "Show only this Frame"
+msgstr ""
+
+#: src/menu.c:308
+msgid "Open Frame in new Window"
+msgstr ""
+
+#: src/menu.c:311
+msgid "Open Frame in new Tab"
+msgstr ""
+
+#: src/menu.c:315
+msgid "_Find Text in this Frame..."
+msgstr ""
+
+#: src/menu.c:318 src/menu.c:349
+msgid "Save Frame As..."
+msgstr ""
+
+#: src/menu.c:336
+msgid "View Frameset Source"
+msgstr ""
+
+#: src/menu.c:338
+msgid "Bookmark this Frameset"
+msgstr ""
+
+#: src/menu.c:340
+msgid "Reload this Frameset"
+msgstr ""
+
+#: src/menu.c:343
+msgid "Show only this Frameset"
+msgstr ""
+
+#: src/menu.c:346
+msgid "_Find Text in this Frameset..."
+msgstr ""
+
+#: src/menu.c:369
+msgid "Open Link in New Window"
+msgstr ""
+
+#: src/menu.c:372
+msgid "Open Link in New Tab"
+msgstr ""
+
+#: src/menu.c:375
+msgid "Open Link"
+msgstr ""
+
+#: src/menu.c:378
+msgid "Bookmark this Link"
+msgstr ""
+
+#: src/menu.c:380
+msgid "Copy Link location"
+msgstr ""
+
+#: src/menu.c:385
+msgid "Save Link As..."
+msgstr ""
+
+#: src/menu.c:389
+msgid "Image Menu..."
+msgstr ""
+
+#: src/menu.c:409
+msgid "Open Image in New Window"
+msgstr ""
+
+#: src/menu.c:412
+msgid "Open Image in New Tab"
+msgstr ""
+
+#: src/menu.c:415
+msgid "Open Image"
+msgstr ""
+
+#: src/menu.c:418
+msgid "Bookmark this Image"
+msgstr ""
+
+#: src/menu.c:420
+msgid "Copy Image location"
+msgstr ""
+
+#: src/menu.c:425
+msgid "Save Image As..."
+msgstr ""
+
+#: src/menu.c:439
+msgid "    BUG METER OPTIONS"
+msgstr ""
+
+#: src/menu.c:441
+msgid "Validate URL with W3C"
+msgstr ""
+
+#: src/menu.c:443
+msgid "Validate URL with WDG"
+msgstr ""
+
+#: src/menu.c:446
+msgid "About Bug Meter..."
+msgstr ""
+
+#: src/menu.c:538
+msgid "New Tab"
+msgstr ""
+
+#: src/menu.c:540
+msgid "Reload Tab"
+msgstr ""
+
+#: src/IO/about.c:33
+msgid ""
+"Content-type: text/html\n"
+"\n"
+"<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN'>\n"
+"<html>\n"
+"<head>\n"
+"<title>Splash screen for dillo-0.8.0-i18n-misc</title>\n"
+"</head>\n"
+"<body bgcolor='#778899' text='#000000' link='#000000' vlink='#000000'>\n"
+"\n"
+"\n"
+"<!--                          -->\n"
+"<!--   the head of the page   -->\n"
+"<!--                          -->\n"
+"\n"
+"<table width='100%' border='0' cellspacing='1' cellpadding='3'>\n"
+" <tr><td>\n"
+"   <table border='1' cellspacing='1' cellpadding='0'>\n"
+"    <tr>\n"
+"    <td bgcolor='#000000'>\n"
+"     <table width='100%' border='0' bgcolor='#ffffff'>\n"
+"     <tr>\n"
+"       <td valign='top' align='left'>\n"
+"         <h1>&nbsp;Welcome to Dillo 0.8.0-i18n-misc&nbsp;</h1>\n"
+"       </td>\n"
+"     </tr>\n"
+"     </table>\n"
+"    </tr>\n"
+"   </table>\n"
+" </td></tr>\n"
+"</table>\n"
+"\n"
+"<font color='RED'>This is Unofficial Version.&nbsp;Please do not ask the "
+"dillo team.</font><br><!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"\n"
+"<!--                                   -->\n"
+"<!-- the main layout table, definition -->\n"
+"<!--                                   -->\n"
+"\n"
+"<table width='100%' border='0' cellspacing='0' cellpadding='0'>\n"
+"<tr><td valign='top' width='150' align='center'>\n"
+"\n"
+"\n"
+"<!--                        -->\n"
+"<!--   The navigation bar   -->\n"
+"<!--                        -->\n"
+"\n"
+"<table border='0' cellspacing='0' cellpadding='0' width='140' "
+"bgcolor='#000000'>\n"
+"<tr>\n"
+"  <td>\n"
+"    <table width='100%' border='0' cellspacing='1' cellpadding='3'>\n"
+"    <tr>\n"
+"      <td colspan='1' bgcolor='#CCCCCC'>\n"
+"        Dillo\n"
+"      </td>\n"
+"    </tr>\n"
+"    <tr>\n"
+"      <td bgcolor='#FFFFFF'>\n"
+"        <table border='0' cellspacing='0' cellpadding='5'><tr><td>\n"
+"        <table border='0' cellspacing='0' cellpadding='2'><tr>\n"
+"        <td></td>\n"
+"        <td>\n"
+"         <a href='http://www.dillo.org/dillo-help.html'>\n"
+"         Help</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.dillo.org/'>Home</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.dillo.org/funding/objectives.html'>\n"
+"         Objectives</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.dillo.org/ChangeLog.html'>\n"
+"         ChangeLog</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.dillo.org/interview.html'>\n"
+"           Interview</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.dillo.org/D_authors.html'>\n"
+"         Authors</a></td>\n"
+"        </tr></table>\n"
+"        </td></tr></table>\n"
+"      </td>\n"
+"    </tr>\n"
+"    </table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"<table border='0' cellspacing='0' cellpadding='0' width='140' "
+"bgcolor='#000000'>\n"
+"<tr>\n"
+"  <td>\n"
+"    <table width='100%' border='0' cellspacing='1' cellpadding='3'>\n"
+"    <tr>\n"
+"      <td colspan='1' bgcolor='#CCCCCC'>\n"
+"        Magazines\n"
+"      </td>\n"
+"    </tr>\n"
+"    <tr>\n"
+"      <td bgcolor='#FFFFFF'>\n"
+"        <table border='0' cellspacing='0' cellpadding='5'><tr><td>\n"
+"        <table border='0' cellpadding='2'><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://lwn.net'>LWN</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://slashdot.org/'>Slashdot</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.kuro5hin.org/?op=section;"
+"section=__all__'>KuroShin</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.nexusmagazine.com'>Nexus&nbsp;M.</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://linuxtoday.com/'>Linux Today</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.gnu-darwin.org/update.html'>Monster News</a></"
+"td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.theregister.co.uk/index.html'>The Register</a></"
+"td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.infoanarchy.org/'>InfoAnarchy</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.linuxforkids.org'>Linux4Kids</a></td>\n"
+"        </tr></table>\n"
+"        </td></tr></table>\n"
+"      </td>\n"
+"    </tr>\n"
+"    </table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"<table border='0' cellspacing='0' cellpadding='0' width='140' "
+"bgcolor='#000000'>\n"
+"<tr>\n"
+"  <td>\n"
+"    <table width='100%' border='0' cellspacing='1' cellpadding='3'>\n"
+"    <tr>\n"
+"      <td colspan='1' bgcolor='#CCCCCC'>\n"
+"        Additional Stuff\n"
+"      </td>\n"
+"    </tr>\n"
+"    <tr>\n"
+"      <td bgcolor='#FFFFFF'>\n"
+"        <table border='0' cellspacing='0' cellpadding='5'><tr><td>\n"
+"        <table border='0' cellpadding='2'><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td><a href='http://www.google.com/'>Google</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td><a href='http://www.wikipedia.org/'>Wikipedia</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td><a href='http://freshmeat.net/'>FreshMeat</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td><a href='http://www.gnu.org/gnu/thegnuproject.html'>GNU\n"
+"         project</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td><a href='http://www.linuxfund.org/'>LinuxFund</a></td>\n"
+"        </tr></table>\n"
+"        </td></tr></table>\n"
+"      </td>\n"
+"    </tr>\n"
+"    </table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"<table border='0' cellspacing='0' cellpadding='0' width='140' "
+"bgcolor='#000000'>\n"
+"<tr>\n"
+"  <td>\n"
+"    <table width='100%' border='0' cellspacing='1' cellpadding='3'>\n"
+"    <tr>\n"
+"      <td colspan='1' bgcolor='#CCCCCC'>\n"
+"        Essential Reading\n"
+"      </td>\n"
+"    </tr>\n"
+"    <tr>\n"
+"      <td bgcolor='#FFFFFF'>\n"
+"        <table border='0' cellspacing='0' cellpadding='5'><tr><td>\n"
+"        <table border='0' cellpadding='2'><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td><a href='http://www.violence.de'>Peace&amp;Violence</a></td>\n"
+"        </tr></table>\n"
+"        </td></tr></table>\n"
+"      </td>\n"
+"    </tr>\n"
+"    </table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"<!-- a small horizontal spacer -->\n"
+"<table border='0' width='100%' cellpadding='0' cellspacing='0'><tr><td "
+"height='10'></td></tr></table>\n"
+"\n"
+"\n"
+"\n"
+"<!--                                                -->\n"
+"<!-- the main layout table, a small vertical spacer -->\n"
+"<!--                                                -->\n"
+"\n"
+"</td><td width='20'></td><td valign='top'>\n"
+"\n"
+"\n"
+"<!--                           -->\n"
+"<!--   Main Part of the page   -->\n"
+"<!--                           -->\n"
+"\n"
+"<table border='0' cellpadding='0' cellspacing='0' align='center' "
+"bgcolor='#000000' width='100%'><tr><td>\n"
+"<table border='0' cellpadding='5' cellspacing='1' width='100%'>\n"
+"<tr>\n"
+"  <td bgcolor='#CCCCCC'>\n"
+"    <h4>Free Software</h4>\n"
+"  </td>\n"
+"</tr><tr>\n"
+"  <td bgcolor='#FFFFFF'>\n"
+"    <table border='0' cellspacing='0' cellpadding='5'><tr><td>\n"
+" <p>\n"
+" Dillo is Free Software in the terms of the GPL.\n"
+" This means you have four basic freedoms:\n"
+" <ul>\n"
+"  <li>Freedom to use the program any way you see fit.\n"
+"  <li>Freedom to study and modify the source code.\n"
+"  <li>Freedom to make backup copies.\n"
+"  <li>Freedom to redistribute it.\n"
+" </ul>\n"
+" The\n"
+"<a href='http://www.gnu.org/licenses/gpl.html'>GPL</a>\n"
+" is the legal mechanism that gives you these freedoms.\n"
+"It also protects them from being taken away: any derivative work\n"
+"based on the program must be under the GPL.\n"
+" <br>\n"
+"    </td></tr></table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"</td></tr></table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"<table border='0' cellpadding='0' cellspacing='0' align='center' "
+"bgcolor='#000000' width='100%'><tr><td>\n"
+"<table border='0' cellpadding='5' cellspacing='1' width='100%'>\n"
+"<tr>\n"
+"  <td bgcolor='#CCCCCC'>\n"
+"    <h4>Release overview</h4>\n"
+"    08 February 2004\n"
+"  </td>\n"
+"</tr><tr>\n"
+"  <td bgcolor='#FFFFFF'>\n"
+"    <table border='0' cellspacing='0' cellpadding='5'>\n"
+"    <tr>\n"
+"     <td>\n"
+"\n"
+"<p>\n"
+" After six months,\n"
+"the new dillo-0.8.0 comes with the largest set of improvements\n"
+"ever:\n"
+"<p>\n"
+" The dpi framework was redesigned. Now the communications and\n"
+"managing are done with a daemon: <em>dpid</em>. We also developed some\n"
+"plugins: downloads, ftp, hello, bookmarks. Downloads uses <em>wget</em>\n"
+"and it can handle several connections at the same time!\n"
+"<p>\n"
+" This release also introduces the <em>bug-meter</em>: a button that shows\n"
+"the count of detected HTML errors in a page, also providing the\n"
+"line where they occur and a hint of how to solve them.\n"
+"It's intended to help webmasters and page\n"
+"authors to polish the contents of their sites with a view to\n"
+"make them standards compliant.\n"
+"<p>\n"
+" Some interesting additions: a context menu for images, a\n"
+"web-search dialog, the \"-geometry\" switch in the CLI, lots of\n"
+"improvements inside the internal widget system, portability enhancements\n"
+"and the usual bug fixes.\n"
+"<p>\n"
+" These improvements, plus much more detailed in the ChangeLog,\n"
+"round up our best dillo!\n"
+"<p>\n"
+"Remember that dillo project uses a release model where every new\n"
+"browser shall be better than the former.\n"
+"<EM>Keep up with the latest one!</EM>\n"
+"\n"
+"     </td>\n"
+"    </tr></table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"</td></tr></table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"<table border='0' cellpadding='0' cellspacing='0' align='center' "
+"bgcolor='#000000' width='100%'><tr><td>\n"
+"<table border='0' cellpadding='5' cellspacing='1' width='100%'>\n"
+"<tr>\n"
+"  <td bgcolor='#CCCCCC'>\n"
+"    <h4>ChangeLog highlights</h4>\n"
+"    (Extracted from the\n"
+"    <a href='http://www.dillo.org/ChangeLog.html'>full\n"
+"    ChangeLog</a>)\n"
+"  </td>\n"
+"</tr><tr>\n"
+"  <td bgcolor='#FFFFFF'>\n"
+"    <table border='0' cellspacing='0' cellpadding='5'>\n"
+"    <tr>\n"
+"     <td>\n"
+"<ul>\n"
+"<li>Introduced a new way of handling dillo plugins! Now the\n"
+"   communications and managing is done by a daemon: dpid.\n"
+"   This comes with a lot of advantages described in Dpid.txt.\n"
+"<li>Developed a plugin for downloads. It uses wget and can handle several\n"
+"   connections at the same time.\n"
+"<li>Adapted the generic parser to make HTML error detection, providing\n"
+"   the line number and a hint (expected tag) in the error message!\n"
+"<li>Added a bug-meter button that shows the count of detected HTML errors\n"
+"   (left click shows the errors, right click offers a validation menu).\n"
+"<li>Added a right-mouse-button popup for images!\n"
+"<li>Added a web search dialog (with toolbar icon, shortcut is Ctrl-S).\n"
+"   The search engine can be set in dillorc (defaults to google).\n"
+"<li>Improved configure.in for better portability.\n"
+"<li>Made SPAM-safe URLs aware of image buttons.\n"
+"<li>Made images showing the ALT text as long as no image data has been\n"
+"   retrieved.\n"
+"<li>Added the \"-geometry\" switch to the CLI.\n"
+"<li>Fixed a bug in findtext (wrong highlighting).\n"
+"</ul>\n"
+"     </td>\n"
+"    </tr></table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"</td></tr></table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"<table border='0' cellpadding='0' cellspacing='0' align='center' "
+"bgcolor='#000000' width='100%'><tr><td>\n"
+"<table border='0' cellpadding='5' cellspacing='1' width='100%'>\n"
+"<tr>\n"
+"  <td bgcolor='#CCCCCC'>\n"
+"    <h4>Notes</h4>\n"
+"  </td>\n"
+"</tr><tr>\n"
+"  <td bgcolor='#FFFFFF'>\n"
+"    <table border='0' cellspacing='0' cellpadding='5'>\n"
+"    <tr>\n"
+"     <td>\n"
+" <ul>\n"
+"   <li> There's a\n"
+"     <a href='http://www.dillo.org/dillorc'>dillorc</a>\n"
+"     (readable  config)  file within the tarball; It is well commented\n"
+"     and  has  plenty  of  options to customize dillo, so <STRONG>copy\n"
+"     it</STRONG>  to  your  <STRONG>~/.dillo/</STRONG>  directory, and\n"
+"     modify to your taste.\n"
+"   <li> There's documentation for developers in the <CODE>/doc</CODE>\n"
+"     dir  within  the  tarball;  you can find directions on everything\n"
+"     else at the home page.\n"
+"   <li> Dillo has context sensitive menus using the\n"
+"     right mouse button (available on pages, links, images,\n"
+"     the Back and Forward buttons, and bug meter).\n"
+"   <li> Dillo behaves very nicely when browsing local files, images, and "
+"HTML.\n"
+"     It's also very good for Internet searching (try Google!).\n"
+"   <li> This release is mainly intended <strong>for developers</strong>\n"
+"        and <em>advanced users</em>\n"
+"   <li> Frames, Java and Javascript are not supported.\n"
+" </ul>\n"
+" <br>\n"
+"     </td>\n"
+"    </tr></table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"</td></tr></table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<table border='0' width='100%' cellpadding='0' cellspacing='0'><tr><td "
+"height='10'></td></tr></table>\n"
+"\n"
+"\n"
+"<!--                                                -->\n"
+"<!-- the main layout table, a small vertical spacer -->\n"
+"<!--                                                -->\n"
+"\n"
+"</td><td width='20'></td>\n"
+"\n"
+"\n"
+"\n"
+"<!--                             -->\n"
+"<!--   The right column (info)   -->\n"
+"<!--                             -->\n"
+"<td valign='top' align='center'>\n"
+"</td>\n"
+"\n"
+"\n"
+"<!--                              -->\n"
+"<!-- end of the main layout table -->\n"
+"<!--                              -->\n"
+"\n"
+"</tr>\n"
+"</table>\n"
+"\n"
+"<!--               -->\n"
+"<!--   footnotes   -->\n"
+"<!--               -->\n"
+"\n"
+"<br><br><center>\n"
+"<hr size='2'>\n"
+"<hr size='2'>\n"
+"</center>\n"
+"</body>\n"
+"</html>\n"
+msgstr ""
+
+#: src/IO/file.c:279
+msgid "Directory listing of"
+msgstr ""
+
+#: src/IO/file.c:487
+msgid "Parent directory"
+msgstr ""
+
+#: src/IO/file.c:651
+#, c-format
+msgid "ERROR: Can't find %s %s"
+msgstr ""
+
+#: src/IO/file.c:656
+#, c-format
+msgid "Warning: Can't find <%s>\n"
+msgstr ""
+
+#: src/IO/http.c:167
+#, c-format
+msgid "Getting %s, referer %s\n"
+msgstr ""
+
+#: src/IO/http.c:229
+#, c-format
+msgid ""
+"Query:\n"
+"%s"
+msgstr ""
+
+#: src/IO/http.c:256
+msgid "--Connection broken\n"
+msgstr ""
+
+#: src/IO/http.c:264 src/IO/https.c:173 src/IO/https.c:204
+msgid "ERROR: unable to connect to remote host"
+msgstr ""
+
+#: src/IO/http.c:272 src/IO/http.c:491 src/IO/http.c:522 src/IO/https.c:363
+#: src/IO/https.c:385
+#, c-format
+msgid "ERROR: %s"
+msgstr ""
+
+#: src/IO/http.c:280 src/IO/https.c:179
+msgid "--Connection established\n"
+msgstr ""
+
+#: src/IO/http.c:313
+#, c-format
+msgid "Http_connect_socket ERROR: %s\n"
+msgstr ""
+
+#: src/IO/http.c:334 src/IO/http.c:348
+#, c-format
+msgid "Connecting to %s\n"
+msgstr ""
+
+#: src/IO/http.c:367
+msgid "Contacting host..."
+msgstr ""
+
+#: src/IO/http.c:388 src/IO/https.c:280
+#, c-format
+msgid "Sending query to %s..."
+msgstr ""
+
+#: src/IO/http.c:457 src/IO/https.c:333
+#, c-format
+msgid "DNS solving %s"
+msgstr ""
+
+#: src/IO/http.c:535 src/IO/https.c:398
+#, c-format
+msgid "ERROR: Dns can't solve %s"
+msgstr ""
+
+#: src/IO/http.c:562 src/IO/https.c:419
+msgid "Query sent, waiting for reply..."
+msgstr ""
+
+#: src/IO/dpi.c:201
+msgid "ERROR: [Dpi_get_token] Can't find token start\n"
+msgstr ""
+
+#: src/IO/dpi.c:231
+msgid "ERROR: [Dpi_get_token] *** NULL code here ***\n"
+msgstr ""
+
+#: src/IO/dpi.c:258
+#, c-format
+msgid "Dpi_parse_token: [%s]\n"
+msgstr ""
+
+#: src/IO/dpi.c:316
+msgid "Dpi: [Dpi_process_io] IOClose\n"
+msgstr ""
+
+#: src/IO/dpi.c:342
+#, c-format
+msgid "Dpi_start_dpid (child): %s\n"
+msgstr ""
+
+#: src/IO/dpi.c:350 src/IO/dpi.c:359
+#, c-format
+msgid "Dpi_start_dpid: %s\n"
+msgstr ""
+
+#: src/IO/dpi.c:355
+#, c-format
+msgid "Dpi_start_dpid: n = %d\n"
+msgstr ""
+
+#: src/IO/dpi.c:382
+#, c-format
+msgid "Dpi_check_uds: %s %s\n"
+msgstr ""
+
+#: src/IO/dpi.c:753 src/IO/dpi.c:757
+#, c-format
+msgid "a_Dpi_bye_dpid: %s\n"
+msgstr ""
+
+#: src/IO/https.c:168
+msgid "--Error detected\n"
+msgstr ""
+
+#: src/IO/https.c:361
+msgid " HTTP: new abort handler! #2\n"
+msgstr ""
+
+#: src/IO/https.c:384
+msgid " HTTP: new abort handler! #1\n"
+msgstr ""
+
+#: src/i18n.c:213
+msgid "charset detect may mistake...\n"
+msgstr ""
+
+#: src/i18n.c:280
+msgid "all ascii code\n"
+msgstr ""
+
+#: src/i18n.c:330
+msgid "unable to fully convert between character encodings\n"
+msgstr ""
+
+#: src/i18n.c:367
+msgid "no support enc\n"
+msgstr ""
+
+#: src/auth.c:39
+msgid "realm"
+msgstr ""
diff -Nur dillo-0.8.0/po/en@boldquot.header dillo-0.8.0.new/po/en@boldquot.header
--- dillo-0.8.0/po/en@boldquot.header	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/po/en@boldquot.header	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,25 @@
+# All this catalog "translates" are quotation characters.
+# The msgids must be ASCII and therefore cannot contain real quotation
+# characters, only substitutes like grave accent (0x60), apostrophe (0x27)
+# and double quote (0x22). These substitutes look strange; see
+# http://www.cl.cam.ac.uk/~mgk25/ucs/quotes.html
+#
+# This catalog translates grave accent (0x60) and apostrophe (0x27) to
+# left single quotation mark (U+2018) and right single quotation mark (U+2019).
+# It also translates pairs of apostrophe (0x27) to
+# left single quotation mark (U+2018) and right single quotation mark (U+2019)
+# and pairs of quotation mark (0x22) to
+# left double quotation mark (U+201C) and right double quotation mark (U+201D).
+#
+# When output to an UTF-8 terminal, the quotation characters appear perfectly.
+# When output to an ISO-8859-1 terminal, the single quotation marks are
+# transliterated to apostrophes (by iconv in glibc 2.2 or newer) or to
+# grave/acute accent (by libiconv), and the double quotation marks are
+# transliterated to 0x22.
+# When output to an ASCII terminal, the single quotation marks are
+# transliterated to apostrophes, and the double quotation marks are
+# transliterated to 0x22.
+#
+# This catalog furthermore displays the text between the quotation marks in
+# bold face, assuming the VT100/XTerm escape sequences.
+#
diff -Nur dillo-0.8.0/po/en@quot.header dillo-0.8.0.new/po/en@quot.header
--- dillo-0.8.0/po/en@quot.header	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/po/en@quot.header	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,22 @@
+# All this catalog "translates" are quotation characters.
+# The msgids must be ASCII and therefore cannot contain real quotation
+# characters, only substitutes like grave accent (0x60), apostrophe (0x27)
+# and double quote (0x22). These substitutes look strange; see
+# http://www.cl.cam.ac.uk/~mgk25/ucs/quotes.html
+#
+# This catalog translates grave accent (0x60) and apostrophe (0x27) to
+# left single quotation mark (U+2018) and right single quotation mark (U+2019).
+# It also translates pairs of apostrophe (0x27) to
+# left single quotation mark (U+2018) and right single quotation mark (U+2019)
+# and pairs of quotation mark (0x22) to
+# left double quotation mark (U+201C) and right double quotation mark (U+201D).
+#
+# When output to an UTF-8 terminal, the quotation characters appear perfectly.
+# When output to an ISO-8859-1 terminal, the single quotation marks are
+# transliterated to apostrophes (by iconv in glibc 2.2 or newer) or to
+# grave/acute accent (by libiconv), and the double quotation marks are
+# transliterated to 0x22.
+# When output to an ASCII terminal, the single quotation marks are
+# transliterated to apostrophes, and the double quotation marks are
+# transliterated to 0x22.
+#
diff -Nur dillo-0.8.0/po/insert-header.sin dillo-0.8.0.new/po/insert-header.sin
--- dillo-0.8.0/po/insert-header.sin	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/po/insert-header.sin	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,23 @@
+# Sed script that inserts the file called HEADER before the header entry.
+#
+# At each occurrence of a line starting with "msgid ", we execute the following
+# commands. At the first occurrence, insert the file. At the following
+# occurrences, do nothing. The distinction between the first and the following
+# occurrences is achieved by looking at the hold space.
+/^msgid /{
+x
+# Test if the hold space is empty.
+s/m/m/
+ta
+# Yes it was empty. First occurrence. Read the file.
+r HEADER
+# Output the file's contents by reading the next line. But don't lose the
+# current line while doing this.
+g
+N
+bb
+:a
+# The hold space was nonempty. Following occurrences. Do nothing.
+x
+:b
+}
  dillo-0.8.0/po/ja.gmo  dillo-0.8.0.new/po/ja.gmo 
diff -Nur dillo-0.8.0/po/ja.po dillo-0.8.0.new/po/ja.po
--- dillo-0.8.0/po/ja.po	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/po/ja.po	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,2882 @@
+# DILLO 
+# Copyright (C) 2003
+# This file is distributed under the same license as the dillo package.
+# Kiyo <kiyo@teki.jpn.ph>, 2003.
+msgid ""
+msgstr ""
+"Project-Id-Version: dillo 0.8.0-i18n-misc-2004xx\n"
+"POT-Creation-Date: 2004-06-02 23:54+0900\n"
+"PO-Revision-Date: 2003-10-02 13:10+0900\n"
+"Last-Translator: Kiyo <kiyo@teki.jpn.ph>\n"
+"Language-Team: Japanese <kiyo@teki.jpn.ph>\n"
+"MIME-Version: 1.0\n"
+"Content-Type: text/plain; charset=EUC-JP\n"
+"Content-Transfer-Encoding: 8bit\n"
+"Report-Msgid-Bugs-To: \n"
+
+#: config/dillocfg.c:78 src/html.c:4033
+msgid "Reset"
+msgstr ""
+
+#: config/dillocfg.c:79 src/interface.c:350
+msgid "Reload"
+msgstr ""
+
+#: config/dillocfg.c:80 src/interface.c:363
+msgid "Save"
+msgstr ""
+
+#: config/dillocfg.c:81
+msgid "Quit"
+msgstr ""
+
+#: config/dillocfg.c:83 config/dillocfg.c:89
+msgid "Dillo Preferences"
+msgstr "Dillo "
+
+#: config/dillocfg.c:112
+msgid "Interface"
+msgstr ""
+
+#: config/dillocfg.c:113
+msgid "  Font  "
+msgstr "    "
+
+#: config/dillocfg.c:114
+msgid "  Color "
+msgstr "      "
+
+#: config/dillocfg.c:115
+msgid " Network "
+msgstr "  "
+
+#: config/dillocfg.c:117
+msgid "   Tab   "
+msgstr "      "
+
+#: config/dillocfg.c:120
+msgid "  Other  "
+msgstr "    "
+
+#: config/dillocfg.c:317
+msgid "Add"
+msgstr ""
+
+#: config/dillocfg.c:318
+msgid "Delete"
+msgstr ""
+
+#: config/dillocfg.c:324
+msgid "Address"
+msgstr ""
+
+#: config/dillocfg.c:325
+msgid "Rule"
+msgstr ""
+
+#: config/dillocfg.c:351 config/dillocfg.c:357
+#, c-format
+msgid "Read failed <%s>\n"
+msgstr "<%s>\n"
+
+#: config/dillocfg.c:438 config/dillocfg.c:446
+#, c-format
+msgid "can't write <%s>\n"
+msgstr "<%s>\n"
+
+#: config/dillocfg_token.c:61
+msgid "Window Size"
+msgstr "Window"
+
+#: config/dillocfg_token.c:69
+msgid "HTTP Proxy"
+msgstr "HTTP"
+
+#: config/dillocfg_token.c:77
+msgid "NO Proxy"
+msgstr ""
+
+#: config/dillocfg_token.c:85
+msgid "User-Agent"
+msgstr ""
+
+#: config/dillocfg_token.c:93
+msgid "Link color"
+msgstr ""
+
+#: config/dillocfg_token.c:101
+msgid "Visited color"
+msgstr ""
+
+#: config/dillocfg_token.c:109
+msgid "BackGround color"
+msgstr ""
+
+#: config/dillocfg_token.c:117
+msgid "Allow white bg"
+msgstr ""
+
+#: config/dillocfg_token.c:125
+msgid "Force my colors"
+msgstr ""
+
+#: config/dillocfg_token.c:133
+msgid "Force visited color"
+msgstr ""
+
+#: config/dillocfg_token.c:141
+msgid "Text color"
+msgstr ""
+
+#: config/dillocfg_token.c:149
+msgid "Use oblique"
+msgstr ""
+
+#: config/dillocfg_token.c:157
+msgid "STARTUP"
+msgstr "URL"
+
+#: config/dillocfg_token.c:165
+msgid "HOMEPAGE"
+msgstr ""
+
+#: config/dillocfg_token.c:173
+msgid "Search-engine's URL"
+msgstr "URL"
+
+#: config/dillocfg_token.c:181
+msgid "Search-engine's charset"
+msgstr ""
+
+#: config/dillocfg_token.c:189
+msgid "Show Tooltip"
+msgstr ""
+
+#: config/dillocfg_token.c:197
+msgid "Panel Size"
+msgstr ""
+
+#: config/dillocfg_token.c:205
+msgid "Small icons"
+msgstr ""
+
+#: config/dillocfg_token.c:213
+msgid "Limit text width"
+msgstr ""
+
+#: config/dillocfg_token.c:221
+msgid "Limit font decoration"
+msgstr ""
+
+#: config/dillocfg_token.c:229
+msgid "Font factor"
+msgstr ""
+
+#: config/dillocfg_token.c:237
+msgid "Font Sizes"
+msgstr ""
+
+#: config/dillocfg_token.c:245
+msgid "Use dicache"
+msgstr ""
+
+#: config/dillocfg_token.c:253
+msgid "Show Back"
+msgstr ""
+
+#: config/dillocfg_token.c:261
+msgid "Show Forw"
+msgstr ""
+
+#: config/dillocfg_token.c:269
+msgid "Show Home"
+msgstr ""
+
+#: config/dillocfg_token.c:277
+msgid "Show Reload"
+msgstr ""
+
+#: config/dillocfg_token.c:285
+msgid "Show Save"
+msgstr ""
+
+#: config/dillocfg_token.c:293
+msgid "Show Stop"
+msgstr ""
+
+#: config/dillocfg_token.c:301
+msgid "Show Bookmarks"
+msgstr ""
+
+#: config/dillocfg_token.c:309
+msgid "Show Menubar"
+msgstr ""
+
+#: config/dillocfg_token.c:317
+msgid "Show ClearURL"
+msgstr "URL"
+
+#: config/dillocfg_token.c:325
+msgid "Show URL box"
+msgstr "URL"
+
+#: config/dillocfg_token.c:333
+msgid "Show Search box"
+msgstr ""
+
+#: config/dillocfg_token.c:341
+msgid "Show Progress box"
+msgstr ""
+
+#: config/dillocfg_token.c:349
+msgid "Show Popup navigation"
+msgstr ""
+
+#: config/dillocfg_token.c:357
+msgid "Show User-Agent"
+msgstr ""
+
+#: config/dillocfg_token.c:365
+msgid "Fullwindow start"
+msgstr ""
+
+#: config/dillocfg_token.c:373
+msgid "Transient dialogs"
+msgstr ""
+
+#: config/dillocfg_token.c:381
+msgid "vw_aafontname"
+msgstr "AA"
+
+#: config/dillocfg_token.c:389
+msgid "fw_aafontname"
+msgstr "AA"
+
+#: config/dillocfg_token.c:397
+msgid "vw_fontname"
+msgstr ""
+
+#: config/dillocfg_token.c:405
+msgid "fw_fontname"
+msgstr ""
+
+#: config/dillocfg_token.c:413
+msgid "Generate submit"
+msgstr ""
+
+#: config/dillocfg_token.c:421
+msgid "Enterpress forces submit"
+msgstr "Enter"
+
+#: config/dillocfg_token.c:429
+msgid "Show debugging messsages"
+msgstr ""
+
+#: config/dillocfg_token.c:437
+msgid "Use old parser"
+msgstr ""
+
+#: config/dillocfg_token.c:445
+msgid "Focus location on new"
+msgstr "WindowURL"
+
+#: config/dillocfg_token.c:453
+msgid "Accept Language"
+msgstr ""
+
+#: config/dillocfg_token.c:462
+msgid "Tab load in background"
+msgstr "Tab"
+
+#: config/dillocfg_token.c:470
+msgid "Tab close middle click"
+msgstr "Tab"
+
+#: config/dillocfg_token.c:478
+msgid "Tab instead of window"
+msgstr "WindowTab"
+
+#: config/dillocfg_token.c:486
+msgid "Tab bar show fullscreen"
+msgstr "Tab"
+
+#: config/dillocfg_token.c:494
+msgid "Tab bar show single tab"
+msgstr "Tab"
+
+#: config/dillocfg_token.c:502
+msgid "Tab bar scroller"
+msgstr "Tab"
+
+#: config/dillocfg_token.c:510
+msgid "Tab bar homogeneous"
+msgstr "Tab"
+
+#: config/dillocfg_token.c:518
+msgid "Tab title compress"
+msgstr "Tab"
+
+#: config/dillocfg_token.c:526
+msgid "Compress vowels"
+msgstr ""
+
+#: config/dillocfg_token.c:534
+msgid "Compress_common_prefixes"
+msgstr ""
+
+#: config/dillocfg_token.c:543
+msgid "Default"
+msgstr ""
+
+#: dpi/bookmarks.c:86
+msgid ""
+"<html>\n"
+"<head>\n"
+"<title>Bookmarks</title>\n"
+"</head>\n"
+"<body bgcolor='#778899' link='black' vlink='gray'>\n"
+"<table border='1' cellpadding='0' width='100%'>\n"
+" <tr><td>\n"
+"  <table width='100%' bgcolor='#b4b4b4'>\n"
+"   <tr>\n"
+"    <td>&nbsp;Bookmarks::</td>\n"
+"    <td width='100%' align='right'>\n"
+"     [<a href='dpi:/bm/modify'>modify</a>]\n"
+"    </td></tr>\n"
+"  </table></td></tr>\n"
+"</table>\n"
+"<br>\n"
+msgstr ""
+"<html>\n"
+"<head>\n"
+"<title></title>\n"
+"</head>\n"
+"<body bgcolor='#778899' link='black' vlink='gray'>\n"
+"<table border='1' cellpadding='0' width='100%'>\n"
+" <tr><td>\n"
+"  <table width='100%' bgcolor='#b4b4b4'>\n"
+"   <tr>\n"
+"    <td><pre> ::</pre></td>\n"
+"    <td width='100%' align='right'>\n"
+"     <pre>[<a href='dpi:/bm/modify'></a>]</pre>\n"
+"    </td></tr>\n"
+"  </table></td></tr>\n"
+"</table>\n"
+"<br>\n"
+
+#: dpi/bookmarks.c:104
+msgid ""
+"<html>\n"
+"<head>\n"
+"<title>Bookmarks</title>\n"
+"</head>\n"
+"<body bgcolor='#778899' link='black' vlink='gray'>\n"
+"<table border='1' cellpadding='0' width='100%'>\n"
+" <tr><td>\n"
+"  <table width='100%' bgcolor='#b4b4b4'>\n"
+"   <tr>\n"
+"    <td>&nbsp;Bookmarks :: modify</td></tr>\n"
+"  </table></td></tr>                            \n"
+"</table>                                        \n"
+"\n"
+"<form>\n"
+"<table width='100%' border='1' cellpadding='0'>\n"
+" <tr><td>\n"
+"  <table width='100%' bgcolor='teal'>\n"
+"   <tr><b>\n"
+"    <td>Select&nbsp;an&nbsp;operation&nbsp;</td>\n"
+"    <td><select name='operation'>\n"
+"     <option value='none' selected>--\n"
+"     <option value='delete'>Delete\n"
+"     <option value='move'>Move\n"
+"     <option value='modify'>Modify\n"
+"     <option value='add_sec'>Add Section\n"
+"     <option value='add_url'>Add URL\n"
+"     </select></td>\n"
+"    <td>,&nbsp;mark&nbsp;its&nbsp;operands,&nbsp;and&nbsp;</td>\n"
+"    <td><input type='submit' name='submit' value='submit.'></td>\n"
+"    <td width='100%'></td>\n"
+"    </b></tr>\n"
+"  </table></td></tr>\n"
+"</table>\n"
+msgstr ""
+"<html>\n"
+"<head>\n"
+"<title></title>\n"
+"</head>\n"
+"<body bgcolor='#778899' link='black' vlink='gray'>\n"
+"<table border='1' cellpadding='0' width='100%'>\n"
+" <tr><td>\n"
+"  <table width='100%' bgcolor='#b4b4b4'>\n"
+"   <tr>\n"
+"    <td><pre>&nbsp; :: </pre></td></tr>\n"
+"  </table></td></tr>                            \n"
+"</table>                                        \n"
+"\n"
+"<table width='100%' border='1' cellpadding='0'>\n"
+" <form>\n"
+" <tr><td>\n"
+"  <table width='100%' bgcolor='teal'>\n"
+"   <tr><b>\n"
+"    <td><pre>&nbsp;</pre></td>\n"
+"    <td><select name='operation'>\n"
+"     <option value='none' selected>--\n"
+"     <option value='delete'>\n"
+"     <option value='move'>\n"
+"     <option value='modify'>\n"
+"     <option value='add_sec'>\n"
+"     <option value='add_url'>URL\n"
+"     </select></td>\n"
+"    <td><pre></pre></td>\n"
+"    <td><input type='submit' name='submit' value=''></td>\n"
+"    <td width='100%'></td>\n"
+"    </b></tr>\n"
+"  </table></td></tr>\n"
+"</table>\n"
+
+#: dpi/bookmarks.c:139
+msgid ""
+"<table border='1' cellpadding='0' cellspacing='20' width='100%'>\n"
+" <tr valign='top'>\n"
+"  <td>\n"
+"   <table bgcolor='#b4b4b4' border='1' cellpadding='4' cellspacing='1'>\n"
+"    <tr><td>\n"
+"     <table width='100%' bgcolor='#b4b4b4'>\n"
+"      <tr><td><small>Sections:</small></td></tr></table></td></tr>\n"
+msgstr ""
+"<table border='1' cellpadding='0' cellspacing='20' width='100%'>\n"
+" <tr valign='top'>\n"
+"  <td>\n"
+"   <table bgcolor='#b4b4b4' border='1' cellpadding='4' cellspacing='1'>\n"
+"    <tr><td>\n"
+"     <table width='100%' bgcolor='#b4b4b4'>\n"
+"      <tr><td><small><pre>:</pre></small></td></tr></table></td></"
+"tr>\n"
+
+#: dpi/bookmarks.c:148
+msgid ""
+"<table border='1' cellpadding='0' cellspacing='20' width='100%'>\n"
+" <tr valign='top'>\n"
+"  <td>\n"
+"   <table bgcolor='#b4b4b4' border='1'>\n"
+"    <tr><td>\n"
+"     <table width='100%' bgcolor='#b4b4b4'>\n"
+"      <tr><td><small>Sections:</small></td></tr></table></td></tr>\n"
+msgstr ""
+"<table border='1' cellpadding='0' cellspacing='20' width='100%'>\n"
+" <tr valign='top'>\n"
+"  <td>\n"
+"   <table bgcolor='#b4b4b4' border='1' cellpadding='4' cellspacing='1'>\n"
+"    <tr><td>\n"
+"     <table width='100%' bgcolor='#b4b4b4'>\n"
+"      <tr><td><small><pre>:</pre></small></td></tr></table></td></"
+"tr>\n"
+
+#: dpi/bookmarks.c:157
+#, c-format
+msgid ""
+"    <tr><td>\n"
+"     <table width='100%%' bgcolor='#b4b4b4'>\n"
+"      <tr><td><b><a href='#s%d'>%s</a></b></td></tr></table></td></tr>\n"
+msgstr ""
+"    <tr><td>\n"
+"     <table width='100%%' bgcolor='#b4b4b4'>\n"
+"      <tr><td><b><a href='#s%d'><pre>%s</pre></a></b></td></tr></table></"
+"td></tr>\n"
+
+#: dpi/bookmarks.c:162
+#, c-format
+msgid ""
+"    <tr><td>\n"
+"     <table width='100%%' bgcolor='#b4b4b4'>\n"
+"      <tr><td width='1%%'><input type='checkbox' name='s%d'></td>\n"
+"       <td><b><a href='#s%d'>%s</a></b></td></tr></table></td></tr>\n"
+msgstr ""
+"    <tr><td>\n"
+"     <table width='100%%' bgcolor='#b4b4b4'>\n"
+"      <tr><td width='1%%'><input type='checkbox' name='s%d'></td>\n"
+"       <td><b><a href='#s%d'><pre>%s</pre></a></b></td></tr></table></td></"
+"tr>\n"
+
+#: dpi/bookmarks.c:182 dpi/bookmarks.c:190
+#, c-format
+msgid ""
+"   <a name='s%d'></a>\n"
+"   <table bgcolor='#bfbfbf' width='100%%' cellspacing='2'>\n"
+"    <tr>\n"
+"     <td bgcolor='#bf0c0c'><font color='white'><b>\n"
+"      &nbsp;&nbsp;&nbsp;%s&nbsp;&nbsp;&nbsp;</b></font></td>\n"
+"     <td bgcolor='white' width='100%%'>&nbsp;</td></tr>\n"
+msgstr ""
+"   <a name='s%d'></a>\n"
+"   <table bgcolor='#bfbfbf' width='100%%' cellspacing='2'>\n"
+"    <tr>\n"
+"     <td bgcolor='#bf0c0c'><font color='white'><b>\n"
+"      <pre>&nbsp;&nbsp;&nbsp;%s&nbsp;&nbsp;&nbsp;</pre></b></font></td>\n"
+"     <td bgcolor='white' width='100%%'>&nbsp;</td></tr>\n"
+
+#: dpi/bookmarks.c:231
+msgid ""
+"<html>\n"
+"<head>\n"
+"<title>Bookmarks</title>\n"
+"</head>\n"
+"<body bgcolor='#778899' link='black' vlink='gray'>\n"
+"<table border='1' cellpadding='0' width='100%'>\n"
+" <tr><td colspan='2'>\n"
+"  <table bgcolor='#b4b4b4' width='100%'>\n"
+"   <tr><td bgcolor='#b4b4b4'>&nbsp;Modify bookmarks:: add section\n"
+"   </td></tr></table></td></tr>\n"
+"</table>\n"
+"<br>\n"
+"<form>\n"
+" <input type='hidden' name='operation' value='add_section'>\n"
+"<table border='1' width='100%'>\n"
+" <tr>\n"
+"  <td bgcolor='olive'><b>New&nbsp;section:</b></td>\n"
+"  <td bgcolor='white' width='100%'></td></tr>\n"
+"</table>\n"
+"<table width='100%' cellpadding='10'>\n"
+"<tr><td>\n"
+" <table width='100%' bgcolor='teal'>\n"
+"  <tr>\n"
+"   <td>Title:</td>\n"
+"   <td><input type='text' name='title' size='64'></td></tr>\n"
+" </table>\n"
+" </td></tr>\n"
+"</table>\n"
+"<table width='100%' cellpadding='4' border='0'>\n"
+"<tr><td bgcolor='#a0a0a0'>\n"
+" <input type='submit' name='submit' value='submit.'></td></tr>\n"
+"</table>\n"
+"</form>\n"
+"</body>\n"
+"</html>\n"
+"\n"
+msgstr ""
+"<html>\n"
+"<head>\n"
+"<title></title>\n"
+"</head>\n"
+"<body bgcolor='#778899' link='black' vlink='gray'>\n"
+"<table border='1' cellpadding='0' width='100%'>\n"
+" <tr><td colspan='2'>\n"
+"  <table bgcolor='#b4b4b4' width='100%'>\n"
+"   <tr><td bgcolor='#b4b4b4'><pre>&nbsp;:: "
+"</pre>\n"
+"   </td></tr></table></td></tr>\n"
+"</table>\n"
+"<br>\n"
+"<form>\n"
+" <input type='hidden' name='operation' value='add_section'>\n"
+"<table border='1' width='100%'>\n"
+" <tr>\n"
+"  <td bgcolor='olive'><b><pre> :</pre></b></td>\n"
+"  <td bgcolor='white' width='100%'></td></tr>\n"
+"</table>\n"
+"<table width='100%' cellpadding='10'>\n"
+"<tr><td>\n"
+" <table width='100%' bgcolor='teal'>\n"
+"  <tr>\n"
+"   <td><pre>:</pre></td>\n"
+"   <td><input type='text' name='title' size='64'></td></tr>\n"
+" </table>\n"
+" </td></tr>\n"
+"</table>\n"
+"<table width='100%' cellpadding='4' border='0'>\n"
+"<tr><td bgcolor='#a0a0a0'>\n"
+" <input type='submit' name='submit' value=''></td></tr>\n"
+"</table>\n"
+"</form>\n"
+"</body>\n"
+"</html>\n"
+"\n"
+
+#: dpi/bookmarks.c:270
+msgid ""
+"<html>\n"
+"<head>\n"
+"<title>Bookmarks</title>\n"
+"</head>\n"
+"<body bgcolor='#778899' link='black' vlink='gray'>\n"
+"<table border='1' cellpadding='0' width='100%'>\n"
+" <tr><td colspan='2'>\n"
+"  <table bgcolor='#b4b4b4' width='100%'>\n"
+"   <tr><td bgcolor='#b4b4b4'>&nbsp;Modify bookmarks:: update\n"
+"   </td></tr></table></td></tr>\n"
+"</table>\n"
+"<br>\n"
+"<form>\n"
+"<input type='hidden' name='operation' value='modify2'>\n"
+msgstr ""
+"<html>\n"
+"<head>\n"
+"<title></title>\n"
+"</head>\n"
+"<body bgcolor='#778899' link='black' vlink='gray'>\n"
+"<table border='1' cellpadding='0' width='100%'>\n"
+" <tr><td colspan='2'>\n"
+"  <table bgcolor='#b4b4b4' width='100%'>\n"
+"   <tr><td bgcolor='#b4b4b4'><pre>&nbsp;:: </"
+"pre>\n"
+"   </td></tr></table></td></tr>\n"
+"</table>\n"
+"<br>\n"
+"<form>\n"
+"<input type='hidden' name='operation' value='modify2'>\n"
+
+#: dpi/bookmarks.c:296
+#, c-format
+msgid ""
+"<tr><td>\n"
+" <table width='100%%' bgcolor='teal'>\n"
+"  <tr>\n"
+"   <td>Title:</td>\n"
+"   <td><input type='text' name='title%d' size='64'\n"
+"        value='%s'></td></tr>\n"
+"  <tr>\n"
+"   <td>URL:</td>\n"
+"   <td>%s</td></tr>\n"
+" </table>\n"
+" </td></tr>\n"
+msgstr ""
+"<tr><td>\n"
+" <table width='100%%' bgcolor='teal'>\n"
+"  <tr>\n"
+"   <td><pre>:</pre></td>\n"
+"   <td><input type='text' name='title%d' size='64'\n"
+"        value='%s'></td></tr>\n"
+"  <tr>\n"
+"   <td>URL:</td>\n"
+"   <td>%s</td></tr>\n"
+" </table>\n"
+" </td></tr>\n"
+
+#: dpi/bookmarks.c:309
+#, c-format
+msgid ""
+"<tr><td>\n"
+" <table width='100%%' bgcolor='teal'>\n"
+"  <tr>\n"
+"   <td>Title:</td>\n"
+"   <td><input type='text' name='s%d' size='64'\n"
+"        value='%s'></td></tr>\n"
+" </table>\n"
+" </td></tr>\n"
+msgstr ""
+"<tr><td>\n"
+" <table width='100%%' bgcolor='teal'>\n"
+"  <tr>\n"
+"   <td><pre>:</pre></td>\n"
+"   <td><input type='text' name='s%d' size='64'\n"
+"        value='%s'></td></tr>\n"
+" </table>\n"
+" </td></tr>\n"
+
+#: dpi/bookmarks.c:322
+#, c-format
+msgid ""
+"<table width='100%' cellpadding='4' border='0'>\n"
+"<tr><td bgcolor='#a0a0a0'>\n"
+" <input type='submit' name='submit' value='submit.'></td></tr>\n"
+"</table>\n"
+"</form>\n"
+"</body>\n"
+"</html>\n"
+msgstr ""
+"<table width='100%' cellpadding='4' border='0'>\n"
+"<tr><td bgcolor='#a0a0a0'>\n"
+" <input type='submit' name='submit' value=''></td></tr>\n"
+"</table>\n"
+"</form>\n"
+"</body>\n"
+"</html>\n"
+
+#: dpi/bookmarks.c:332
+msgid ""
+"<html>\n"
+"<head>\n"
+"<title>Bookmarks</title>\n"
+"</head>\n"
+"<body bgcolor='#778899' link='black' vlink='gray'>\n"
+"<table border='1' cellpadding='0' width='100%'>\n"
+" <tr><td colspan='2'>\n"
+"  <table bgcolor='#b4b4b4' width='100%'>\n"
+"   <tr><td bgcolor='#b4b4b4'>&nbsp;Modify bookmarks:: add url\n"
+"   </td></tr></table></td></tr>\n"
+"</table>\n"
+"<br>\n"
+"<form>\n"
+"<input type='hidden' name='operation' value='add_url2'>\n"
+"<table border='1' width='100%'>\n"
+" <tr>\n"
+"  <td bgcolor='olive'><b>Add&nbsp;url:</b></td>\n"
+"  <td bgcolor='white' width='100%'></td></tr>\n"
+"</table>\n"
+"<table width='100%' cellpadding='10'>\n"
+"<tr><td>\n"
+" <table width='100%' bgcolor='teal'>\n"
+"  <tr>\n"
+"   <td>Title:</td>\n"
+"   <td><input type='text' name='title' size='64'></td></tr>\n"
+"  <tr>\n"
+"   <td>URL:</td>\n"
+"   <td><input type='text' name='url' size='64'></td></tr>\n"
+" </table>\n"
+" </td></tr>\n"
+"</table>\n"
+"<table width='100%' cellpadding='4' border='0'>\n"
+"<tr><td bgcolor='#a0a0a0'>\n"
+" <input type='submit' name='submit' value='submit.'></td></tr>\n"
+"</table>\n"
+"</form>\n"
+"</body>\n"
+"</html>\n"
+msgstr ""
+"<html>\n"
+"<head>\n"
+"<title></title>\n"
+"</head>\n"
+"<body bgcolor='#778899' link='black' vlink='gray'>\n"
+"<table border='1' cellpadding='0' width='100%'>\n"
+" <tr><td colspan='2'>\n"
+"  <table bgcolor='#b4b4b4' width='100%'>\n"
+"   <tr><td bgcolor='#b4b4b4'><pre>&nbsp;:: URL</"
+"pre>\n"
+"   </td></tr></table></td></tr>\n"
+"</table>\n"
+"<br>\n"
+"<form>\n"
+"<input type='hidden' name='operation' value='add_url2'>\n"
+"<table border='1' width='100%'>\n"
+" <tr>\n"
+"  <td bgcolor='olive'><b><pre>URL:</pre></b></td>\n"
+"  <td bgcolor='white' width='100%'></td></tr>\n"
+"</table>\n"
+"<table width='100%' cellpadding='10'>\n"
+"<tr><td>\n"
+" <table width='100%' bgcolor='teal'>\n"
+"  <tr>\n"
+"   <td><pre>:</pre></td>\n"
+"   <td><input type='text' name='title' size='64'></td></tr>\n"
+"  <tr>\n"
+"   <td>URL:</td>\n"
+"   <td><input type='text' name='url' size='64'></td></tr>\n"
+" </table>\n"
+" </td></tr>\n"
+"</table>\n"
+"<table width='100%' cellpadding='4' border='0'>\n"
+"<tr><td bgcolor='#a0a0a0'>\n"
+" <input type='submit' name='submit' value=''></td></tr>\n"
+"</table>\n"
+"</form>\n"
+"</body>\n"
+"</html>\n"
+
+#: dpi/bookmarks.c:757
+msgid "Unclassified"
+msgstr ""
+
+#: dpi/bookmarks.c:790
+#, c-format
+msgid "echo \":s0: Unclassified\" > %s"
+msgstr "echo \":s0: \" > %s"
+
+#: dpi/bookmarks.c:851
+#, c-format
+msgid ""
+"Syntax error in bookmarks file:\n"
+" %s"
+msgstr ": %s"
+
+#: dpi/bookmarks.c:958
+msgid "Added bookmark!"
+msgstr "!"
+
+#: dpi/bookmarks.c:1154
+msgid "Update&nbsp;sections:"
+msgstr "<pre>:</pre>"
+
+#: dpi/bookmarks.c:1174
+msgid "Update&nbsp;titles:"
+msgstr "<pre>:</pre>"
+
+#: dpi/bookmarks.c:1474
+msgid "Delete: you must mark what to delete!"
+msgstr ": !"
+
+#: dpi/bookmarks.c:1480
+msgid "Move: you must mark a target section!"
+msgstr ": !"
+
+#: dpi/bookmarks.c:1482
+msgid "Move: can not move a section (yet)."
+msgstr ": ()"
+
+#: dpi/bookmarks.c:1484
+msgid "Move: you must mark some urls, and a target section!"
+msgstr ": URL()!"
+
+#: dpi/bookmarks.c:1489
+msgid "Modify: you must mark what to update!"
+msgstr ": !"
+
+#: dpi/bookmarks.c:1506
+msgid "Add url: only one target section is allowed!"
+msgstr "URL: !"
+
+#: dpi/bookmarks.c:1513
+msgid "No operation, just do nothing!"
+msgstr "!"
+
+#: dpi/bookmarks.c:1516
+msgid "Sorry, not implemented yet."
+msgstr ""
+
+#: dpi/bookmarks.c:1680
+msgid "Haven't got a full tag!\n"
+msgstr "!\n"
+
+#: dpi/bookmarks.c:1720 src/tab.c:293 src/tab.c:425
+msgid "(Untitled)"
+msgstr "()"
+
+#: dpi/bookmarks.c:1761
+msgid "<HTML><body> Error on the bookmarks server...</body></html>"
+msgstr ""
+"<HTML><!----><body> ...</body></html>"
+
+#: dpid/dpi_socket_dir.c:105
+msgid "The dpi_socket_dir file does not exist\n"
+msgstr "dpi_socket_dir\n"
+
+#: dpid/dpi_socket_dir.c:109 dpid/dpi_socket_dir.c:113
+msgid "debug_msg - init_sockdir: The socket directory "
+msgstr "debug_msg - init_sockdir: socket"
+
+#: dpid/dpi_socket_dir.c:110
+#, c-format
+msgid "%s exists and is OK\n"
+msgstr "%sOK\n"
+
+#: dpid/dpi_socket_dir.c:114
+#, c-format
+msgid "%s does not exist or is not a directory\n"
+msgstr "%s\n"
+
+#: dpid/dpi_socket_dir.c:123
+msgid " - Failed to create dpi socket directory\n"
+msgstr " - dpi socket\n"
+
+#: dpid/dpi_socket_dir.c:126
+#, c-format
+msgid " - failed to save %s\n"
+msgstr " - %s\n"
+
+#: dpid/main.c:57 dpid/main.c:64 dpid/main.c:75 dpid/main.c:83 dpid/main.c:97
+#: dpid/main.c:102 dpid/main.c:107
+#, c-format
+msgid "ERROR in child proc for %s\n"
+msgstr "%s\n"
+
+#: dpid/main.c:164
+#, c-format
+msgid ": dpid failed to parse cmd in %s\n"
+msgstr ": dpid%s\n"
+
+#: dpid/main.c:242
+msgid "Failed to create socket directory\n"
+msgstr "socket\n"
+
+#: dpid/main.c:252
+msgid "dpid refuses to start, possibly because:\n"
+msgstr "dpid:\n"
+
+#: dpid/main.c:253
+msgid "\t1) An instance of dpid is already running.\n"
+msgstr "\t1) dpid\n"
+
+#: dpid/main.c:254
+msgid "\t2) A previous dpid didn't clean up on exit.\n"
+msgstr "\t2) dpid\n"
+
+#: dpid/main.c:257
+msgid "init_srs_sockets failed\n"
+msgstr "init_srs_sockets\n"
+
+#: dpid/main.c:270
+msgid "dpid started\n"
+msgstr "dpid\n"
+
+#: dpid/main.c:309
+msgid "accept on srs socket failed\n"
+msgstr "srs socket\n"
+
+#: dpid/main.c:310
+msgid "service pending connections, and continue\n"
+msgstr "\n"
+
+#: dpid/main.c:334
+msgid "get_command failed\n"
+msgstr "get_command\n"
+
+#: src/commands.c:162
+msgid "View Source"
+msgstr ""
+
+#: src/commands.c:179
+msgid "Detected HTML errors"
+msgstr "HTML"
+
+#: src/commands.c:264
+msgid "Stopped"
+msgstr ""
+
+#: src/cache.c:243
+msgid "WARNING: Cache_entry_add, leaking an entry.\n"
+msgstr ": Cache_entry_add\n"
+
+#: src/cache.c:354
+msgid "Cache_prepare_reload: ERROR, entry still has clients\n"
+msgstr ""
+"Cache_prepare_reload:  \n"
+
+#: src/cache.c:392
+msgid "ERROR: unsupported protocol"
+msgstr ": "
+
+#: src/cache.c:474
+#, c-format
+msgid "Redirect loop for URL: >%s<\n"
+msgstr "URL: >%s<\n"
+
+#: src/cache.c:726
+#, c-format
+msgid "Cache_decode_data: got all data -- decodinging %s\n"
+msgstr "Cache_decode_data:  -- %s\n"
+
+#: src/cache.c:735
+msgid "Cache_decode_data: not gzip data!\n"
+msgstr "Cache_decode_data: gzip!\n"
+
+#: src/cache.c:741
+msgid "Cache_decode_data: invalid gzip data!\n"
+msgstr "Cache_decode_data: gzip!\n"
+
+#: src/cache.c:794
+msgid "not x-gzip\n"
+msgstr "x-gzip\n"
+
+#: src/cache.c:846
+msgid "Cache_process_io Op = IOAbort; not implemented yet\n"
+msgstr "Cache_process_io Op = IOAbort; \n"
+
+#: src/cache.c:895
+#, c-format
+msgid "ERROR: redirect loop for: %s"
+msgstr ": %s"
+
+#: src/cache.c:905
+#, c-format
+msgid ""
+">>>Redirect from: %s\n"
+" to %s\n"
+msgstr ""
+">>>%s\n"
+"%s\n"
+
+#: src/cache.c:923
+msgid ">>>Image redirection without entity-content<<<\n"
+msgstr ">>>entity-content<<<\n"
+
+#: src/cache.c:925
+msgid ">>>Image redirection with entity-content<<<\n"
+msgstr ">>>entity-content<<<\n"
+
+#: src/cache.c:961
+msgid "FATAL!:*** >>>> Cache_process_queue Caught busy!!!\n"
+msgstr "!:*** >>>> Cache_process_queue!!!\n"
+
+#: src/cache.c:1006
+msgid "Client Callback is NULL"
+msgstr "NULL"
+
+#: src/cache.c:1081
+msgid "WARNING: Cache_stop_client, inexistent client\n"
+msgstr ": Cache_stop_client \n"
+
+#: src/cache.c:1223 src/capi.c:391 src/capi.c:444 src/capi.c:492
+#: src/capi.c:526 src/IO/dpi.c:660 src/IO/dpi.c:672 src/IO/dpi.c:723
+msgid " Not implemented\n"
+msgstr "\n"
+
+#: src/capi.c:219
+msgid "Capi_verify_dpi_url_request: Permission Denied!\n"
+msgstr "Capi_verify_dpi_url_request: !\n"
+
+#: src/capi.c:265
+#, c-format
+msgid "  a_Capi_open_url:: web->Image=%p\n"
+msgstr "  a_Capi_open_url:: web->Image=%p\n"
+
+#: src/capi.c:269
+#, c-format
+msgid "  url_str = %s\n"
+msgstr "  url_str = %s\n"
+
+#: src/capi.c:284
+#, c-format
+msgid "  reload=%d URL_E2EReload=%d\n"
+msgstr "  reload=%d URL_E2EReload=%d\n"
+
+#: src/capi.c:354
+msgid " ERROR: [a_Capi_dpi_send_cmd] No open connection found\n"
+msgstr " : [a_Capi_dpi_send_cmd] \n"
+
+#: src/capi.c:420
+msgid "ERROR: can't start dpid daemon!"
+msgstr ": dpid"
+
+#: src/capi.c:508
+msgid " Error with pipe\n"
+msgstr "pipe\n"
+
+#: src/dillo.c:103
+msgid ""
+"  -x, --xid XID          Open first Dillo window in an existing\n"
+"                         GtkSocket which window ID is XID (decimal)."
+msgstr ""
+"  -x, --xid XID         window IDXID()GtkSocket\n"
+"                        Dillowindow"
+
+#: src/dillo.c:106
+msgid "  -v, --version          Display version info and exit."
+msgstr "  -v, --version         "
+
+#: src/dillo.c:108
+msgid "  -h, --help             Display this help text and exit."
+msgstr "  -h, --help            "
+
+#: src/dillo.c:110
+msgid "  -f, --fullwindow       Start in full window mode."
+msgstr "  -f, --fullwindow      "
+
+#: src/dillo.c:112
+msgid "  -l, --local            Don't follow links for this URL(s)."
+msgstr "  -l, --local           URL"
+
+#: src/dillo.c:114
+msgid ""
+"  -g, -geometry GEO      Set initial window position where GEO is\n"
+"                         <width>x<height>{+-}<x>{+-}<y>"
+msgstr ""
+"  -g, -geometry GEO      GEO\n"
+"                         <width>x<height>{+-}<x>{+-}<y>"
+
+#: src/dillo.c:118
+msgid ""
+"  -D, --debug-rendering  Draw additionaly several lines in a web page,\n"
+"                         representing its structure. For debugging. "
+msgstr ""
+"  -D, --debug-rendering  WEB\n"
+"                           "
+
+#: src/dillo.c:247
+#, c-format
+msgid ""
+"Error: the XID must be an unsigned decimal numerical value.\n"
+"The offending value was: %s\n"
+msgstr ""
+": XID\n"
+": %s\n"
+
+#: src/dillo.c:262
+msgid "Error in command line options.\n"
+msgstr "\n"
+
+#: src/dillo.c:270
+#, c-format
+msgid "Setting gtk charset to %s...\n"
+msgstr "gtk charset%s...\n"
+
+#: src/dillo.c:375
+#, c-format
+msgid "Dillo: error creating directory %s: %s\n"
+msgstr "Dillo: %s: %s\n"
+
+#: src/dillo.c:378
+#, c-format
+msgid "Dillo: error reading %s: %s\n"
+msgstr "Dillo: %s: %s\n"
+
+#: src/dillo.c:427
+#, c-format
+msgid "Option %s requires %d argument(s)\n"
+msgstr " %s%d\n"
+
+#: src/dillo.c:462
+msgid ""
+"\n"
+"Usage: dillo [OPTIONS] [URL|FILE]...\n"
+"Options:\n"
+msgstr ""
+"\n"
+": dillo [] [URL|]...\n"
+":\n"
+
+#: src/dillo.c:469
+#, c-format
+msgid "  %s, %s   *Undocumented*\n"
+msgstr "  %s, %s   ()\n"
+
+#: src/dillo.c:472
+msgid ""
+"  URL                   URL to browse.\n"
+"  FILE                  Local FILE to view.\n"
+msgstr ""
+"  URL                   URL\n"
+"  FILE                  \n"
+
+#: src/dillo.c:474
+msgid ""
+"  URL                    URL to browse.\n"
+"  FILE                   Local FILE to view.\n"
+msgstr ""
+"  URL                   URL\n"
+"  FILE                  \n"
+
+#: src/html.c:155
+#, c-format
+msgid "HTML warning: line %d, "
+msgstr "HTML : %d, "
+
+#: src/html.c:183
+#, c-format
+msgid "URL has %d illegal character%s (00-1F, 7F or space)\n"
+msgstr "URL%d(00-1F, 7F)%s\n"
+
+#: src/html.c:1179
+msgid "TAB character inside <PRE>\n"
+msgstr "TAB<PRE>\n"
+
+#: src/html.c:1418
+#, c-format
+msgid "unexpected closing tag: %s. -- expected </%s>\n"
+msgstr ": %s -- </%s>\n"
+
+#: src/html.c:1497
+#, c-format
+msgid "Garbage after length: %s\n"
+msgstr "%s\n"
+
+#: src/html.c:1550
+msgid "color is not in \"#RRGGBB\" format\n"
+msgstr "color\"#RRGGBB\"\n"
+
+#: src/html.c:1561
+msgid "HEAD element must go before the BODY section\n"
+msgstr "BASEHEAD\n"
+
+#: src/html.c:1598
+msgid "the TITLE element must be inside the HEAD section\n"
+msgstr "TITLEHEAD\n"
+
+#: src/html.c:1841
+msgid "<td> or <th> outside <table>\n"
+msgstr "<td><th><table>\n"
+
+#: src/html.c:1845
+msgid "<td> or <th> outside <tr>\n"
+msgstr "<td><th><tr>\n"
+
+#: src/html.c:2035
+msgid "<noframes> outside of <frameset>!!!\n"
+msgstr "<noframes><frameset>!!!\n"
+
+#: src/html.c:2043
+msgid "<noframe> is illegal tag !!! use <noframes>.\n"
+msgstr "<noframe>!!! <noframes>\n"
+
+#: src/html.c:2223
+msgid "<frame> outside of <frameset>\n"
+msgstr "<frame><frameset>\n"
+
+#: src/html.c:2226
+msgid "<frame> inside of <noframes>\n"
+msgstr "<frame><noframes>\n"
+
+#: src/html.c:2229
+msgid "<frame> inside of <iframe>\n"
+msgstr "<frame><iframe>\n"
+
+#: src/html.c:2281
+msgid "incorrectly placed <frameset>\n"
+msgstr "<frameset>\n"
+
+#: src/html.c:2297
+msgid "<frameset> inside of <noframes>\n"
+msgstr "<frameset><noframes>\n"
+
+#: src/html.c:2302
+msgid "<frameset> inside of <iframe>\n"
+msgstr "<frameset><iframe>\n"
+
+#: src/html.c:2624
+#, c-format
+msgid "IMG tag only specifies <%s>\n"
+msgstr "IMG<%s>\n"
+
+#: src/html.c:2757
+msgid "  Html_tag_open_img: server-side map (ISMAP)\n"
+msgstr "  Html_tag_open_img: server-side map (ISMAP)\n"
+
+#: src/html.c:2785
+msgid "nested <map>\n"
+msgstr "<map>\n"
+
+#: src/html.c:2837
+msgid "usemap coords MUST be separated with ','\n"
+msgstr "usemap','\n"
+
+#: src/html.c:2881
+msgid "nohref"
+msgstr "nohref"
+
+#: src/html.c:2968
+#, c-format
+msgid "Registering ANCHOR: %s\n"
+msgstr "ANCHOR: %s\n"
+
+#: src/html.c:3137
+msgid "<li> outside <ul> or <ol>\n"
+msgstr "<li><ul><ol>\n"
+
+#: src/html.c:3298
+msgid "nested forms\n"
+msgstr "forms\n"
+
+#: src/html.c:3346
+msgid " (added a submit button internally)\n"
+msgstr " (submit)\n"
+
+#: src/html.c:3445
+msgid "META elements must be inside the HEAD section\n"
+msgstr "METAHEAD\n"
+
+#: src/html.c:3500
+#, c-format
+msgid ""
+"The NON-STANDARD meta refresh tag. The HTML 4.01 SPEC (sec 7.4.4) recommends "
+"explicitly to avoid it. The author wanted you to go <%s>\n"
+msgstr ""
+"meta refreshHTML4.01SPEC(sec 7.4.4)"
+"()<%s>"
+"\n"
+
+#: src/html.c:3877
+msgid "Html_submit_form: Method unknown\n"
+msgstr "Html_submit_form: \n"
+
+#: src/html.c:3948
+msgid "Html_input_image: unable to create image submit.\n"
+msgstr "Html_input_image: \n"
+
+#: src/html.c:3970
+msgid "input camp outside <form>\n"
+msgstr "input<form>\n"
+
+#: src/html.c:4026
+msgid "submit"
+msgstr ""
+
+#: src/html.c:4043
+msgid "Submit"
+msgstr ""
+
+#: src/html.c:4060
+msgid "An input of the type \"file\" wasn't rendered!\n"
+msgstr "input\"file\"\n"
+
+#: src/html.c:4237
+msgid "<textarea> outside <form>\n"
+msgstr "<textarea><form>\n"
+
+#: src/html.c:4241
+msgid "nested <textarea>\n"
+msgstr "<textarea>\n"
+
+#: src/html.c:4314
+msgid "<select> outside <form>\n"
+msgstr "<select><form>\n"
+
+#: src/html.c:4318
+msgid "nested <select>\n"
+msgstr "<select>\n"
+
+#: src/html.c:4549
+msgid "base URI is relative (it MUST be absolute)\n"
+msgstr "base URI()\n"
+
+#: src/html.c:4556
+msgid "the BASE element must appear in the HEAD section\n"
+msgstr "BASEHEAD\n"
+
+#: src/html.c:5045
+msgid "Html_write_raw : bufsize is negative!\n"
+msgstr "Html_write_raw : !\n"
+
+#: src/html.c:5123
+msgid "attribute lacks closing quote\n"
+msgstr "\n"
+
+#: src/html.c:5362
+msgid "could not allocate character encoding converter"
+msgstr ""
+
+#: src/misc.c:356
+msgid "Untitled"
+msgstr ""
+
+#: src/interface.c:265
+msgid "Clear the url-box!"
+msgstr "URL"
+
+#: src/interface.c:279
+msgid "Search the Web"
+msgstr "Web"
+
+#: src/interface.c:311 src/menu.c:248
+msgid "Back"
+msgstr ""
+
+#: src/interface.c:312
+msgid "Go to previous page"
+msgstr ""
+
+#: src/interface.c:325 src/menu.c:250
+msgid "Forward"
+msgstr ""
+
+#: src/interface.c:326
+msgid "Go to next page"
+msgstr ""
+
+#: src/interface.c:339
+msgid "Home"
+msgstr ""
+
+#: src/interface.c:340
+msgid "Go to the Home page"
+msgstr ""
+
+#: src/interface.c:351
+msgid "Reload this page"
+msgstr ""
+
+#: src/interface.c:364
+msgid "Save this page"
+msgstr ""
+
+#: src/interface.c:371 src/menu.c:252
+msgid "Stop"
+msgstr ""
+
+#: src/interface.c:372
+msgid "Stop the current transfer"
+msgstr ""
+
+#: src/interface.c:383
+msgid "Book"
+msgstr ""
+
+#: src/interface.c:384
+msgid "View bookmarks"
+msgstr ""
+
+#: src/interface.c:546 src/interface.c:731
+msgid "Hide Controls"
+msgstr ""
+
+#: src/interface.c:546 src/interface.c:731
+msgid "Show Controls"
+msgstr ""
+
+#: src/interface.c:820
+msgid "Show HTML bugs"
+msgstr "HTML"
+
+#: src/interface.c:1167
+msgid "Dillo: Open File"
+msgstr "Dillo: "
+
+#: src/interface.c:1237
+msgid "Clear"
+msgstr ""
+
+#: src/interface.c:1245 src/interface.c:1296 src/interface.c:1370
+msgid "Cancel"
+msgstr ""
+
+#: src/interface.c:1289 src/interface.c:1363 src/interface.c:1434
+msgid "OK"
+msgstr ""
+
+#: src/interface.c:1345
+msgid "User Name:"
+msgstr ":"
+
+#: src/interface.c:1354
+msgid "Password:"
+msgstr ":"
+
+#: src/interface.c:1400
+msgid "Dillo: Enter Authentication"
+msgstr "Dillo: "
+
+#: src/interface.c:1418
+msgid "Dillo: Question"
+msgstr "Dillo: "
+
+#: src/interface.c:1432
+msgid "Dillo: Open URL"
+msgstr "Dillo: URL"
+
+#: src/interface.c:1456
+#, c-format
+msgid "File saved (%d Bytes)"
+msgstr "(%d )"
+
+#: src/interface.c:1533
+#, c-format
+msgid "Error trying to save: %s\n"
+msgstr "%s\n"
+
+#: src/interface.c:1562
+msgid "Dillo: Save URL as File..."
+msgstr "Dillo: URL..."
+
+#: src/interface.c:1589
+msgid "Dillo: Save link as File..."
+msgstr "Dillo: ..."
+
+#: src/interface.c:1631 src/interface.c:1634
+msgid "Dillo: Find text"
+msgstr "Dillo: "
+
+#: src/interface.c:1632
+#, c-format
+msgid "Cannot find \"%s\"."
+msgstr "\"%s\""
+
+#: src/interface.c:1635
+#, c-format
+msgid "No further occurence of \"%s\". Restarting from the beginning."
+msgstr "\"%s\" "
+
+#: src/interface.c:1645
+msgid ""
+"Unexpected return from a_Dw_gtk_scrolled_window_search(), in interface."
+"c:1621...\n"
+msgstr ""
+"a_Dw_gtk_scrolled_window_search()interface."
+"c:1621...\n"
+
+#: src/interface.c:1693
+msgid "Dillo: Find text in page"
+msgstr "Dillo: "
+
+#: src/interface.c:1695
+msgid "Case sensitive"
+msgstr "/"
+
+#: src/interface.c:1696
+msgid "Find"
+msgstr ""
+
+#: src/interface.c:1743
+msgid "Dillo"
+msgstr "Dillo"
+
+#: src/interface.c:1743
+msgid "Dillo: Search the Web"
+msgstr "Dillo: Web"
+
+#: src/interface.c:1745
+msgid "Search"
+msgstr ""
+
+#: src/interface.c:1821
+msgid "Close"
+msgstr ""
+
+#: src/interface.c:1895
+msgid "close"
+msgstr ""
+
+#: src/nav.c:387
+#, c-format
+msgid "Unhandled switch type %d in a_Nav_jump_callback in src/nav.c\n"
+msgstr "src/nav.ca_Nav_jump_callbackswitch %d\n"
+
+#: src/nav.c:450
+msgid "Repost form data?"
+msgstr "?"
+
+#: src/menu.c:190
+msgid "_File"
+msgstr "(_F)"
+
+#: src/menu.c:191
+msgid "_New Window"
+msgstr "Window(_N)"
+
+#: src/menu.c:194
+msgid "New _Tab"
+msgstr "(_T)"
+
+#: src/menu.c:198
+msgid "_Open File..."
+msgstr "(_O)..."
+
+#: src/menu.c:200
+msgid "Open _URL..."
+msgstr "URL(_U)..."
+
+#: src/menu.c:206
+msgid "Close Window"
+msgstr "Window"
+
+#: src/menu.c:209 src/menu.c:536
+msgid "Close Tab"
+msgstr ""
+
+#: src/menu.c:213
+msgid "Exit Dillo"
+msgstr "Dillo"
+
+#: src/menu.c:217
+msgid "_View"
+msgstr "(_V)"
+
+#: src/menu.c:219
+msgid "Previous tab"
+msgstr ""
+
+#: src/menu.c:221
+msgid "Next tab"
+msgstr ""
+
+#: src/menu.c:225
+msgid "_Options..."
+msgstr "(_O)..."
+
+#: src/menu.c:254
+msgid "_Reload"
+msgstr "(_R)"
+
+#: src/menu.c:258
+msgid "View page So_urce"
+msgstr "(_u)"
+
+#: src/menu.c:260
+msgid "View page Bugs"
+msgstr "(_u)"
+
+#: src/menu.c:261
+msgid "_Bookmark this Page"
+msgstr "(_B)"
+
+#: src/menu.c:264
+msgid "Duplicate this Page"
+msgstr ""
+
+#: src/menu.c:267
+msgid "Duplicate this tab"
+msgstr ""
+
+#: src/menu.c:271
+msgid "_Find Text"
+msgstr "(_F)"
+
+#: src/menu.c:274
+msgid "Jump to..."
+msgstr "..."
+
+#: src/menu.c:276
+msgid "This Frame..."
+msgstr "..."
+
+#: src/menu.c:277
+msgid "This Frameset..."
+msgstr "..."
+
+#: src/menu.c:281
+msgid "Save Page As..."
+msgstr "..."
+
+#: src/menu.c:299
+msgid "View frame Source"
+msgstr ""
+
+#: src/menu.c:301
+msgid "Bookmark this Frame"
+msgstr ""
+
+#: src/menu.c:303
+msgid "Reload this Frame"
+msgstr ""
+
+#: src/menu.c:306
+msgid "Show only this Frame"
+msgstr ""
+
+#: src/menu.c:308
+msgid "Open Frame in new Window"
+msgstr "Window"
+
+#: src/menu.c:311
+msgid "Open Frame in new Tab"
+msgstr ""
+
+#: src/menu.c:315
+msgid "_Find Text in this Frame..."
+msgstr "(_F)..."
+
+#: src/menu.c:318 src/menu.c:349
+msgid "Save Frame As..."
+msgstr "..."
+
+#: src/menu.c:336
+msgid "View Frameset Source"
+msgstr ""
+
+#: src/menu.c:338
+msgid "Bookmark this Frameset"
+msgstr ""
+
+#: src/menu.c:340
+msgid "Reload this Frameset"
+msgstr ""
+
+#: src/menu.c:343
+msgid "Show only this Frameset"
+msgstr ""
+
+#: src/menu.c:346
+msgid "_Find Text in this Frameset..."
+msgstr "(_F)..."
+
+#: src/menu.c:369
+msgid "Open Link in New Window"
+msgstr "Window"
+
+#: src/menu.c:372
+msgid "Open Link in New Tab"
+msgstr ""
+
+#: src/menu.c:375
+msgid "Open Link"
+msgstr ""
+
+#: src/menu.c:378
+msgid "Bookmark this Link"
+msgstr "(_B)"
+
+#: src/menu.c:380
+msgid "Copy Link location"
+msgstr ""
+
+#: src/menu.c:385
+msgid "Save Link As..."
+msgstr "..."
+
+#: src/menu.c:389
+msgid "Image Menu..."
+msgstr "..."
+
+#: src/menu.c:409
+msgid "Open Image in New Window"
+msgstr "Window"
+
+#: src/menu.c:412
+msgid "Open Image in New Tab"
+msgstr ""
+
+#: src/menu.c:415
+msgid "Open Image"
+msgstr ""
+
+#: src/menu.c:418
+msgid "Bookmark this Image"
+msgstr ""
+
+#: src/menu.c:420
+msgid "Copy Image location"
+msgstr ""
+
+#: src/menu.c:425
+msgid "Save Image As..."
+msgstr "..."
+
+#: src/menu.c:439
+msgid "    BUG METER OPTIONS"
+msgstr "    "
+
+#: src/menu.c:441
+msgid "Validate URL with W3C"
+msgstr "URLW3C"
+
+#: src/menu.c:443
+msgid "Validate URL with WDG"
+msgstr "URLWDG"
+
+#: src/menu.c:446
+msgid "About Bug Meter..."
+msgstr "..."
+
+#: src/menu.c:538
+msgid "New Tab"
+msgstr ""
+
+#: src/menu.c:540
+msgid "Reload Tab"
+msgstr ""
+
+#: src/IO/about.c:33
+msgid ""
+"Content-type: text/html\n"
+"\n"
+"<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN'>\n"
+"<html>\n"
+"<head>\n"
+"<title>Splash screen for dillo-0.8.0-i18n-misc</title>\n"
+"</head>\n"
+"<body bgcolor='#778899' text='#000000' link='#000000' vlink='#000000'>\n"
+"\n"
+"\n"
+"<!--                          -->\n"
+"<!--   the head of the page   -->\n"
+"<!--                          -->\n"
+"\n"
+"<table width='100%' border='0' cellspacing='1' cellpadding='3'>\n"
+" <tr><td>\n"
+"   <table border='1' cellspacing='1' cellpadding='0'>\n"
+"    <tr>\n"
+"    <td bgcolor='#000000'>\n"
+"     <table width='100%' border='0' bgcolor='#ffffff'>\n"
+"     <tr>\n"
+"       <td valign='top' align='left'>\n"
+"         <h1>&nbsp;Welcome to Dillo 0.8.0-i18n-misc&nbsp;</h1>\n"
+"       </td>\n"
+"     </tr>\n"
+"     </table>\n"
+"    </tr>\n"
+"   </table>\n"
+" </td></tr>\n"
+"</table>\n"
+"\n"
+"<font color='RED'>This is Unofficial Version.&nbsp;Please do not ask the "
+"dillo team.</font><br><!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"\n"
+"<!--                                   -->\n"
+"<!-- the main layout table, definition -->\n"
+"<!--                                   -->\n"
+"\n"
+"<table width='100%' border='0' cellspacing='0' cellpadding='0'>\n"
+"<tr><td valign='top' width='150' align='center'>\n"
+"\n"
+"\n"
+"<!--                        -->\n"
+"<!--   The navigation bar   -->\n"
+"<!--                        -->\n"
+"\n"
+"<table border='0' cellspacing='0' cellpadding='0' width='140' "
+"bgcolor='#000000'>\n"
+"<tr>\n"
+"  <td>\n"
+"    <table width='100%' border='0' cellspacing='1' cellpadding='3'>\n"
+"    <tr>\n"
+"      <td colspan='1' bgcolor='#CCCCCC'>\n"
+"        Dillo\n"
+"      </td>\n"
+"    </tr>\n"
+"    <tr>\n"
+"      <td bgcolor='#FFFFFF'>\n"
+"        <table border='0' cellspacing='0' cellpadding='5'><tr><td>\n"
+"        <table border='0' cellspacing='0' cellpadding='2'><tr>\n"
+"        <td></td>\n"
+"        <td>\n"
+"         <a href='http://www.dillo.org/dillo-help.html'>\n"
+"         Help</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.dillo.org/'>Home</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.dillo.org/funding/objectives.html'>\n"
+"         Objectives</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.dillo.org/ChangeLog.html'>\n"
+"         ChangeLog</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.dillo.org/interview.html'>\n"
+"           Interview</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.dillo.org/D_authors.html'>\n"
+"         Authors</a></td>\n"
+"        </tr></table>\n"
+"        </td></tr></table>\n"
+"      </td>\n"
+"    </tr>\n"
+"    </table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"<table border='0' cellspacing='0' cellpadding='0' width='140' "
+"bgcolor='#000000'>\n"
+"<tr>\n"
+"  <td>\n"
+"    <table width='100%' border='0' cellspacing='1' cellpadding='3'>\n"
+"    <tr>\n"
+"      <td colspan='1' bgcolor='#CCCCCC'>\n"
+"        Magazines\n"
+"      </td>\n"
+"    </tr>\n"
+"    <tr>\n"
+"      <td bgcolor='#FFFFFF'>\n"
+"        <table border='0' cellspacing='0' cellpadding='5'><tr><td>\n"
+"        <table border='0' cellpadding='2'><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://lwn.net'>LWN</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://slashdot.org/'>Slashdot</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.kuro5hin.org/?op=section;"
+"section=__all__'>KuroShin</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.nexusmagazine.com'>Nexus&nbsp;M.</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://linuxtoday.com/'>Linux Today</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.gnu-darwin.org/update.html'>Monster News</a></"
+"td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.theregister.co.uk/index.html'>The Register</a></"
+"td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.infoanarchy.org/'>InfoAnarchy</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.linuxforkids.org'>Linux4Kids</a></td>\n"
+"        </tr></table>\n"
+"        </td></tr></table>\n"
+"      </td>\n"
+"    </tr>\n"
+"    </table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"<table border='0' cellspacing='0' cellpadding='0' width='140' "
+"bgcolor='#000000'>\n"
+"<tr>\n"
+"  <td>\n"
+"    <table width='100%' border='0' cellspacing='1' cellpadding='3'>\n"
+"    <tr>\n"
+"      <td colspan='1' bgcolor='#CCCCCC'>\n"
+"        Additional Stuff\n"
+"      </td>\n"
+"    </tr>\n"
+"    <tr>\n"
+"      <td bgcolor='#FFFFFF'>\n"
+"        <table border='0' cellspacing='0' cellpadding='5'><tr><td>\n"
+"        <table border='0' cellpadding='2'><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td><a href='http://www.google.com/'>Google</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td><a href='http://www.wikipedia.org/'>Wikipedia</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td><a href='http://freshmeat.net/'>FreshMeat</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td><a href='http://www.gnu.org/gnu/thegnuproject.html'>GNU\n"
+"         project</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td><a href='http://www.linuxfund.org/'>LinuxFund</a></td>\n"
+"        </tr></table>\n"
+"        </td></tr></table>\n"
+"      </td>\n"
+"    </tr>\n"
+"    </table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"<table border='0' cellspacing='0' cellpadding='0' width='140' "
+"bgcolor='#000000'>\n"
+"<tr>\n"
+"  <td>\n"
+"    <table width='100%' border='0' cellspacing='1' cellpadding='3'>\n"
+"    <tr>\n"
+"      <td colspan='1' bgcolor='#CCCCCC'>\n"
+"        Essential Reading\n"
+"      </td>\n"
+"    </tr>\n"
+"    <tr>\n"
+"      <td bgcolor='#FFFFFF'>\n"
+"        <table border='0' cellspacing='0' cellpadding='5'><tr><td>\n"
+"        <table border='0' cellpadding='2'><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td><a href='http://www.violence.de'>Peace&amp;Violence</a></td>\n"
+"        </tr></table>\n"
+"        </td></tr></table>\n"
+"      </td>\n"
+"    </tr>\n"
+"    </table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"<!-- a small horizontal spacer -->\n"
+"<table border='0' width='100%' cellpadding='0' cellspacing='0'><tr><td "
+"height='10'></td></tr></table>\n"
+"\n"
+"\n"
+"\n"
+"<!--                                                -->\n"
+"<!-- the main layout table, a small vertical spacer -->\n"
+"<!--                                                -->\n"
+"\n"
+"</td><td width='20'></td><td valign='top'>\n"
+"\n"
+"\n"
+"<!--                           -->\n"
+"<!--   Main Part of the page   -->\n"
+"<!--                           -->\n"
+"\n"
+"<table border='0' cellpadding='0' cellspacing='0' align='center' "
+"bgcolor='#000000' width='100%'><tr><td>\n"
+"<table border='0' cellpadding='5' cellspacing='1' width='100%'>\n"
+"<tr>\n"
+"  <td bgcolor='#CCCCCC'>\n"
+"    <h4>Free Software</h4>\n"
+"  </td>\n"
+"</tr><tr>\n"
+"  <td bgcolor='#FFFFFF'>\n"
+"    <table border='0' cellspacing='0' cellpadding='5'><tr><td>\n"
+" <p>\n"
+" Dillo is Free Software in the terms of the GPL.\n"
+" This means you have four basic freedoms:\n"
+" <ul>\n"
+"  <li>Freedom to use the program any way you see fit.\n"
+"  <li>Freedom to study and modify the source code.\n"
+"  <li>Freedom to make backup copies.\n"
+"  <li>Freedom to redistribute it.\n"
+" </ul>\n"
+" The\n"
+"<a href='http://www.gnu.org/licenses/gpl.html'>GPL</a>\n"
+" is the legal mechanism that gives you these freedoms.\n"
+"It also protects them from being taken away: any derivative work\n"
+"based on the program must be under the GPL.\n"
+" <br>\n"
+"    </td></tr></table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"</td></tr></table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"<table border='0' cellpadding='0' cellspacing='0' align='center' "
+"bgcolor='#000000' width='100%'><tr><td>\n"
+"<table border='0' cellpadding='5' cellspacing='1' width='100%'>\n"
+"<tr>\n"
+"  <td bgcolor='#CCCCCC'>\n"
+"    <h4>Release overview</h4>\n"
+"    08 February 2004\n"
+"  </td>\n"
+"</tr><tr>\n"
+"  <td bgcolor='#FFFFFF'>\n"
+"    <table border='0' cellspacing='0' cellpadding='5'>\n"
+"    <tr>\n"
+"     <td>\n"
+"\n"
+"<p>\n"
+" After six months,\n"
+"the new dillo-0.8.0 comes with the largest set of improvements\n"
+"ever:\n"
+"<p>\n"
+" The dpi framework was redesigned. Now the communications and\n"
+"managing are done with a daemon: <em>dpid</em>. We also developed some\n"
+"plugins: downloads, ftp, hello, bookmarks. Downloads uses <em>wget</em>\n"
+"and it can handle several connections at the same time!\n"
+"<p>\n"
+" This release also introduces the <em>bug-meter</em>: a button that shows\n"
+"the count of detected HTML errors in a page, also providing the\n"
+"line where they occur and a hint of how to solve them.\n"
+"It's intended to help webmasters and page\n"
+"authors to polish the contents of their sites with a view to\n"
+"make them standards compliant.\n"
+"<p>\n"
+" Some interesting additions: a context menu for images, a\n"
+"web-search dialog, the \"-geometry\" switch in the CLI, lots of\n"
+"improvements inside the internal widget system, portability enhancements\n"
+"and the usual bug fixes.\n"
+"<p>\n"
+" These improvements, plus much more detailed in the ChangeLog,\n"
+"round up our best dillo!\n"
+"<p>\n"
+"Remember that dillo project uses a release model where every new\n"
+"browser shall be better than the former.\n"
+"<EM>Keep up with the latest one!</EM>\n"
+"\n"
+"     </td>\n"
+"    </tr></table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"</td></tr></table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"<table border='0' cellpadding='0' cellspacing='0' align='center' "
+"bgcolor='#000000' width='100%'><tr><td>\n"
+"<table border='0' cellpadding='5' cellspacing='1' width='100%'>\n"
+"<tr>\n"
+"  <td bgcolor='#CCCCCC'>\n"
+"    <h4>ChangeLog highlights</h4>\n"
+"    (Extracted from the\n"
+"    <a href='http://www.dillo.org/ChangeLog.html'>full\n"
+"    ChangeLog</a>)\n"
+"  </td>\n"
+"</tr><tr>\n"
+"  <td bgcolor='#FFFFFF'>\n"
+"    <table border='0' cellspacing='0' cellpadding='5'>\n"
+"    <tr>\n"
+"     <td>\n"
+"<ul>\n"
+"<li>Introduced a new way of handling dillo plugins! Now the\n"
+"   communications and managing is done by a daemon: dpid.\n"
+"   This comes with a lot of advantages described in Dpid.txt.\n"
+"<li>Developed a plugin for downloads. It uses wget and can handle several\n"
+"   connections at the same time.\n"
+"<li>Adapted the generic parser to make HTML error detection, providing\n"
+"   the line number and a hint (expected tag) in the error message!\n"
+"<li>Added a bug-meter button that shows the count of detected HTML errors\n"
+"   (left click shows the errors, right click offers a validation menu).\n"
+"<li>Added a right-mouse-button popup for images!\n"
+"<li>Added a web search dialog (with toolbar icon, shortcut is Ctrl-S).\n"
+"   The search engine can be set in dillorc (defaults to google).\n"
+"<li>Improved configure.in for better portability.\n"
+"<li>Made SPAM-safe URLs aware of image buttons.\n"
+"<li>Made images showing the ALT text as long as no image data has been\n"
+"   retrieved.\n"
+"<li>Added the \"-geometry\" switch to the CLI.\n"
+"<li>Fixed a bug in findtext (wrong highlighting).\n"
+"</ul>\n"
+"     </td>\n"
+"    </tr></table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"</td></tr></table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"<table border='0' cellpadding='0' cellspacing='0' align='center' "
+"bgcolor='#000000' width='100%'><tr><td>\n"
+"<table border='0' cellpadding='5' cellspacing='1' width='100%'>\n"
+"<tr>\n"
+"  <td bgcolor='#CCCCCC'>\n"
+"    <h4>Notes</h4>\n"
+"  </td>\n"
+"</tr><tr>\n"
+"  <td bgcolor='#FFFFFF'>\n"
+"    <table border='0' cellspacing='0' cellpadding='5'>\n"
+"    <tr>\n"
+"     <td>\n"
+" <ul>\n"
+"   <li> There's a\n"
+"     <a href='http://www.dillo.org/dillorc'>dillorc</a>\n"
+"     (readable  config)  file within the tarball; It is well commented\n"
+"     and  has  plenty  of  options to customize dillo, so <STRONG>copy\n"
+"     it</STRONG>  to  your  <STRONG>~/.dillo/</STRONG>  directory, and\n"
+"     modify to your taste.\n"
+"   <li> There's documentation for developers in the <CODE>/doc</CODE>\n"
+"     dir  within  the  tarball;  you can find directions on everything\n"
+"     else at the home page.\n"
+"   <li> Dillo has context sensitive menus using the\n"
+"     right mouse button (available on pages, links, images,\n"
+"     the Back and Forward buttons, and bug meter).\n"
+"   <li> Dillo behaves very nicely when browsing local files, images, and "
+"HTML.\n"
+"     It's also very good for Internet searching (try Google!).\n"
+"   <li> This release is mainly intended <strong>for developers</strong>\n"
+"        and <em>advanced users</em>\n"
+"   <li> Frames, Java and Javascript are not supported.\n"
+" </ul>\n"
+" <br>\n"
+"     </td>\n"
+"    </tr></table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"</td></tr></table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<table border='0' width='100%' cellpadding='0' cellspacing='0'><tr><td "
+"height='10'></td></tr></table>\n"
+"\n"
+"\n"
+"<!--                                                -->\n"
+"<!-- the main layout table, a small vertical spacer -->\n"
+"<!--                                                -->\n"
+"\n"
+"</td><td width='20'></td>\n"
+"\n"
+"\n"
+"\n"
+"<!--                             -->\n"
+"<!--   The right column (info)   -->\n"
+"<!--                             -->\n"
+"<td valign='top' align='center'>\n"
+"</td>\n"
+"\n"
+"\n"
+"<!--                              -->\n"
+"<!-- end of the main layout table -->\n"
+"<!--                              -->\n"
+"\n"
+"</tr>\n"
+"</table>\n"
+"\n"
+"<!--               -->\n"
+"<!--   footnotes   -->\n"
+"<!--               -->\n"
+"\n"
+"<br><br><center>\n"
+"<hr size='2'>\n"
+"<hr size='2'>\n"
+"</center>\n"
+"</body>\n"
+"</html>\n"
+msgstr ""
+"Content-type: text/html\n"
+"\n"
+"<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN'>\n"
+"<html>\n"
+"<head>\n"
+"<title>Splash screen for dillo-0.8.0-i18n-misc</title>\n"
+"</head>\n"
+"<body bgcolor='#778899' text='#000000' link='#000000' vlink='#000000'>\n"
+"\n"
+"\n"
+"<!--                          -->\n"
+"<!--   the head of the page   -->\n"
+"<!--                          -->\n"
+"\n"
+"<table width='100%' border='0' cellspacing='1' cellpadding='3'>\n"
+" <tr><td>\n"
+"   <table border='1' cellspacing='1' cellpadding='0'>\n"
+"    <tr>\n"
+"    <td bgcolor='#000000'>\n"
+"     <table width='100%' border='0' bgcolor='#ffffff'>\n"
+"     <tr>\n"
+"       <td valign='top' align='left'>\n"
+"         <h1>&nbsp;Dillo 0.8.0-i18n-misc&nbsp;</h1>\n"
+"       </td>\n"
+"     </tr>\n"
+"     </table>\n"
+"    </tr>\n"
+"   </table>\n"
+" </td></tr>\n"
+"</table>\n"
+"\n"
+"<font color='RED'>&nbsp;"
+"Dillo"
+"</font><!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"\n"
+"<!--                                   -->\n"
+"<!-- the main layout table, definition -->\n"
+"<!--                                   -->\n"
+"\n"
+"<table width='100%' border='0' cellspacing='0' cellpadding='0'>\n"
+"<tr><td valign='top' width='150' align='center'>\n"
+"\n"
+"\n"
+"<!--                        -->\n"
+"<!--   The navigation bar   -->\n"
+"<!--                        -->\n"
+"\n"
+"<table border='0' cellspacing='0' cellpadding='0' width='140' "
+"bgcolor='#000000'>\n"
+"<tr>\n"
+"  <td>\n"
+"    <table width='100%' border='0' cellspacing='1' cellpadding='3'>\n"
+"    <tr>\n"
+"      <td colspan='1' bgcolor='#CCCCCC'>\n"
+"        Dillo\n"
+"      </td>\n"
+"    </tr>\n"
+"    <tr>\n"
+"      <td bgcolor='#FFFFFF'>\n"
+"        <table border='0' cellspacing='0' cellpadding='5'><tr><td>\n"
+"        <table border='0' cellspacing='0' cellpadding='2'><tr>\n"
+"        <td></td>\n"
+"        <td>\n"
+"         <a href='http://www.dillo.org/dillo-help.html'>\n"
+"         Help</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.dillo.org/'>Home</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.dillo.org/funding/objectives.html'>\n"
+"         Objectives</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.dillo.org/ChangeLog.html'>\n"
+"         ChangeLog</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.dillo.org/interview.html'>\n"
+"           Interview</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.dillo.org/D_authors.html'>\n"
+"         Authors</a></td>\n"
+"        </tr></table>\n"
+"        </td></tr></table>\n"
+"      </td>\n"
+"    </tr>\n"
+"    </table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"<table border='0' cellspacing='0' cellpadding='0' width='140' "
+"bgcolor='#000000'>\n"
+"<tr>\n"
+"  <td>\n"
+"    <table width='100%' border='0' cellspacing='1' cellpadding='3'>\n"
+"    <tr>\n"
+"      <td colspan='1' bgcolor='#CCCCCC'>\n"
+"        Magazines\n"
+"      </td>\n"
+"    </tr>\n"
+"    <tr>\n"
+"      <td bgcolor='#FFFFFF'>\n"
+"        <table border='0' cellspacing='0' cellpadding='5'><tr><td>\n"
+"        <table border='0' cellpadding='2'><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://lwn.net'>LWN</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://slashdot.org/'>Slashdot</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.kuro5hin.org/?op=section;"
+"section=__all__'>KuroShin</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.nexusmagazine.com'>Nexus&nbsp;M.</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://linuxtoday.com/'>Linux Today</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.gnu-darwin.org/update.html'>Monster News</a></"
+"td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.theregister.co.uk/index.html'>The Register</a></"
+"td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.infoanarchy.org/'>InfoAnarchy</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td>\n"
+"         <a href='http://www.linuxforkids.org'>Linux4Kids</a></td>\n"
+"        </tr></table>\n"
+"        </td></tr></table>\n"
+"      </td>\n"
+"    </tr>\n"
+"    </table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"<table border='0' cellspacing='0' cellpadding='0' width='140' "
+"bgcolor='#000000'>\n"
+"<tr>\n"
+"  <td>\n"
+"    <table width='100%' border='0' cellspacing='1' cellpadding='3'>\n"
+"    <tr>\n"
+"      <td colspan='1' bgcolor='#CCCCCC'>\n"
+"        Additional Stuff\n"
+"      </td>\n"
+"    </tr>\n"
+"    <tr>\n"
+"      <td bgcolor='#FFFFFF'>\n"
+"        <table border='0' cellspacing='0' cellpadding='5'><tr><td>\n"
+"        <table border='0' cellpadding='2'><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td><a href='http://www.google.com/'>Google</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td><a href='http://www.wikipedia.org/'>Wikipedia</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td><a href='http://freshmeat.net/'>FreshMeat</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td><a href='http://www.gnu.org/gnu/thegnuproject.html'>GNU\n"
+"         project</a></td>\n"
+"        </tr><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td><a href='http://www.linuxfund.org/'>LinuxFund</a></td>\n"
+"        </tr></table>\n"
+"        </td></tr></table>\n"
+"      </td>\n"
+"    </tr>\n"
+"    </table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"<table border='0' cellspacing='0' cellpadding='0' width='140' "
+"bgcolor='#000000'>\n"
+"<tr>\n"
+"  <td>\n"
+"    <table width='100%' border='0' cellspacing='1' cellpadding='3'>\n"
+"    <tr>\n"
+"      <td colspan='1' bgcolor='#CCCCCC'>\n"
+"        Essential Reading\n"
+"      </td>\n"
+"    </tr>\n"
+"    <tr>\n"
+"      <td bgcolor='#FFFFFF'>\n"
+"        <table border='0' cellspacing='0' cellpadding='5'><tr><td>\n"
+"        <table border='0' cellpadding='2'><tr>\n"
+"        <td>&nbsp;&nbsp;</td>\n"
+"        <td><a href='http://www.violence.de'>Peace&amp;Violence</a></td>\n"
+"        </tr></table>\n"
+"        </td></tr></table>\n"
+"      </td>\n"
+"    </tr>\n"
+"    </table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"<!-- a small horizontal spacer -->\n"
+"<table border='0' width='100%' cellpadding='0' cellspacing='0'><tr><td "
+"height='10'></td></tr></table>\n"
+"\n"
+"\n"
+"\n"
+"<!--                                                -->\n"
+"<!-- the main layout table, a small vertical spacer -->\n"
+"<!--                                                -->\n"
+"\n"
+"</td><td width='20'></td><td valign='top'>\n"
+"\n"
+"\n"
+"<!--                           -->\n"
+"<!--   Main Part of the page   -->\n"
+"<!--                           -->\n"
+"\n"
+"<table border='0' cellpadding='0' cellspacing='0' align='center' "
+"bgcolor='#000000' width='100%'><tr><td>\n"
+"<table border='0' cellpadding='5' cellspacing='1' width='100%'>\n"
+"<tr>\n"
+"  <td bgcolor='#CCCCCC'>\n"
+"    <h4>Free Software</h4>\n"
+"  </td>\n"
+"</tr><tr>\n"
+"  <td bgcolor='#FFFFFF'>\n"
+"    <table border='0' cellspacing='0' cellpadding='5'><tr><td>\n"
+" <p>\n"
+" Dillo is Free Software in the terms of the GPL.\n"
+" This means you have four basic freedoms:\n"
+" <ul>\n"
+"  <li>Freedom to use the program any way you see fit.\n"
+"  <li>Freedom to study and modify the source code.\n"
+"  <li>Freedom to make backup copies.\n"
+"  <li>Freedom to redistribute it.\n"
+" </ul>\n"
+" The\n"
+"<a href='http://www.gnu.org/licenses/gpl.html'>GPL</a>\n"
+" is the legal mechanism that gives you these freedoms.\n"
+"It also protects them from being taken away: any derivative work\n"
+"based on the program must be under the GPL.\n"
+" <br>\n"
+"    </td></tr></table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"</td></tr></table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"<table border='0' cellpadding='0' cellspacing='0' align='center' "
+"bgcolor='#000000' width='100%'><tr><td>\n"
+"<table border='0' cellpadding='5' cellspacing='1' width='100%'>\n"
+"<tr>\n"
+"  <td bgcolor='#CCCCCC'>\n"
+"    <h4>Release overview</h4>\n"
+"    08 February 2004\n"
+"  </td>\n"
+"</tr><tr>\n"
+"  <td bgcolor='#FFFFFF'>\n"
+"    <table border='0' cellspacing='0' cellpadding='5'>\n"
+"    <tr>\n"
+"     <td>\n"
+"\n"
+"<p>\n"
+" After six months,\n"
+"the new dillo-0.8.0 comes with the largest set of improvements\n"
+"ever:\n"
+"<p>\n"
+" The dpi framework was redesigned. Now the communications and\n"
+"managing are done with a daemon: <em>dpid</em>. We also developed some\n"
+"plugins: downloads, ftp, hello, bookmarks. Downloads uses <em>wget</em>\n"
+"and it can handle several connections at the same time!\n"
+"<p>\n"
+" This release also introduces the <em>bug-meter</em>: a button that shows\n"
+"the count of detected HTML errors in a page, also providing the\n"
+"line where they occur and a hint of how to solve them.\n"
+"It's intended to help webmasters and page\n"
+"authors to polish the contents of their sites with a view to\n"
+"make them standards compliant.\n"
+"<p>\n"
+" Some interesting additions: a context menu for images, a\n"
+"web-search dialog, the \"-geometry\" switch in the CLI, lots of\n"
+"improvements inside the internal widget system, portability enhancements\n"
+"and the usual bug fixes.\n"
+"<p>\n"
+" These improvements, plus much more detailed in the ChangeLog,\n"
+"round up our best dillo!\n"
+"<p>\n"
+"Remember that dillo project uses a release model where every new\n"
+"browser shall be better than the former.\n"
+"<EM>Keep up with the latest one!</EM>\n"
+"\n"
+"     </td>\n"
+"    </tr></table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"</td></tr></table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"<table border='0' cellpadding='0' cellspacing='0' align='center' "
+"bgcolor='#000000' width='100%'><tr><td>\n"
+"<table border='0' cellpadding='5' cellspacing='1' width='100%'>\n"
+"<tr>\n"
+"  <td bgcolor='#CCCCCC'>\n"
+"    <h4>ChangeLog highlights</h4>\n"
+"    (Extracted from the\n"
+"    <a href='http://www.dillo.org/ChangeLog.html'>full\n"
+"    ChangeLog</a>)\n"
+"  </td>\n"
+"</tr><tr>\n"
+"  <td bgcolor='#FFFFFF'>\n"
+"    <table border='0' cellspacing='0' cellpadding='5'>\n"
+"    <tr>\n"
+"     <td>\n"
+"<ul>\n"
+"<li>Introduced a new way of handling dillo plugins! Now the\n"
+"   communications and managing is done by a daemon: dpid.\n"
+"   This comes with a lot of advantages described in Dpid.txt.\n"
+"<li>Developed a plugin for downloads. It uses wget and can handle several\n"
+"   connections at the same time.\n"
+"<li>Adapted the generic parser to make HTML error detection, providing\n"
+"   the line number and a hint (expected tag) in the error message!\n"
+"<li>Added a bug-meter button that shows the count of detected HTML errors\n"
+"   (left click shows the errors, right click offers a validation menu).\n"
+"<li>Added a right-mouse-button popup for images!\n"
+"<li>Added a web search dialog (with toolbar icon, shortcut is Ctrl-S).\n"
+"   The search engine can be set in dillorc (defaults to google).\n"
+"<li>Improved configure.in for better portability.\n"
+"<li>Made SPAM-safe URLs aware of image buttons.\n"
+"<li>Made images showing the ALT text as long as no image data has been\n"
+"   retrieved.\n"
+"<li>Added the \"-geometry\" switch to the CLI.\n"
+"<li>Fixed a bug in findtext (wrong highlighting).\n"
+"</ul>\n"
+"     </td>\n"
+"    </tr></table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"</td></tr></table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<br>\n"
+"\n"
+"<table border='0' cellpadding='0' cellspacing='0' align='center' "
+"bgcolor='#000000' width='100%'><tr><td>\n"
+"<table border='0' cellpadding='5' cellspacing='1' width='100%'>\n"
+"<tr>\n"
+"  <td bgcolor='#CCCCCC'>\n"
+"    <h4>Notes</h4>\n"
+"  </td>\n"
+"</tr><tr>\n"
+"  <td bgcolor='#FFFFFF'>\n"
+"    <table border='0' cellspacing='0' cellpadding='5'>\n"
+"    <tr>\n"
+"     <td>\n"
+" <ul>\n"
+"   <li> There's a\n"
+"     <a href='http://www.dillo.org/dillorc'>dillorc</a>\n"
+"     (readable  config)  file within the tarball; It is well commented\n"
+"     and  has  plenty  of  options to customize dillo, so <STRONG>copy\n"
+"     it</STRONG>  to  your  <STRONG>~/.dillo/</STRONG>  directory, and\n"
+"     modify to your taste.\n"
+"   <li> There's documentation for developers in the <CODE>/doc</CODE>\n"
+"     dir  within  the  tarball;  you can find directions on everything\n"
+"     else at the home page.\n"
+"   <li> Dillo has context sensitive menus using the\n"
+"     right mouse button (available on pages, links, images,\n"
+"     the Back and Forward buttons, and bug meter).\n"
+"   <li> Dillo behaves very nicely when browsing local files, images, and "
+"HTML.\n"
+"     It's also very good for Internet searching (try Google!).\n"
+"   <li> This release is mainly intended <strong>for developers</strong>\n"
+"        and <em>advanced users</em>\n"
+"   <li> Frames, Java and Javascript are not supported.\n"
+" </ul>\n"
+" <br>\n"
+"     </td>\n"
+"    </tr></table>\n"
+"  </td>\n"
+"</tr>\n"
+"</table>\n"
+"</td></tr></table>\n"
+"\n"
+"<!-- a small horizontal spacer -->\n"
+"<table border='0' width='100%' cellpadding='0' cellspacing='0'><tr><td "
+"height='10'></td></tr></table>\n"
+"\n"
+"\n"
+"<!--                                                -->\n"
+"<!-- the main layout table, a small vertical spacer -->\n"
+"<!--                                                -->\n"
+"\n"
+"</td><td width='20'></td>\n"
+"\n"
+"\n"
+"\n"
+"<!--                             -->\n"
+"<!--   The right column (info)   -->\n"
+"<!--                             -->\n"
+"<td valign='top' align='center'>\n"
+"</td>\n"
+"\n"
+"\n"
+"<!--                              -->\n"
+"<!-- end of the main layout table -->\n"
+"<!--                              -->\n"
+"\n"
+"</tr>\n"
+"</table>\n"
+"\n"
+"<!--               -->\n"
+"<!--   footnotes   -->\n"
+"<!--               -->\n"
+"\n"
+"<br><br><center>\n"
+"<hr size='2'>\n"
+"<hr size='2'>\n"
+"</center>\n"
+"</body>\n"
+"</html>\n"
+
+#: src/IO/file.c:279
+msgid "Directory listing of"
+msgstr " "
+
+#: src/IO/file.c:487
+msgid "Parent directory"
+msgstr ""
+
+#: src/IO/file.c:651
+#, c-format
+msgid "ERROR: Can't find %s %s"
+msgstr ": %s %s"
+
+#: src/IO/file.c:656
+#, c-format
+msgid "Warning: Can't find <%s>\n"
+msgstr ": <%s>\n"
+
+#: src/IO/http.c:167
+#, c-format
+msgid "Getting %s, referer %s\n"
+msgstr "%s  %s\n"
+
+#: src/IO/http.c:229
+#, c-format
+msgid ""
+"Query:\n"
+"%s"
+msgstr ""
+":\n"
+"%s"
+
+#: src/IO/http.c:256
+msgid "--Connection broken\n"
+msgstr "--\n"
+
+#: src/IO/http.c:264 src/IO/https.c:173 src/IO/https.c:204
+msgid "ERROR: unable to connect to remote host"
+msgstr ": "
+
+#: src/IO/http.c:272 src/IO/http.c:491 src/IO/http.c:522 src/IO/https.c:363
+#: src/IO/https.c:385
+#, c-format
+msgid "ERROR: %s"
+msgstr ": %s"
+
+#: src/IO/http.c:280 src/IO/https.c:179
+msgid "--Connection established\n"
+msgstr "--\n"
+
+#: src/IO/http.c:313
+#, c-format
+msgid "Http_connect_socket ERROR: %s\n"
+msgstr "Http_connect_socket: %s\n"
+
+#: src/IO/http.c:334 src/IO/http.c:348
+#, c-format
+msgid "Connecting to %s\n"
+msgstr "%s\n"
+
+#: src/IO/http.c:367
+msgid "Contacting host..."
+msgstr "..."
+
+#: src/IO/http.c:388 src/IO/https.c:280
+#, c-format
+msgid "Sending query to %s..."
+msgstr "%s..."
+
+#: src/IO/http.c:457 src/IO/https.c:333
+#, c-format
+msgid "DNS solving %s"
+msgstr "DNS%s"
+
+#: src/IO/http.c:535 src/IO/https.c:398
+#, c-format
+msgid "ERROR: Dns can't solve %s"
+msgstr ": DNS%s"
+
+#: src/IO/http.c:562 src/IO/https.c:419
+msgid "Query sent, waiting for reply..."
+msgstr " ..."
+
+#: src/IO/dpi.c:201
+msgid "ERROR: [Dpi_get_token] Can't find token start\n"
+msgstr ": [Dpi_get_token] \n"
+
+#: src/IO/dpi.c:231
+msgid "ERROR: [Dpi_get_token] *** NULL code here ***\n"
+msgstr ": [Dpi_get_token] *** NULL ***\n"
+
+#: src/IO/dpi.c:258
+#, c-format
+msgid "Dpi_parse_token: [%s]\n"
+msgstr "Dpi_parse_token: [%s]\n"
+
+#: src/IO/dpi.c:316
+msgid "Dpi: [Dpi_process_io] IOClose\n"
+msgstr "Dpi: [Dpi_process_io] IOClose\n"
+
+#: src/IO/dpi.c:342
+#, c-format
+msgid "Dpi_start_dpid (child): %s\n"
+msgstr "Dpi_start_dpid (child): %s\n"
+
+#: src/IO/dpi.c:350 src/IO/dpi.c:359
+#, c-format
+msgid "Dpi_start_dpid: %s\n"
+msgstr "Dpi_start_dpid: %s\n"
+
+#: src/IO/dpi.c:355
+#, c-format
+msgid "Dpi_start_dpid: n = %d\n"
+msgstr "Dpi_start_dpid: n = %d\n"
+
+#: src/IO/dpi.c:382
+#, c-format
+msgid "Dpi_check_uds: %s %s\n"
+msgstr "Dpi_check_uds: %s %s\n"
+
+#: src/IO/dpi.c:753 src/IO/dpi.c:757
+#, c-format
+msgid "a_Dpi_bye_dpid: %s\n"
+msgstr "a_Dpi_bye_dpid: %s\n"
+
+#: src/IO/https.c:168
+msgid "--Error detected\n"
+msgstr "--\n"
+
+#: src/IO/https.c:361
+msgid " HTTP: new abort handler! #2\n"
+msgstr " HTTP: abort! #2\n"
+
+#: src/IO/https.c:384
+msgid " HTTP: new abort handler! #1\n"
+msgstr " HTTP: abort! #1\n"
+
+#: src/i18n.c:213
+msgid "charset detect may mistake...\n"
+msgstr "...\n"
+
+#: src/i18n.c:280
+msgid "all ascii code\n"
+msgstr "ASCII\n"
+
+#: src/i18n.c:330
+msgid "unable to fully convert between character encodings\n"
+msgstr "\n"
+
+#: src/i18n.c:367
+msgid "no support enc\n"
+msgstr "\n"
+
+#: src/auth.c:39
+msgid "realm"
+msgstr ""
+
+#~ msgid "FORM lacks a Submit button\n"
+#~ msgstr "FORMSubmit\n"
+
+#~ msgid "bookmarks.dpi (v.13): accepting connections...\n"
+#~ msgstr "bookmarks.dpi (v.13): ...\n"
+
+#~ msgid "Add Bookmark for Link"
+#~ msgstr ""
+
+#~ msgid "ERROR: suspicious username: %s\n"
+#~ msgstr ": : %s\n"
+
+#~ msgid "Server NOT running\n"
+#~ msgstr "\n"
+
+#~ msgid "<waited %d cycles for server to be on line>\n"
+#~ msgstr "<%d>\n"
+
+#~ msgid "[dpi::connect] errno:%d %s\n"
+#~ msgstr "[dpi::connect] errno:%d %s\n"
+
+#~ msgid " Cookie "
+#~ msgstr "   "
+
+#~ msgid "Tab"
+#~ msgstr ""
+
+#~ msgid "Window Width"
+#~ msgstr "Window"
+
+#~ msgid "Window Height"
+#~ msgstr "Window"
+
+#~ msgid "broken JIS code!\n"
+#~ msgstr "JIS\n"
+
+#~ msgid "guess maybe mistaken. recheck charset.\n"
+#~ msgstr "\n"
+
+#~ msgid "Rendering"
+#~ msgstr ""
+
+#~ msgid "Width"
+#~ msgstr ""
+
+#~ msgid "General"
+#~ msgstr ""
+
+#~ msgid "found <meta> tag.\n"
+#~ msgstr "<meta>\n"
+
+#~ msgid "charset=\"%s\"\n"
+#~ msgstr "charset=\"%s\"\n"
+
+#~ msgid "not found meta tag charset.\n"
+#~ msgstr "metacharset\n"
+
+#~ msgid "Setting locale to %s...\n"
+#~ msgstr "LOCALE%s...\n"
+
+#~ msgid "Dillo: normal exit!\n"
+#~ msgstr "Dillo: \n"
diff -Nur dillo-0.8.0/po/Makefile.in.in dillo-0.8.0.new/po/Makefile.in.in
--- dillo-0.8.0/po/Makefile.in.in	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/po/Makefile.in.in	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,317 @@
+# Makefile for PO directory in any package using GNU gettext.
+# Copyright (C) 1995-1997, 2000-2002 by Ulrich Drepper <drepper@gnu.ai.mit.edu>
+#
+# This file can be copied and used freely without restrictions.  It can
+# be used in projects which are not available under the GNU General Public
+# License but which still want to provide support for the GNU gettext
+# functionality.
+# Please note that the actual code of GNU gettext is covered by the GNU
+# General Public License and is *not* in the public domain.
+
+PACKAGE = @PACKAGE@
+VERSION = @VERSION@
+
+SHELL = /bin/sh
+@SET_MAKE@
+
+srcdir = @srcdir@
+top_srcdir = @top_srcdir@
+VPATH = @srcdir@
+
+prefix = @prefix@
+exec_prefix = @exec_prefix@
+datadir = @datadir@
+localedir = $(datadir)/locale
+gettextsrcdir = $(datadir)/gettext/po
+
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+MKINSTALLDIRS = @MKINSTALLDIRS@
+mkinstalldirs = $(SHELL) `case "$(MKINSTALLDIRS)" in /*) echo "$(MKINSTALLDIRS)" ;; *) echo "$(top_builddir)/$(MKINSTALLDIRS)" ;; esac`
+
+GMSGFMT = @GMSGFMT@
+MSGFMT = @MSGFMT@
+XGETTEXT = @XGETTEXT@
+MSGMERGE = msgmerge
+MSGMERGE_UPDATE = @MSGMERGE@ --update
+MSGINIT = msginit
+MSGCONV = msgconv
+MSGFILTER = msgfilter
+
+POFILES = @POFILES@
+GMOFILES = @GMOFILES@
+UPDATEPOFILES = @UPDATEPOFILES@
+DUMMYPOFILES = @DUMMYPOFILES@
+DISTFILES.common = Makefile.in.in Makevars remove-potcdate.sin \
+$(DISTFILES.common.extra1) $(DISTFILES.common.extra2) $(DISTFILES.common.extra3)
+DISTFILES = $(DISTFILES.common) POTFILES.in $(DOMAIN).pot \
+$(POFILES) $(GMOFILES) \
+$(DISTFILES.extra1) $(DISTFILES.extra2) $(DISTFILES.extra3)
+
+POTFILES = \
+
+CATALOGS = @CATALOGS@
+
+# Makevars gets inserted here. (Don't remove this line!)
+
+.SUFFIXES:
+.SUFFIXES: .po .gmo .mo .sed .sin .nop .po-update
+
+.po.mo:
+	@echo "$(MSGFMT) -c -o $@ $<"; \
+	$(MSGFMT) -c -o t-$@ $< && mv t-$@ $@
+
+.po.gmo:
+	@lang=`echo $* | sed -e 's,.*/,,'`; \
+	test "$(srcdir)" = . && cdcmd="" || cdcmd="cd $(srcdir) && "; \
+	echo "$${cdcmd}rm -f $${lang}.gmo && $(GMSGFMT) -c --statistics -o $${lang}.gmo $${lang}.po"; \
+	cd $(srcdir) && rm -f $${lang}.gmo && $(GMSGFMT) -c --statistics -o t-$${lang}.gmo $${lang}.po && mv t-$${lang}.gmo $${lang}.gmo
+
+.sin.sed:
+	sed -e '/^#/d' $< > t-$@
+	mv t-$@ $@
+
+
+all: all-@USE_NLS@
+
+all-yes: $(CATALOGS)
+all-no:
+
+# Note: Target 'all' must not depend on target '$(DOMAIN).pot-update',
+# otherwise packages like GCC can not be built if only parts of the source
+# have been downloaded.
+
+$(DOMAIN).pot-update: $(POTFILES) $(srcdir)/POTFILES.in remove-potcdate.sed
+	$(XGETTEXT) --default-domain=$(DOMAIN) --directory=$(top_srcdir) \
+	  --add-comments=TRANSLATORS: $(XGETTEXT_OPTIONS) \
+	  --files-from=$(srcdir)/POTFILES.in \
+	  --copyright-holder='$(COPYRIGHT_HOLDER)'
+	test ! -f $(DOMAIN).po || { \
+	  if test -f $(srcdir)/$(DOMAIN).pot; then \
+	    sed -f remove-potcdate.sed < $(srcdir)/$(DOMAIN).pot > $(DOMAIN).1po && \
+	    sed -f remove-potcdate.sed < $(DOMAIN).po > $(DOMAIN).2po && \
+	    if cmp $(DOMAIN).1po $(DOMAIN).2po >/dev/null 2>&1; then \
+	      rm -f $(DOMAIN).1po $(DOMAIN).2po $(DOMAIN).po; \
+	    else \
+	      rm -f $(DOMAIN).1po $(DOMAIN).2po $(srcdir)/$(DOMAIN).pot && \
+	      mv $(DOMAIN).po $(srcdir)/$(DOMAIN).pot; \
+	    fi; \
+	  else \
+	    mv $(DOMAIN).po $(srcdir)/$(DOMAIN).pot; \
+	  fi; \
+	}
+
+$(srcdir)/$(DOMAIN).pot:
+	$(MAKE) $(DOMAIN).pot-update
+
+$(POFILES): $(srcdir)/$(DOMAIN).pot
+	@lang=`echo $@ | sed -e 's,.*/,,' -e 's/\.po$$//'`; \
+	test "$(srcdir)" = . && cdcmd="" || cdcmd="cd $(srcdir) && "; \
+	echo "$${cdcmd}$(MSGMERGE_UPDATE) $${lang}.po $(DOMAIN).pot"; \
+	cd $(srcdir) && $(MSGMERGE_UPDATE) $${lang}.po $(DOMAIN).pot
+
+
+install: install-exec install-data
+install-exec:
+install-data: install-data-@USE_NLS@
+	if test "$(PACKAGE)" = "gettext"; then \
+	  $(mkinstalldirs) $(DESTDIR)$(gettextsrcdir); \
+	  for file in $(DISTFILES.common); do \
+	    $(INSTALL_DATA) $(srcdir)/$$file \
+			    $(DESTDIR)$(gettextsrcdir)/$$file; \
+	  done; \
+	else \
+	  : ; \
+	fi
+install-data-no: all
+install-data-yes: all
+	$(mkinstalldirs) $(DESTDIR)$(datadir)
+	@catalogs='$(CATALOGS)'; \
+	for cat in $$catalogs; do \
+	  cat=`basename $$cat`; \
+	  lang=`echo $$cat | sed -e 's/\.gmo$$//'`; \
+	  dir=$(localedir)/$$lang/LC_MESSAGES; \
+	  $(mkinstalldirs) $(DESTDIR)$$dir; \
+	  if test -r $$cat; then realcat=$$cat; else realcat=$(srcdir)/$$cat; fi; \
+	  $(INSTALL_DATA) $$realcat $(DESTDIR)$$dir/$(DOMAIN).mo; \
+	  echo "installing $$realcat as $(DESTDIR)$$dir/$(DOMAIN).mo"; \
+	  for lc in '' $(EXTRA_LOCALE_CATEGORIES); do \
+	    if test -n "$$lc"; then \
+	      if (cd $(DESTDIR)$(localedir)/$$lang && LC_ALL=C ls -l -d $$lc 2>/dev/null) | grep ' -> ' >/dev/null; then \
+	        link=`cd $(DESTDIR)$(localedir)/$$lang && LC_ALL=C ls -l -d $$lc | sed -e 's/^.* -> //'`; \
+	        mv $(DESTDIR)$(localedir)/$$lang/$$lc $(DESTDIR)$(localedir)/$$lang/$$lc.old; \
+	        mkdir $(DESTDIR)$(localedir)/$$lang/$$lc; \
+	        (cd $(DESTDIR)$(localedir)/$$lang/$$lc.old && \
+	         for file in *; do \
+	           if test -f $$file; then \
+	             ln -s ../$$link/$$file $(DESTDIR)$(localedir)/$$lang/$$lc/$$file; \
+	           fi; \
+	         done); \
+	        rm -f $(DESTDIR)$(localedir)/$$lang/$$lc.old; \
+	      else \
+	        if test -d $(DESTDIR)$(localedir)/$$lang/$$lc; then \
+	          :; \
+	        else \
+	          rm -f $(DESTDIR)$(localedir)/$$lang/$$lc; \
+	          mkdir $(DESTDIR)$(localedir)/$$lang/$$lc; \
+	        fi; \
+	      fi; \
+	      rm -f $(DESTDIR)$(localedir)/$$lang/$$lc/$(DOMAIN).mo; \
+	      ln -s ../LC_MESSAGES/$(DOMAIN).mo $(DESTDIR)$(localedir)/$$lang/$$lc/$(DOMAIN).mo 2>/dev/null || \
+	      ln $(DESTDIR)$(localedir)/$$lang/LC_MESSAGES/$(DOMAIN).mo $(DESTDIR)$(localedir)/$$lang/$$lc/$(DOMAIN).mo 2>/dev/null || \
+	      cp -p $(DESTDIR)$(localedir)/$$lang/LC_MESSAGES/$(DOMAIN).mo $(DESTDIR)$(localedir)/$$lang/$$lc/$(DOMAIN).mo; \
+	      echo "installing $$realcat link as $(DESTDIR)$(localedir)/$$lang/$$lc/$(DOMAIN).mo"; \
+	    fi; \
+	  done; \
+	done
+
+install-strip: install
+
+installdirs: installdirs-exec installdirs-data
+installdirs-exec:
+installdirs-data: installdirs-data-@USE_NLS@
+	if test "$(PACKAGE)" = "gettext"; then \
+	  $(mkinstalldirs) $(DESTDIR)$(gettextsrcdir); \
+	else \
+	  : ; \
+	fi
+installdirs-data-no:
+installdirs-data-yes:
+	$(mkinstalldirs) $(DESTDIR)$(datadir)
+	@catalogs='$(CATALOGS)'; \
+	for cat in $$catalogs; do \
+	  cat=`basename $$cat`; \
+	  lang=`echo $$cat | sed -e 's/\.gmo$$//'`; \
+	  dir=$(localedir)/$$lang/LC_MESSAGES; \
+	  $(mkinstalldirs) $(DESTDIR)$$dir; \
+	  for lc in '' $(EXTRA_LOCALE_CATEGORIES); do \
+	    if test -n "$$lc"; then \
+	      if (cd $(DESTDIR)$(localedir)/$$lang && LC_ALL=C ls -l -d $$lc 2>/dev/null) | grep ' -> ' >/dev/null; then \
+	        link=`cd $(DESTDIR)$(localedir)/$$lang && LC_ALL=C ls -l -d $$lc | sed -e 's/^.* -> //'`; \
+	        mv $(DESTDIR)$(localedir)/$$lang/$$lc $(DESTDIR)$(localedir)/$$lang/$$lc.old; \
+	        mkdir $(DESTDIR)$(localedir)/$$lang/$$lc; \
+	        (cd $(DESTDIR)$(localedir)/$$lang/$$lc.old && \
+	         for file in *; do \
+	           if test -f $$file; then \
+	             ln -s ../$$link/$$file $(DESTDIR)$(localedir)/$$lang/$$lc/$$file; \
+	           fi; \
+	         done); \
+	        rm -f $(DESTDIR)$(localedir)/$$lang/$$lc.old; \
+	      else \
+	        if test -d $(DESTDIR)$(localedir)/$$lang/$$lc; then \
+	          :; \
+	        else \
+	          rm -f $(DESTDIR)$(localedir)/$$lang/$$lc; \
+	          mkdir $(DESTDIR)$(localedir)/$$lang/$$lc; \
+	        fi; \
+	      fi; \
+	    fi; \
+	  done; \
+	done
+
+# Define this as empty until I found a useful application.
+installcheck:
+
+uninstall: uninstall-exec uninstall-data
+uninstall-exec:
+uninstall-data: uninstall-data-@USE_NLS@
+	if test "$(PACKAGE)" = "gettext"; then \
+	  for file in $(DISTFILES.common); do \
+	    rm -f $(DESTDIR)$(gettextsrcdir)/$$file; \
+	  done; \
+	else \
+	  : ; \
+	fi
+uninstall-data-no:
+uninstall-data-yes:
+	catalogs='$(CATALOGS)'; \
+	for cat in $$catalogs; do \
+	  cat=`basename $$cat`; \
+	  lang=`echo $$cat | sed -e 's/\.gmo$$//'`; \
+	  for lc in LC_MESSAGES $(EXTRA_LOCALE_CATEGORIES); do \
+	    rm -f $(DESTDIR)$(localedir)/$$lang/$$lc/$(DOMAIN).mo; \
+	  done; \
+	done
+
+check: all
+
+dvi info tags TAGS ID:
+
+mostlyclean:
+	rm -f remove-potcdate.sed
+	rm -f core core.* $(DOMAIN).po $(DOMAIN).1po $(DOMAIN).2po *.new.po
+	rm -fr *.o
+
+clean: mostlyclean
+
+distclean: clean
+	rm -f Makefile Makefile.in POTFILES *.mo
+
+maintainer-clean: distclean
+	@echo "This command is intended for maintainers to use;"
+	@echo "it deletes files that may require special tools to rebuild."
+	rm -f $(GMOFILES)
+
+distdir = $(top_builddir)/$(PACKAGE)-$(VERSION)/$(subdir)
+dist distdir:
+	$(MAKE) update-po
+	@$(MAKE) dist2
+# This is a separate target because 'update-po' must be executed before.
+dist2: $(DISTFILES)
+	dists="$(DISTFILES)"; \
+	if test -f $(srcdir)/ChangeLog; then dists="$$dists ChangeLog"; fi; \
+	if test -f $(srcdir)/LINGUAS; then dists="$$dists LINGUAS"; fi; \
+	for file in $$dists; do \
+	  if test -f $$file; then \
+	    cp -p $$file $(distdir); \
+	  else \
+	    cp -p $(srcdir)/$$file $(distdir); \
+	  fi; \
+	done
+
+update-po: Makefile
+	$(MAKE) $(DOMAIN).pot-update
+	$(MAKE) $(UPDATEPOFILES)
+	$(MAKE) update-gmo
+
+# General rule for updating PO files.
+
+.nop.po-update:
+	@lang=`echo $@ | sed -e 's/\.po-update$$//'`; \
+	if test "$(PACKAGE)" = "gettext"; then PATH=`pwd`/../src:$$PATH; fi; \
+	tmpdir=`pwd`; \
+	echo "$$lang:"; \
+	test "$(srcdir)" = . && cdcmd="" || cdcmd="cd $(srcdir) && "; \
+	echo "$${cdcmd}$(MSGMERGE) $$lang.po $(DOMAIN).pot -o $$lang.new.po"; \
+	cd $(srcdir); \
+	if $(MSGMERGE) $$lang.po $(DOMAIN).pot -o $$tmpdir/$$lang.new.po; then \
+	  if cmp $$lang.po $$tmpdir/$$lang.new.po >/dev/null 2>&1; then \
+	    rm -f $$tmpdir/$$lang.new.po; \
+	  else \
+	    if mv -f $$tmpdir/$$lang.new.po $$lang.po; then \
+	      :; \
+	    else \
+	      echo "msgmerge for $$lang.po failed: cannot move $$tmpdir/$$lang.new.po to $$lang.po" 1>&2; \
+	      exit 1; \
+	    fi; \
+	  fi; \
+	else \
+	  echo "msgmerge for $$lang.po failed!" 1>&2; \
+	  rm -f $$tmpdir/$$lang.new.po; \
+	fi
+
+$(DUMMYPOFILES):
+
+update-gmo: Makefile $(GMOFILES)
+	@:
+
+Makefile: Makefile.in.in $(top_builddir)/config.status POTFILES.in
+	cd $(top_builddir) \
+	  && CONFIG_FILES=$(subdir)/$@.in CONFIG_HEADERS= \
+	       $(SHELL) ./config.status
+
+force:
+
+# Tell versions [3.59,3.63) of GNU make not to export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -Nur dillo-0.8.0/po/Makevars dillo-0.8.0.new/po/Makevars
--- dillo-0.8.0/po/Makevars	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/po/Makevars	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,25 @@
+# Makefile variables for PO directory in any package using GNU gettext.
+
+# Usually the message domain is the same as the package name.
+DOMAIN = $(PACKAGE)
+
+# These two variables depend on the location of this directory.
+subdir = po
+top_builddir = ..
+
+# These options get passed to xgettext.
+XGETTEXT_OPTIONS = --keyword=_ --keyword=N_
+
+# This is the copyright holder that gets inserted into the header of the
+# $(DOMAIN).pot file.  Set this to the copyright holder of the surrounding
+# package.  (Note that the msgstr strings, extracted from the package's
+# sources, belong to the copyright holder of the package.)  Translators are
+# expected to transfer the copyright for their translations to this person
+# or entity, or to disclaim their copyright.  The empty string stands for
+# the public domain; in this case the translators are expected to disclaim
+# their copyright.
+COPYRIGHT_HOLDER = Free Software Foundation, Inc.
+
+# This is the list of locale categories, beyond LC_MESSAGES, for which the
+# message catalogs shall be used.  It is usually empty.
+EXTRA_LOCALE_CATEGORIES =
diff -Nur dillo-0.8.0/po/POTFILES.in dillo-0.8.0.new/po/POTFILES.in
--- dillo-0.8.0/po/POTFILES.in	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/po/POTFILES.in	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,151 @@
+config/dillocfg.c
+config/dillocfg.h
+config/dillocfg_token.c
+config/dillocfg_token.h
+config/dillocfg_option.c
+config/dillocfg_option.h
+dpi/bookmarks.c
+dpi/downloads.c
+dpi/ftp.c
+dpi/hello.c
+dpi/https.c
+dpid/dpi.c
+dpid/dpi.h
+dpid/dpi_service.c
+dpid/dpi_service.h
+dpid/dpi_socket_dir.c
+dpid/dpi_socket_dir.h
+dpid/dpid.c
+dpid/dpid.h
+dpid/dpid_common.c
+dpid/dpid_common.h
+dpid/main.c
+src/acconfig.h
+src/chain.h
+src/chain.c
+src/commands.c
+src/commands.h
+src/cache.c
+src/cache.h
+src/capi.c
+src/capi.h
+src/debug.h
+src/dw.h
+src/dw.c
+src/dw_aligned_page.c
+src/dw_aligned_page.h
+src/dw_bullet.c
+src/dw_bullet.h
+src/dw_button.c
+src/dw_button.h
+src/dw_container.c
+src/dw_container.h
+src/dw_embed_gtk.c
+src/dw_embed_gtk.h
+src/dw_ext_iterator.h
+src/dw_ext_iterator.c
+src/dw_gtk_scrolled_frame.c
+src/dw_gtk_scrolled_frame.h
+src/dw_gtk_scrolled_window.c
+src/dw_gtk_scrolled_window.h
+src/dw_gtk_statuslabel.c
+src/dw_gtk_statuslabel.h
+src/dw_gtk_viewport.c
+src/dw_gtk_viewport.h
+src/dw_hruler.c
+src/dw_hruler.h
+src/dw_image.c
+src/dw_image.h
+src/dw_list_item.c
+src/dw_list_item.h
+src/dw_marshal.c
+src/dw_marshal.h
+src/dw_page.c
+src/dw_page.h
+src/dw_style.c
+src/dw_style.h
+src/dw_table.c
+src/dw_table.h
+src/dw_table_cell.c
+src/dw_table_cell.h
+src/dw_tooltip.c
+src/dw_tooltip.h
+src/dw_widget.c
+src/dw_widget.h
+src/findtext.c
+src/findtext.h
+src/selection.c
+src/selection.h
+src/web.c
+src/web.h
+src/progressbar.c
+src/progressbar.h
+src/dillo.c
+src/dillo.h
+src/bookmark.c
+src/bookmark.h
+src/browser.h
+src/dicache.c
+src/dicache.h
+src/dns.c
+src/dns.h
+src/gif.c
+src/jpeg.c
+src/png.c
+src/html.c
+src/html.h
+src/image.c
+src/image.h
+src/misc.c
+src/misc.h
+src/interface.h
+src/interface.c
+src/history.c
+src/history.h
+src/nav.c
+src/nav.h
+src/plain.c
+src/menu.c
+src/menu.h
+src/prefs.c
+src/prefs.h
+src/colors.c
+src/colors.h
+src/bitvec.c
+src/bitvec.h
+src/klist.c
+src/klist.h
+src/url.c
+src/url.h
+src/cookies.c
+src/cookies.h
+src/list.h
+src/pixmaps.h
+src/IO/mime.c
+src/IO/mime.h
+src/IO/about.c
+src/IO/Url.c
+src/IO/Url.h
+src/IO/proto.c
+src/IO/file.c
+src/IO/http.c
+src/IO/dpi.c
+src/IO/IO.c
+src/IO/IO.h
+src/IO/https.c
+src/IO/DBIO.c
+src/IO/DBIO.h
+src/doc.c
+src/doc.h
+src/i18n.c
+src/i18n.h
+src/gtkframeset.c
+src/gtkframeset.h
+src/pagemark.c
+src/pagemark.h
+src/tab.c
+src/tab.h
+src/user_agent.h
+src/auth.c
+src/auth.h
+src/intl.h
diff -Nur dillo-0.8.0/po/quot.sed dillo-0.8.0.new/po/quot.sed
--- dillo-0.8.0/po/quot.sed	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/po/quot.sed	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,6 @@
+s/"\([^"]*\)"/\1/g
+s/`\([^`']*\)'/\1/g
+s/ '\([^`']*\)' / \1 /g
+s/ '\([^`']*\)'$/ \1/g
+s/^'\([^`']*\)' /\1 /g
+s//""/g
diff -Nur dillo-0.8.0/po/remove-potcdate.sin dillo-0.8.0.new/po/remove-potcdate.sin
--- dillo-0.8.0/po/remove-potcdate.sin	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/po/remove-potcdate.sin	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,19 @@
+# Sed script that remove the POT-Creation-Date line in the header entry
+# from a POT file.
+#
+# The distinction between the first and the following occurrences of the
+# pattern is achieved by looking at the hold space.
+/^"POT-Creation-Date: .*"$/{
+x
+# Test if the hold space is empty.
+s/P/P/
+ta
+# Yes it was empty. First occurrence. Remove the line.
+g
+d
+bb
+:a
+# The hold space was nonempty. Following occurrences. Do nothing.
+x
+:b
+}
diff -Nur dillo-0.8.0/po/Rules-quot dillo-0.8.0.new/po/Rules-quot
--- dillo-0.8.0/po/Rules-quot	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/po/Rules-quot	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,42 @@
+# Special Makefile rules for English message catalogs with quotation marks.
+
+DISTFILES.common.extra1 = quot.sed boldquot.sed en@quot.header en@boldquot.header insert-header.sin Rules-quot
+
+.SUFFIXES: .insert-header .po-update-en
+
+en@quot.po-update: en@quot.po-update-en
+en@boldquot.po-update: en@boldquot.po-update-en
+
+.insert-header.po-update-en:
+	@lang=`echo $@ | sed -e 's/\.po-update-en$$//'`; \
+	if test "$(PACKAGE)" = "gettext"; then PATH=`pwd`/../src:$$PATH; GETTEXTLIBDIR=`cd $(top_srcdir)/src && pwd`; export GETTEXTLIBDIR; fi; \
+	tmpdir=`pwd`; \
+	echo "$$lang:"; \
+	ll=`echo $$lang | sed -e 's/@.*//'`; \
+	LC_ALL=C; export LC_ALL; \
+	cd $(srcdir); \
+	if $(MSGINIT) -i $(DOMAIN).pot --no-translator -l $$ll -o - 2>/dev/null | sed -f $$tmpdir/$$lang.insert-header | $(MSGCONV) -t UTF-8 | $(MSGFILTER) sed -f `echo $$lang | sed -e 's/.*@//'`.sed 2>/dev/null > $$tmpdir/$$lang.new.po; then \
+	  if cmp $$lang.po $$tmpdir/$$lang.new.po >/dev/null 2>&1; then \
+	    rm -f $$tmpdir/$$lang.new.po; \
+	  else \
+	    if mv -f $$tmpdir/$$lang.new.po $$lang.po; then \
+	      :; \
+	    else \
+	      echo "creation of $$lang.po failed: cannot move $$tmpdir/$$lang.new.po to $$lang.po" 1>&2; \
+	      exit 1; \
+	    fi; \
+	  fi; \
+	else \
+	  echo "creation of $$lang.po failed!" 1>&2; \
+	  rm -f $$tmpdir/$$lang.new.po; \
+	fi
+
+en@quot.insert-header: insert-header.sin
+	sed -e '/^#/d' -e 's/HEADER/en@quot.header/g' $(srcdir)/insert-header.sin > en@quot.insert-header
+
+en@boldquot.insert-header: insert-header.sin
+	sed -e '/^#/d' -e 's/HEADER/en@boldquot.header/g' $(srcdir)/insert-header.sin > en@boldquot.insert-header
+
+mostlyclean: mostlyclean-quot
+mostlyclean-quot:
+	rm -f *.insert-header
diff -Nur dillo-0.8.0/README dillo-0.8.0.new/README
--- dillo-0.8.0/README	2004-02-06 15:19:14.000000000 +0000
+++ dillo-0.8.0.new/README	2004-10-13 01:13:29.000000000 +0000
@@ -1,3 +1,9 @@
+===============================
+ Dillo i18n patch by Kiyo
+===============================
+
+See ChangeLog.
+
 =======
  Dillo
 =======
@@ -106,3 +112,5 @@
 Jorge.-
 (jcid@dillo.org)
 Feb 05, 2004
+
+
diff -Nur dillo-0.8.0/src/auth.c dillo-0.8.0.new/src/auth.c
--- dillo-0.8.0/src/auth.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/src/auth.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,150 @@
+#include <config.h>
+#include "auth.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "intl.h"
+#include "klist.h"
+#include "list.h"
+#include "cache.h"
+#include "web.h"
+#include "interface.h"
+#include "nav.h"
+#include "history.h"
+
+void Auth_confirmed(DilloDoc *dd);
+void Auth_refused(DilloDoc *dd);
+void Auth_load_authenticated(DilloDoc *dd, DilloUrl *url);
+unsigned char *base64_encode(const unsigned char *);
+
+typedef struct _Realm Realm;
+
+struct _Realm {
+   DilloUrl *base_url;
+   GString *auth;
+};
+
+static Realm *realms = NULL;
+static gint num_realms;
+static gint realms_max = 16;
+
+void a_Auth_byrealm(GString *auth_realm, DilloUrl *NewUrl, DilloDoc *dd)
+{
+   /* we already have a password dialogue open */
+   if (NULL != dd->auth_await_url)
+      return;
+
+   dd->auth_await_url = a_Url_dup(NewUrl);
+   if(strstr(auth_realm->str, "realm"))
+       memcpy(strstr(auth_realm->str, "realm"), _("realm"), 5);
+   //auth_realm = g_string_append(auth_realm, "\n");
+   a_Interface_passwd_dialog(dd->bw, auth_realm->str,
+                             Auth_confirmed, dd,
+                             Auth_refused, dd);
+   return;
+}
+
+GString *a_Auth_byurl(DilloUrl *n)
+{
+   gchar *offset;
+   int i, longest = -1, len = 0, longlen = 0;
+   gchar *ptr;
+
+   if (n == NULL)
+      return NULL;
+
+   for (i=0; i < num_realms; i++) {
+      ptr = URL_STR(realms[i].base_url);
+      if (NULL == (offset = strrchr(ptr, '/')))
+         offset = ptr + strlen(ptr);
+      if (strncmp(URL_STR(n), ptr, (char*) offset - (char*) ptr) == 0) {
+         len = (gchar *) offset - (gchar *) ptr;
+         if (longlen <= len) {
+            longlen=len;
+            longest=i;
+         }
+      }
+   }
+   return longest == -1 ? NULL : realms[longest].auth;
+}
+
+void Auth_confirmed(DilloDoc *dd)
+{
+   DilloUrl *NewUrl;
+   GString *new_auth;
+   GtkEntry *uentry,*pentry;
+   GString *up = g_string_new("");
+   gchar *encoded;
+
+   if (NULL == dd->auth_await_url)
+      return;
+
+   NewUrl = dd->auth_await_url;
+
+   /* are we still trying to browse the url that wants authentication? */
+
+   if (a_Url_cmp(a_History_get_url(NAV_TOP(dd)), NewUrl) != 0) {
+      printf("Browser Url has changed\n");
+      /* free the url here, maybe ? */
+      a_Url_free(NewUrl);
+      dd->auth_await_url = NULL;
+      return;
+   }
+
+   /* fetch and encode authorization */
+   uentry = GTK_ENTRY(dd->bw->passwd_dialog_uentry);
+   pentry = GTK_ENTRY(dd->bw->passwd_dialog_pentry);
+   /* ... */
+   g_string_sprintfa(up, "%s:%s", gtk_entry_get_text(uentry),
+                     gtk_entry_get_text(pentry));
+   new_auth = g_string_new("");
+   g_string_sprintfa(new_auth, "Basic %s", encoded = base64_encode(up->str));
+   g_free(encoded);
+   a_List_add(realms, num_realms, realms_max);
+   realms[num_realms].base_url = a_Url_dup(NewUrl);
+   realms[num_realms].auth = new_auth;
+   num_realms++;
+   Auth_load_authenticated(dd, NewUrl);
+   dd->auth_await_url = NULL;
+}
+
+void Auth_refused(DilloDoc *dd)
+{
+   DilloUrl *NewUrl;
+
+   if (NULL == dd->auth_await_url)
+      return;
+   NewUrl = dd->auth_await_url;
+   a_Url_free(NewUrl);
+   dd->auth_await_url = NULL;
+}
+
+void Auth_load_authenticated(DilloDoc *dd, DilloUrl *NewUrl)
+{
+   a_Url_set_flags(NewUrl, URL_FLAGS(NewUrl) | URL_E2EReload);
+   a_Nav_push(dd, NewUrl);
+   a_Url_free(NewUrl);
+}
+  
+void a_Auth_freeall(void)
+{
+}
+
+unsigned char *base64_encode(const unsigned char *src) {
+   static char base64[] =
+      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+   const unsigned char *s;
+   unsigned char *c, *d;
+   int l, bufsize;
+
+   c = d = (unsigned char *)malloc((bufsize = (l = strlen(src)) * 4 / 3 + 1) + 6);
+   for(s = src; l > 0 && c - d < bufsize; s += 3, c += 4, l -= 3) {
+      c[0] = base64[s[0] >> 2];
+      c[1] = base64[((s[0] & 03) << 4) | (l>1 ? s[1] >> 4 : 0)];
+      c[2] = l>1 ? base64[((s[1] & 15) << 2) | (l>2 ? s[2] >> 6 : 0)] : '=';
+      c[3] = l>2 ? base64[s[2] & 63] : '=';
+   }
+   *c = 0;
+   return d;
+}
+
diff -Nur dillo-0.8.0/src/auth.h dillo-0.8.0.new/src/auth.h
--- dillo-0.8.0/src/auth.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/src/auth.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,14 @@
+#ifndef __AUTH_H__
+#define __AUTH_H__
+
+#include <glib.h>
+#include <gtk/gtk.h>
+#include "url.h"
+#include "doc.h"
+
+void a_Auth_byrealm(GString *auth_realm,DilloUrl *NewUrl, DilloDoc *dd);
+GString *a_Auth_byurl(DilloUrl *url);
+void a_Auth_freeall(void);
+
+#endif /* AUTH_H */
+
diff -Nur dillo-0.8.0/src/bookmark.c dillo-0.8.0.new/src/bookmark.c
--- dillo-0.8.0/src/bookmark.c	2004-01-05 19:25:46.000000000 +0000
+++ dillo-0.8.0.new/src/bookmark.c	2004-10-13 01:13:29.000000000 +0000
@@ -14,6 +14,7 @@
 #include <stdlib.h>
 #include <string.h>
 
+#include "i18n.h"
 #include "msg.h"
 #include "browser.h"
 #include "history.h"
@@ -37,36 +38,36 @@
  * and finally ask it to add a new bookmark.
  * (this is an example of dpi chat)
  */
-void a_Bookmarks_chat_add(BrowserWindow *Bw, char *Cmd, char *answer)
+void a_Bookmarks_chat_add(DilloDoc *Dd, char *Cmd, char *answer)
 {
    char *cmd1 = "<dpi cmd='chat' msg='Hi server'>";
    char *cmd2 = "<dpi cmd='chat' msg='I want to set a bookmark'>";
    char *cmd3 = "<dpi cmd='chat' msg='Sure it is!'>";
-   static BrowserWindow *bw = NULL;
+   static DilloDoc *dd = NULL;
    static gchar *cmd4 = NULL;
 
    _MSG("a_Bookmarks_chat_add\n answer=%s\n", answer ? answer : "(null)");
 
-   if (Bw)
-      bw = Bw;
+   if (Dd)
+      dd = Dd;
    if (!cmd4 && Cmd)
       cmd4 = g_strdup(Cmd);
 
    if (!answer) {
-      a_Capi_dpi_send_cmd(NULL, bw, cmd1, "bookmarks", 1);
+      a_Capi_dpi_send_cmd(NULL, dd, cmd1, "bookmarks", 1);
 
    } else {
       /* we have an answer */
       if (answer) {
          if (*answer == 'H') {
             /* "Hi browser" */
-            a_Capi_dpi_send_cmd(NULL, bw, cmd2, "bookmarks", 0);
+            a_Capi_dpi_send_cmd(NULL, dd, cmd2, "bookmarks", 0);
          } else if (*answer == 'I') {
             /* "Is it worth?" */
-            a_Capi_dpi_send_cmd(NULL, bw, cmd3, "bookmarks", 0);
+            a_Capi_dpi_send_cmd(NULL, dd, cmd3, "bookmarks", 0);
          } else if (*answer == 'O') {
             /* "OK, send it!" */
-            a_Capi_dpi_send_cmd(NULL, bw, cmd4, "bookmarks", 0);
+            a_Capi_dpi_send_cmd(NULL, dd, cmd4, "bookmarks", 0);
             g_free(cmd4);
             cmd4 = NULL;
          }
@@ -77,35 +78,34 @@
 /*
  * Add the new bookmark through the bookmarks server
  */
-void a_Bookmarks_add(GtkWidget *widget, gpointer client_data)
+void a_Bookmarks_add(DilloDoc *dd, DilloUrl *url)
 {
-   BrowserWindow *bw = (BrowserWindow *)client_data;
    gchar *title, *t;
-   DilloUrl *url;
    gchar *cmd = NULL;
 
-   url = a_Menu_popup_get_url(bw);
-   g_return_if_fail(url != NULL);
+   g_return_if_fail(url != NULL && dd != NULL);
 
    /* if the page has no title, we'll use the url string */
-   title = (gchar *) a_History_get_title_by_url(url, 1);
+   title = (gchar *) a_I18n_locale_from_DILLO_CHARSET(
+		   a_History_get_title_by_url(url, 1), -1);
    title = (t = a_Misc_stuff_chars(title, "'\"")) ? t : title;
 
    cmd = g_strdup_printf("<dpi cmd='add_bookmark' url='%s' title='%s'>",
                          URL_STR(url), title);
-   a_Bookmarks_chat_add(bw, cmd, NULL);
+   a_Bookmarks_chat_add(dd, cmd, NULL);
+   g_free(title);
    g_free(cmd);
 }
 
 /*
  * Request the server to show the bookmarks
  */
-void a_Bookmarks_show(BrowserWindow *bw)
+void a_Bookmarks_show(DilloDoc *dd)
 {
    DilloUrl *url;
 
    url = a_Url_new("dpi:/bm/", NULL, 0, 0, 0);
-   a_Nav_push(bw, url);
+   a_Nav_push(dd, url);
    a_Url_free(url);
 }
 
diff -Nur dillo-0.8.0/src/bookmark.h dillo-0.8.0.new/src/bookmark.h
--- dillo-0.8.0/src/bookmark.h	2002-12-06 23:55:52.000000000 +0000
+++ dillo-0.8.0.new/src/bookmark.h	2004-10-13 01:13:29.000000000 +0000
@@ -5,10 +5,11 @@
 
 
 void a_Bookmarks_init(void);
-void a_Bookmarks_add(GtkWidget *widget, gpointer client_data);
-void a_Bookmarks_show(BrowserWindow *bw);
+//void a_Bookmarks_add(GtkWidget *widget, gpointer client_data);
+void a_Bookmarks_add(DilloDoc *dd, DilloUrl *url);
+void a_Bookmarks_show(DilloDoc *dd);
 
 /* todo: this is for testing purposes */
-void a_Bookmarks_chat_add(BrowserWindow *Bw, char *Cmd, char *answer);
+void a_Bookmarks_chat_add(DilloDoc *Dd, char *Cmd, char *answer);
 
 #endif /* __BOOKMARK_H__ */
diff -Nur dillo-0.8.0/src/browser.h dillo-0.8.0.new/src/browser.h
--- dillo-0.8.0/src/browser.h	2004-02-03 19:03:28.000000000 +0000
+++ dillo-0.8.0.new/src/browser.h	2004-10-13 01:13:29.000000000 +0000
@@ -4,17 +4,17 @@
 #include <sys/types.h>
 #include <gdk/gdk.h>
 #include <gtk/gtk.h>
-
-#include "url.h"     /* for DilloUrl */
-
+#include "url.h"       /* for DilloUrl */
+#include "dw_style.h"  /* for DwStyle */
 
 typedef struct _BrowserWindow BrowserWindow;
 typedef struct _DilloMenuPopup DilloMenuPopup;
+typedef struct _DilloDoc DilloDoc;
 
 typedef struct {
     DilloUrl *Url;   /* URL-key for this cache connection */
     gint Flags;      /* {WEB_RootUrl, WEB_Image, WEB_Download} */
-} BwUrls;
+} DdUrls;
 
 /* The popup menus so that we can call them. */
 struct _DilloMenuPopup
@@ -25,12 +25,16 @@
    GtkWidget *over_back;
    GtkWidget *over_forw;
    GtkWidget *over_bug;
+   GtkWidget *over_frame;
+#ifndef DISABLE_TABS
+   GtkWidget *over_tab;
+#endif /* !DISABLE_TABS */
    DilloUrl *url;
    DilloUrl *url2;
    GtkWidget *ol_oi_submenu;
 };
 
-/* browser_window contains all widgets to create a single window */
+/* browser_window contains everything related to a window */
 struct _BrowserWindow
 {
    /* Control-Panel handleboxes --used for hiding */
@@ -38,6 +42,9 @@
    /* Flag: TRUE when control-panel is hidden */
    gboolean fullwindow;
 
+   /* The tag for the idle function that sets button sensitivity. */
+   guint sens_idle_tag;
+
    /* widgets for the main window */
    GtkWidget *main_window;
    GtkWidget *back_button;
@@ -54,28 +61,116 @@
    GtkWidget *progress_box;
    GtkWidget *status_box;
    GtkWidget *status;
+#ifdef ENABLE_USER_AGENT
+   GtkWidget *useragent_box;
+#endif
    GtkWidget *status_bug_meter;
    gint status_is_link;
    GtkWidget *imgprogress;
    GtkWidget *progress;
 
+   /* popup menu navigation widgets */
+   GtkWidget *back_op_menu_button;
+   GtkWidget *forw_op_menu_button;
+   GtkWidget *stop_op_menu_button;
+
    /* the keyboard accelerator table */
    GtkAccelGroup *accel_group;
 
+   /* the tooltips group */
+   GtkTooltips *tooltips;
+
    /* Popup menu for this BrowserWindow */
    DilloMenuPopup menu_popup;
 
-   /* The "Headings" and "Anchors" menus */
+   /* The Pagemark menu_item (points to individual document's pagemark menus */
    GtkWidget *pagemarks_menuitem;
-   GtkWidget *pagemarks_menu;
-   GtkWidget *pagemarks_last;
 
    /* "View page Bugs" menuitem so we can set its sensitivity */
    GtkWidget *viewbugs_menuitem;
    
+   /* The Frame menu_item (points to individual frame menus */
+   GtkWidget *frame_menuitem;
+
+   /* The Frameset menu_item (points to nested frameset menus */
+   GtkWidget *frameset_menuitem;
+
+   /* widgets for dialog boxes off main window */
+   GtkWidget *open_dialog_window;
+   GtkWidget *open_dialog_entry;
+   GtkWidget *openfile_dialog_window;
+   GtkWidget *quit_dialog_window;
+   GtkWidget *save_dialog_window;
+   GtkWidget *save_link_dialog_window;
+   GtkWidget *findtext_dialog_window;
+   GtkWidget *findtext_dialog_check;
+   GtkWidget *findtext_dialog_entry;
+   GtkWidget *search_dialog_window;
+   GtkWidget *search_dialog_entry;
+   GtkWidget *question_dialog_window;
+   gpointer  question_dialog_data;
+   GtkWidget *passwd_dialog_window;
+   GtkWidget *passwd_dialog_uentry;
+   GtkWidget *passwd_dialog_pentry;
+   GtkWidget *viewsource_window;
+   GtkWidget *pagebugs_window;
+   GtkWidget *full_screen_off_button;
+
+   /* the container widget, this contains either the tabbrowser
+    * or the docwin
+    */
+   GtkContainer *container;
+
+   /* tab width adjustment magic. Yes, it is magic. In essence,
+    * this contains the average width of a character in a string
+    * in the current display context and with the current language.
+    * This is used to calculate the expected width of tab labels
+    *
+    * the value is calculated when the tabbrowser is loaded
+    */
+   gfloat tab_label_average_character_width;
+
+   /* the currently displayed document */
+   DilloDoc *dd;
+
+   /* the findtext state (TRUE if search string has been found
+    * in the document or any of its children
+    */
+   gboolean found;
+
+   /* the list of documents to search through in findtext */
+   GList *dd_list;
+   /* the current index for dd_list */
+   gint dd_list_index;
+   /* The id for the idle function that sets button sensitivity. */
+   guint sens_idle_id;
+};
+
+/* dillo_doc contains all data pertaining to a single document */
+struct _DilloDoc
+{
+   /* the BrowserWindow this document is currently part of */
+   BrowserWindow *bw;
+
    /* This is the main document widget. (HTML rendering or whatever) */
    GtkWidget *docwin;
 
+   /* The initial style for the widget */
+   DwStyle *style;
+
+   /* for nested documents, points to parent document */
+   DilloDoc *parent;
+
+   /* This is the frameset widget. */
+   GtkWidget *frameset;
+
+   /* document name (as used in 'target=window_or_frame_name' attribute */
+   gchar *name;
+
+   /* The "Headings" and "Anchors" menus */
+   GtkWidget *pagemarks_menu;
+   GtkWidget *pagemarks_last;
+
    /* Current cursor type */
    GdkCursorType CursorType;
 
@@ -92,30 +187,16 @@
    gint NumImages;
    /* Number of different images already loaded */
    gint NumImagesGot;
+   /* the current document progress */
+   gfloat progress;
+   /* 'ready' is true when the root document has finished loading */
+   gboolean ready;
 
    /* List of all Urls requested by this page (and its types) */
-   BwUrls *PageUrls;
+   DdUrls *PageUrls;
    gint NumPageUrls;
    gint MaxPageUrls;
 
-   /* widgets for dialog boxes off main window */
-   GtkWidget *open_dialog_window;
-   GtkWidget *open_dialog_entry;
-   GtkWidget *openfile_dialog_window;
-   GtkWidget *quit_dialog_window;
-   GtkWidget *save_dialog_window;
-   GtkWidget *save_link_dialog_window;
-   GtkWidget *findtext_dialog_window;
-   GtkWidget *findtext_dialog_check;
-   GtkWidget *findtext_dialog_entry;
-   GtkWidget *search_dialog_window;
-   GtkWidget *search_dialog_entry;
-   GtkWidget *question_dialog_window;
-   gpointer  question_dialog_data;
-   GtkWidget *viewsource_window;
-   GtkWidget *pagebugs_window;
-   GtkWidget *full_screen_off_button;
-
    /* Dillo navigation stack (holds indexes to history list) */
    gint *nav_stack;
    gint nav_stack_size;       /* [1 based] */
@@ -130,11 +211,8 @@
     * the first time and has not gotten the dw yet. */
    gboolean nav_expecting;
 
-   /* The id for the idle function that sets button sensitivity. */
-   guint sens_idle_id;
+   DilloUrl *auth_await_url;
 };
 
-
-
 #endif /* __BROWSER_H__ */
 
diff -Nur dillo-0.8.0/src/cache.c dillo-0.8.0.new/src/cache.c
--- dillo-0.8.0/src/cache.c	2004-01-05 19:25:46.000000000 +0000
+++ dillo-0.8.0.new/src/cache.c	2004-10-13 01:13:29.000000000 +0000
@@ -13,6 +13,7 @@
  * Dillo's cache module
  */
 
+#include <config.h>
 #include <ctype.h>              /* for tolower */
 #include <sys/types.h>
 
@@ -22,14 +23,20 @@
 #include <fcntl.h>
 #include <unistd.h>
 
+#include "intl.h"
 #include "msg.h"
 #include "list.h"
 #include "IO/Url.h"
 #include "IO/IO.h"
+#include <zlib.h>
+
+#include "i18n.h"
 #include "web.h"
+#include "doc.h" 
 #include "dicache.h"
 #include "interface.h"
 #include "nav.h"
+#include "auth.h"
 #include "cookies.h"
 #include "misc.h"
 
@@ -45,7 +52,9 @@
 typedef struct {
    const DilloUrl *Url;      /* Cached Url. Url is used as a primary Key */
    const char *Type;         /* MIME type string */
+   const char *Encoding;     /* Data encoding */
    GString *Header;          /* HTTP header */
+   GString *AuthRealm;        /* Authentication realm */
    const DilloUrl *Location; /* New URI for redirects */
    void *Data;               /* Pointer to raw data */
    size_t ValidSize,         /* Actually size of valid range */
@@ -199,6 +208,7 @@
 {
    NewEntry->Url = a_Url_dup(Url);
    NewEntry->Type = NULL;
+   NewEntry->Encoding = NULL;
    NewEntry->Header = g_string_new("");
    NewEntry->Location = NULL;
    NewEntry->Data = NULL;
@@ -209,6 +219,7 @@
    NewEntry->io = NULL;
    NewEntry->CCCQuery = a_Chain_new();
    NewEntry->CCCAnswer = NULL;
+   NewEntry->AuthRealm = NULL;
 }
 
 /*
@@ -229,7 +240,7 @@
    CacheData_t *new_entry = g_new(CacheData_t, 1);
 
    if (Cache_entry_search(Url))
-      DEBUG_MSG(5, "WARNING: Cache_entry_add, leaking an entry.\n");
+      DEBUG_MSG(5, _("WARNING: Cache_entry_add, leaking an entry.\n"));
 
    Cache_entry_init(new_entry, Url);  /* Set safe values */
    g_hash_table_insert(CacheHash, (gpointer)new_entry->Url, new_entry);
@@ -244,6 +255,7 @@
    a_Url_free((DilloUrl *)entry->Url);
    g_free((gchar *)entry->Type);
    g_string_free(entry->Header, TRUE);
+   g_free((gchar *)entry->Encoding);
    a_Url_free((DilloUrl *)entry->Location);
    g_free(entry->Data);
    g_free(entry);
@@ -339,7 +351,7 @@
       Cache_entry_remove(NULL, url);
       return 1;
    } else {
-      MSG("Cache_prepare_reload: ERROR, entry still has clients\n");
+      MSG(_("Cache_prepare_reload: ERROR, entry still has clients\n"));
    }
 
    return 0;
@@ -377,7 +389,9 @@
                                  a_Cache_ccc, BCK, cccFunct, 1, 1);
          a_Chain_bcb(OpStart, entry->CCCQuery, (void *)entry->Url, Web);
       } else {
-         a_Interface_msg(Web->bw, "ERROR: unsupported protocol");
+		 gchar *msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("ERROR: unsupported protocol"));
+         a_Interface_msg(Web->dd->bw, msg_enc);
+		 g_free(msg_enc);
          a_Cache_ccc(OpAbort, 1, FWD, entry->CCCQuery, NULL, NULL);
          ClientKey = 0; /* aborted */
       }
@@ -457,7 +471,7 @@
       /* Test for a redirection loop */
       for (i = 0; i < stackSize - 1; i++) {
          if (stack[i] == entry) {
-            g_warning ("Redirect loop for URL: >%s<\n", URL_STR_(Url));
+            g_warning (_("Redirect loop for URL: >%s<\n"), URL_STR_(Url));
             for (i = 0; i < stackSize; i++)
                stack[i]->Flags |= CA_RedirectLoop;
             entry = NULL;
@@ -547,9 +561,11 @@
 {
    gchar *header = entry->Header->str;
    gchar *Length, *Type, *location_str;
+   gchar *Encoding;
 #ifndef DISABLE_COOKIES
    GList *Cookies;
 #endif
+   gchar *auth_type_realm;
 
    if ( HdrLen < 12 ) {
       /* Not enough info. */
@@ -566,6 +582,13 @@
 
    } else if ( strncmp(header + 9, "404", 3) == 0 ) {
       entry->Flags |= CA_NotFound;
+   } else if ( strncmp(header + 9, "401", 3) == 0 ) {
+      auth_type_realm = Cache_parse_field(header,"WWW-Authenticate");
+      entry->Flags |= CA_Redirect;
+      if (entry->Location)
+         a_Url_free((DilloUrl*) entry->Location);
+      entry->Location = a_Url_dup(entry->Url);
+      entry->AuthRealm = g_string_new(auth_type_realm);
    }
 
    entry->ValidSize = io->Status - HdrLen;
@@ -611,6 +634,12 @@
                         entry->Data, entry->ValidSize));
    }
    entry->Type = Type;
+   /* Get Content-Encoding */
+   if ( (Encoding = Cache_parse_field(header, "Content-Encoding")) == NULL ) {
+     //DEBUG_HTTP_MSG("Server didn't send Content-Encoding in header.\n");
+     Encoding = NULL;
+   }
+   entry->Encoding = Encoding;
 }
 
 /*
@@ -643,6 +672,135 @@
 }
 
 /*
+ * CONTENT-ENCODING: Process any encoded data
+ *
+ * Unfortunately we need to provide a private uncompress function as 
+ * the one in zlib assumes that a zlib header will appear in the compressed
+ * block -- gzip doesn't provide one so inflateInit2 must be called with
+ * negative MAX_WBITS to get the library to cope.
+ */
+
+static int 
+dillo_uncompress(Bytef *dest, uLongf *destLen, const Bytef *source, uLong sourceLen)
+{
+    z_stream stream;
+    int err;
+
+    stream.next_in = (Bytef*)source;
+    stream.avail_in = (uInt)sourceLen;
+    /* Check for source > 64K on 16-bit machine: */
+    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
+
+    stream.next_out = dest;
+    stream.avail_out = (uInt)*destLen;
+    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
+
+    stream.zalloc = (alloc_func)0;
+    stream.zfree = (free_func)0;
+
+    err = inflateInit2(&stream, -MAX_WBITS);
+    if (err != Z_OK) return err;
+
+    err = inflate(&stream, Z_FINISH);
+    if (err != Z_STREAM_END) {
+        inflateEnd(&stream);
+        return err == Z_OK ? Z_BUF_ERROR : err;
+    }
+    *destLen = stream.total_out;
+
+    err = inflateEnd(&stream);
+    return err;
+}
+
+ 
+static void Cache_decode_data(CacheData_t *entry)
+{
+   void                        *new_Data = NULL;
+   int                         rc;
+   unsigned char       *p;
+   int                         method;
+   int                         flags;
+   int                         expand = 2;
+   uLongf                      destLen;
+
+   DEBUG_MSG(4, _("Cache_decode_data: got all data -- decodinging %s\n"), entry->Encoding);
+   if( strcmp(entry->Encoding, "x-gzip") == 0
+			|| strcmp(entry->Encoding, "gzip") == 0) {   
+      
+      /* entry->Data holds the data to expand */
+      /* entry->TotalSize is length of data */
+      
+      p = entry->Data;
+      if ( (*p++ != 0x1f) || (*p++ != 0x8b) ) {
+        DEBUG_MSG(5, _("Cache_decode_data: not gzip data!\n"));
+        goto exit;
+      }
+      method = *p++;
+      flags  = *p++;
+      if ( (method != Z_DEFLATED) || (flags & 0xE0) ) {
+        DEBUG_MSG(5, _("Cache_decode_data: invalid gzip data!\n"));
+        goto exit;
+      }
+
+      /* skip some headers */
+      p += 6;
+      if( (flags & 0x04) != 0 ) {
+         /* skip extra field */
+         int i = (*p++);
+         i += ((*p++)<<8);
+         p += i;
+      }
+      if( (flags & 0x08) != 0 ) {
+         /* skip name */
+         while( *p != 0 ) 
+               p++;
+         p++;
+      }
+      if( (flags & 0x10) != 0 ) {
+         /* skip comment */
+         while( *p != 0 )
+               p++;
+         p++;
+      }
+      if( (flags & 0x02) != 0 ) {
+         /* skip CRC */
+         p += 2;
+      }
+      
+      /* finished with header, rest is compressed data without zlib header */
+      rc = Z_BUF_ERROR; /* just to get started */
+      while( rc == Z_BUF_ERROR ) {
+           /* FIXME -- should limit times round loop? */
+           expand++;   /* start with 300% expansion */
+       destLen = expand * entry->TotalSize;
+       new_Data = g_realloc(new_Data, destLen);
+       rc = dillo_uncompress((Bytef *)new_Data, &destLen, (Bytef *)p, (uLong)entry->TotalSize);
+      }
+      if( rc == Z_OK ) {
+			DEBUG_MSG(4, "Cache_decode_data: %.2fKB -> %.2f KB (%ld%%)\n",
+					(float)entry->TotalSize/1024, (float)destLen/1024, destLen * 100 /entry->TotalSize);
+         g_realloc(new_Data, destLen);
+         g_free(entry->Data);
+         entry->Data = new_Data;
+         entry->TotalSize = destLen;
+         entry->ValidSize = destLen;
+         entry->BuffSize = destLen;
+         }
+      else {
+         g_free(new_Data);
+      }
+
+   }else{
+		MSG(_("not x-gzip\n"));
+	}
+       
+exit:;       
+   g_free((void *)entry->Encoding);
+   entry->Encoding = NULL;
+}
+
+
+/*
  * Receive new data, update the reception buffer (for next read), update the
  * cache, and service the client queue.
  *
@@ -674,12 +832,18 @@
       entry->TotalSize = entry->ValidSize;
       entry->io = NULL;
       entry->CCCAnswer = NULL;
+      /* CONTENT-ENCODING -- 
+			if encoded then translate and clear client block */
+      if ( entry->Encoding != NULL ) {
+         Cache_decode_data(entry);
+      }
+
       Cache_process_queue(entry);
       return;
    } else if ( Op == IOAbort ) {
       /* todo: implement Abort
        * (eliminate cache entry and anything related) */
-      DEBUG_MSG(5, "Cache_process_io Op = IOAbort; not implemented yet\n");
+      DEBUG_MSG(5, _("Cache_process_io Op = IOAbort; not implemented yet\n"));
       entry->io = NULL;
       entry->CCCAnswer = NULL;
       return;
@@ -722,13 +886,15 @@
  * Process redirections (HTTP 30x answers)
  * (This is a work in progress --not finished yet)
  */
-static gint Cache_redirect(CacheData_t *entry, gint Flags, BrowserWindow *bw)
+static gint Cache_redirect(CacheData_t *entry, gint Flags, DilloDoc *dd)
 {
    DilloUrl *NewUrl;
 
    /* if there's a redirect loop, stop now */
    if (entry->Flags & CA_RedirectLoop) {
-     a_Interface_msg(bw, "ERROR: redirect loop for: %s", URL_STR_(entry->Url));
+	 gchar *msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("ERROR: redirect loop for: %s"));
+     a_Interface_msg(dd->bw, msg_enc, URL_STR_(entry->Url));
+	 g_free(msg_enc);
      return 0;
    }
 
@@ -736,23 +902,27 @@
         ((entry->Flags & CA_ForceRedirect) || !entry->ValidSize ||
          entry->ValidSize < 1024 ) ) {
 
-      DEBUG_MSG(3, ">>>Redirect from: %s\n to %s\n",
+      DEBUG_MSG(3, _(">>>Redirect from: %s\n to %s\n"),
               URL_STR_(entry->Url), URL_STR_(entry->Location));
       DEBUG_MSG(3,"%s", entry->Header->str);
 
       if ( Flags & WEB_RootUrl ) {
          /* Redirection of the main page */
-         a_Nav_remove_top_url(bw);
-         NewUrl = a_Url_new(URL_STR_(entry->Location), URL_STR_(entry->Url),
-                            0, 0, 0);
-         a_Nav_push(bw, NewUrl);
+         NewUrl =a_Url_new(URL_STR_(entry->Location),URL_STR_(entry->Url),
+                           0, 0, 0);
+         if (entry->AuthRealm) {
+            a_Auth_byrealm(entry->AuthRealm, NewUrl, dd);
+            return 0;
+         } 
+         a_Nav_remove_top_url(dd);
+         a_Nav_push(dd, NewUrl);
          a_Url_free(NewUrl);
       } else {
          /* Sub entity redirection (most probably an image) */
          if ( !entry->ValidSize ) {
-            DEBUG_MSG(3,">>>Image redirection without entity-content<<<\n");
+            DEBUG_MSG(3,_(">>>Image redirection without entity-content<<<\n"));
          } else {
-            DEBUG_MSG(3, ">>>Image redirection with entity-content<<<\n");
+            DEBUG_MSG(3, _(">>>Image redirection with entity-content<<<\n"));
          }
       }
    }
@@ -788,12 +958,18 @@
    const DilloUrl *Url = entry->Url;
 
    if ( Busy )
-      DEBUG_MSG(5, "FATAL!:*** >>>> Cache_process_queue Caught busy!!!\n");
+      DEBUG_MSG(5, _("FATAL!:*** >>>> Cache_process_queue Caught busy!!!\n"));
    Busy = TRUE;
    if ( !(entry->Flags & CA_GotHeader) ) {
       Busy = FALSE;
       return;
    }
+   
+   /* CONTENT-ENCODING -- don't let clients process data yet */
+   if ( entry->Encoding != NULL ) {
+      Busy = FALSE;
+      return;
+   }
 
    for ( i = 0; (Client = g_slist_nth_data(ClientQueue, i)); ++i ) {
       if ( Client->Url == Url ) {
@@ -802,7 +978,7 @@
 
          /* For root URLs, clear the "expecting for reply..." message */
          if (ClientWeb->flags & WEB_RootUrl && !(entry->Flags & CA_MsgErased)){
-            a_Interface_msg(ClientWeb->bw, "");
+            a_Interface_msg(ClientWeb->dd->bw, "");
             entry->Flags |= CA_MsgErased;
          }
          /* For non root URLs, ignore redirections and 404 answers */
@@ -823,17 +999,17 @@
          /* Remove client when done */
          if ( (entry->Flags & CA_GotData) ) {
             /* Copy Client data to local vars */
-            void *bw = ClientWeb->bw;
+            void *dd = ClientWeb->dd;
             gint flags = ClientWeb->flags;
             /* We finished sending data, let the client know */
             if (!Client->Callback)
-               DEBUG_MSG(3, "Client Callback is NULL");
+               DEBUG_MSG(3, _("Client Callback is NULL"));
             else
                (Client->Callback)(CA_Close, Client);
             Cache_client_dequeue(Client, NULLKey);
             --i; /* Keep the index value in the next iteration */
             if ( entry->Flags & CA_Redirect )
-               Cache_redirect(entry, flags, bw);
+               Cache_redirect(entry, flags, dd);
          }
       }
    } /* for */
@@ -884,7 +1060,7 @@
    for ( i = 0; (Client = g_slist_nth_data(ClientQueue, i)); ++i ) {
       if ( Client->Url == Url ) {
          Web = Client->Web;
-         a_Interface_remove_client(Web->bw, Client->Key);
+         a_Doc_remove_client(Web->dd, Client->Key);
       }
    }
 }
@@ -902,7 +1078,7 @@
 
    if (!(List = g_slist_find_custom(ClientQueue, GINT_TO_POINTER(Key),
                                     Cache_client_key_cmp))){
-      DEBUG_MSG(5, "WARNING: Cache_stop_client, inexistent client\n");
+      DEBUG_MSG(4, _("WARNING: Cache_stop_client, inexistent client\n"));
       return;
    }
 
@@ -1044,7 +1220,7 @@
             break;
             }
          case OpStop:
-            MSG(" Not implemented\n");
+            MSG(_(" Not implemented\n"));
             break;
          case OpAbort:
             Cache_entry_remove_raw(NULL, Info->LocalKey);
diff -Nur dillo-0.8.0/src/capi.c dillo-0.8.0.new/src/capi.c
--- dillo-0.8.0/src/capi.c	2003-12-11 16:14:22.000000000 +0000
+++ dillo-0.8.0.new/src/capi.c	2004-10-13 01:13:29.000000000 +0000
@@ -17,9 +17,12 @@
 
 #include <string.h>
 
+#include "i18n.h"
+#include "intl.h"
 #include "msg.h"
 #include "capi.h"
 #include "IO/Url.h"
+#include "web.h"
 #include "chain.h"
 #include "list.h"
 #include "interface.h"
@@ -34,7 +37,7 @@
 
 typedef struct {
    DilloWeb *web;        /* Necessary for <dpi cmd='open_url' ...> */
-   void *bw;
+   DilloDoc *dd;
    gchar *server;
    gchar *datastr;
    gint SockFD;
@@ -77,13 +80,14 @@
  * Create a new connection data structure
  */
 static dpi_conn_t *
- Capi_dpi_conn_new(DilloWeb *web, void *bw, char *server, gchar *datastr)
+Capi_dpi_conn_new(DilloWeb *web, DilloDoc *dd, char *server, gchar *datastr)
 {
    dpi_conn_t *conn;
 
    conn = g_new(dpi_conn_t, 1);
    conn->web = web;
-   conn->bw = bw;
+   conn->dd = dd;
+   conn->server = server;
    conn->server = g_strdup(server);
    conn->datastr = g_strdup(datastr);
    conn->SockFD = -1;
@@ -202,8 +206,8 @@
    /* test POST and GET */
    if (strchr(URL_STR(web->url), '?') || URL_DATA_(web->url)) {
       /* safety measure: only allow dpi requests from dpi-generated urls */
-      if (a_Nav_stack_size(web->bw)) {
-         referer = a_History_get_url(NAV_TOP(web->bw));
+      if (a_Nav_stack_size(web->dd)) {
+         referer = a_History_get_url(NAV_TOP(web->dd));
          if (g_strncasecmp(URL_STR(referer), "dpi:/", 5) == 0)
             allow = TRUE;
       }
@@ -212,7 +216,7 @@
    }
 
    if (!allow) {
-      MSG("Capi_verify_dpi_url_request: Permission Denied!\n");
+      MSG(_("Capi_verify_dpi_url_request: Permission Denied!\n"));
       MSG("  URL_STR : %s\n", URL_STR(web->url));
       if (URL_DATA_(web->url))
          MSG("  URL_DATA: %s\n", URL_DATA(web->url));
@@ -258,11 +262,11 @@
    char *url_str = URL_STR(web->url);
    gint use_cache = 0, safe = 0, reload = 0, ret = 0;
 
-   _MSG("  a_Capi_open_url:: web->Image=%p\n", web->Image);
+   _MSG(_("  a_Capi_open_url:: web->Image=%p\n"), web->Image);
 
    if (a_Capi_url_uses_dpi(url_str, &server) && !Call) {
 
-      MSG("  url_str = %s\n", url_str);
+      _MSG(_("  url_str = %s\n"), url_str);
 
       if (g_strncasecmp(url_str, "dpi:/", 5) == 0) {
          /* safety check... */
@@ -277,13 +281,13 @@
          safe = 1;
       }
 
-      _MSG("  reload=%d URL_E2EReload=%d\n", reload,
+      _MSG(_("  reload=%d URL_E2EReload=%d\n"), reload,
            (URL_FLAGS(web->url) & URL_E2EReload));
 
       if (safe && reload) {
          /* Send dpip command */
          cmd = g_strdup_printf("<dpi cmd='open_url' url='%s'>", url_str);
-         a_Capi_dpi_send_cmd(web, web->bw, cmd, server, 1);
+         a_Capi_dpi_send_cmd(web, web->dd, cmd, server, 1);
          g_free(cmd);
 
          /* test the new dpi-cache connection! */
@@ -319,21 +323,22 @@
  * Send a dpi cmd.
  * (For instance: add_bookmark, open_url, send_preferences, ...)
  */
-gint a_Capi_dpi_send_cmd(DilloWeb *web, void *bw, char *cmd, char *server,
+gint a_Capi_dpi_send_cmd(DilloWeb *web, void *dd, char *cmd, char *server,
                          gint flags)
 {
    dpi_conn_t *conn;
    DataBuf *dbuf;
 
    //**/sleep(1);
-   //**/a_Interface_msg(bw, cmd);
+   //**/a_Interface_msg(dd->bw, cmd);
 
    if (flags & 1) {
       /* open a new connection to server */
 
       /* Create a new connection data struct and add it to the list */
-      conn = Capi_dpi_conn_new(web, bw, server, cmd);
+      conn = Capi_dpi_conn_new(web, dd, server, cmd);
       Capi_dpi_conn_ref(conn);
+
       /* start the CCC operations */
       a_Capi_ccc(OpStart, 1, BCK, conn->InfoSend, conn, server);
 
@@ -346,7 +351,7 @@
          a_Capi_ccc(OpSend, 1, BCK, conn->InfoSend, dbuf, NULL);
          g_free(dbuf);
       } else {
-         MSG(" ERROR: [a_Capi_dpi_send_cmd] No open connection found\n");
+         MSG(_(" ERROR: [a_Capi_dpi_send_cmd] No open connection found\n"));
       }
    }
 
@@ -383,7 +388,7 @@
             break;
          case OpStop:
          case OpAbort:
-            MSG(" Not implemented\n");
+            MSG(_(" Not implemented\n"));
             break;
          }
       } else {  /* FWD */
@@ -412,7 +417,7 @@
          case OpAbort:
             conn = Info->LocalKey;
             if (Data1 && !strcmp(Data1, "ERR_dpid"))
-               a_Interface_msg(conn->bw, "ERROR: can't start dpid daemon!");
+               a_Interface_msg(conn->dd->bw, _("ERROR: can't start dpid daemon!"));
             Capi_dpi_conn_unref(conn);
             g_free(Info);
             break;
@@ -436,7 +441,7 @@
          case OpStop:
          case OpAbort:
             Capi_dpi_conn_unref(Info->LocalKey);
-            MSG(" Not implemented\n");
+            MSG(_(" Not implemented\n"));
             break;
          }
       } else {  /* FWD */
@@ -445,10 +450,14 @@
          case OpSend:
             conn = Info->LocalKey;
             if (strcmp(Data2, "send_status_message") == 0) {
-               a_Interface_msg(conn->bw, Data1);
+			   gchar *Data1_enc = a_I18n_locale_to_DILLO_CHARSET(Data1);
+               a_Interface_msg(conn->dd->bw, Data1_enc);
+			   g_free(Data1_enc);
             } else if (strcmp(Data2, "chat") == 0) {
-               a_Interface_msg(conn->bw, Data1);
+			   gchar *Data1_enc = a_I18n_locale_to_DILLO_CHARSET(Data1);
+               a_Interface_msg(conn->dd->bw, Data1);
                a_Bookmarks_chat_add(NULL, NULL, Data1);
+			   g_free(Data1_enc);
             } else if (strcmp(Data2, "start_send_page") == 0) {
                /* start the pipe-writing chain */
                a_Capi_ccc(OpStart, 3, BCK, a_Chain_new(), Info->LocalKey,NULL);
@@ -458,7 +467,7 @@
             } else if (strcmp(Data2, "send_page_2eof") == 0) {
                a_Capi_ccc(OpSend, 3, BCK, conn->InfoPipe, Data1, NULL);
             } else if (strcmp(Data2, "reload_request") == 0) {
-               a_Nav_reload(conn->bw);
+               a_Nav_reload(conn->dd);
             }
             break;
          case OpEnd:
@@ -480,7 +489,7 @@
             }
          case OpStop:
          case OpAbort:
-            MSG(" Not implemented\n");
+            MSG(_(" Not implemented\n"));
             break;
          }
       }
@@ -496,7 +505,7 @@
             Capi_dpi_conn_ref(conn);
             conn->InfoPipe = Info;
             if (pipe(conn->DpiPipe)) {
-               MSG(" Error with pipe\n");
+               MSG(_(" Error with pipe\n"));
                return;
             }
             a_Chain_link_new(Info, a_Capi_ccc, BCK, a_IO_ccc, 3, 3);
@@ -514,7 +523,7 @@
          case OpStop:
          case OpAbort:
             Capi_dpi_conn_unref(Info->LocalKey);
-            MSG(" Not implemented\n");
+            MSG(_(" Not implemented\n"));
             break;
          }
       } else {  /* FWD */
diff -Nur dillo-0.8.0/src/capi.h dillo-0.8.0.new/src/capi.h
--- dillo-0.8.0/src/capi.h	2003-12-05 15:23:25.000000000 +0000
+++ dillo-0.8.0.new/src/capi.h	2004-10-13 01:13:29.000000000 +0000
@@ -10,7 +10,7 @@
  */
 gint a_Capi_open_url(DilloWeb *web, CA_Callback_t Call, void *CbData);
 gint a_Capi_get_buf(const DilloUrl *Url, gchar **PBuf, gint *BufSize);
-gint a_Capi_dpi_send_cmd(DilloWeb *web, void *bw, char *cmd, char *server,
+gint a_Capi_dpi_send_cmd(DilloWeb *web, void *dd, char *cmd, char *server,
                          gint flags);
 gint a_Capi_url_uses_dpi(gchar *url_str, gchar **server_ptr);
 
diff -Nur dillo-0.8.0/src/commands.c dillo-0.8.0.new/src/commands.c
--- dillo-0.8.0/src/commands.c	2004-01-25 14:40:28.000000000 +0000
+++ dillo-0.8.0.new/src/commands.c	2004-10-13 01:13:29.000000000 +0000
@@ -10,17 +10,23 @@
  * (at your option) any later version.
  */
 
+#include <config.h>
 #include <gtk/gtk.h>
 #include <stdio.h>              /* for sprintf */
 #include <sys/time.h>           /* for gettimeofday (testing gorp only) */
 #include <unistd.h>
 #include <string.h>             /* for strcat() */
 
+#include "intl.h"
 #include "msg.h"
 #include "bookmark.h"
 #include "interface.h"
+#ifndef DISABLE_TABS
+#include "tab.h"
+#endif /* !DISABLE_TABS */
 #include "history.h"
 #include "nav.h"
+#include "doc.h"
 #include "misc.h"
 #include "commands.h"
 #include "prefs.h"
@@ -28,6 +34,9 @@
 #include "capi.h"
 #include "selection.h"
 
+#include <gdk/gdkkeysyms.h>
+#include "i18n.h"
+
 /* FILE MENU */
 
 /*
@@ -43,6 +52,17 @@
    gtk_widget_grab_focus(nbw->location);
 }
 
+#ifndef DISABLE_TABS
+/*
+ * Create a new browser tab
+ */
+void a_Commands_new_tab_callback(GtkWidget *widget, gpointer client_data)
+{
+  BrowserWindow *bw = (BrowserWindow *) client_data;
+  a_Tab_new(bw);
+}
+
+#endif
 /*
  * Create and show the "Open file" dialog
  */
@@ -63,10 +83,13 @@
 }
 
 /*
- * ?
+ * Show Configurarion Script
  */
 void a_Commands_prefs_callback(GtkWidget *widget, gpointer client_data)
 {
+    gchar *cmd = g_strdup_printf("dillocfg&\n");
+    system(cmd);
+    g_free(cmd);
 }
 
 /*
@@ -75,9 +98,34 @@
 void a_Commands_close_callback(GtkWidget *widget, gpointer client_data)
 {
    BrowserWindow *bw = (BrowserWindow *)client_data;
+   a_Interface_findtext_dialog_close();
    gtk_widget_destroy(bw->main_window);
 }
 
+#ifndef DISABLE_TABS
+/*
+ * Close current browser tab, and exit dillo if it's the last one.
+ */
+void a_Commands_close_current_tab_callback(GtkWidget *widget, gpointer client_data)
+{
+   BrowserWindow *bw = (BrowserWindow *)client_data;
+   a_Tab_close(bw->dd);
+}
+
+/*
+ * Close a browser tab, and exit dillo if it's the last one.
+ *
+ * The difference with a_Commands_close_current_tab_callback is that this
+ * callback is called with a specific dd as parameter, while the former is
+ * called with only a bw
+ */
+void a_Commands_close_tab_callback(GtkWidget *widget, gpointer client_data)
+{
+   DilloDoc *dd = (DilloDoc *)client_data;
+   a_Tab_close(dd);
+}
+
+#endif /* DISABLE_TABS */
 /*
  * Free memory and quit dillo
  */
@@ -90,19 +138,28 @@
 /* PAGE MENU */
 
 /*
- * Show current page's source code.
+ * Show current root document's source
  */
-void a_Commands_viewsource_callback (GtkWidget *widget, gpointer client_data)
+void a_Commands_viewsource_callback(GtkWidget *widget, gpointer client_data)
 {
-   BrowserWindow *bw = (BrowserWindow *)client_data;
+   BrowserWindow *bw = (BrowserWindow *) client_data;
+   a_Commands_viewsource_doc_callback(widget, (gpointer) bw->dd);
+}
+
+/*
+ * Show document's source code.
+ */
+void a_Commands_viewsource_doc_callback (GtkWidget *widget, gpointer client_data)
+{
+   DilloDoc *dd = (DilloDoc *)client_data;
    gchar *buf;
    gint buf_size;
-
+  
    /* Get page source data */
-   a_Capi_get_buf(a_History_get_url(NAV_TOP(bw)), &buf, &buf_size);
+   a_Capi_get_buf(a_History_get_url(NAV_TOP(dd)), &buf, &buf_size);
    /* Show it */
-   a_Interface_text_window (&bw->viewsource_window,
-                            "View Source", "view_source",
+   a_Interface_text_window (&dd->bw->viewsource_window,
+                            _("View Source"), "view_source",
                             buf, buf_size,
                             500, 500);
 }
@@ -118,15 +175,15 @@
 
    if (event->button == 1) {
       /* Show it */
-      a_Interface_text_window (&html_lb->bw->pagebugs_window,
-                               "Detected HTML errors", "page_bugs",
+      a_Interface_text_window (&html_lb->dd->bw->pagebugs_window,
+                               _("Detected HTML errors"), "page_bugs",
                                html_lb->page_bugs->str,
                                html_lb->page_bugs->len,
                                500, 500);
       return TRUE;
    } else if (event->button == 3) {
 
-      gtk_menu_popup(GTK_MENU(html_lb->bw->menu_popup.over_bug), NULL, NULL,
+      gtk_menu_popup(GTK_MENU(html_lb->dd->bw->menu_popup.over_bug), NULL, NULL,
                      NULL, NULL, event->button, event->time);
       return TRUE;
    }
@@ -141,7 +198,7 @@
 }
 
 /*
- * Create and show the "Find Text" dialog window
+ * Create and show the "Find Text" dialog window for this page
  */
 void a_Commands_findtext_callback(GtkWidget *widget, gpointer client_data)
 {
@@ -159,7 +216,42 @@
 {
 }
 
+#ifndef DISABLE_FRAMES
+/* DOCUMENT (FRAME/IFRAME) MENU */
 
+/*
+ * Create and show the "Find Text" dialog window for this document
+ */
+void a_Commands_findtext_doc_callback(GtkWidget *widget, gpointer client_data)
+{
+   DilloDoc *dd = (DilloDoc *) client_data;
+
+   /* set search list to this document's visible children */
+   dd->bw->dd_list = a_Doc_get_visible_children(dd);
+   a_Interface_findtext_dialog( dd->bw );
+}
+
+/*
+ * Bring up the save doc dialog
+ */
+void a_Commands_save_doc_callback(GtkWidget *widget, gpointer client_data)
+{
+   DilloDoc *dd = (DilloDoc *) client_data;
+
+   a_Menu_popup_set_url(dd->bw, a_History_get_url(NAV_TOP(dd)));
+   a_Interface_save_link_dialog(widget, dd->bw);
+}
+
+/*
+ * Show only this doc in the page
+ */
+void a_Commands_showonly_doc_callback(GtkWidget *widget, gpointer client_data)
+{
+   DilloDoc *dd = (DilloDoc *) client_data;
+
+   a_Nav_push(dd->bw->dd, a_History_get_url(NAV_TOP(dd)));
+}
+#endif /* !DISABLE_FRAMES */
 /* TOOLBAR MENU */
 
 /*
@@ -169,10 +261,12 @@
 void a_Commands_stop_callback(GtkWidget *widget, gpointer client_data)
 {
    BrowserWindow *bw = client_data;
-   a_Nav_cancel_expect(bw);
-   a_Interface_stop(bw);
+   gchar *msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("Stopped"));
+   a_Nav_cancel_expect(bw->dd);
+   a_Doc_stop(bw->dd);
    a_Interface_set_button_sens(bw);
-   a_Interface_msg(bw, "Stopped");
+   a_Interface_msg(bw, msg_enc);
+   g_free(msg_enc);
 }
 
 /*
@@ -182,7 +276,7 @@
 {
    BrowserWindow *bw = (BrowserWindow *) client_data;
 
-   a_Nav_back(bw);
+   a_Nav_back(bw->dd);
 }
 
 /*
@@ -199,7 +293,27 @@
       /* Handled by the default toolbar button handler */
       break;
    case 2:
-      /* Not used yet */
+	  if (widget == bw->home_button || widget == bw->bookmarks_button) {
+		  DilloDoc *newdd;
+#ifndef DISABLE_TABS
+		  if (prefs.tab_instead_of_window) {
+			  newdd = a_Doc_new();
+			  a_Tab_add(bw, newdd);
+			  a_Tab_switch(newdd);
+		  } else
+#endif
+		  {
+			  gint width, height;
+			  BrowserWindow *newbw;
+
+			  gdk_window_get_size (bw->main_window->window,
+					  &width, &height);
+			  newbw = a_Interface_browser_window_new(width, height, 0);
+			  newdd = newbw->dd;
+		  }
+		  if (widget == bw->home_button) a_Nav_home(newdd);
+		  else a_Bookmarks_show(bw->dd);
+	  }
       break;
    case 3:
       if (widget == bw->back_button) {
@@ -232,14 +346,19 @@
    switch (event->button) {
    case 1:
       /* Open link in the same bw */
-      a_Nav_jump_callback(widget, bw, 0);
+      a_Nav_jump_callback(widget, bw->dd, 0);
       break;
    case 2:
       /* Open link in a new bw */
-      a_Nav_jump_callback(widget, bw, 1);
+      a_Nav_jump_callback(widget, bw->dd, 1);
       break;
    case 3:
+#ifndef DISABLE_TABS
+      /* Open link in a new tab */
+      a_Nav_jump_callback(widget, bw->dd, 2);
+#else
       /* Not used */
+#endif
       break;
    }
 }
@@ -251,17 +370,28 @@
 {
    BrowserWindow *bw = (BrowserWindow *) client_data;
 
-   a_Nav_forw(bw);
+   a_Nav_forw(bw->dd);
+}
+
+/*
+ * Start the reload process for a document
+ */
+void a_Commands_reload_doc_callback(GtkWidget *widget, gpointer client_data)
+{
+   DilloDoc *dd = (DilloDoc *)client_data;
+
+   a_Nav_reload(dd);
 }
 
 /*
- * Start the reload process
+ * Start the reload process for the page
  */
 void a_Commands_reload_callback(GtkWidget *widget, gpointer client_data)
 {
    BrowserWindow *bw = (BrowserWindow *) client_data;
 
-   a_Nav_reload(bw);
+   a_Interface_findtext_dialog_close();
+   a_Nav_reload(bw->dd);
 }
 
 /*
@@ -271,7 +401,7 @@
 {
    BrowserWindow *bw = (BrowserWindow *) client_data;
 
-   a_Nav_home(bw);
+   a_Nav_home(bw->dd);
 }
 
 /*
@@ -279,11 +409,12 @@
  */
 void a_Commands_save_callback(GtkWidget *widget, gpointer client_data)
 {
-   BrowserWindow *bw = (BrowserWindow *) client_data;
+   BrowserWindow *bw = (BrowserWindow *) client_data;  
 
    a_Interface_save_dialog(widget, bw);
 }
 
+
 /*
  * Bring up the save link dialog
  */
@@ -294,15 +425,58 @@
    a_Interface_save_link_dialog(widget, bw);
 }
 
+#ifdef ENABLE_USER_AGENT
+/*
+ * Set User-Agent
+ */
+void a_Commands_useragent_callback(GtkWidget *widget, gpointer client_data)
+{
+   if(prefs.user_agent) g_free(prefs.user_agent);
+   prefs.user_agent = g_strdup(gtk_entry_get_text(GTK_ENTRY(widget)));
+}
+#endif
 
-/* BOOKMARKS MENU */
+#ifndef DISABLE_TABS
+/* VIEW MENU */
+void a_Commands_tab_prev_callback(GtkWidget *widget, gpointer client_data)
+{
+  BrowserWindow *bw = (BrowserWindow *) client_data;
+  gtk_notebook_prev_page(GTK_NOTEBOOK(bw->container));
+}
+
+void a_Commands_tab_next_callback(GtkWidget *widget, gpointer client_data)
+{
+  BrowserWindow *bw = (BrowserWindow *) client_data;
+  gtk_notebook_next_page(GTK_NOTEBOOK(bw->container));
+}
 
+#endif
+/* BOOKMARKS MENU */
 /*
- * Add a bookmark to the current bookmark widget.
+ * Add a bookmark for the current doc to the current bookmark widget.
  */
 void a_Commands_addbm_callback(GtkWidget *widget, gpointer client_data)
 {
-   a_Bookmarks_add(widget, client_data);
+   BrowserWindow *bw = (BrowserWindow *) client_data;
+
+   a_Bookmarks_add(bw->dd, a_History_get_url(NAV_TOP(bw->dd)));
+}
+
+void a_Commands_addbm_doc_callback(GtkWidget *widget, gpointer client_data)
+{
+   DilloDoc *dd = (DilloDoc *) client_data;
+
+   a_Bookmarks_add(dd, a_History_get_url(NAV_TOP(dd)));
+}
+
+/*
+ * add a bookmark for the current link
+ */
+void a_Commands_addbm_link_callback(GtkWidget *widget, gpointer client_data)
+{
+   BrowserWindow *bw = (BrowserWindow *) client_data;
+
+   a_Bookmarks_add(bw->dd, a_Menu_popup_get_url(bw));
 }
 
 /*
@@ -312,7 +486,7 @@
 {
    BrowserWindow *bw = (BrowserWindow *) client_data;
 
-   a_Bookmarks_show(bw);
+   a_Bookmarks_show(bw->dd);
 }
 
 
@@ -327,7 +501,7 @@
    BrowserWindow *bw = (BrowserWindow *) client_data;
    DilloUrl *url = a_Url_new(DILLO_HOME, NULL, 0, 0, 0);
 
-   a_Nav_push(bw, url);
+   a_Nav_push(bw->dd, url);
    a_Url_free(url);
 }
 
@@ -341,7 +515,7 @@
 {
    BrowserWindow *bw = (BrowserWindow *)client_data;
 
-   a_Nav_push(bw, a_Menu_popup_get_url(bw));
+   a_Nav_push(bw->dd, a_Menu_popup_get_url(bw));
 }
 
 /*
@@ -355,10 +529,62 @@
 
    gdk_window_get_size (bw->main_window->window, &width, &height);
    newbw = a_Interface_browser_window_new(width, height, 0);
-   a_Nav_push(newbw, a_Menu_popup_get_url(bw));
+   a_Nav_push(newbw->dd, a_Menu_popup_get_url(bw));
+}
+
+/*
+ * Duplicate current page in a new window
+ */
+void a_Commands_duplicate_callback(GtkWidget *widget, gpointer client_data)
+{
+   BrowserWindow *bw = (BrowserWindow *)client_data;
+   if(bw->dd->nav_stack == NULL) {
+       a_Commands_new_callback(widget, client_data);
+       return;
+   }
+
+   a_Menu_popup_set_url(bw, a_History_get_url(NAV_TOP(bw->dd)));
+   a_Commands_open_link_nw_callback(widget, client_data);
+}
+
+#ifndef DISABLE_TABS
+/*
+ * Open link in another tab
+ */
+void a_Commands_open_link_nw_tab_callback(GtkWidget *widget, gpointer client_data)
+{
+   BrowserWindow *bw = (BrowserWindow *)client_data;
+   DilloDoc *newdd;
+
+   newdd = a_Doc_new();
+   a_Tab_add(bw, newdd);
+
+   if(prefs.tab_load_in_background)
+     /* irritating Gdk-CRITICAL warning here from widget */
+     ;
+   else
+     a_Tab_switch(newdd);
+
+   a_Nav_push(newdd, a_Menu_popup_get_url(bw));
 }
 
 /*
+ * Duplicate current page in a new tab
+ */
+void a_Commands_duplicate_tab_callback(GtkWidget *widget, gpointer client_data)
+{
+   BrowserWindow *bw = (BrowserWindow *)client_data;
+   if(bw->dd->nav_stack == NULL) {
+       a_Commands_new_tab_callback(widget, client_data);
+       return;
+   }
+
+   a_Menu_popup_set_url(bw, a_History_get_url(NAV_TOP(bw->dd)));
+   a_Commands_open_link_nw_tab_callback(widget, client_data);
+}
+#endif
+
+/*
  * Called when the user wants the popup's URL for pasting.
  */
 void a_Commands_select_popup_url_callback(GtkWidget *widget, gpointer data)
@@ -367,7 +593,6 @@
    a_Selection_set_selection(widget, URL_STR(a_Menu_popup_get_url(bw)));
 }
 
-
 /* BUG METER POP-UP MENU */
 
 /*
@@ -380,7 +605,7 @@
    DilloUrl *url;
 
    /* prepare the validation request URI */
-   o_url = URL_STR(a_History_get_url(NAV_TOP(bw)));
+   o_url = URL_STR(a_History_get_url(NAV_TOP(bw->dd)));
    e_url = a_Misc_escape_chars(o_url, ":/?");
    n_url = e_url ? e_url : o_url;
    g_string_sprintf(gstr, fmt, n_url);
@@ -389,7 +614,7 @@
    url = a_Url_new(gstr->str, NULL, 0, 0, 0);
    g_string_free(gstr, TRUE);
 
-   a_Nav_push(bw, url);
+   a_Nav_push(bw->dd, url);
    a_Url_free(url);
 }
 
@@ -425,7 +650,56 @@
    const gchar *info_str = "http://www.dillo.org/help/bug_meter.html";
    DilloUrl *url = a_Url_new(info_str, NULL, 0, 0, 0);
 
-   a_Nav_push(bw, url);
+   /* here we should un-highlight the selected text */
+   a_Nav_push(bw->dd, url);
    a_Url_free(url);
 }
 
+/* MAIN WINDOW */
+
+/*
+ * callback for full screen toggle
+ */
+void a_Commands_full_screen_callback (gpointer client_data)
+{
+   BrowserWindow *bw = (BrowserWindow *) client_data;
+   a_Interface_toggle_panel(bw, TRUE);
+}
+
+/*
+ * Handler for double-mouse-clicks that don't belong to the viewport.
+ */
+gint a_Commands_click_callback(gpointer client_data, GdkEventButton *event)
+{
+   BrowserWindow *bw = (BrowserWindow *) client_data;
+   if (event->type == GDK_2BUTTON_PRESS && event->button == 1)
+      a_Interface_toggle_panel(bw, TRUE);
+   return TRUE;
+}
+
+/*
+ * Handler for key presses that don't belong to the viewport.
+ * (Used to customize the interface a bit)
+ */
+void a_Commands_key_press_handler(GtkWidget *widget,
+                                  GdkEventKey *event,
+                                  gpointer client_data)
+{
+   BrowserWindow *bw = client_data;
+   switch (event->keyval) {
+   case GDK_BackSpace:
+     /* This key is handled here because GTK accel group ignores it */
+     if (event->state & GDK_SHIFT_MASK)
+       a_Commands_forw_callback(NULL, bw);
+     else
+       a_Commands_back_callback(NULL, bw);
+     break;
+   case GDK_slash:
+     /* This key is handled here because GTK accel group ignores it */
+     a_Commands_findtext_callback(NULL, bw);
+     break;
+   default:
+     /* g_print(">> Key pressed!\n"); */
+     break;
+   }
+}
diff -Nur dillo-0.8.0/src/commands.h dillo-0.8.0.new/src/commands.h
--- dillo-0.8.0/src/commands.h	2004-01-25 14:33:16.000000000 +0000
+++ dillo-0.8.0.new/src/commands.h	2004-10-13 01:13:29.000000000 +0000
@@ -9,11 +9,14 @@
 void a_Commands_exit_callback (GtkWidget *widget, gpointer client_data);
 
 void a_Commands_viewsource_callback (GtkWidget *widget, gpointer client_data);
+void a_Commands_viewsource_doc_callback (GtkWidget *widget, gpointer client_data);
 gint a_Commands_view_page_bugs_callback (GtkWidget *button,
                                            GdkEventButton *event,
                                            gpointer client_data);
 void a_Commands_selectall_callback (GtkWidget *widget, gpointer client_data);
 void a_Commands_findtext_callback (GtkWidget *widget, gpointer client_data);
+void a_Commands_findtext_doc_callback (GtkWidget *widget, gpointer client_data);
+void a_Commands_showonly_doc_callback(GtkWidget *widget, gpointer client_data);
 void a_Commands_print_callback (GtkWidget *widget, gpointer client_data);
 
 void a_Commands_navpress_callback (
@@ -24,12 +27,18 @@
 void a_Commands_back_callback (GtkWidget *widget, gpointer client_data);
 void a_Commands_forw_callback (GtkWidget *widget, gpointer client_data);
 void a_Commands_reload_callback (GtkWidget *widget, gpointer client_data);
+void a_Commands_reload_doc_callback (GtkWidget *widget, gpointer client_data);
 void a_Commands_stop_callback (GtkWidget *widget, gpointer client_data);
 void a_Commands_home_callback (GtkWidget *widget, gpointer client_data);
 void a_Commands_save_callback (GtkWidget *widget, gpointer client_data);
+void a_Commands_save_doc_callback (GtkWidget *widget, gpointer client_data);
 void a_Commands_save_link_callback (GtkWidget *widget, gpointer client_data);
-
+#ifdef ENABLE_USER_AGENT
+void a_Commands_useragent_callback(GtkWidget *widget, gpointer client_data);
+#endif
 void a_Commands_addbm_callback (GtkWidget *widget, gpointer client_data);
+void a_Commands_addbm_doc_callback (GtkWidget *widget, gpointer client_data);
+void a_Commands_addbm_link_callback (GtkWidget *widget, gpointer client_data);
 void a_Commands_viewbm_callback (GtkWidget *widget, gpointer client_data);
 
 void a_Commands_helphome_callback (GtkWidget *widget, gpointer client_data);
@@ -37,9 +46,24 @@
 void a_Commands_open_link_callback(GtkWidget *widget, gpointer client_data);
 void a_Commands_open_link_nw_callback(GtkWidget *widget, gpointer client_data);
 void a_Commands_select_popup_url_callback(GtkWidget *widget, gpointer data);
+void a_Commands_duplicate_callback(GtkWidget *widget, gpointer client_data);
 
 void a_Commands_ob_w3c_callback(GtkWidget *widget, gpointer client_data);
 void a_Commands_ob_wdg_callback(GtkWidget *widget, gpointer client_data);
 void a_Commands_ob_info_callback(GtkWidget *widget, gpointer client_data);
 
+void a_Commands_full_screen_callback(gpointer client_data);
+gint a_Commands_click_callback(gpointer client_data, GdkEventButton *event);
+void a_Commands_key_press_handler(GtkWidget *widget,
+        GdkEventKey *event, gpointer client_data);
+
+#ifndef DISABLE_TABS
+void a_Commands_new_tab_callback(GtkWidget *widget, gpointer client_data);
+void a_Commands_close_current_tab_callback(GtkWidget *widget, gpointer client_data);
+void a_Commands_close_tab_callback(GtkWidget *widget, gpointer client_data);
+void a_Commands_tab_prev_callback (GtkWidget *widget, gpointer client_data);
+void a_Commands_tab_next_callback (GtkWidget *widget, gpointer client_data);
+void a_Commands_open_link_nw_tab_callback(GtkWidget *widget, gpointer client_data);
+void a_Commands_duplicate_tab_callback(GtkWidget *widget, gpointer client_data);
+#endif
 #endif /* __COMMANDS_H__ */
diff -Nur dillo-0.8.0/src/cookies.c dillo-0.8.0.new/src/cookies.c
--- dillo-0.8.0/src/cookies.c	2003-11-15 21:52:45.000000000 +0000
+++ dillo-0.8.0.new/src/cookies.c	2004-10-13 01:13:29.000000000 +0000
@@ -32,7 +32,8 @@
 #include "list.h"
 #include "cookies.h"
 
-#define DEBUG_LEVEL 8
+#define DEBUG_LEVEL 0
+//#define DEBUG_LEVEL 8
 #include "debug.h"
 
 /* The maximum length of a line in the cookie file */
@@ -121,7 +122,8 @@
 static void Cookies_free_cookie(CookieData_t *cookie)
 {
    g_free(cookie->name);
-   g_free(cookie->value);
+   if(cookie->value != NULL)
+      g_free(cookie->value);
    g_free(cookie->domain);
    g_free(cookie->path);
    g_free(cookie->comment);
@@ -362,7 +364,7 @@
       "Cookies: Expire date is malformed!\n"
       " (should be RFC-1123 | RFC-850 | ANSI asctime)\n"
       " Ignoring cookie...\n";
-
+   
    if (!(cp = strchr(expires, ',')) && strlen(expires) == 24) {
       /* Looks like ANSI asctime format... */
       cp = (gchar *)expires;
@@ -374,7 +376,7 @@
       seconds = strtol(cp + 17, NULL, 10);  /* seconds */
 
    } else if (cp && ((cp - expires == 3 && strlen(cp) == 26) ||
-                     (cp - expires > 5  && strlen(cp) == 24))) {
+                     (cp - expires > 5 && (strlen(cp) == 24 || strlen(cp) == 26)))) {
       /* RFC-1123 | RFC-850 format */
       day = strtol(cp + 2, NULL, 10);
       month = Cookies_get_month(cp + 5);
@@ -387,6 +389,7 @@
 
    } else {
       DEBUG_MSG(5, E_msg);
+      DEBUG_MSG(5, "expires:%s\n",expires);
       return (time_t) 0;
    }
 
@@ -395,6 +398,7 @@
          hour >= 0 && hour < 24 && minutes >= 0 && minutes < 60 &&
          seconds >= 0 && seconds < 60)) {
       DEBUG_MSG(5, E_msg);
+      DEBUG_MSG(5, "invalid time\n");
       return (time_t) 0;
    }
 
@@ -485,7 +489,6 @@
 {
    GList *domain_cookies, *tmp;
    char *domain_str;
-
    /* Don't add an expired cookie */
    if (!cookie->session_only && cookie->expires_at < time(NULL)) {
       Cookies_free_cookie(cookie);
@@ -558,7 +561,7 @@
 {
    char *str = *cookie_str;
    int i, end = 0;
-   gboolean got_attr = FALSE;
+   gboolean got_attr = FALSE, have_value = TRUE;
 
    for (i = 0; ; i++) {
       switch (str[i]) {
@@ -567,6 +570,10 @@
       case '=':
       case ';':
          got_attr = TRUE;
+         if(str[i] == '=' && str[i+1] == ';'){
+             DEBUG_MSG(5, "no value\n");
+             have_value = FALSE;
+         }
          if (end == 0)
             end = i;
          break;
@@ -582,6 +589,7 @@
          /* fall through! */
       default:
          if (got_attr) {
+            if(!have_value) i--;
             *cookie_str = str + i;
             return g_strndup(str, end);
          }
@@ -603,6 +611,11 @@
    char *str = *cookie_str;
    int i = -1, end = 0;
 
+   if(str[0] == ';') {
+       cookie_str += 1;
+       return strdup("");
+   }
+
    while (!end) {
       ++i;
       switch (str[i]) {
@@ -724,7 +737,6 @@
             DEBUG_MSG(8,"Cookie has 'Expires' attribute "
                         "which isn't RFC-2965 compliant.\n");
             value = Cookies_parse_value(&str, TRUE, FALSE);
-
             if (value) {
                cookie->expires_at = Cookies_create_timestamp(value);
                cookie->session_only = FALSE;
@@ -762,7 +774,7 @@
          /* Oops! this can't be good... */
          g_free(attr);
          Cookies_free_cookie(cookie);
-         DEBUG_MSG(8, "Cookie contains illegal attribute!\n");
+         DEBUG_MSG(8, "Cookie contains illegal attribute!:%s\n",str);
          return NULL;
       }
 
@@ -925,7 +937,6 @@
          if (Cookies_validate_domain(cookie, set_url)) {
             if (action == COOKIE_ACCEPT_SESSION)
                cookie->session_only = TRUE;
-
             Cookies_add_cookie(cookie);
          } else {
             DEBUG_MSG(5, "Rejecting cookie for %s from %s:\n",
@@ -1085,7 +1096,7 @@
 
    /* Get a file pointer */
    filename = a_Misc_prepend_user_home(".dillo/cookiesrc");
-   stream = Cookies_fopen(filename, "DEFAULT DENY\n");
+   stream = Cookies_fopen(filename, "DEFAULT ACCEPT_SESSION\n");
    g_free(filename);
 
    if (!stream)
diff -Nur dillo-0.8.0/src/dicache.c dillo-0.8.0.new/src/dicache.c
--- dillo-0.8.0/src/dicache.c	2003-11-18 17:27:55.000000000 +0000
+++ dillo-0.8.0.new/src/dicache.c	2004-10-13 01:13:29.000000000 +0000
@@ -17,6 +17,7 @@
 
 #include "image.h"
 #include "web.h"
+#include "doc.h"
 #include "dicache.h"
 #include "cache.h"
 #include "interface.h"
@@ -261,7 +262,7 @@
       }
    } else if ( Op == CA_Close || Op == CA_Abort ) {
       a_Image_close(Web->Image);
-      a_Interface_close_client(Web->bw, Client->Key);
+      a_Doc_close_client(Web->dd, Client->Key);
    }
 }
 
@@ -364,7 +365,7 @@
       DicEntry->cmap = NULL;
    }
    a_Image_close(Web->Image);
-   a_Interface_close_client(Web->bw, Client->Key);
+   a_Doc_close_client(Web->dd, Client->Key);
 }
 
 /* ------------------------------------------------------------------------- */
diff -Nur dillo-0.8.0/src/dillo.c dillo-0.8.0.new/src/dillo.c
--- dillo-0.8.0/src/dillo.c	2004-02-06 15:53:59.000000000 +0000
+++ dillo-0.8.0.new/src/dillo.c	2004-10-13 01:13:29.000000000 +0000
@@ -19,6 +19,8 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include <config.h>
+
 #include <stdio.h>
 #include <gtk/gtk.h>
 
@@ -35,10 +37,13 @@
 #include <locale.h>
 
 #include <config.h>
+#include "intl.h"
+#include "i18n.h"
 #include "msg.h"
 #include "dillo.h"
 #include "misc.h"
 #include "nav.h"
+#include "doc.h"
 #include "history.h"
 #include "bookmark.h"
 #include "dicache.h"
@@ -95,26 +100,27 @@
  */
 static CLI_options Options[] = {
    {"-x", "--xid",        1, DILLO_CLI_XID,
-    "  -x, --xid XID          Open first Dillo window in an existing\n"
-    "                         GtkSocket which window ID is XID (decimal)."},
+    N_("  -x, --xid XID          Open first Dillo window in an existing\n"
+    "                         GtkSocket which window ID is XID (decimal).")},
    {"-v", "--version",    0, DILLO_CLI_VERSION,
-    "  -v, --version          Display version info and exit."},
+    N_("  -v, --version          Display version info and exit.")},
    {"-h", "--help",       0, DILLO_CLI_HELP,
-    "  -h, --help             Display this help text and exit."},
+    N_("  -h, --help             Display this help text and exit.")},
    {"-f", "--fullwindow", 0, DILLO_CLI_FULLWINDOW,
-    "  -f, --fullwindow       Start in full window mode."},
+    N_("  -f, --fullwindow       Start in full window mode.")},
    {"-l", "--local",      0, DILLO_CLI_LOCAL,
-    "  -l, --local            Don't follow links for this URL(s)."},
+    N_("  -l, --local            Don't follow links for this URL(s).")},
    {"-g", "-geometry",    1, DILLO_CLI_GEOMETRY,
-    "  -g, -geometry GEO      Set initial window position where GEO is\n"
-    "                         <width>x<height>{+-}<x>{+-}<y>"},
+    N_("  -g, -geometry GEO      Set initial window position where GEO is\n"
+    "                         <width>x<height>{+-}<x>{+-}<y>")},
    {"-D", "--debug-rendering",
                           0, DILLO_CLI_DBG_RENDERING,
-    "  -D, --debug-rendering  Draw additionaly several lines in a web page,\n"
-    "                         representing its structure. For debugging. "},
+    N_("  -D, --debug-rendering  Draw additionaly several lines in a web page,\n"
+    "                         representing its structure. For debugging. ")},
    {NULL, NULL, 0, 0, NULL}
 };
 
+
 /*
  * Return the maximum number of option arguments
  */
@@ -182,7 +188,7 @@
   while (1) {
      pid = waitpid (-1, &status, WNOHANG);
      if (pid < 0) {
-        perror ("waitpid");
+        //perror ("waitpid");
         break;
      }
      if (pid == 0)
@@ -213,6 +219,11 @@
    /* set locale */
    curr_locale = g_strdup(setlocale(LC_ALL, NULL));
    gtk_set_locale();
+   /* get lang */
+   a_I18n_set_DW_lang(getenv("LANG"));
+   /* Initialize Gettext */
+   bindtextdomain (PACKAGE, LOCALEDIR);
+   textdomain (PACKAGE);
    /* Initialize GUI and parse GTK related args */
    gtk_init(&argc, &argv);
    gdk_rgb_init();
@@ -233,8 +244,8 @@
         if (opt_argv[0][0] >= '0' && opt_argv[0][0] <= '9') {
            xid = strtol(opt_argv[0], NULL, 10);
         } else {
-           g_printerr("Error: the XID must be an unsigned decimal numerical "
-                      "value.\nThe offending value was: %s\n", opt_argv[0]);
+           g_printerr(_("Error: the XID must be an unsigned decimal numerical "
+                   "value.\nThe offending value was: %s\n"), opt_argv[0]);
            return -1;
         }
         break;
@@ -248,14 +259,15 @@
        if (a_Misc_parse_geometry(opt_argv[0], &xpos, &ypos, &width, &height))
           break;
      default:
-        g_printerr("Error in command line options.\n");
+        g_printerr(_("Error in command line options.\n"));
         return -1;
         break;
      }
    }
 
    /* Send a delayed locale-related message */
-   MSG("Setting locale to %s...\n", curr_locale);
+   //g_print(_("Setting locale to %s...\n"), curr_locale);
+   MSG(_("Setting gtk charset to %s...\n"), DW_CHARSET);
    g_free(curr_locale);
 
    /* This lets threads in the file module end peacefully when aborted
@@ -280,6 +292,7 @@
    a_Interface_init();
    a_Dw_init();
    a_Cookies_init();
+   a_Doc_init();
 
    /* -f overrides dillorc */
    if (options_got & DILLO_CLI_FULLWINDOW)
@@ -302,9 +315,13 @@
    a_Bookmarks_init();
 
    /* Send dillo startup screen */
-   start_url = a_Url_new("splash", "about:", 0, 0, 0);
-   a_Nav_push(bw, start_url);
-   a_Url_free(start_url);
+   if(argc == 1){
+	   if(prefs.startup != NULL){
+		   start_url = prefs.startup;
+	   } else start_url = a_Url_new("splash", "about:", 0, 0, 0);
+	   a_Nav_push(bw->dd, start_url);
+	   a_Url_free(start_url);
+   }
 
    for (i = idx; i < argc; i++) {
       /* If more than one URL/FILE, open in new window */
@@ -314,7 +331,7 @@
       start_url = Dillo_make_start_url(argv[i]);
       if (options_got & DILLO_CLI_LOCAL)
          a_Url_set_flags(start_url, URL_FLAGS(start_url) | URL_SpamSafe);
-      a_Nav_push(bw, start_url);
+      a_Nav_push(bw->dd, start_url);
       a_Url_free(start_url);
    }
 
@@ -330,13 +347,18 @@
    a_Cache_freeall();
    a_Dicache_freeall();
    a_Http_freeall();
+#ifdef DILLO_SSL
+   a_Https_freeall();
+#endif
    a_Dns_freeall();
    a_Prefs_freeall();
    a_Dw_freeall();
    a_History_free();
-
+#ifdef DEBUG
+   g_mem_profile();
+#endif
    //a_Dpi_bye_dpid();
-   MSG("Dillo: normal exit!\n");
+   //MSG(_("Dillo: normal exit!\n"));
    return 0;
 }
 
@@ -350,10 +372,10 @@
 
    if ( stat(dir, &st) == -1 ) {
       if ( errno == ENOENT && mkdir(dir, 0700) < 0 ) {
-         MSG("Dillo: error creating directory %s: %s\n",
-             dir, g_strerror(errno));
+         MSG(_("Dillo: error creating directory %s: %s\n"),
+                 dir, strerror(errno));
       } else
-         MSG("Dillo: error reading %s: %s\n", dir, g_strerror(errno));
+         MSG(_("Dillo: error reading %s: %s\n"), dir, strerror(errno));
    }
 }
 
@@ -402,8 +424,8 @@
 
          /* Optional arguments have opt_argc < 0 */
          if (i < n_arg) {
-            g_printerr("Option %s requires %d argument(s)\n",
-                       argv[idx - i - 1], n_arg);
+            g_printerr(_("Option %s requires %d argument(s)\n"),
+                    argv[idx - i - 1], n_arg);
             state = O_ERROR;
          } else
             state = O_OK;
@@ -437,18 +459,20 @@
  */
 static void Dillo_print_help(CLI_options *options)
 {
-   g_print("\nUsage: dillo [OPTIONS] [URL|FILE]...\n"
-              "Options:\n");
+   g_print(_("\nUsage: dillo [OPTIONS] [URL|FILE]...\n"
+              "Options:\n"));
 
    for (; options && options->sh_opt; options++) {
       if (options->help)
-         g_print("%s\n", options->help);
+         g_print("%s\n", _(options->help));
       else
-         g_print("  %s, %s   *Undocumented*\n", options->sh_opt,
+         g_print(_("  %s, %s   *Undocumented*\n"), options->sh_opt,
                  options->lg_opt);
    }
-   g_print("  URL                    URL to browse.\n"
-           "  FILE                   Local FILE to view.\n");
+   g_print(_("  URL                   URL to browse.\n"
+           "  FILE                  Local FILE to view.\n"));
+   g_print(_("  URL                    URL to browse.\n"
+           "  FILE                   Local FILE to view.\n"));
    g_print("\n");
 }
 
diff -Nur dillo-0.8.0/src/dns.c dillo-0.8.0.new/src/dns.c
--- dillo-0.8.0/src/dns.c	2003-11-21 16:44:02.000000000 +0000
+++ dillo-0.8.0.new/src/dns.c	2004-10-13 01:13:29.000000000 +0000
@@ -31,7 +31,8 @@
 #include "dns.h"
 #include "list.h"
 
-#define DEBUG_LEVEL 5
+#define DEBUG_LEVEL 0
+//#define DEBUG_LEVEL 5
 #include "debug.h"
 
 
diff -Nur dillo-0.8.0/src/doc.c dillo-0.8.0.new/src/doc.c
--- dillo-0.8.0/src/doc.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/src/doc.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,658 @@
+/*
+ *
+ * Copyright (C) 2003 Frank de Lange
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+#include "dw_widget.h"
+#include "dw_gtk_scrolled_window.h"
+#include "dw_gtk_viewport.h"
+#include "dw_container.h"
+#include "doc.h"
+#include "list.h"
+#include "debug.h"
+#include "cache.h"
+#include "nav.h"
+#include "pagemark.h"
+#include "interface.h"
+#include "commands.h"
+#include <math.h> /* for rint() */
+#ifndef DISABLE_TABS
+/* for a_Tab_title_set */
+#include "tab.h"
+#endif /* !DISABLE_TABS */
+#include "progressbar.h"
+#include "prefs.h"
+
+#define DEBUG_EVENT  0
+#define DEBUG_SIZE  10
+#define DEBUG_ALLOC 10
+
+/* #define DEBUG_LEVEL  0 */
+#include "debug.h"
+
+/*
+ * Local Data
+ */
+
+/* DilloDoc holds everything pertaining to a single document */
+static DilloDoc **dillo_doc;
+static gint num_dd, num_dd_max;
+
+/*
+ * Initialize global data
+ */
+void a_Doc_init(void)
+{
+   num_dd = 0;
+   num_dd_max = 16;
+   dillo_doc = NULL;
+}
+
+/* callbacks */
+
+/*
+ * callback for docwin delete
+ *
+ * this will call a_Doc_destroy for the associated DilloDoc
+ */
+void
+Doc_docwin_destroy_callback(GtkWidget *widget,
+                           gpointer user_data)
+{
+   DilloDoc *dd = (DilloDoc *) user_data;
+   /* aargh... get GTK to be quit about the non-existing gadget... */
+   if (GTK_DW_SCROLLED_WINDOW(widget)->gadget)
+     GTK_DW_SCROLLED_WINDOW(widget)->gadget = NULL;
+
+   a_Doc_destroy(dd);
+}
+
+/* public functions */
+
+/*
+ * Stop all active connections for the document (except downloads)
+ */
+void a_Doc_stop(DilloDoc *dd)
+{
+   g_return_if_fail ( dd != NULL );
+
+   /* Remove root clients */
+   while ( dd->NumRootClients ) {
+      a_Cache_stop_client(dd->RootClients[0]);
+      a_List_remove(dd->RootClients, 0, dd->NumRootClients);
+   }
+   /* Remove image clients */
+   while ( dd->NumImageClients ) {
+      a_Cache_stop_client(dd->ImageClients[0]);
+      a_List_remove(dd->ImageClients, 0, dd->NumImageClients);
+   }
+}
+
+/*
+ * Empty RootClients, ImageClients and PageUrls lists and
+ * reset progress bar data.
+ */
+void a_Doc_clean(DilloDoc *dd)
+{
+   g_return_if_fail ( dd != NULL );
+
+   while ( dd->NumRootClients )
+      a_List_remove(dd->RootClients, 0, dd->NumRootClients);
+
+   while ( dd->NumImageClients )
+      a_List_remove(dd->ImageClients, 0, dd->NumImageClients);
+
+   while ( dd->NumPageUrls ) {
+      a_Url_free(dd->PageUrls[0].Url);
+      a_List_remove(dd->PageUrls, 0, dd->NumPageUrls);
+   }
+
+   /* Zero image-progressbar data */
+   dd->NumImages = 0;
+   dd->NumImagesGot = 0;
+
+   /* Zero progressbar data and ready state */
+   dd->progress = 0.0;
+   dd->ready = TRUE;
+}
+
+/*
+ * Remove the cache-client from the dd list
+ * (client can be a image or a html page)
+ */
+void a_Doc_remove_client(DilloDoc *dd, gint ClientKey)
+{
+   gint i;
+   gboolean Found = FALSE;
+
+   g_return_if_fail ( dd != NULL );
+
+   for ( i = 0; !Found && i < dd->NumRootClients; ++i)
+      if ( dd->RootClients[i] == ClientKey ) {
+         a_List_remove(dd->RootClients, i, dd->NumRootClients);
+         Found = TRUE;
+      }
+
+   for ( i = 0; !Found && i < dd->NumImageClients; ++i)
+      if ( dd->ImageClients[i] == ClientKey ) {
+         a_List_remove(dd->ImageClients, i, dd->NumImageClients);
+         dd->NumImagesGot++;
+         Found = TRUE;
+      }
+
+   a_Interface_set_button_sens(dd->bw);
+}
+
+
+/*
+ * Remove the cache-client from the dd list
+ * (client can be a image or a html page)
+ */
+void a_Doc_close_client(DilloDoc *dd, gint ClientKey)
+{
+   g_return_if_fail ( dd != NULL );
+
+   a_Doc_remove_client(dd, ClientKey);
+   a_Doc_progress_update(dd);
+}
+
+/*
+ * update progress bar, set button sensitivity
+ */
+void
+a_Doc_progress_update(DilloDoc *dd)
+{
+   gchar progress[PBAR_L];
+
+   g_return_if_fail ( dd != NULL );
+   
+   if(dd->bw->dd == dd) {
+     a_Interface_set_button_sens(dd->bw);
+     g_snprintf(progress, PBAR_L, "%s%d of %d",
+		PBAR_ISTR(prefs.panel_size == 1),
+		dd->NumImagesGot, dd->NumImages);
+     a_Progressbar_update(dd->bw->imgprogress, progress,
+			  (dd->NumImagesGot == dd->NumImages) ? 0 : 1 );
+     g_snprintf(progress, PBAR_L, "%s%.1f Kb",
+		PBAR_PSTR(prefs.panel_size == 1),
+		(float)dd->progress);
+     a_Progressbar_update(dd->bw->progress, progress, (dd->ready) ? 0 : 1 );
+   }
+}
+
+
+/*
+ * Add a reference to the cache-client in the document's list.
+ * This helps us keep track of which are active in the document so that it's
+ * possible to abort them.
+ * (Root: Flag, whether a Root URL or not)
+ */
+void a_Doc_add_client(DilloDoc *dd, gint Key, gint Root)
+{
+   gint nc;
+
+   g_return_if_fail ( dd != NULL );
+
+   if ( Root ) {
+      nc = dd->NumRootClients;
+      a_List_add(dd->RootClients, nc, dd->MaxRootClients);
+      dd->RootClients[nc] = Key;
+      dd->NumRootClients++;
+   } else {
+      nc = dd->NumImageClients;
+      a_List_add(dd->ImageClients, nc, dd->MaxImageClients);
+      dd->ImageClients[nc] = Key;
+      dd->NumImageClients++;
+      dd->NumImages++;
+   }
+   a_Doc_progress_update(dd);
+}
+
+/*
+ * Add an URL to the document's list.
+ * This helps us keep track of page requested URLs so that it's
+ * possible to stop, abort and reload them.)
+ *   Flags: Chosen from {DD_Root, DD_Image, DD_Download}
+ */
+void a_Doc_add_url(DilloDoc *dd, const DilloUrl *Url, gint Flags)
+{
+   gint nu, i;
+   gboolean found = FALSE;
+
+   g_return_if_fail ( dd != NULL && Url != NULL );
+
+   nu = dd->NumPageUrls;
+   for ( i = 0; i < nu; i++ ) {
+      if ( !a_Url_cmp(Url, dd->PageUrls[i].Url) ) {
+         found = TRUE;
+         break;
+      }
+   }
+   if ( !found ) {
+      a_List_add(dd->PageUrls, nu, dd->MaxPageUrls);
+      dd->PageUrls[nu].Url = a_Url_dup(Url);
+      dd->PageUrls[nu].Flags = Flags;
+      dd->NumPageUrls++;
+   }
+}
+
+/*
+ * set document title
+ *
+ * this will propagate to the current interface element
+ *
+ * currently just forwards to a_Tab_title_set (when tabs
+ * are compiled in) or a_Interface_set_page_title (when
+ * compiled without tab support)
+ */
+void
+a_Doc_title_set(DilloDoc *dd, gchar *title)
+{
+   g_return_if_fail ( dd != NULL && title != NULL );
+
+   /* only set title for top level document */
+   if(dd->parent == NULL)
+#ifndef DISABLE_TABS
+   a_Tab_title_set(dd, title);
+#else
+   a_Interface_set_page_title(dd->bw, title);
+#endif
+}
+
+/*
+ * set document location
+ *
+ * this will propagate to the current interface element
+ *
+ * currently just forwards to a_Interface_set_location_text
+ */
+void
+a_Doc_location_set(DilloDoc *dd, gchar *location)
+{
+   g_return_if_fail ( dd != NULL && location != NULL );
+
+   /* only set location text if this is the current tab */
+   if((dd->parent == NULL) && dd->bw->dd == dd) {
+     a_Interface_set_location_text(dd->bw, location);
+   }
+}
+
+/*
+ * destroy a document
+ */
+void a_Doc_destroy(DilloDoc *dd)
+{
+   gint i;
+ 
+   g_return_if_fail ( dd != NULL );
+   
+   /* stop/abort open connections. */
+   a_Doc_stop(dd);
+   
+   for (i = 0; i < num_dd; i++)
+     if (dillo_doc[i] == dd) {
+       dillo_doc[i] = dillo_doc[--num_dd];
+       break;
+     }
+   
+   /* free nav_stack and nav_expect stuff */
+   a_Nav_free(dd);
+   
+   /* unref the style */
+   if(dd->style)
+     a_Dw_style_unref(dd->style);
+   
+   /* destroy pagemark menu */
+   a_Pagemark_destroy(dd);
+   
+   g_free(dd->RootClients);
+   g_free(dd->ImageClients); 
+
+#ifndef XHTML_DTD_STRICT
+   if(dd->name)
+     g_free(dd->name);
+  
+#endif /* !XHTML_DTD_STRICT */
+   for (i = 0; i < dd->NumPageUrls; i++)
+     a_Url_free(dd->PageUrls[i].Url);
+   g_free(dd->PageUrls);
+   g_free(dd);
+}
+
+/*
+ * set the dd's cursor type, and update the docwin if it is
+ * mapped.
+ */
+void a_Doc_set_cursor(DilloDoc *dd, GdkCursorType CursorType)
+{
+   GdkCursor *cursor;
+
+   g_return_if_fail ( dd != NULL );
+
+   if ( dd->CursorType != CursorType ) {
+     if(GTK_WIDGET_MAPPED(dd->docwin)) {
+       cursor = gdk_cursor_new(CursorType);
+       gdk_window_set_cursor(dd->docwin->window, cursor);
+       gdk_cursor_destroy(cursor);
+     }
+     dd->CursorType = CursorType;
+   }
+}
+
+/*
+ * Get the DilloDoc which contains *docwin
+ * returns NULL if dd not found
+ */
+DilloDoc *
+a_Doc_get_by_docwin(GtkWidget *docwin)
+{
+   gint i;
+
+   g_return_val_if_fail ( docwin != NULL, NULL );
+
+   for (i = 0; i < num_dd; i++)
+     if (dillo_doc[i]->docwin == docwin)
+       return dillo_doc[i];
+
+   return NULL;
+}
+
+#ifndef XHTML_DTD_STRICT
+/*
+ * set the dd's name (used for targeted links)
+ */
+void a_Doc_set_name(DilloDoc *dd, gchar *name)
+{
+   g_return_if_fail((dd != NULL) && (name != NULL));
+
+   if (dd && name) {
+     if (dd->name)
+       g_free((gchar *)dd->name);
+     dd->name = g_strdup(name);
+   }
+}
+
+/*
+ * Get a named DilloDoc
+ *
+ * First checks if name is one of the reserved names
+ * ("_blank", "_self", "_parent" and "_top") and acts
+ * accordingly if so. If not, it searches for a document
+ * with the same root as the document which initiated the
+ * search. If still not found, it searches for the first
+ * document with the given name.
+ *
+ * returns NULL if no matching document found
+ */
+DilloDoc *
+a_Doc_get_by_name(DilloDoc *dd, gchar *name)
+{
+  gint i, n;
+  DilloDoc *parent, *document;
+  gint width, height;
+  BrowserWindow *newbw;
+
+  g_return_val_if_fail((dd != NULL) && (name != NULL), NULL);
+
+  parent = a_Doc_get_root(dd);
+  document = NULL;
+
+  /* first see if the target name is one of the reserved names,
+   * if so act appropriately */
+  if(!g_strcasecmp(name, "_blank")) {
+
+#ifndef DISABLE_TABS
+    if(prefs.tab_instead_of_window) 
+      {
+	document = a_Doc_new();
+	a_Tab_add(parent->bw, document);
+      }
+    else
+#endif /* !DISABLE_TABS */
+      {
+	gdk_window_get_size(parent->bw->main_window->window, &width, &height);
+	newbw = a_Interface_browser_window_new(width, height, 0);
+	document = newbw->dd;
+      }
+  }
+  else if(!g_strcasecmp(name, "_self"))
+    document = dd;
+  else if(!g_strcasecmp(name, "_parent"))
+    document = a_Doc_get_parent(dd);
+  else if(!g_strcasecmp(name, "_top"))
+    document = a_Doc_get_root(dd);
+
+  /* if previous search did not match, first try to find document with same parent, 
+   * if not found try to find first matching named document
+   */
+  if(!document)
+    for (n = 1; n >= 0; n--) {
+      for (i = 0; i < num_dd; i++)
+	if (dillo_doc[i]->name &&
+	    (!g_strcasecmp(name, dillo_doc[i]->name)) &&
+	    (n ? (a_Doc_get_root(dillo_doc[i]) == parent) : TRUE)) {
+	  document = dillo_doc[i];
+	  break;
+	}
+      if(document)
+	break;
+    }
+
+  return document;
+}
+
+#endif /* !XHTML_DTD_STRICT */
+/*
+ * Get the parent document
+ * For unparented documents it just returns the document itself
+ */
+DilloDoc *
+a_Doc_get_parent(DilloDoc *dd)
+{
+   DilloDoc *parent;
+
+   g_return_val_if_fail(dd != NULL, NULL);
+
+   parent = dd;
+   if(parent->parent)
+     parent = parent->parent;
+
+   return parent;
+}
+
+/*
+ * Get the root document
+ * For unparented documents it just returns the document itself.
+ */
+DilloDoc *
+a_Doc_get_root(DilloDoc *dd)
+{
+   DilloDoc *parent;
+
+   g_return_val_if_fail(dd != NULL, NULL);
+
+   parent = dd;
+   while(parent->parent)
+     parent = parent->parent;
+
+   return parent;
+}
+
+/*
+ * get all visible children (nested documents) for this document
+ *
+ * returns: pointer to GList containing all visible descendants of
+ *          the document (including the document itself as the first
+ *          item if it is visible. Frameset documents are not visible,
+ *          so they are not included in the list).
+ *
+ * returned GList must be g_list_free()'d by caller
+ */
+GList *
+a_Doc_get_visible_children(DilloDoc *dd)
+{
+   gint i;
+   GList *children;
+
+   g_return_val_if_fail(dd != NULL, NULL);
+
+   children = NULL;
+
+   /* first add 'self' to list */
+   if(GTK_WIDGET_VISIBLE(dd->docwin))
+     children = g_list_append(children, dd);
+   for (i = 0; i < num_dd; i++)
+     if (dillo_doc[i]->parent == dd)
+       children = g_list_concat(children, 
+				a_Doc_get_visible_children(dillo_doc[i]));
+
+   return children;
+}
+
+/*
+ * Set parent
+ */
+void
+a_Doc_set_parent(DilloDoc *dd, DilloDoc *parent)
+{
+   g_return_if_fail (dd != NULL && parent != NULL);
+   
+   dd->parent = parent;
+   a_Doc_set_browserwindow(dd, parent->bw);
+}
+
+/*   
+ * set browserwindow
+ */
+void
+a_Doc_set_browserwindow(DilloDoc *dd, BrowserWindow *bw)
+{
+   DwStyle style_attrs;
+   DwStyleFont font;
+
+   g_return_if_fail (dd != NULL && bw != NULL);
+
+   /* set dd's current window */
+   dd->bw = bw;
+
+   /* Catch key_press event */
+   gtk_signal_connect(GTK_OBJECT(GTK_BIN(dd->docwin)->child),
+		      "key_press_event",
+		      GTK_SIGNAL_FUNC(a_Commands_key_press_handler),
+		      bw);
+   
+   /* Full screen mode via double click is done in two ways: First,
+    * a feature of the selection is used, since in complex pages,
+    * getting events back to the viewport is quite difficult. Second,
+    * a simple callback, called e.g. when viewing image resources.
+    */
+   a_Selection_set_dclick_callback(
+      GTK_DW_VIEWPORT(GTK_BIN(GTK_BIN(dd->docwin)->child)->child)->selection,
+      (void(*)(gpointer))a_Commands_full_screen_callback,
+      bw);
+   /* Selection requires an owner widget */
+   a_Selection_set_owner(
+      GTK_DW_VIEWPORT(GTK_BIN(GTK_BIN(dd->docwin)->child)->child)->selection,
+      GTK_BIN(dd->docwin)->child);
+
+#if 0
+   /* deselect location bar contents when the scrolled_frame gets focus */
+   gtk_signal_connect_object(GTK_OBJECT(GTK_BIN(dd->docwin)->child),
+			     "grab-focus",
+			     a_Interface_content_focus_callback,
+			     (gpointer) bw);
+#endif
+
+   gtk_signal_connect_object_after(GTK_OBJECT(GTK_BIN(dd->docwin)->child),
+                                   "button_press_event",
+                                   GTK_SIGNAL_FUNC(a_Commands_click_callback),
+                                   (gpointer) bw);
+
+   /* create style for Dw */
+   font.name = prefs.vw_fontname; /* must be defined */
+   font.size = rint(DOC_DEFAULT_FONT_SIZE * prefs.font_factor);
+   font.weight = 400;
+   font.style = DW_STYLE_FONT_STYLE_NORMAL;
+   
+   a_Dw_style_init_values (&style_attrs, dd->bw->main_window->window);
+   a_Dw_style_box_set_val (&style_attrs.margin, DOC_DEFAULT_MARGIN);
+   style_attrs.font = a_Dw_style_font_new (&font);
+   style_attrs.color =
+     a_Dw_style_color_new (prefs.text_color, dd->bw->main_window->window);
+   style_attrs.background_color =
+     a_Dw_style_color_new (prefs.bg_color, dd->bw->main_window->window);
+   dd->style = a_Dw_style_new (&style_attrs, dd->bw->main_window->window);
+}
+
+/*
+ * Create a new DilloDoc
+ * (the new document is stored in dillo_doc)
+ */
+DilloDoc *
+a_Doc_new(void)
+{
+   DilloDoc *dd;
+   dd = g_new0(DilloDoc, 1);
+   a_List_add(dillo_doc, num_dd, num_dd_max);
+   dillo_doc[num_dd++] = dd;
+
+   a_Nav_init(dd);
+
+   dd->docwin = a_Dw_gtk_scrolled_window_new();
+   dd->style = NULL;
+   dd->parent = NULL;
+
+   dd->frameset = NULL;
+   dd->name = NULL;
+
+   gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(dd->docwin),
+                                  GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
+
+   /* this callback NULLs the docwin->gadget (to keep GTK from
+    * complaining when it tries to destroy a non-existing widget - there
+    * should be a check in dw_gtk_scrolled_window to see if scrolled->gadget
+    * really points at a GTK widget...
+    *
+    * it also destroys the DilloDoc by the way...
+    */
+   gtk_signal_connect(GTK_OBJECT(dd->docwin),
+                      "destroy",
+                      GTK_SIGNAL_FUNC(Doc_docwin_destroy_callback),
+                      (gpointer) dd);
+
+   gtk_widget_show(dd->docwin);
+
+   /* initialize the rest of the bt's data. */
+   dd->RootClients = NULL;
+   dd->NumRootClients = 0;
+   dd->MaxRootClients = 8;
+
+   dd->ImageClients = NULL;
+   dd->NumImageClients = 0;
+   dd->MaxImageClients = 8;
+   dd->NumImages = 0;
+   dd->NumImagesGot = 0;
+
+   dd->PageUrls = NULL;
+   dd->NumPageUrls = 0;
+   dd->MaxPageUrls = 8;
+
+   dd->auth_await_url = NULL;
+
+   dd->pagemarks_menu = NULL;
+   dd->pagemarks_last = NULL;
+
+   dd->CursorType = -1;
+
+   dd->progress = 0.0;
+   dd->ready = TRUE;
+
+   return dd;
+}
+
+
diff -Nur dillo-0.8.0/src/doc.h dillo-0.8.0.new/src/doc.h
--- dillo-0.8.0/src/doc.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/src/doc.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,37 @@
+#ifndef __DOC_H__
+#define __DOC_H__
+
+#include "browser.h"   /* for DilloDoc */
+
+/* used to set default margin for documents */
+#define DOC_DEFAULT_MARGIN 5
+#define DOC_DEFAULT_FONT_SIZE 12.0
+
+/* macros for documents */
+#define DD_HAS_FOCUS(dd,bw) bw->dd == dd
+
+void a_Doc_init(void);
+void a_Doc_stop(DilloDoc *dd);
+void a_Doc_clean(DilloDoc *dd);
+void a_Doc_title_set(DilloDoc *dd, gchar *title);
+void a_Doc_location_set(DilloDoc *dd, gchar *location);
+void a_Doc_remove_client(DilloDoc *dd, gint ClientKey);
+void a_Doc_close_client(DilloDoc *dd, gint ClientKey);
+void a_Doc_add_client(DilloDoc *dd, gint Key, gint Root);
+void a_Doc_add_url(DilloDoc *dd, const DilloUrl *Url, gint Flags);
+void a_Doc_destroy(DilloDoc *dd);
+void a_Doc_set_cursor(DilloDoc *dd, GdkCursorType CursorType);
+#ifndef XHTML_DTD_STRICT
+void a_Doc_set_name(DilloDoc *dd, gchar *name);
+DilloDoc * a_Doc_get_by_name(DilloDoc *dd, gchar *name);
+#endif /* !XHTML_DTD_STRICT */
+void a_Doc_set_parent(DilloDoc *dd, DilloDoc *parent);
+void a_Doc_set_browserwindow(DilloDoc *dd, BrowserWindow *bw);
+void a_Doc_progress_update(DilloDoc *dd);
+GList * a_Doc_get_visible_children(DilloDoc *dd);
+DilloDoc * a_Doc_get_by_docwin(GtkWidget *docwin);
+DilloDoc * a_Doc_get_parent(DilloDoc *dd);
+DilloDoc * a_Doc_get_root(DilloDoc *dd);
+DilloDoc * a_Doc_new(void);
+
+#endif /* __DOC_H__ */
diff -Nur dillo-0.8.0/src/dw_gtk_scrolled_frame.c dillo-0.8.0.new/src/dw_gtk_scrolled_frame.c
--- dillo-0.8.0/src/dw_gtk_scrolled_frame.c	2004-02-03 19:14:30.000000000 +0000
+++ dillo-0.8.0.new/src/dw_gtk_scrolled_frame.c	2004-10-13 01:13:29.000000000 +0000
@@ -451,25 +451,29 @@
    case GDK_Up:
    case GDK_KP_Up:
       Dw_gtk_scrolled_frame_move_by (frame, 0,
-                                     - frame->vadjustment->step_increment);
+                                     - frame->vadjustment->step_increment
+                                     * ((event->state & GDK_SHIFT_MASK)?12:2));
       return TRUE;
 
    case GDK_Down:
    case GDK_KP_Down:
       Dw_gtk_scrolled_frame_move_by (frame, 0,
-                                     + frame->vadjustment->step_increment);
+                                     + frame->vadjustment->step_increment
+                                     * ((event->state & GDK_SHIFT_MASK)?12:2));
       return TRUE;
 
    case GDK_Left:
    case GDK_KP_Left:
       Dw_gtk_scrolled_frame_move_by (frame,
-                                     - frame->hadjustment->step_increment, 0);
+                                     - frame->hadjustment->step_increment
+                                     * ((event->state & GDK_SHIFT_MASK)?12:2), 0);
       return TRUE;
 
    case GDK_Right:
    case GDK_KP_Right:
       Dw_gtk_scrolled_frame_move_by (frame,
-                                     + frame->hadjustment->step_increment, 0);
+                                     + frame->hadjustment->step_increment
+                                     * ((event->state & GDK_SHIFT_MASK)?12:2), 0);
       return TRUE;
 
    case GDK_Tab:
@@ -490,7 +494,7 @@
                                         0);
       else
          Dw_gtk_scrolled_frame_move_by (frame, 0,
-                                        - frame->vadjustment->page_increment);
+                                        - frame->vadjustment->page_increment * 1.9);
       return TRUE;
 
    case GDK_Page_Down:
@@ -502,7 +506,7 @@
                                         0);
       else
          Dw_gtk_scrolled_frame_move_by (frame, 0,
-                                        + frame->vadjustment->page_increment);
+                                        + frame->vadjustment->page_increment * 1.9);
       return TRUE;
 
    case GDK_Home:
diff -Nur dillo-0.8.0/src/dw_gtk_scrolled_window.c dillo-0.8.0.new/src/dw_gtk_scrolled_window.c
--- dillo-0.8.0/src/dw_gtk_scrolled_window.c	2004-01-05 19:25:46.000000000 +0000
+++ dillo-0.8.0.new/src/dw_gtk_scrolled_window.c	2004-10-13 01:13:29.000000000 +0000
@@ -15,6 +15,7 @@
 #include "dw_gtk_scrolled_frame.h"
 #include "dw_gtk_viewport.h"
 #include "findtext.h"
+#include "dw_tooltip.h"
 #include <gtk/gtk.h>
 
 #include "debug.h"
@@ -242,6 +243,7 @@
    GtkWidget *hscrollbar, *vscrollbar;
    gint gx, gy;
 
+   a_Dw_tooltip_count_reset();
    GTK_WIDGET_CLASS(parent_class)->size_allocate (widget, allocation);
    widget->allocation = *allocation;
 
@@ -465,7 +467,7 @@
 void a_Dw_gtk_scrolled_window_reset_search (GtkDwScrolledWindow *scrolled)
 {
    GtkWidget *viewport;
-
+   //g_print("%d\n",(int)gtk_type_check_object_cast ((GtkTypeObject*) scrolled, gtk_bin_get_type ()));
    viewport = GTK_BIN(GTK_BIN(scrolled)->child)->child;
    a_Findtext_reset_search (GTK_DW_VIEWPORT(viewport)->findtext_state);
 }
diff -Nur dillo-0.8.0/src/dw_image.c dillo-0.8.0.new/src/dw_image.c
--- dillo-0.8.0/src/dw_image.c	2003-11-18 17:27:56.000000000 +0000
+++ dillo-0.8.0.new/src/dw_image.c	2004-10-13 01:13:29.000000000 +0000
@@ -10,9 +10,16 @@
  * (at your option) any later version.
  */
 
+#include "i18n_gtk.h"
 #include "msg.h"
 #include "dw_image.h"
 #include "dw_gtk_viewport.h"
+#ifndef DISABLE_ANTI_ALIAS
+   #include <X11/Xlib.h>
+   #include <X11/Xft/Xft.h>
+   #undef Status
+   #include <gdk/gdkx.h>
+#endif
 #include "prefs.h"
 #include "dw_marshal.h"
 #include "list.h"
@@ -86,11 +93,15 @@
    LINK_PRESSED,
    LINK_RELEASED,
    LINK_CLICKED,
+   IMAGE_PRESSED,
    LAST_SIGNAL
 };
 
 static guint image_signals[LAST_SIGNAL] = { 0 };
 static DwWidgetClass *parent_class;
+#ifndef DISABLE_ANTI_ALIAS
+static XftDraw *xftdraw = NULL;
+#endif
 
 
 /*
@@ -207,6 +218,14 @@
                       GTK_TYPE_BOOL,
                       4, GTK_TYPE_INT, GTK_TYPE_INT, GTK_TYPE_INT,
                       GTK_TYPE_GDK_EVENT);
+   image_signals[IMAGE_PRESSED] =
+      gtk_signal_new ("image_pressed",
+                      GTK_RUN_FIRST,
+                      object_class->type,
+                      GTK_SIGNAL_OFFSET (DwImageClass, image_pressed),
+                      gtk_marshal_NONE__POINTER,
+                      GTK_TYPE_NONE,
+                      1, GTK_TYPE_GDK_EVENT);
    gtk_object_class_add_signals (object_class, image_signals, LAST_SIGNAL);
 
    widget_class = (DwWidgetClass*)klass;
@@ -251,6 +270,9 @@
                                    DwRequisition *requisition)
 {
    DwImage *image;
+#ifndef DISABLE_ANTI_ALIAS
+   XGlyphInfo info;
+#endif
 
    image = DW_IMAGE (widget);
    
@@ -261,8 +283,14 @@
       requisition->descent = 0;
    } else {
       if (image->alt_text_width == -1)
+#ifndef DISABLE_ANTI_ALIAS
+         XftTextExtentsUtf8(GDK_DISPLAY(), widget->style->font->font,
+            image->alt_text, strlen(image->alt_text), &info);
+         image->alt_text_width = info.xOff;
+#else
          image->alt_text_width = 
             gdk_string_width (widget->style->font->font, image->alt_text);
+#endif
 
       requisition->width = image->alt_text_width;
       requisition->ascent = widget->style->font->font->ascent;
@@ -312,6 +340,11 @@
    guchar *buffer, *bstart;
    int i;
    gboolean selected = FALSE;
+#ifndef DISABLE_ANTI_ALIAS
+   XGlyphInfo info;
+   XftColor xftcolor;   
+   GdkWindow *window;
+#endif
 
    if (image->buffer) {
       p_Dw_widget_draw_widget_box (widget, area, FALSE);
@@ -345,8 +378,14 @@
    } else {
       if (image->alt_text && image->alt_text[0]) {
          if (image->alt_text_width == -1)
+#ifndef DISABLE_ANTI_ALIAS
+            XftTextExtentsUtf8(GDK_DISPLAY(), widget->style->font->font,
+               image->alt_text, strlen(image->alt_text), &info);
+            image->alt_text_width = info.xOff;
+#else
             image->alt_text_width = 
                gdk_string_width (widget->style->font->font, image->alt_text);
+#endif
 
          if (widget->allocation.width < image->alt_text_width ||
              widget->allocation.ascent + widget->allocation.descent
@@ -355,13 +394,42 @@
             p_Dw_widget_will_clip (widget);
 
          p_Dw_widget_draw_widget_box (widget, area, FALSE);
-         gdk_draw_string
+#ifndef DISABLE_ANTI_ALIAS
+         if (!xftdraw) {
+            window = DW_WIDGET_WINDOW (widget);
+            xftdraw = XftDrawCreate(GDK_DISPLAY(),
+                     GDK_WINDOW_XWINDOW(window),
+                     DefaultVisual(GDK_DISPLAY(), DefaultScreen(GDK_DISPLAY())),
+                     DefaultColormap(GDK_DISPLAY(), DefaultScreen(GDK_DISPLAY())));
+#ifdef XFT_VERSION
+            if (XftDrawDrawable(xftdraw) != GDK_WINDOW_XWINDOW(window)) {
+#else
+            if (xftdraw->drawable != GDK_WINDOW_XWINDOW(window)) {
+#endif
+               XftDrawChange(xftdraw, GDK_WINDOW_XWINDOW(window));
+            }
+         }
+         xftcolor.pixel = widget->style->color->color.pixel;
+         xftcolor.color.red = widget->style->color->color.red;
+         xftcolor.color.green = widget->style->color->color.green;
+         xftcolor.color.blue = widget->style->color->color.blue;
+         xftcolor.color.alpha = 0xffff;
+         XftDrawStringUtf8(xftdraw,
+               &xftcolor,           
+               widget->style->font->font,
+               p_Dw_widget_x_world_to_viewport (widget, widget->allocation.x),
+               p_Dw_widget_y_world_to_viewport (widget, widget->allocation.y),
+               image->alt_text,
+               strlen(image->alt_text));
+#else
+         a_I18n_gdk_draw_string
             (DW_WIDGET_WINDOW (widget), widget->style->font->font,
              widget->style->color->gc,
              p_Dw_widget_x_world_to_viewport (widget, widget->allocation.x),
              p_Dw_widget_y_world_to_viewport (widget, widget->allocation.y)
              + widget->style->font->font->ascent,
              image->alt_text);
+#endif
       }
    }
 
@@ -379,10 +447,12 @@
                                        DwWidget *last_widget,
                                        GdkEventMotion *event)
 {
+   /*
    DwImage *image = DW_IMAGE (widget);
 
    if (image->tooltip)
       a_Dw_tooltip_on_enter (image->tooltip);
+   */
    return FALSE;
 }
 
@@ -429,6 +499,14 @@
       gtk_signal_emit (GTK_OBJECT (widget), image_signals[LINK_PRESSED],
                        image->pressed_link, link_x, link_y, event,
                        &return_val);
+   
+#if 0
+   if (DW_WIDGET(widget)->button_sensitive) {
+      gtk_signal_emit (GTK_OBJECT (widget), image_signals[IMAGE_PRESSED], event);
+      return TRUE;
+   } else
+      return FALSE;
+#endif
 
    return return_val;
 }
diff -Nur dillo-0.8.0/src/dw_image.h dillo-0.8.0.new/src/dw_image.h
--- dillo-0.8.0/src/dw_image.h	2003-10-24 19:45:00.000000000 +0000
+++ dillo-0.8.0.new/src/dw_image.h	2004-10-13 01:13:29.000000000 +0000
@@ -73,6 +73,10 @@
    gboolean (*link_clicked)  (DwImage *page,
                               gint link, gint x, gint y,
                               GdkEventButton *event);
+#if 1
+   void (*image_pressed) (DwImage *page,
+                          GdkEventButton *event);
+#endif
 };
 
 
diff -Nur dillo-0.8.0/src/dw_page.c dillo-0.8.0.new/src/dw_page.c
--- dillo-0.8.0/src/dw_page.c	2004-02-02 15:21:03.000000000 +0000
+++ dillo-0.8.0.new/src/dw_page.c	2004-10-13 01:13:29.000000000 +0000
@@ -19,6 +19,8 @@
 #include <ctype.h>
 #include <string.h>
 #include <stdio.h>
+#include <errno.h>
+#include <iconv.h>
 
 #include <gtk/gtk.h>
 
@@ -29,6 +31,7 @@
 #include "dw_gtk_viewport.h"
 
 #include "prefs.h"
+#include "i18n.h"
 
 #define DEBUG_REWRAP_LEVEL    0
 #define DEBUG_SIZE_LEVEL     10
@@ -204,6 +207,12 @@
 
    DW_WIDGET_SET_FLAGS (page, DW_USES_HINTS);
 
+#ifndef DISABLE_ANTI_ALIAS
+   page->xftdraw = NULL;
+#endif
+   if (strcmp(RENDER_CHARSET, DILLO_CHARSET) == 0)
+	   page->it = (iconv_t)-1;
+   else page->it = iconv_open(RENDER_CHARSET, DILLO_CHARSET);
    page->list_item = FALSE;
    page->inner_padding = 0;
    page->line1_offset = 0;
@@ -358,6 +367,11 @@
       parent_class->destroy. */
    page->num_words = 0;
    page->num_lines = 0;
+#ifndef DISABLE_ANTI_ALIAS
+   if (page->xftdraw) 
+      XftDrawDestroy(page->xftdraw);
+#endif
+   if (page->it != (iconv_t)-1) iconv_close(page->it);
 
    DBG_OBJ_SET_NUM(page, "num_lines", page->num_lines);
 
@@ -1305,6 +1319,10 @@
    GdkWindow *window;
    GdkGC *gc, *hl_gc;
    DwStyleColor *page_bg_color, *word_bg_color;
+#ifndef DISABLE_ANTI_ALIAS
+   XftColor xftcolor;
+   XGlyphInfo info;
+#endif
 
    /* Here's an idea on how to optimize this routine to minimize the number
     * of calls to gdk_draw_string:
@@ -1317,7 +1335,7 @@
    widget = DW_WIDGET (page);
    window = DW_WIDGET_WINDOW (widget);
    page_bg_color = p_Dw_widget_get_bg_color (widget);
-
+  
    x_widget = Dw_page_line_total_x_offset(page,line);
    x_viewport =
       p_Dw_widget_x_world_to_viewport (widget,
@@ -1327,6 +1345,21 @@
       p_Dw_widget_y_world_to_viewport (widget,
                                        widget->allocation.y + y_widget);
    y_viewport_base = y_viewport + line->ascent;
+#ifndef DISABLE_ANTI_ALIAS
+   if (page->xftdraw == 0) {
+      page->xftdraw = XftDrawCreate(GDK_DISPLAY(),
+            GDK_WINDOW_XWINDOW(window),
+            DefaultVisual(GDK_DISPLAY(), DefaultScreen(GDK_DISPLAY())),
+            DefaultColormap(GDK_DISPLAY(), DefaultScreen(GDK_DISPLAY())));
+   }
+ #ifdef XFT_VERSION
+   if (XftDrawDrawable(page->xftdraw) != GDK_WINDOW_XWINDOW(window)) {
+ #else
+   if (page->xftdraw->drawable != GDK_WINDOW_XWINDOW(window)) {
+ #endif
+      XftDrawChange(page->xftdraw, GDK_WINDOW_XWINDOW(window));
+   }
+#endif
 
    for (word_index = line->first_word; word_index < line->last_word;
         word_index++) {
@@ -1335,7 +1368,12 @@
       gc = word->style->color->gc;
 
       switch (word->content.type) {
-      case DW_CONTENT_TEXT:
+      case DW_CONTENT_TEXT: {
+          /* Change from internal charset to render charset. */
+          gchar *word_str = word->content.data.text;
+          if (page->it != (iconv_t)-1)
+			  word->content.data.text = a_I18n_convert_raw(page->it,
+                  word->content.data.text, strlen(word->content.data.text));
          if (word->style->background_color)
             word_bg_color = word->style->background_color;
          else
@@ -1371,9 +1409,24 @@
                                   word->size.ascent + word->size.descent,
                                   FALSE);
 
+#ifndef DISABLE_ANTI_ALIAS
+         /* draw string using Xft */
+         xftcolor.pixel = word->style->color->color.pixel;
+         xftcolor.color.red = word->style->color->color.red;
+         xftcolor.color.green = word->style->color->color.green;
+         xftcolor.color.blue = word->style->color->color.blue;
+         xftcolor.color.alpha = 0xffff;
+         XftDrawStringUtf8(page->xftdraw,
+               &xftcolor,           
+               word->style->font->font,
+               x_viewport, y_viewport_base + diff,
+               word->content.data.text,
+               strlen(word->content.data.text));
+#else
          gdk_draw_string (window, word->style->font->font, gc,
                           x_viewport, y_viewport_base + diff,
                           word->content.data.text);
+#endif
 
          /* underline */
          if (word->style->text_decoration & DW_STYLE_TEXT_DECORATION_UNDERLINE)
@@ -1411,6 +1464,20 @@
             if (word->hl_start[layer] != -1) {
                word_len = strlen (word->content.data.text);
                eff_hl_end = MIN (word_len, word->hl_end[layer]);
+#ifndef DISABLE_ANTI_ALIAS
+               XftTextExtentsUtf8(GDK_DISPLAY(),
+                     word->style->font->font,
+                     word->content.data.text,
+                     word->hl_start[layer],
+                     &info);
+               start_hl = x_viewport + info.xOff;
+               XftTextExtentsUtf8(GDK_DISPLAY(),
+                     word->style->font->font,
+                     word->content.data.text + word->hl_start[layer],
+                     eff_hl_end - word->hl_start[layer],
+                     &info);
+               width_hl = info.xOff;
+#else
                start_hl = x_viewport +
                   gdk_text_width (word->style->font->font,
                                   word->content.data.text,
@@ -1420,6 +1487,7 @@
                                   word->content.data.text
                                   + word->hl_start[layer],
                                   eff_hl_end - word->hl_start[layer]);
+#endif
 
                /* If the space after this word highlighted, and this word
                 * is not the last one in this line, highlight also the
@@ -1442,11 +1510,24 @@
 
                   /* Highlight the text. */
                   hl_gc = word->style->color->inverse_gc;
+#ifndef DISABLE_ANTI_ALIAS
+                  xftcolor.pixel = word->style->color->inverse_color.pixel;
+                  xftcolor.color.red = word->style->color->inverse_color.red;
+                  xftcolor.color.green = word->style->color->inverse_color.green;
+                  xftcolor.color.blue = word->style->color->inverse_color.blue;
+                  xftcolor.color.alpha = 0xffff;
+                  XftDrawStringUtf8(page->xftdraw,
+                        &xftcolor,           
+                        word->style->font->font,
+                        start_hl, y_viewport_base + diff,
+                        word->content.data.text + word->hl_start[layer],
+                        eff_hl_end - word->hl_start[layer]);
+#else
                   gdk_draw_text (window, word->style->font->font, hl_gc,
-                                 start_hl, y_viewport_base + diff,
-                                 word->content.data.text
-                                 + word->hl_start[layer],
-                                 eff_hl_end - word->hl_start[layer]);
+                          start_hl, y_viewport_base + diff,
+                          word->content.data.text + word->hl_start[layer],
+                          eff_hl_end - word->hl_start[layer]);
+#endif
 
                   /* underline and strike-through */
                   if (word->style->text_decoration
@@ -1467,8 +1548,12 @@
                }
             }
          }
+		 if (page->it != (iconv_t)-1) {
+            g_free(word->content.data.text);
+            word->content.data.text = word_str;
+		 }
          break;
-
+      }
       case DW_CONTENT_WIDGET:
          child = word->content.data.widget;
          if (p_Dw_widget_intersect (child, area, &child_area))
@@ -1656,11 +1741,14 @@
 {
    DwIterator *it;
    DwPageLine *line, *last_line;
-   gint32 next_word_start_x, word_start_x, word_x, next_word_x, yfirst, ylast;
+   gint32 next_word_start_x, word_start_x, word_x, next_word_x = 0, yfirst, ylast;
    gint char_pos = 0, word_index, line_index, link;
    DwPageWord *word;
    gboolean found;
    gboolean within_content;
+#ifndef DISABLE_ANTI_ALIAS
+   XGlyphInfo info;
+#endif
 
    DEBUG_MSG (DEBUG_EVENT_LEVEL,
               "Dw_page_send_selection_event: x = %d, y = %d\n", x, y);
@@ -1736,19 +1824,39 @@
                   /* Search the character the mouse pointer is in.
                    * next_word_x is the right side of this character. */
                   char_pos = 0;
-                  while ((next_word_x = word_start_x +
-                          gdk_text_width(word->style->font->font,
-                                         word->content.data.text,
-                                         char_pos))
-                         <= x)
-                     char_pos++;
-
+#ifndef DISABLE_ANTI_ALIAS
+                  while (char_pos < word->content.length){
+                      XftTextExtentsUtf8(GDK_DISPLAY(),
+                              word->style->font->font,
+                              word->content.data.text,
+                              char_pos,
+                              &info);
+                      if(!((next_word_x = word_start_x + info.xOff) <= x))
+                          break;
+                      char_pos++;
+                  }
+                  /* The left side of this character. */
+                  XftTextExtentsUtf8(GDK_DISPLAY(),
+                        word->style->font->font,
+                        word->content.data.text,
+                        char_pos - 1,
+                        &info);
+                  word_x = word_start_x + info.xOff;
+#else
+                  while (char_pos < word->content.length
+                          && (next_word_x = word_start_x +
+                              gdk_text_width(word->style->font->font,
+                                  word->content.data.text,
+                                  char_pos))
+                          <= x)
+                      char_pos++;
                   /* The left side of this character. */
                   word_x =
                      word_start_x + gdk_text_width (word->style->font->font,
                                                     word->content.data.text,
                                                     char_pos - 1);
 
+#endif
                   /* If the mouse pointer is left from the middle, use the left
                    * position, otherwise, use the right one. */
                   if (x <= (word_x + next_word_x) / 2)
@@ -1915,7 +2023,28 @@
 static void Dw_page_calc_text_size  (DwPage *page, char *text, DwStyle *style,
                                      DwRequisition *size)
 {
-   size->width = gdk_string_width (style->font->font, text);
+#ifndef DISABLE_ANTI_ALIAS
+   XGlyphInfo info;
+#endif
+   gint   text_len = strlen(text);
+   gchar *render_str = text;
+   gint   render_len = text_len;
+
+   /* Change from internal charset to render charset. */
+   if (page->it != (iconv_t)-1) {
+	   render_str = a_I18n_convert_raw(page->it, text, text_len);
+	   render_len = strlen(render_str);
+   }
+
+#ifndef DISABLE_ANTI_ALIAS
+   XftTextExtentsUtf8(GDK_DISPLAY(),
+         style->font->font, render_str, render_len, &info);
+   size->width = info.xOff;
+#else
+   size->width = gdk_string_width (style->font->font, render_str);
+#endif
+   if (page->it != (iconv_t)-1) g_free(render_str);
+
    size->ascent = style->font->font->ascent;
    size->descent = style->font->font->descent;
 
@@ -1943,6 +2072,7 @@
                             style);
    word->content.type = DW_CONTENT_TEXT;
    word->content.data.text = text;
+   //word->content.length = text_len;
    Dw_page_word_wrap (page, page->num_words - 1);
 }
 
@@ -2398,6 +2528,9 @@
    DwPageLine *line;
    gint wi, l;
    gint32 diff;
+#ifndef DISABLE_ANTI_ALIAS
+   XGlyphInfo info;
+#endif
 
    line = &page->lines[Dw_page_find_line_of_word (page, ii->pos)];
    word = &page->words[ii->pos];
@@ -2406,10 +2539,19 @@
    if (start == 0)
       diff = 0;
    else {
-      if (word->content.type == DW_CONTENT_TEXT)
+      if (word->content.type == DW_CONTENT_TEXT) {
+#ifndef DISABLE_ANTI_ALIAS
+         XftTextExtentsUtf8(GDK_DISPLAY(),
+                     word->style->font->font,
+                     word->content.data.text,
+                     start,
+                     &info);
+         diff = info.xOff;
+#else
          diff = gdk_text_width (word->style->font->font,
                                 word->content.data.text, start);
-      else
+#endif
+      } else
          diff = word->size.width;
    }
 
@@ -2433,9 +2575,19 @@
          allocation->width = word->size.width;
       else if (end >= l)
          allocation->width = word->size.width + word->eff_space;
-      else
+      else {
+#ifndef DISABLE_ANTI_ALIAS
+         XftTextExtentsUtf8(GDK_DISPLAY(),
+                     word->style->font->font,
+                     word->content.data.text,
+                     end,
+                     &info);
+         allocation->width = info.xOff;
+#else
          allocation->width = gdk_text_width (word->style->font->font,
                                              word->content.data.text, end);
+#endif
+      }
    } else {
       if (end == 1)
          allocation->width = word->size.width;
diff -Nur dillo-0.8.0/src/dw_page.h dillo-0.8.0.new/src/dw_page.h
--- dillo-0.8.0/src/dw_page.h	2003-10-24 19:45:12.000000000 +0000
+++ dillo-0.8.0.new/src/dw_page.h	2004-10-13 01:13:29.000000000 +0000
@@ -5,6 +5,7 @@
 #define __DW_PAGE_H__
 
 #include <gdk/gdk.h>
+#include <iconv.h>
 #include "dw_container.h"
 #include "url.h"
 
@@ -72,7 +73,10 @@
 struct _DwPage
 {
    DwContainer container;
-
+#ifndef DISABLE_ANTI_ALIAS
+   XftDraw *xftdraw;
+#endif
+   iconv_t it;
    /* These fields provide some ad-hoc-functionality, used by sub-classes. */
    gboolean list_item;      /* If TRUE, the first word of the page is treated
                                specially (search in source). */
diff -Nur dillo-0.8.0/src/dw_style.c dillo-0.8.0.new/src/dw_style.c
--- dillo-0.8.0/src/dw_style.c	2003-11-15 21:57:53.000000000 +0000
+++ dillo-0.8.0.new/src/dw_style.c	2004-10-13 01:13:29.000000000 +0000
@@ -11,6 +11,7 @@
 
 #include "dw_style.h"
 #include "dw_widget.h"
+#include "prefs.h"
 
 #include <gdk/gdk.h>
 #include <stdio.h>
@@ -278,56 +279,102 @@
  */
 static void Dw_style_font_realize (DwStyleFont *font, gboolean try_all)
 {
-   char fontname[256], *style_char_1 = NULL, *style_char_2 = NULL;
+   gchar fontname[256], *style_char_1 = NULL, *style_char_2 = NULL;
 
-   switch (font->style) {
-   case DW_STYLE_FONT_STYLE_NORMAL:
-      style_char_1 = style_char_2 = "r";
-      break;
-   case DW_STYLE_FONT_STYLE_ITALIC:
-      style_char_1 = "i";
-      style_char_2 = "o";
-      break;
-   case DW_STYLE_FONT_STYLE_OBLIQUE:
-      style_char_1 = "o";
-      style_char_2 = "i";
-      break;
+#ifndef DISABLE_ANTI_ALIAS
+   if (prefs.limit_font_decoration) {
+       sprintf(fontname, "%s:style=Roman,Regular,Medium:size=%d",
+               font->name, font->size);
+   } else {
+       switch (font->style) {
+       case DW_STYLE_FONT_STYLE_NORMAL:
+          style_char_1 = style_char_2 = "Roman";
+          break;
+       case DW_STYLE_FONT_STYLE_ITALIC:
+          style_char_1 = "Italic";
+          style_char_2 = "Oblique";
+          break;
+       case DW_STYLE_FONT_STYLE_OBLIQUE:
+          style_char_1 = "Oblique";
+          style_char_2 = "Italic";
+          break;
+       }
+       if (font->weight >= 500 && font->style != DW_STYLE_FONT_STYLE_NORMAL)
+           sprintf(fontname, "%s:style=Bold%s,Semibold%s:size=%d",
+                   font->name, style_char_1, style_char_1, font->size);
+       else if (font->style != DW_STYLE_FONT_STYLE_NORMAL)
+           sprintf(fontname, "%s:style=%s,Medium%s:size=%d",
+                   font->name, style_char_1, style_char_1, font->size);
+       else if (font->weight >= 500)
+           sprintf(fontname, "%s:style=Bold,Semibold:size=%d",
+                   font->name, font->size);
+       else
+           sprintf(fontname, "%s:style=Roman,Regular,Medium:size=%d",
+                   font->name, font->size);
    }
+   font->font = XftFontOpenName(GDK_DISPLAY(),
+         DefaultScreen(GDK_DISPLAY()),
+         fontname);
+ 
+   if (font->font) {
+      XGlyphInfo info;
+      XftTextExtentsUtf8(GDK_DISPLAY(), font->font, " ", 1, &info);
+      font->space_width = info.xOff;
+      XftTextExtentsUtf8(GDK_DISPLAY(), font->font, "x", 1, &info);
+      font->x_height = info.y;
+   }
+#else
+   if (prefs.limit_font_decoration) {
+       sprintf (fontname, 
+               "-%s-medium-r-*-*-%d-*-75-75-*-*-*-*",
+               font->name,
+               font->size 
+               );
+   } else {
+       switch (font->style) {
+       case DW_STYLE_FONT_STYLE_NORMAL:
+          style_char_1 = style_char_2 = "r";
+          break;
+       case DW_STYLE_FONT_STYLE_ITALIC:
+          style_char_1 = "i";
+          style_char_2 = "o";
+          break;
+       case DW_STYLE_FONT_STYLE_OBLIQUE:
+          style_char_1 = "o";
+          style_char_2 = "i";
+          break;
+       }
    
-   sprintf (fontname, "-*-%s-%s-%s-*-*-%d-*-75-75-*-*-iso8859-1",
-            font->name,
-            (font->weight >= 500) ? "bold" : "medium",
-            style_char_1, font->size);
-   font->font = gdk_font_load (fontname);
-
-   if (font->font == NULL && font->style != DW_STYLE_FONT_STYLE_NORMAL) {
-      sprintf (fontname, "-*-%s-%s-%s-*-*-%d-*-75-75-*-*-iso8859-1",
+       sprintf (fontname, 
+               "-%s-%s-%s-*-*-%d-*-75-75-*-*-*-*,"
+               "-%s-%s-%s-*-*-%d-*-75-75-*-*-*-*,"
+               "-%s-*-*-*-*-%d-*-75-75-*-*-*-*",
+               font->name,
+               (font->weight >= 500) ? "bold" : "medium",
+               style_char_1,
+               font->size,
                font->name,
                (font->weight >= 500) ? "bold" : "medium",
-               style_char_2, font->size);
-      font->font = gdk_font_load (fontname);
+               style_char_2,
+               font->size,
+               font->name,
+               font->size
+               );
    }
+   font->font = gdk_fontset_load (fontname);
 
    if (try_all) {
-      if (font->font == NULL) {
-         /* Can't load the font - substitute the default instead. */
-         font->font =
-            gdk_font_load
-            ("-adobe-helvetica-medium-r-normal--*-100-*-*-*-*-iso8859-1");
+      if (!font->font) {
+         /* Try any font this size. */
+         sprintf (fontname,
+                 "-*-*-medium-r-*-*-%d-*-*-*-*-*-*-*",
+                 font->size);
+         font->font = gdk_fontset_load(fontname);
       }
-
-      if (font->font == NULL) {
-         /* Try another platform-font that should be available. (iPaq) */
-         font->font =
-            gdk_font_load
-            ("-misc-fixed-medium-r-normal--13-120-75-75-c-80-iso8859-1");
-      }
-
-      if (font->font == NULL) {
-         /* Can't load any suitable font!  */
-         g_warning ("Can't load any ISO8859-1 font!?! :(");
-         font->font =
-            gdk_font_load ("-adobe-helvetica-*-*-*--*-*-*-*-*-*-*-*");
+      if (!font->font) {
+         /* Try all fonts! */
+         g_warning ("Trouble loading fonts!?! :(");
+         font->font = gdk_fontset_load("*");
       }
    }
 
@@ -335,6 +382,7 @@
       font->space_width = gdk_char_width (font->font, ' ');
       font->x_height = gdk_char_height (font->font, 'x');
    }
+#endif
 }
 
 
@@ -474,7 +522,11 @@
 {
    g_hash_table_remove (fonts_table, font);
    g_free (font->name);
-   gdk_font_unref (font->font);
+#ifndef DISABLE_ANTI_ALIAS
+   XftFontClose (GDK_DISPLAY(), font->font);
+#else
+    gdk_font_unref (font->font);
+#endif
    g_free (font);
 }
 
diff -Nur dillo-0.8.0/src/dw_style.h dillo-0.8.0.new/src/dw_style.h
--- dillo-0.8.0/src/dw_style.h	2003-11-15 21:57:54.000000000 +0000
+++ dillo-0.8.0.new/src/dw_style.h	2004-10-13 01:13:29.000000000 +0000
@@ -2,6 +2,13 @@
 #define __DW_STYLE_H__
 
 #include <gdk/gdktypes.h>
+#ifndef DISABLE_ANTI_ALIAS
+   #include <X11/Xlib.h>
+   #include <X11/Xft/Xft.h>
+   #undef Status
+   #include <gdk/gdkx.h>
+#endif
+
 
 #define DW_STYLE_ALIGN_LEFT   1
 #define DW_STYLE_ALIGN_RIGHT  2
@@ -145,6 +152,35 @@
 
 #define DW_STYLE_LENGTH_AUTO           0
 
+#ifndef DISABLE_ANTI_ALIAS
+ #ifndef XFT_VERSION
+  #ifndef XFT_DRAW_N_SRC
+   #define XFT_DRAW_N_SRC      2
+  #endif
+struct _XftDraw {
+    Display         *dpy;
+    Drawable        drawable;
+    Visual          *visual;    /* NULL for bitmaps */
+    Colormap        colormap;
+    Region          clip;
+    Bool            core_set;
+    Bool            render_set;
+    Bool            render_able;
+    struct {
+        Picture         pict;
+        struct {
+            Picture         pict;
+            XRenderColor    color;
+        } src[XFT_DRAW_N_SRC];
+    } render;
+    struct {
+        GC              draw_gc;
+        unsigned long   fg;
+        Font            font;
+    } core;
+};
+ #endif
+#endif
 
 struct _DwStyleBox
 {
@@ -187,10 +223,14 @@
    gint weight;
    DwStyleFontStyle style;
 
-#ifdef USE_TYPE1
-   gint t1fontid;
+#ifndef DISABLE_ANTI_ALIAS
+   XftFont *font;
 #else
-   GdkFont *font;
+   #ifdef USE_TYPE1
+      gint t1fontid;
+   #else
+      GdkFont *font;
+   #endif
 #endif
    gint space_width;
    gint x_height;
diff -Nur dillo-0.8.0/src/dw_table_cell.c dillo-0.8.0.new/src/dw_table_cell.c
--- dillo-0.8.0/src/dw_table_cell.c	2003-04-15 19:20:59.000000000 +0000
+++ dillo-0.8.0.new/src/dw_table_cell.c	2004-10-13 01:13:29.000000000 +0000
@@ -146,6 +146,9 @@
    DwTableCell *cell = DW_TABLE_CELL (aligned_page);
    DwPage *page = DW_PAGE (aligned_page);
    DwPageWord *word;
+#ifndef DISABLE_ANTI_ALIAS
+   XGlyphInfo info;
+#endif
    int i, word_index;
    gint32 w;
 
@@ -167,8 +170,17 @@
       }
    } else {
       word = &page->words[cell->char_word_index];
+#ifndef DISABLE_ANTI_ALIAS
+     XftTextExtentsUtf8(GDK_DISPLAY(),
+           word->style->font->font,
+           word->content.data.text,
+           cell->char_word_pos,
+           &info);
+     w += info.xOff;
+#else
       w += gdk_text_width (word->style->font->font, word->content.data.text,
                            cell->char_word_pos);
+#endif
    }
 
    return w;
diff -Nur dillo-0.8.0/src/dw_tooltip.c dillo-0.8.0.new/src/dw_tooltip.c
--- dillo-0.8.0/src/dw_tooltip.c	2003-11-21 16:44:55.000000000 +0000
+++ dillo-0.8.0.new/src/dw_tooltip.c	2004-10-13 01:13:29.000000000 +0000
@@ -13,6 +13,7 @@
  */
 
 #include <gtk/gtk.h>
+#include "i18n.h"
 #include "dw_tooltip.h"
 
 /* The amount of space around the text, including the border. */
@@ -22,19 +23,22 @@
  * tooltip. */
 #define DIFF 10
 
-static gboolean Dw_tooltip_draw (DwTooltip *tooltip);
+static gint pop_count = 0;
+static gboolean Dw_tooltip_draw  (DwTooltip *tooltip);
 
 /*
- * Create a new tooltip.
+ * Create a new tooltip from DILLO_CHARSET string.
  */
 DwTooltip* a_Dw_tooltip_new (const gchar *text)
 {
    DwTooltip *tooltip;
 
+   pop_count = 0;
+   
    tooltip = g_new (DwTooltip, 1);
    tooltip->window = NULL;
    tooltip->timeout_id = 0;
-   tooltip->text = g_strdup (text);
+   tooltip->text = a_I18n_DW_CHARSET_from_DILLO_CHARSET(text, -1);
    return tooltip;
 }
 
@@ -56,11 +60,15 @@
 void a_Dw_tooltip_on_enter (DwTooltip *tooltip)
 {
    a_Dw_tooltip_on_leave (tooltip);
-   tooltip->timeout_id = gtk_timeout_add (500, (GtkFunction)Dw_tooltip_draw,
+
+   /* Since it is called by switch without knowing why, 
+    * 2 times of the beginning ignore.
+    */
+   if(pop_count > 2)
+      tooltip->timeout_id = gtk_timeout_add (500, (GtkFunction)Dw_tooltip_draw,
                                           tooltip);
 }
 
-
 /*
  * Call this function if the pointer has left the widget/word.
  */
@@ -77,12 +85,17 @@
    }
 }
 
+void a_Dw_tooltip_count_reset ()
+{
+   pop_count = 0;
+}
 
 /*
  * Call this function if the pointer has moved within the widget/word.
  */
 void a_Dw_tooltip_on_motion (DwTooltip *tooltip)
 {
+   pop_count++;
    a_Dw_tooltip_on_enter (tooltip);
 }
 
@@ -147,5 +160,3 @@
    return FALSE;
 }
 
-
-
diff -Nur dillo-0.8.0/src/dw_tooltip.h dillo-0.8.0.new/src/dw_tooltip.h
--- dillo-0.8.0/src/dw_tooltip.h	2001-12-22 20:56:01.000000000 +0000
+++ dillo-0.8.0.new/src/dw_tooltip.h	2004-10-13 01:13:29.000000000 +0000
@@ -19,6 +19,7 @@
 void       a_Dw_tooltip_on_enter  (DwTooltip *tooltip);
 void       a_Dw_tooltip_on_leave  (DwTooltip *tooltip);
 void       a_Dw_tooltip_on_motion (DwTooltip *tooltip);
+void       a_Dw_tooltip_count_reset();
 
 
 #endif /* __DW_TOOLTIP_H__ */
diff -Nur dillo-0.8.0/src/dw_widget.c dillo-0.8.0.new/src/dw_widget.c
--- dillo-0.8.0/src/dw_widget.c	2004-01-05 19:25:46.000000000 +0000
+++ dillo-0.8.0.new/src/dw_widget.c	2004-10-13 01:13:29.000000000 +0000
@@ -22,7 +22,7 @@
 #define DEBUG_SIZE   0
 #define DEBUG_ALLOC  0
 
-/*#define DEBUG_LEVEL 10*/
+/* #define DEBUG_LEVEL 10 */
 #include "debug.h"
 
 static void Dw_widget_init                (DwWidget *widget);
@@ -1340,6 +1340,9 @@
    if (!widget->button_sensitive_set)
       widget->button_sensitive = parent->button_sensitive;
 
+   if (!widget->button_sensitive_set)
+      widget->button_sensitive = parent->button_sensitive;
+
    DBG_OBJ_ASSOC (widget, parent);
 
    if (DW_WIDGET_REALIZED (parent))
diff -Nur dillo-0.8.0/src/dw_widget.h dillo-0.8.0.new/src/dw_widget.h
--- dillo-0.8.0/src/dw_widget.h	2004-01-05 19:25:46.000000000 +0000
+++ dillo-0.8.0.new/src/dw_widget.h	2004-10-13 01:13:29.000000000 +0000
@@ -155,6 +155,7 @@
       char *anchor;
       gint break_space;
    } data;
+   gint length;
 };
 
 struct _DwIterator
@@ -356,6 +357,9 @@
 void    a_Dw_widget_set_button_sensitive (DwWidget *widget,
                                           gboolean button_sensitive);
 
+void    a_Dw_widget_set_button_sensitive (DwWidget *widget,
+                                          gboolean button_sensitive);
+
 DwWidget *a_Dw_widget_get_toplevel  (DwWidget *widget);
 
 void    a_Dw_widget_scroll_to       (DwWidget *widget,
diff -Nur dillo-0.8.0/src/findtext.c dillo-0.8.0.new/src/findtext.c
--- dillo-0.8.0/src/findtext.c	2004-02-02 15:26:38.000000000 +0000
+++ dillo-0.8.0.new/src/findtext.c	2004-10-13 01:13:29.000000000 +0000
@@ -55,6 +55,7 @@
 #include "debug.h"
 #include <string.h>
 #include <ctype.h>
+#include "i18n.h"
 
 /*
  * Searches needle in haystack, according to type:
@@ -300,6 +301,40 @@
 }
 
 
+/* insert a space between words. */
+gchar *Findtext_add_space(gchar *str){
+   char *encStr, *parseStr;
+   int buf_index = 0;
+   int parse_index = 0;
+   int wordnum = 0;
+   int len = strlen(str);
+   if(len == 0)
+      return str;
+   //g_print("SOURCE[%3d]: %s\n",len, str);
+   parseStr = g_malloc0(len * 2);
+   while(buf_index < len){
+      if ((wordnum = a_I18n_mblen(&str[buf_index])) == 0){
+         while(isprint(str[buf_index + wordnum]))
+            wordnum++;
+      }
+      if(wordnum == 0){
+         g_warning("Findtext_add_space() invalid char.\n");
+         //parseStr[parse_index] = str[buf_index];
+         buf_index++;
+      } else {
+         strncpy(&parseStr[parse_index], &str[buf_index], wordnum);
+         parse_index += wordnum;
+         buf_index += wordnum;
+         parseStr[parse_index] = ' ';
+      }
+      parse_index++;
+   }
+   parseStr[parse_index - ((wordnum == 0)?0:1)] = 0;
+   encStr = g_strndup(parseStr,strlen(parseStr));
+   //g_print("PARSE[%3d]: %s\n",strlen(parseStr), parseStr);
+   g_free(parseStr);
+   return encStr;
+}
 
 FindtextResult a_Findtext_search (FindtextState *state,
                                   gchar *str,
@@ -308,6 +343,7 @@
    int i;
    gboolean new_key = FALSE, was_highlighted = FALSE, first_trial;
    FindtextResult result2;
+   char *encStr;
 
    if (state->widget == NULL)
       return FINDTEXT_NOT_FOUND;
@@ -326,20 +362,22 @@
       state->hl_iterator = NULL;
    }
 
+   encStr = Findtext_add_space(str);
+
    /* If the key (or the widget) changes (including case sensitivity),
       the search is started from the beginning. */
    if (state->keystr == NULL || state->case_sens != case_sens ||
-       strcmp(state->keystr, str) != 0) {
+       strcmp(state->keystr, encStr) != 0) {
       new_key = TRUE;
 
       if (state->keystr != NULL)
          g_free (state->keystr);
-      state->keystr = g_strdup (str);
+      state->keystr = g_strdup (encStr);
       state->case_sens = case_sens;
 
       if (state->key != NULL)
          Findtext_key_destroy (state->key);
-      state->key = Findtext_key_new (str, case_sens);
+      state->key = Findtext_key_new (encStr, case_sens);
 
       if (state->iterator)
          a_Dw_word_iterator_free (state->iterator);
@@ -416,6 +454,7 @@
       g_assert (result2 == FINDTEXT_SUCCESS);
       return FINDTEXT_RESTART;
    }
+   g_free(encStr);
 }
 
 /*
@@ -441,3 +480,5 @@
       state->hl_iterator = NULL;
    }
 }
+
+/* vim: set ts=3 sw=3 sts=3 expandtab:*/
diff -Nur dillo-0.8.0/src/gtkframeset.c dillo-0.8.0.new/src/gtkframeset.c
--- dillo-0.8.0/src/gtkframeset.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/src/gtkframeset.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,1304 @@
+/*
+ * File: gtkframeset.c
+ * Copyright (C) 2003 Frank de Lange <frank@unternet.org>
+ *
+ *   a frameset widget for GTK - The GIMP Toolkit
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+
+#include "gtkframeset.h"
+#include <stdlib.h>              /* for strtod() */
+#include <ctype.h>               /* for isspace() */
+#include <string.h>              /* for strpbrk() */
+//#include <stdlib.h>              /* for abs() */
+
+
+#define DEBUG_ALLOC 10
+#define DEBUG_EVENT 10
+/* #define DEBUG_LEVEL 10 */
+#include "debug.h"
+
+/* child args */
+enum
+{
+  CHILD_ARG_0,
+  CHILD_ARG_ROW_ATTACH,
+  CHILD_ARG_COL_ATTACH,
+  CHILD_ARG_X_PADDING,
+  CHILD_ARG_Y_PADDING,
+  CHILD_ARG_BORDER,
+  CHILD_ARG_NORESIZE
+};
+  
+/* declarations */
+static void gtk_frameset_class_init          (GtkFramesetClass  *klass);
+static void gtk_frameset_init	             (GtkFrameset       *frameset);
+static void gtk_frameset_finalize	     (GtkObject	        *object);
+static void gtk_frameset_size_allocate       (GtkWidget	        *widget,
+					      GtkAllocation     *allocation);
+static void gtk_frameset_map	             (GtkWidget	        *widget);
+static void gtk_frameset_unmap	             (GtkWidget	        *widget);
+static void gtk_frameset_draw	             (GtkWidget	        *widget,
+					      GdkRectangle      *area);
+static gint gtk_frameset_expose	             (GtkWidget	        *widget,
+					      GdkEventExpose    *event);
+static void gtk_frameset_set_child_arg       (GtkContainer      *container,
+					      GtkWidget         *child,
+					      GtkArg            *arg,
+					      guint              arg_id);
+static void gtk_frameset_get_child_arg       (GtkContainer      *container,
+					      GtkWidget         *child,
+					      GtkArg            *arg,
+					      guint              arg_id);
+static GtkType gtk_frameset_child_type       (GtkContainer      *container);
+static void gtk_frameset_add	             (GtkContainer      *container,
+					      GtkWidget	        *widget);
+static void gtk_frameset_remove	             (GtkContainer      *container,
+					      GtkWidget	        *widget);
+static void gtk_frameset_forall	             (GtkContainer      *container,
+					      gboolean	         include_internals,
+					      GtkCallback        callback,
+					      gpointer	         callback_data);
+static void gtk_frameset_realize             (GtkWidget         *widget);
+static void gtk_frameset_unrealize           (GtkWidget         *widget);
+static gint gtk_frameset_button_press        (GtkWidget         *widget,
+					      GdkEventButton    *event);
+static gint gtk_frameset_button_release      (GtkWidget         *widget,
+					      GdkEventButton    *event);
+static gint gtk_frameset_motion              (GtkWidget         *widget,
+					      GdkEventMotion    *event);
+static gint gtk_frameset_enter               (GtkWidget         *widget,
+					      GdkEventCrossing  *event);
+static gint gtk_frameset_leave               (GtkWidget         *widget,
+					      GdkEventCrossing  *event);
+
+/* private functions */
+static void gtk_frameset_size_allocate_init (GtkFrameset        *frameset);
+static void gtk_frameset_size_allocate_pass1(GtkFrameset        *frameset);
+static GSList *gtk_frameset_get_multi_length(const gchar        *attr);
+static void gtk_frameset_calculate_lengths  (GtkFrameset        *frameset);
+static gint gtk_frameset_set_resize_rowcol  (GtkWidget          *widget,
+					     guint               x,
+					     guint               y);
+
+static GtkContainerClass *parent_class = NULL;
+
+/* standard GTK function */
+GtkType
+gtk_frameset_get_type (void)
+{
+  static GtkType frameset_type = 0;
+  
+  if (!frameset_type)
+    {
+      static const GtkTypeInfo frameset_info =
+      {
+	"GtkFrameset",
+	sizeof (GtkFrameset),
+	sizeof (GtkFramesetClass),
+	(GtkClassInitFunc) gtk_frameset_class_init,
+	(GtkObjectInitFunc) gtk_frameset_init,
+        /* reserved_1 */ NULL,
+	/* reserved_2 */ NULL,
+	(GtkClassInitFunc) NULL,
+      };
+      
+      frameset_type = gtk_type_unique (gtk_container_get_type (), &frameset_info);
+    }
+  
+  return frameset_type;
+}
+
+/* standard GTK function */
+static void
+gtk_frameset_class_init (GtkFramesetClass *class)
+{
+  GtkObjectClass *object_class;
+  GtkWidgetClass *widget_class;
+  GtkContainerClass *container_class;
+  
+  object_class = (GtkObjectClass*) class;
+  widget_class = (GtkWidgetClass*) class;
+  container_class = (GtkContainerClass*) class;
+  
+  parent_class = gtk_type_class (gtk_container_get_type ());
+  
+  gtk_container_add_child_arg_type ("GtkFrameset::row_attach", GTK_TYPE_UINT, GTK_ARG_READWRITE, CHILD_ARG_ROW_ATTACH);
+  gtk_container_add_child_arg_type ("GtkFrameset::col_attach", GTK_TYPE_UINT, GTK_ARG_READWRITE, CHILD_ARG_COL_ATTACH);
+  gtk_container_add_child_arg_type ("GtkFrameset::x_padding", GTK_TYPE_UINT, GTK_ARG_READWRITE, CHILD_ARG_X_PADDING);
+  gtk_container_add_child_arg_type ("GtkFrameset::y_padding", GTK_TYPE_UINT, GTK_ARG_READWRITE, CHILD_ARG_Y_PADDING);
+  gtk_container_add_child_arg_type ("GtkFrameset::border", GTK_TYPE_BOOL, GTK_ARG_READWRITE, CHILD_ARG_BORDER);
+  gtk_container_add_child_arg_type ("GtkFrameset::noresize", GTK_TYPE_BOOL, GTK_ARG_READWRITE, CHILD_ARG_NORESIZE);
+
+  object_class->finalize = gtk_frameset_finalize;
+  
+  widget_class->size_allocate = gtk_frameset_size_allocate;
+  widget_class->map = gtk_frameset_map;
+  widget_class->unmap = gtk_frameset_unmap;
+  widget_class->draw = gtk_frameset_draw;
+  widget_class->expose_event = gtk_frameset_expose;
+  widget_class->realize = gtk_frameset_realize;
+  widget_class->unrealize = gtk_frameset_unrealize;
+  widget_class->button_press_event = gtk_frameset_button_press;
+  widget_class->button_release_event = gtk_frameset_button_release;
+  widget_class->motion_notify_event = gtk_frameset_motion;
+  widget_class->enter_notify_event = gtk_frameset_enter;
+  widget_class->leave_notify_event = gtk_frameset_leave;
+  
+  container_class->add = gtk_frameset_add;
+  container_class->remove = gtk_frameset_remove;
+  container_class->forall = gtk_frameset_forall;
+  container_class->child_type = gtk_frameset_child_type;
+  container_class->set_child_arg = gtk_frameset_set_child_arg;
+  container_class->get_child_arg = gtk_frameset_get_child_arg;
+}
+
+/* standard GTK function */
+static GtkType
+gtk_frameset_child_type (GtkContainer   *container)
+{
+  return GTK_TYPE_WIDGET;
+}
+
+/* standard GTK function */
+static void
+gtk_frameset_set_child_arg (GtkContainer   *container,
+			    GtkWidget      *child,
+			    GtkArg         *arg,
+			    guint           arg_id)
+{
+  GtkFrameset *frameset;
+  GtkFramesetChild *frameset_child;
+  GList *list;
+
+  frameset = GTK_FRAMESET (container);
+  frameset_child = NULL;
+  for (list = frameset->children; list; list = list->next)
+    {
+      frameset_child = list->data;
+
+      if (frameset_child->widget == child)
+	break;
+    }
+  if (!list)
+    return;
+
+  switch (arg_id)
+    {
+    case CHILD_ARG_ROW_ATTACH:
+      frameset_child->row_attach = GTK_VALUE_UINT (*arg);
+      break;
+    case CHILD_ARG_COL_ATTACH:
+      frameset_child->col_attach = GTK_VALUE_UINT (*arg);
+      break;
+    case CHILD_ARG_X_PADDING:
+      frameset_child->xpadding = GTK_VALUE_UINT (*arg);
+      break;
+    case CHILD_ARG_Y_PADDING:
+      frameset_child->ypadding = GTK_VALUE_UINT (*arg);
+      break;
+    case CHILD_ARG_BORDER:
+      frameset_child->border = GTK_VALUE_BOOL (*arg);
+      /* only SET this value (it is set to FALSE by default), otherwise
+       * border frames followed by noborder frames will lose their border
+       * 
+       * This feature can also be provided by manipulating the child widget's
+       * border directly. I have tested this and it works. I might use it in a later
+       * version of GtkFrameset */
+      if(GTK_VALUE_BOOL(*arg)) {
+	if(frameset_child->row_attach > 0)
+	  /* set top border */
+	  frameset->rows[frameset_child->row_attach - 1].border = GTK_VALUE_BOOL (*arg);
+	frameset->rows[frameset_child->row_attach].border = GTK_VALUE_BOOL (*arg);
+	if(frameset_child->col_attach > 0)
+	  /* set left border */
+	  frameset->cols[frameset_child->col_attach - 1].border = GTK_VALUE_BOOL (*arg);
+	frameset->cols[frameset_child->col_attach].border = GTK_VALUE_BOOL (*arg);
+      }
+      break;
+    case CHILD_ARG_NORESIZE:
+      frameset_child->noresize = GTK_VALUE_BOOL (*arg);
+      /* only SET this value (it is set to FALSE by default), otherwise
+       * noresize frames followed by resizable frames will be resizable as
+       * well through the resizable frames' left/top edge */
+      if(GTK_VALUE_BOOL(*arg)) {
+	if(frameset_child->row_attach + 1 < frameset->nrows)
+	  /* make lower edge unresizable */
+	  frameset->rows[frameset_child->row_attach + 1].noresize = GTK_VALUE_BOOL (*arg);
+	frameset->rows[frameset_child->row_attach].noresize = GTK_VALUE_BOOL (*arg);
+	if(frameset_child->col_attach + 1 < frameset->ncols)
+	  /* make right edge unresizable */
+	  frameset->cols[frameset_child->col_attach + 1].noresize = GTK_VALUE_BOOL (*arg);
+	frameset->cols[frameset_child->col_attach].noresize = GTK_VALUE_BOOL (*arg);
+      }
+      break;
+    default:
+      break;
+    }
+  if (GTK_WIDGET_VISIBLE (child) && GTK_WIDGET_VISIBLE (frameset))
+    gtk_widget_queue_resize (child);
+}
+
+/* standard GTK function */
+static void
+gtk_frameset_get_child_arg (GtkContainer   *container,
+			 GtkWidget      *child,
+			 GtkArg         *arg,
+			 guint           arg_id)
+{
+  GtkFrameset *frameset;
+  GtkFramesetChild *frameset_child;
+  GList *list;
+
+  frameset = GTK_FRAMESET (container);
+  frameset_child = NULL;
+  for (list = frameset->children; list; list = list->next)
+    {
+      frameset_child = list->data;
+
+      if (frameset_child->widget == child)
+	break;
+    }
+  if (!list)
+    return;
+
+  switch (arg_id)
+    {
+    case CHILD_ARG_ROW_ATTACH:
+      GTK_VALUE_UINT (*arg) = frameset_child->row_attach;
+      break;
+    case CHILD_ARG_COL_ATTACH:
+      GTK_VALUE_UINT (*arg) = frameset_child->col_attach;
+      break;
+    case CHILD_ARG_X_PADDING:
+      GTK_VALUE_UINT (*arg) = frameset_child->xpadding;
+      break;
+    case CHILD_ARG_Y_PADDING:
+      GTK_VALUE_UINT (*arg) = frameset_child->ypadding;
+      break;
+    case CHILD_ARG_BORDER:
+      GTK_VALUE_BOOL (*arg) = frameset_child->border;
+      break;
+    case CHILD_ARG_NORESIZE:
+      GTK_VALUE_BOOL (*arg) = frameset_child->noresize;
+      break;
+    default:
+      arg->type = GTK_TYPE_INVALID;
+      break;
+    }
+}
+
+/*
+ * Standard GTK function
+ */
+static void
+gtk_frameset_realize (GtkWidget *widget)
+{
+  GtkFrameset *frameset = GTK_FRAMESET(widget);
+  GdkWindowAttr attributes;
+  gint attributes_mask;
+
+  GTK_WIDGET_SET_FLAGS (widget, GTK_REALIZED);
+  
+  attributes.x = widget->allocation.x;
+  attributes.y = widget->allocation.y;
+  attributes.width = widget->allocation.width;
+  attributes.height = widget->allocation.height;
+  attributes.window_type = GDK_WINDOW_CHILD;
+  attributes.wclass = GDK_INPUT_OUTPUT;
+  attributes.visual = gtk_widget_get_visual (widget);
+  attributes.colormap = gtk_widget_get_colormap (widget);
+  attributes.event_mask = gtk_widget_get_events (widget) | GDK_EXPOSURE_MASK;
+  attributes_mask = (GDK_WA_X | GDK_WA_Y | GDK_WA_VISUAL | GDK_WA_COLORMAP);
+  attributes.event_mask |= (GDK_BUTTON_PRESS_MASK |
+			    GDK_BUTTON_RELEASE_MASK |
+			    GDK_POINTER_MOTION_MASK |
+			    GDK_POINTER_MOTION_HINT_MASK |
+			    GDK_ENTER_NOTIFY_MASK |
+			    GDK_LEAVE_NOTIFY_MASK);
+  
+  widget->window = gdk_window_new (gtk_widget_get_parent_window (widget),
+				   &attributes, attributes_mask);
+
+  frameset->cursor_rowcol = gdk_cursor_new(GDK_FLEUR);
+  frameset->cursor_row = gdk_cursor_new(GDK_SB_V_DOUBLE_ARROW);
+  frameset->cursor_col = gdk_cursor_new(GDK_SB_H_DOUBLE_ARROW);
+
+  gdk_window_set_user_data (widget->window, frameset);
+  widget->style = gtk_style_attach (widget->style, widget->window);
+  gtk_style_set_background (widget->style, widget->window, GTK_STATE_NORMAL);
+  gdk_window_set_back_pixmap (widget->window, NULL, TRUE);
+}
+
+/*
+ * standard GTK function
+ */
+static void
+gtk_frameset_unrealize (GtkWidget *widget)
+{
+  GtkFrameset *frameset = GTK_FRAMESET(widget);
+
+  gdk_cursor_destroy(frameset->cursor_rowcol);
+  gdk_cursor_destroy(frameset->cursor_row);
+  gdk_cursor_destroy(frameset->cursor_col);
+
+  GTK_WIDGET_CLASS(parent_class)->unrealize (widget);
+}
+  
+/* standard GTK function */
+static void
+gtk_frameset_init (GtkFrameset *frameset)
+{
+  GTK_WIDGET_UNSET_FLAGS (frameset, GTK_NO_WINDOW);
+
+  frameset->children = NULL;
+  frameset->rows = NULL;
+  frameset->cols = NULL;
+  frameset->nrows = 0;
+  frameset->ncols = 0;
+  frameset->resize_row = RESIZE_NONE;
+  frameset->resize_col = RESIZE_NONE;
+  frameset->in_drag = FALSE;
+  frameset->cursor_rowcol = NULL;
+  frameset->cursor_row = NULL;
+  frameset->cursor_col = NULL;
+
+  gtk_frameset_resize (frameset, "*", "*");
+}
+
+/*
+ * standard GTK function
+ *
+ * resize frameset. It is only possible to enlarge the
+ * frameset (or change dimensions while keeping the same
+ * size) as reducing the size could orphan children.
+ */
+void
+gtk_frameset_resize (GtkFrameset *frameset,
+		     gchar *row_multilengths,
+		     gchar *col_multilengths)
+{
+  gint n_rows, n_cols, n;
+  GSList *rows, *cols;
+  gfloat total_percentage, total_relative;
+  gfloat row_per_relative, row_per_percent;
+  gfloat col_per_relative, col_per_percent;
+
+  g_return_if_fail (frameset != NULL);
+  g_return_if_fail (GTK_IS_FRAMESET(frameset));
+  g_return_if_fail (row_multilengths || col_multilengths);
+
+  DEBUG_MSG(DEBUG_EVENT, "gtk_frameset_resize(%d, %s, %s)\n", (gint) frameset, row_multilengths, col_multilengths);
+  
+  rows = gtk_frameset_get_multi_length(row_multilengths);
+  cols = gtk_frameset_get_multi_length(col_multilengths);
+
+  /* (older versions of) compiler happiness */
+  row_per_relative = 0;
+  row_per_percent = 0;
+  col_per_relative = 0;
+  col_per_percent = 0;
+
+  n_rows = g_slist_length(rows);
+  n_cols = g_slist_length(cols);
+
+   /* calculate row and column dimensions. These calculations are slightly hairy...
+    * The theory goes as follows:
+    * 
+    * Starting point is the frameset width and height. 
+    * First come frames with absolute dimensions. No frame can be bigger than the frameset,
+    * so checks are performed to make sure that absolute frame dimensions do not
+    * exceed frameset dimensions. When the total number of frames with absolute dimensions
+    * exceeds the frameset dimensions, the available space is divided by ratio to those frames.
+    * In case there are only absolute dimensioned frames, available space is divided by ratio to
+    * these frames and the absolute dimensions are transformed into percentual dimensions.
+    *
+    * Next come frames with percentual dimensions. They get to divide the remaining space after
+    * all absolute dimensions have been allocated. If the total of all percentual dimensions adds
+    * up to more than 100, the calculation is normalised to 100%.
+    *
+    * Last come frames with relative dimensions. They get to divide the remaining space after
+    * all absolute and percentual dimensions have been allocated. All available space is divided
+    * by ratio to relative weights and allocated to frames. In the second stage, relative dimensions
+    * are transformed into percentual dimensions so the frameset ends up having only absolute (pixel)
+    * and percentual dimensions.
+    *
+    * The calculations are performed in two stages. In the first (aggregation) stage, the total weight of
+    * absolute, percentual and relative dimensions is calculated. In the second (normalisation) stage, relative
+    * dimensions are transformed into percentual dimensions. The actual calculation of pixel dimensions
+    * is performed in the callback function as it depends on information about the current size of the
+    * frameset widget.
+    *
+    * Can this be optimised? Sure, but... later...
+    */
+
+  if(n_rows >= frameset->nrows)
+    {
+      frameset->nrows = n_rows;
+      frameset->rows = g_realloc (frameset->rows, frameset->nrows * sizeof (GtkFramesetRowCol));
+
+      frameset->row_total_absolute = 0;
+      total_percentage = 0;
+      total_relative = 0;
+      
+      for(n = 0; n < frameset->nrows; n++) {
+	frameset->rows[n].length = GPOINTER_TO_INT(g_slist_nth_data(rows, n));
+	frameset->rows[n].noresize = FALSE;
+	frameset->rows[n].border = FALSE;
+	if(LENGTH_IS_RELATIVE(frameset->rows[n].length))
+	  (LENGTH_GET_RELATIVE(frameset->rows[n].length) ?
+	   total_relative += LENGTH_GET_RELATIVE(frameset->rows[n].length) :
+	   total_relative++);
+	else if(LENGTH_IS_PERCENTAGE(frameset->rows[n].length))
+	  total_percentage += LENGTH_GET_PERCENTAGE(frameset->rows[n].length);
+	else if(LENGTH_IS_ABSOLUTE(frameset->rows[n].length)) {
+	  frameset->row_total_absolute += LENGTH_GET_ABSOLUTE(frameset->rows[n].length);
+	}
+      }
+      
+      if((total_percentage == 0) && (total_relative == 0)) {
+	for(n = 0; n < frameset->nrows; n++)
+	  if(LENGTH_IS_ABSOLUTE(frameset->rows[n].length))
+	    frameset->rows[n].length =
+	      LENGTH_CREATE_PERCENTAGE((gfloat) LENGTH_GET_ABSOLUTE(frameset->rows[n].length) /
+				       frameset->row_total_absolute);
+	frameset->row_total_absolute = 0;
+	row_per_percent = 1;
+      } else if(total_percentage < 1) {
+	row_per_relative = (gfloat) (1 - total_percentage) / total_relative;
+	row_per_percent = (gfloat) (total_relative > 0 ? 1 : 1.0 / total_percentage);
+      } else {
+	row_per_percent = (gfloat) (1 / total_percentage);
+	row_per_relative = 0;
+      }
+    }
+
+  if(n_cols >= frameset->ncols)
+    {
+      frameset->ncols = n_cols;
+      frameset->cols = g_realloc (frameset->cols, frameset->ncols * sizeof (GtkFramesetRowCol));
+      frameset->col_total_absolute = 0;
+      total_percentage = 0;
+      total_relative = 0;
+      
+      for(n = 0; n < frameset->ncols; n++) {
+	frameset->cols[n].length = GPOINTER_TO_INT(g_slist_nth_data(cols, n));
+	frameset->cols[n].noresize = FALSE;
+	frameset->cols[n].border = FALSE;
+	if(LENGTH_IS_RELATIVE(frameset->cols[n].length))
+	  (LENGTH_GET_RELATIVE(frameset->cols[n].length) ?
+	   total_relative += LENGTH_GET_RELATIVE(frameset->cols[n].length) :
+	   total_relative++);
+	else if(LENGTH_IS_PERCENTAGE(frameset->cols[n].length))
+	  total_percentage += LENGTH_GET_PERCENTAGE(frameset->cols[n].length);
+	else if(LENGTH_IS_ABSOLUTE(frameset->cols[n].length)) {
+	  frameset->col_total_absolute += LENGTH_GET_ABSOLUTE(frameset->cols[n].length);
+	}
+      }
+
+      /* normalize values */
+      if((total_percentage == 0) && (total_relative == 0)) {
+	for(n = 0; n < frameset->ncols; n++)
+	  if(LENGTH_IS_ABSOLUTE(frameset->cols[n].length))
+	    frameset->cols[n].length =
+	      LENGTH_CREATE_PERCENTAGE((gfloat) LENGTH_GET_ABSOLUTE(frameset->cols[n].length) /
+				       frameset->col_total_absolute);
+	frameset->col_total_absolute = 0;
+	col_per_percent = 1;
+	col_per_relative = 0;
+      } else if(total_percentage < 1) {
+	col_per_relative = (gfloat) (1 - total_percentage) / total_relative;
+	col_per_percent = (gfloat) (total_relative > 0 ? 1 : 1.0 / total_percentage);
+      } else {
+	col_per_percent = (gfloat) (1 / total_percentage);
+	col_per_relative = 0;
+      }
+    }
+
+  /* now, calculate actual width/height distribution */
+  if(frameset->nrows > 1) {
+     for(n_rows = 0; n_rows < frameset->nrows; n_rows++) {
+       if(LENGTH_IS_RELATIVE(frameset->rows[n_rows].length))
+	 frameset->rows[n_rows].length = 
+	   LENGTH_CREATE_PERCENTAGE((LENGTH_GET_RELATIVE(frameset->rows[n_rows].length) ?
+				     (LENGTH_GET_RELATIVE(frameset->rows[n_rows].length) * row_per_relative) :
+				     row_per_relative));
+       else if(LENGTH_IS_PERCENTAGE(frameset->rows[n_rows].length))
+	 frameset->rows[n_rows].length =
+	   LENGTH_CREATE_PERCENTAGE((LENGTH_GET_PERCENTAGE(frameset->rows[n_rows].length) * row_per_percent));
+     }
+  } else
+    frameset->rows[0].length = LENGTH_CREATE_PERCENTAGE(1);
+
+  if(frameset->ncols > 1) {
+     for(n_cols = 0; n_cols < frameset->ncols; n_cols++) {
+       if(LENGTH_IS_RELATIVE(frameset->cols[n_cols].length))
+	 frameset->cols[n_cols].length = 
+	   LENGTH_CREATE_PERCENTAGE((LENGTH_GET_RELATIVE(frameset->cols[n_cols].length) ?
+				     (LENGTH_GET_RELATIVE(frameset->cols[n_cols].length) * col_per_relative) :
+				     col_per_relative));
+       else if(LENGTH_IS_PERCENTAGE(frameset->cols[n_cols].length))
+	 frameset->cols[n_cols].length =
+	   LENGTH_CREATE_PERCENTAGE(LENGTH_GET_PERCENTAGE(frameset->cols[n_cols].length) * col_per_percent);
+     }
+  } else
+    frameset->cols[0].length = LENGTH_CREATE_PERCENTAGE(1);
+
+  g_slist_free(rows);
+  g_slist_free(cols);
+}
+
+/* standard GTK function */
+GtkWidget*
+gtk_frameset_new (gchar	*row_multilengths,
+		  gchar	*col_multilengths)
+{
+  GtkFrameset *frameset;
+
+  if (!row_multilengths)
+    row_multilengths = "*";
+  if (!col_multilengths)
+    col_multilengths = "*";
+  
+  frameset = gtk_type_new (gtk_frameset_get_type ());
+
+  DEBUG_MSG(DEBUG_EVENT, "/*\n");
+
+  gtk_frameset_resize(frameset, row_multilengths, col_multilengths);
+
+  DEBUG_MSG(DEBUG_EVENT, " * NEW frameset: %d\n", (gint) frameset);
+  DEBUG_MSG(DEBUG_EVENT, " *               %d rows, %d cols\n", frameset->nrows, frameset->ncols);
+  DEBUG_MSG(DEBUG_EVENT, " */\n");
+  
+  return GTK_WIDGET (frameset);
+}
+
+/* standard GTK function */
+void
+gtk_frameset_attach (GtkFrameset	  *frameset,
+		     GtkWidget	          *child,
+		     guint		   row_attach,
+		     guint		   col_attach,
+		     guint                 xpadding,
+		     guint                 ypadding,
+		     gboolean              border,
+		     gboolean              noresize)
+{
+  GtkFramesetChild *frameset_child;
+  
+  g_return_if_fail (frameset != NULL);
+  g_return_if_fail (GTK_IS_FRAMESET (frameset));
+  g_return_if_fail (child != NULL);
+  g_return_if_fail (GTK_IS_WIDGET (child));
+  g_return_if_fail (child->parent == NULL);
+  g_return_if_fail (col_attach < frameset->ncols);
+  g_return_if_fail (row_attach < frameset->nrows);
+
+  DEBUG_MSG(DEBUG_EVENT, "gtk_frameset_attach(%d, %d, %d, %d, %d, %d, %d, %d)\n",
+	    (gint) frameset, (gint) child, row_attach, col_attach,
+	    xpadding, ypadding, border, noresize);
+  
+  frameset_child = g_new (GtkFramesetChild, 1);
+  frameset_child->widget = child;
+  frameset_child->row_attach = row_attach;
+  frameset_child->col_attach = col_attach;
+  frameset_child->xpadding = xpadding;
+  frameset_child->ypadding = ypadding;
+  frameset_child->border = border;
+  frameset_child->noresize = noresize;
+  
+  frameset->children = g_list_prepend (frameset->children, frameset_child);
+  
+  gtk_widget_set_parent (child, GTK_WIDGET (frameset));
+  
+  if (GTK_WIDGET_REALIZED (child->parent))
+    gtk_widget_realize (child);
+
+  if (GTK_WIDGET_VISIBLE (child->parent) && GTK_WIDGET_VISIBLE (child))
+    {
+      if (GTK_WIDGET_MAPPED (child->parent))
+	gtk_widget_map (child);
+      
+      gtk_widget_queue_resize (child);
+    }
+}
+
+/*
+ * Standard GTK function
+ *
+ * add a widget (frame) to the frameset. The widget
+ * will be put in the current_frame (which will
+ * be increased in the process)
+ */
+static void
+gtk_frameset_add (GtkContainer *frameset,
+		  GtkWidget    *widget)
+{
+  guint row, col;
+
+  /* is there space left in the frameset for this frame? */
+  if (GTK_FRAMESET(frameset)->current_frame >= 
+      (GTK_FRAMESET(frameset)->nrows * GTK_FRAMESET(frameset)->ncols)) {
+    DEBUG_MSG(DEBUG_EVENT, "No space in frameset for frame\n");
+    return;
+  }
+  
+  /* calculate row and column for frame */
+  col = GTK_FRAMESET(frameset)->current_frame % GTK_FRAMESET(frameset)->ncols;
+  row = GTK_FRAMESET(frameset)->current_frame / GTK_FRAMESET(frameset)->ncols;
+  
+  DEBUG_MSG(DEBUG_EVENT, "NEW FRAME in frameset %d\n", (gint) frameset);
+  DEBUG_MSG(DEBUG_EVENT, "      ROW %d COL %d\n", row, col);
+  
+  gtk_frameset_attach(GTK_FRAMESET(frameset), /* the frameset widget */
+		      widget,                 /* the child widget */
+		      row,                    /* row to attach to */
+		      col,                    /* column to attach to */
+		      0,                      /* marginwidth */
+		      0,                      /* marginheight */
+		      FALSE,                  /* border */
+		      FALSE);                 /* noresize */
+
+  (GTK_FRAMESET(frameset)->current_frame)++;
+}
+
+/* standard GTK function */
+static void
+gtk_frameset_remove (GtkContainer *container,
+		     GtkWidget    *widget)
+{
+  GtkFrameset *frameset;
+  GtkFramesetChild *child;
+  GList *children;
+  
+  g_return_if_fail (container != NULL);
+  g_return_if_fail (GTK_IS_FRAMESET (container));
+  g_return_if_fail (widget != NULL);
+  
+  frameset = GTK_FRAMESET (container);
+  children = frameset->children;
+  
+  while (children)
+    {
+      child = children->data;
+      children = children->next;
+      
+      if (child->widget == widget)
+	{
+	  gboolean was_visible = GTK_WIDGET_VISIBLE (widget);
+	  
+	  gtk_widget_unparent (widget);
+	  
+	  frameset->children = g_list_remove (frameset->children, child);
+	  g_free (child);
+	  
+	  if (was_visible && GTK_WIDGET_VISIBLE (container))
+	    gtk_widget_queue_resize (GTK_WIDGET (container));
+	  break;
+	}
+    }
+}
+
+/* standard GTK function */
+static void
+gtk_frameset_forall (GtkContainer *container,
+		  gboolean	include_internals,
+		  GtkCallback	callback,
+		  gpointer	callback_data)
+{
+  GtkFrameset *frameset;
+  GtkFramesetChild *child;
+  GList *children;
+  
+  g_return_if_fail (container != NULL);
+  g_return_if_fail (GTK_IS_FRAMESET (container));
+  g_return_if_fail (callback != NULL);
+  
+  frameset = GTK_FRAMESET (container);
+  children = frameset->children;
+  
+  while (children)
+    {
+      child = children->data;
+      children = children->next;
+      
+      (* callback) (child->widget, callback_data);
+    }
+}
+
+/* standard GTK function */
+/* standard GTK function */
+static void
+gtk_frameset_finalize (GtkObject *object)
+{
+  GtkFrameset *frameset;
+  
+  g_return_if_fail (object != NULL);
+  g_return_if_fail (GTK_IS_FRAMESET (object));
+  
+  frameset = GTK_FRAMESET (object);
+  
+  g_free (frameset->rows);
+  g_free (frameset->cols);
+  
+  (* GTK_OBJECT_CLASS (parent_class)->finalize) (object);
+}
+
+/* standard GTK function */
+static void
+gtk_frameset_map (GtkWidget *widget)
+{
+  GtkFrameset *frameset;
+  GtkFramesetChild *child;
+  GList *children;
+  
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_FRAMESET (widget));
+  
+  frameset = GTK_FRAMESET (widget);
+  GTK_WIDGET_SET_FLAGS (frameset, GTK_MAPPED);
+  
+  children = frameset->children;
+  while (children)
+    {
+      child = children->data;
+      children = children->next;
+      
+      if (GTK_WIDGET_VISIBLE (child->widget) &&
+	  !GTK_WIDGET_MAPPED (child->widget))
+	gtk_widget_map (child->widget);
+    }
+
+  gdk_window_show(widget->window);
+}
+
+/* standard GTK function */
+static void
+gtk_frameset_unmap (GtkWidget *widget)
+{
+  GtkFrameset *frameset;
+  GtkFramesetChild *child;
+  GList *children;
+  
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_FRAMESET (widget));
+  
+  frameset = GTK_FRAMESET (widget);
+  GTK_WIDGET_UNSET_FLAGS (frameset, GTK_MAPPED);
+  
+  children = frameset->children;
+  while (children)
+    {
+      child = children->data;
+      children = children->next;
+      
+      if (GTK_WIDGET_VISIBLE (child->widget) &&
+	  GTK_WIDGET_MAPPED (child->widget))
+	gtk_widget_unmap (child->widget);
+    }
+
+  gdk_window_hide(widget->window);
+}
+
+/* standard GTK function */
+static void
+gtk_frameset_draw (GtkWidget    *widget,
+		  GdkRectangle *area)
+{
+  GtkFrameset *frameset;
+  GtkFramesetChild *child;
+  GList *children;
+  GdkRectangle child_area;
+  
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_FRAMESET (widget));
+  
+  if (GTK_WIDGET_VISIBLE (widget) && GTK_WIDGET_MAPPED (widget))
+    {
+      frameset = GTK_FRAMESET (widget);
+      
+      children = frameset->children;
+      while (children)
+	{
+	  child = children->data;
+	  children = children->next;
+	  
+	  if (gtk_widget_intersect (child->widget, area, &child_area))
+	    gtk_widget_draw (child->widget, &child_area);
+	}
+    }
+}
+
+/* standard GTK function */
+static gint
+gtk_frameset_expose (GtkWidget	    *widget,
+		     GdkEventExpose *event)
+{
+  GtkFrameset *frameset;
+  GtkFramesetChild *child;
+  GList *children;
+  GdkEventExpose child_event;
+  
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_FRAMESET (widget), FALSE);
+  
+  if (GTK_WIDGET_VISIBLE (widget) && GTK_WIDGET_MAPPED (widget))
+    {
+      frameset = GTK_FRAMESET (widget);
+      
+      child_event = *event;
+      
+      children = frameset->children;
+      while (children)
+	{
+	  child = children->data;
+	  children = children->next;
+	  
+	  if (GTK_WIDGET_NO_WINDOW (child->widget) &&
+	      gtk_widget_intersect (child->widget, &event->area, &child_event.area))
+	    gtk_widget_event (child->widget, (GdkEvent*) &child_event);
+	}
+    }
+  
+  return FALSE;
+}
+
+/* standard GTK function */
+static void
+gtk_frameset_size_allocate (GtkWidget     *widget,
+			    GtkAllocation *allocation)
+{
+  GtkFrameset *frameset;
+  
+  g_return_if_fail (widget != NULL);
+  g_return_if_fail (GTK_IS_FRAMESET (widget));
+  g_return_if_fail (allocation != NULL);
+
+  DEBUG_MSG(DEBUG_EVENT, "gtk_frameset_size_allocate(%d, {w:%d, h:%d, x:%d, y:%d})\n",
+	    (gint) widget, allocation->width, allocation->height, allocation->x, allocation->y);
+  
+  widget->allocation = *allocation;
+  frameset = GTK_FRAMESET (widget);
+
+  if (GTK_WIDGET_REALIZED (widget))
+    gdk_window_move_resize (widget->window,
+			    allocation->x, allocation->y,
+			    allocation->width, allocation->height);
+  
+  gtk_frameset_size_allocate_init (frameset);
+  gtk_frameset_size_allocate_pass1 (frameset);
+}
+
+/*
+ * Calculate child dimensions relative to those of frameset,
+ * based on row and column length specifications
+ */
+void
+gtk_frameset_size_allocate_init(GtkFrameset *frameset)
+{
+  gint n_rows, n_cols;
+  gfloat per_percent;
+  gint real_width, real_height;
+  gint row_borderspace, col_borderspace;
+  guint location;
+  
+  /* calculate total amount of border space used */
+  row_borderspace = 0;
+  col_borderspace = 0;
+
+  for(n_rows = 0; n_rows < frameset->nrows - 1; n_rows++)
+    row_borderspace += (frameset->rows[n_rows].border ? GTKFRAMESET_DEFAULT_BORDER_SIZE : 0);
+  for(n_cols = 0; n_cols < frameset->ncols - 1; n_cols++)
+    col_borderspace += (frameset->cols[n_cols].border ? GTKFRAMESET_DEFAULT_BORDER_SIZE : 0);
+
+  real_width =
+    (col_borderspace < GTK_WIDGET(frameset)->allocation.width ?
+     GTK_WIDGET(frameset)->allocation.width - col_borderspace : 0);
+  real_height =
+    (row_borderspace < GTK_WIDGET(frameset)->allocation.height ?
+     GTK_WIDGET(frameset)->allocation.height - row_borderspace : 0);
+  
+  location = 0;
+  if(frameset->nrows > 1) {
+    /* calculate number of pixels to dole out per percent */
+    per_percent = (gfloat) (real_height > frameset->row_total_absolute ?
+			    ((real_height - frameset->row_total_absolute) / 100.0) : 0);
+    for(n_rows = 0; n_rows < frameset->nrows; n_rows++) {
+      if(LENGTH_IS_PERCENTAGE(frameset->rows[n_rows].length))
+	frameset->rows[n_rows].allocation =
+	  (gint) (per_percent * 100 * LENGTH_GET_PERCENTAGE(frameset->rows[n_rows].length));
+      else if(LENGTH_IS_ABSOLUTE(frameset->rows[n_rows].length))
+	frameset->rows[n_rows].allocation =
+	  (gint) LENGTH_GET_ABSOLUTE(frameset->rows[n_rows].length);
+      
+      frameset->rows[n_rows].location = location;
+      location += frameset->rows[n_rows].allocation +
+	(frameset->rows[n_rows].border ? GTKFRAMESET_DEFAULT_BORDER_SIZE : 0);
+    }
+  } else {
+    frameset->rows[0].allocation = real_height;
+    frameset->rows[0].location = 0;
+  }
+  
+  location = 0;
+  if(frameset->ncols > 1) {
+    /* calculate number of pixels to dole out per percent */
+    per_percent = (gfloat) (real_width > frameset->col_total_absolute ?
+			    ((real_width - frameset->col_total_absolute) / 100.0) : 0);
+    for(n_cols = 0; n_cols < frameset->ncols; n_cols++) {
+      if(LENGTH_IS_PERCENTAGE(frameset->cols[n_cols].length))
+	frameset->cols[n_cols].allocation =
+	  (gint) (per_percent * 100 * LENGTH_GET_PERCENTAGE(frameset->cols[n_cols].length));
+      else if(LENGTH_IS_ABSOLUTE(frameset->cols[n_cols].length))
+	frameset->cols[n_cols].allocation =
+	  (gint) LENGTH_GET_ABSOLUTE(frameset->cols[n_cols].length);
+      
+      frameset->cols[n_cols].location = location;
+      location += frameset->cols[n_cols].allocation +
+	(frameset->cols[n_cols].border ? GTKFRAMESET_DEFAULT_BORDER_SIZE : 0);
+    }
+  } else {
+    frameset->cols[0].allocation = real_width;
+    frameset->cols[0].location = 0;
+  }
+}
+
+/*
+ * allocate children according to their placement in frameset
+ */
+static void
+gtk_frameset_size_allocate_pass1(GtkFrameset *frameset)
+{
+  GtkFramesetChild *child;
+  GList *children;
+  GtkAllocation *alloc;
+
+  alloc = g_new0(GtkAllocation, 1);
+
+  children = frameset->children;
+  while(children)
+    {
+      child = children->data;
+      children = children->next;
+      
+      if(GTK_WIDGET_VISIBLE(child->widget)) {
+	alloc->width = (frameset->cols[child->col_attach].allocation < (2 * child->xpadding) ?
+			0 : frameset->cols[child->col_attach].allocation - (2 * child->xpadding));
+	
+	alloc->height = (frameset->rows[child->row_attach].allocation < (2 * child->ypadding) ?
+			 0 : frameset->rows[child->row_attach].allocation - (2 * child->ypadding));
+	alloc->x = frameset->cols[child->col_attach].location + child->xpadding;
+	alloc->y = frameset->rows[child->row_attach].location + child->ypadding;
+	gtk_widget_size_allocate(GTK_WIDGET(child->widget), alloc);
+
+	DEBUG_MSG(DEBUG_ALLOC, "widget %d (row %d, col %d) allocated (w:%d, h:%d, x:%d, y:%d)\n",
+		  (gint) child->widget, child->row_attach, child->col_attach,
+		  alloc->width, alloc->height,
+		  frameset->cols[child->col_attach].location,
+		  frameset->rows[child->row_attach].location);
+      }
+    }
+  g_free(alloc);
+}
+
+
+
+/*
+ * Parse a comma-separated list of %MultiLengths, and returns a GSList
+ * of lenghts. The caller has to free the GSList.
+ */
+static GSList*
+gtk_frameset_get_multi_length (const gchar *attr)
+{
+  GSList *list;
+  gdouble value;
+  gchar *end;
+  Length length;
+
+  g_return_val_if_fail(attr != NULL, NULL);
+
+  list = NULL;
+
+  while(TRUE) {
+    value = g_strtod (attr, &end);
+    switch (*end) {
+    case '%':
+      length = LENGTH_CREATE_PERCENTAGE (value / 100);
+      break;
+      
+    case '*':
+      length = LENGTH_CREATE_RELATIVE (value);
+      break;
+      
+    default:
+      length = LENGTH_CREATE_ABSOLUTE ((gint) value);
+      break;
+    }
+
+    list = g_slist_append(list, GINT_TO_POINTER(length));
+ 
+    /* there MUST be a comma between values */
+    if(!(end = strchr(end, ',')))
+      break;
+    /* valid %MultiLength characters: 0123456789%* */
+    if(!(attr = strpbrk(end, "0123456789%*")))
+      break;
+  }
+ 
+  return list;
+}
+
+/*
+ * given the current location and allocation values, calculate
+ * row/col length values. The results are used in size_allocate
+ */
+static void
+gtk_frameset_calculate_lengths(GtkFrameset *frameset)
+{
+  gint n;
+  guint total_percentage;
+
+  total_percentage = 0;
+  frameset->col_total_absolute = 0;
+  for(n = 0; n < frameset->ncols; n++)
+    if(LENGTH_IS_ABSOLUTE(frameset->cols[n].length)) {
+      frameset->cols[n].length = LENGTH_CREATE_ABSOLUTE(frameset->cols[n].allocation);
+      frameset->col_total_absolute += frameset->cols[n].allocation;
+    } else
+      total_percentage += frameset->cols[n].allocation;
+
+  for(n = 0; n < frameset->ncols; n++) {
+    if(!(LENGTH_IS_ABSOLUTE(frameset->cols[n].length)))
+      frameset->cols[n].length =
+	LENGTH_CREATE_PERCENTAGE(((gfloat) frameset->cols[n].allocation) / total_percentage);
+  }
+
+  total_percentage = 0;
+  frameset->row_total_absolute = 0;
+  for(n = 0; n < frameset->nrows; n++)
+    if(LENGTH_IS_ABSOLUTE(frameset->rows[n].length)) {
+      frameset->rows[n].length = LENGTH_CREATE_ABSOLUTE(frameset->rows[n].allocation);
+      frameset->row_total_absolute += frameset->rows[n].allocation;
+    } else
+      total_percentage += frameset->rows[n].allocation;
+
+  for(n = 0; n < frameset->nrows; n++) {
+    if(!(LENGTH_IS_ABSOLUTE(frameset->rows[n].length)))
+      frameset->rows[n].length =
+	LENGTH_CREATE_PERCENTAGE(((gfloat) frameset->rows[n].allocation) / total_percentage);
+  }
+}
+
+/*
+ * set the resize_row and resize_col attributes and set resize cursor (if any)
+ */
+static gint
+gtk_frameset_set_resize_rowcol(GtkWidget *widget, guint x, guint y)
+{
+  GtkFrameset *frameset = GTK_FRAMESET(widget);
+  guint n;
+
+  g_return_val_if_fail (widget != NULL,FALSE);
+  g_return_val_if_fail (GTK_IS_FRAMESET (widget),FALSE);
+
+  frameset->resize_row = RESIZE_NONE;
+  frameset->resize_col = RESIZE_NONE;
+
+  for(n=1; n < frameset->ncols; n++) {
+    if(frameset->cols[n - 1].allocation + frameset->cols[n - 1].location - GTKFRAMESET_DEFAULT_BORDER_SIZE <= x &&
+       frameset->cols[n].location + GTKFRAMESET_DEFAULT_BORDER_SIZE >= x &&
+       !frameset->cols[n].noresize) {
+      frameset->resize_col = n - 1;
+      break;
+    }
+  }
+
+  for(n=1; n < frameset->nrows; n++) {
+    if(frameset->rows[n - 1].allocation + frameset->rows[n - 1].location - GTKFRAMESET_DEFAULT_BORDER_SIZE <= y &&
+       frameset->rows[n].location + GTKFRAMESET_DEFAULT_BORDER_SIZE >= y &&
+       !frameset->rows[n].noresize) {
+      frameset->resize_row = n - 1;
+      break;
+    }
+  }
+
+  if((frameset->resize_row != RESIZE_NONE) && (frameset->resize_col != RESIZE_NONE))
+    gdk_window_set_cursor(widget->window, frameset->cursor_rowcol);
+  else if(frameset->resize_row != RESIZE_NONE)
+    gdk_window_set_cursor(widget->window, frameset->cursor_row);
+  else if(frameset->resize_col != RESIZE_NONE)
+    gdk_window_set_cursor(widget->window, frameset->cursor_col);
+  else
+    gdk_window_set_cursor(widget->window, NULL);
+
+  return TRUE;
+}
+
+/*
+ * standard GTK function
+ *
+ * enter drag mode on button_1_press over frame border
+ */
+static gint
+gtk_frameset_button_press (GtkWidget *widget, GdkEventButton *event)
+{
+  GtkFrameset *frameset = GTK_FRAMESET(widget);
+
+  g_return_val_if_fail (widget != NULL,FALSE);
+  g_return_val_if_fail (GTK_IS_FRAMESET (widget),FALSE);
+
+  if(!frameset->in_drag &&
+     (event->button == 1) &&
+     (frameset->resize_row != RESIZE_NONE || frameset->resize_col != RESIZE_NONE))
+    {
+      frameset->in_drag = TRUE;
+      gdk_pointer_grab (widget->window, FALSE,
+			GDK_POINTER_MOTION_HINT_MASK 
+			| GDK_BUTTON1_MOTION_MASK 
+			| GDK_BUTTON_RELEASE_MASK,
+			NULL, NULL, event->time);
+    }
+  
+  return TRUE;
+}
+
+/*
+ * standard GTK function
+ */
+static gint
+gtk_frameset_button_release (GtkWidget *widget, GdkEventButton *event)
+{
+  GtkFrameset *frameset = GTK_FRAMESET(widget);
+
+  g_return_val_if_fail (widget != NULL,FALSE);
+  g_return_val_if_fail (GTK_IS_FRAMESET (widget),FALSE);
+
+  if(frameset->in_drag && (event->button == 1))
+    {
+      frameset->in_drag = FALSE;
+      gdk_pointer_ungrab (event->time);
+      gtk_widget_queue_resize(GTK_WIDGET(frameset));
+    }
+
+  return TRUE;
+}
+
+/*
+ * standard GTK function
+ *
+ * determine row/col to resize (from x, y and noresize attribute),
+ * set appropriate cursor (row resize, col resize or both)
+ */
+static gint
+gtk_frameset_enter (GtkWidget *widget, GdkEventCrossing *event)
+{
+  g_return_val_if_fail (widget != NULL,FALSE);
+  g_return_val_if_fail (GTK_IS_FRAMESET (widget),FALSE);
+
+  return gtk_frameset_set_resize_rowcol(widget, event->x, event->y);
+}
+
+/*
+ * standard GTK function
+ *
+ * unset resize cursor and resize_row/resize_col
+ */
+static gint
+gtk_frameset_leave (GtkWidget *widget, GdkEventCrossing *event)
+{
+  GtkFrameset *frameset = GTK_FRAMESET(widget);
+
+  g_return_val_if_fail (widget != NULL,FALSE);
+  g_return_val_if_fail (GTK_IS_FRAMESET (widget),FALSE);
+
+  frameset->resize_row = RESIZE_NONE;
+  frameset->resize_col = RESIZE_NONE;
+  gdk_window_set_cursor(widget->window, NULL);
+
+  return TRUE;
+}
+
+/*
+ * standard GTK function
+ *
+ * resize row and/or column when in_drag is true
+ *  otherwise
+ * if resize_row or resize_col is set
+ * set resize_row/resize_col and cursor
+ *
+ * This way, motion events without prior enter events will not set the
+ * cursor
+ */
+static gint
+gtk_frameset_motion (GtkWidget *widget, GdkEventMotion *event)
+{
+  GtkFrameset *frameset = GTK_FRAMESET(widget);
+  guint x, y;
+  gint diff;
+  gboolean return_val;
+
+  g_return_val_if_fail (widget != NULL, FALSE);
+  g_return_val_if_fail (GTK_IS_FRAMESET (widget), FALSE);
+
+  if (event->is_hint)
+    gtk_widget_get_pointer(widget, &x, &y);
+  else {
+    x = event->x;
+    y = event->y;
+  }
+  
+  if (frameset->in_drag)
+    {
+      if(frameset->resize_row >= 0) {
+	diff = (y - frameset->rows[frameset->resize_row].location) -
+	  frameset->rows[frameset->resize_row].allocation;
+	if(frameset->rows[frameset->resize_row].allocation + diff > 0 &&
+	   frameset->rows[frameset->resize_row + 1].allocation - diff > 0) {
+	  frameset->rows[frameset->resize_row].allocation += diff;
+	  frameset->rows[frameset->resize_row + 1].location += diff;
+	  frameset->rows[frameset->resize_row + 1].allocation -= diff;
+	}
+      }
+
+      if(frameset->resize_col >= 0) {
+	diff = (x - frameset->cols[frameset->resize_col].location) -
+	  frameset->cols[frameset->resize_col].allocation;
+	if(frameset->cols[frameset->resize_col].allocation + diff > 0 &&
+	   frameset->cols[frameset->resize_col + 1].allocation - diff > 0) {
+	  frameset->cols[frameset->resize_col].allocation += diff;
+	  frameset->cols[frameset->resize_col + 1].location += diff;
+	  frameset->cols[frameset->resize_col + 1].allocation -= diff;
+	}
+      }
+
+      gtk_frameset_calculate_lengths(frameset);
+      gtk_widget_queue_resize(GTK_WIDGET(frameset));
+      return_val = TRUE;
+    } else
+      /* only adjust resize_row/resize_col if either of these is already set,
+       * this way the cursor will not be changed by motion events without prior
+       * enter event */
+      if(frameset->resize_row != RESIZE_NONE ||
+	 frameset->resize_col != RESIZE_NONE)
+         return_val = gtk_frameset_set_resize_rowcol(widget, x, y);
+      else
+	return_val = TRUE;
+
+  return return_val;
+}
+
diff -Nur dillo-0.8.0/src/gtkframeset.h dillo-0.8.0.new/src/gtkframeset.h
--- dillo-0.8.0/src/gtkframeset.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/src/gtkframeset.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,133 @@
+/*
+ * File: gtkframeset.h
+ * Copyright (C) 2003 Frank de Lange <frank@unternet.org>
+ *
+ *   a frameset widget for GTK - The GIMP Toolkit
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Library General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifndef __GTK_FRAMESET_H__
+#define __GTK_FRAMESET_H__
+
+#include <gdk/gdk.h>
+#include <gtk/gtkcontainer.h>
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+
+#define GTK_FRAMESET(obj)	     (GTK_CHECK_CAST ((obj), GTK_TYPE_FRAMESET, GtkFrameset))
+#define GTK_TYPE_FRAMESET	     (gtk_frameset_get_type ())
+#define GTK_FRAMESET_CLASS(klass)    (GTK_CHECK_CLASS_CAST ((klass), GTK_TYPE_FRAMESET, GtkFramesetClass))
+#define GTK_IS_FRAMESET(obj)	     (GTK_CHECK_TYPE ((obj), GTK_TYPE_FRAMESET))
+#define GTK_IS_FRAMESET_CLASS(klass) (GTK_CHECK_CLASS_TYPE ((klass), GTK_TYPE_FRAMESET))
+
+
+typedef struct _GtkFrameset	     GtkFrameset;
+typedef struct _GtkFramesetClass     GtkFramesetClass;
+typedef struct _GtkFramesetChild     GtkFramesetChild;
+typedef struct _GtkFramesetRowCol    GtkFramesetRowCol;
+typedef gint32 Length;
+
+/* (adapted from dw_style.h) Lengths */
+#define LENGTH_CREATE_ABSOLUTE(n)     (((n) << 2) | 1)
+#define LENGTH_CREATE_PERCENTAGE(n)   ((LENGTH_FLOAT_TO_REAL (n) << 3) | 2)
+#define LENGTH_CREATE_RELATIVE(n)     ((LENGTH_FLOAT_TO_REAL (n) << 3) | 6)
+#define LENGTH_UNDEF_LENGTH           0
+
+#define LENGTH_IS_ABSOLUTE(l)         ((l) & 1)
+#define LENGTH_IS_PERCENTAGE(l)       (((l) & 7) == 2)
+#define LENGTH_IS_RELATIVE(l)         (((l) & 7) == 6)
+
+#define LENGTH_GET_ABSOLUTE(l)        ((l) >> 2)
+#define LENGTH_GET_PERCENTAGE(l)      LENGTH_REAL_TO_FLOAT ((l) >> 3)
+#define LENGTH_GET_RELATIVE(l)        LENGTH_REAL_TO_FLOAT ((l) >> 3)
+
+#define LENGTH_REAL_TO_FLOAT(v)       ((gfloat)(v) / 0x10000)
+#define LENGTH_FLOAT_TO_REAL(v)       ((gint)((v) * 0x10000))
+
+/* used in frame resize */
+#define RESIZE_NONE                   -1
+
+/* default border size */
+#define GTKFRAMESET_DEFAULT_BORDER_SIZE 2
+
+struct _GtkFrameset
+{
+  GtkContainer container;
+  
+  GList *children;
+  GtkFramesetRowCol *rows;
+  GtkFramesetRowCol *cols;
+  guint row_total_absolute, col_total_absolute;
+  guint16 nrows;
+  guint16 ncols;
+  guint16 current_frame;
+  gboolean in_drag : 1;
+  gint16 resize_row, resize_col;
+  GdkCursor *cursor_rowcol, *cursor_row, *cursor_col;
+};
+
+struct _GtkFramesetClass
+{
+  GtkContainerClass parent_class;
+};
+
+struct _GtkFramesetChild
+{
+  GtkWidget *widget;
+  guint16 row_attach;
+  guint16 col_attach;
+  guint16 xpadding;
+  guint16 ypadding;
+  gboolean border : 1;
+  gboolean noresize : 1;
+};
+
+struct _GtkFramesetRowCol
+{
+  guint16 location;
+  guint16 allocation;
+  gboolean noresize : 1;
+  gboolean border: 1;
+  Length length;
+  guint16 spacing;
+};
+
+
+GtkType	   gtk_frameset_get_type        (void);
+GtkWidget* gtk_frameset_new	        (gchar	       *rows,
+					 gchar	       *columns);
+void       gtk_frameset_resize          (GtkFrameset   *frameset,
+					 gchar	       *rows,
+					 gchar	       *columns);
+void	   gtk_frameset_attach	        (GtkFrameset   *frameset,
+					 GtkWidget     *child,
+					 guint		row_attach,
+					 guint		col_attach,
+					 guint          xpadding,
+					 guint          ypadding,
+					 gboolean       border,
+					 gboolean       noresize);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __GTK_FRAMESET_H__ */
diff -Nur dillo-0.8.0/src/html.c dillo-0.8.0.new/src/html.c
--- dillo-0.8.0/src/html.c	2004-02-06 23:10:45.000000000 +0000
+++ dillo-0.8.0.new/src/html.c	2004-10-13 01:13:29.000000000 +0000
@@ -15,24 +15,32 @@
  */
 
 #define USE_TABLES
+//#define SEND_HTML_MSG /* meta-refresh */
 
+#include <config.h>
 #include <ctype.h>      /* for isspace and tolower */
 #include <string.h>     /* for memcpy and memmove */
 #include <stdlib.h>
 #include <stdio.h>      /* for sprintf */
-#include <math.h>      /* for rint */
+#include <math.h>       /* for rint */
+#include <errno.h>      /* for iconv error codes */
+#include <time.h>       /* for nanosleep */
 
 #include <gtk/gtk.h>
 
+#include "intl.h"
 #include "msg.h"
 #include "list.h"
 #include "colors.h"
 #include "dillo.h"
 #include "history.h"
 #include "nav.h"
+#include "doc.h"
 #include "menu.h"
+#include "pagemark.h"
 #include "commands.h"
 #include "dw.h"         /* for Dw_cursor_hand */
+#include "dw_gtk_scrolled_window.h" /* for a_Dw_gtk_scrolled_window_get_dw */
 
 #include "dw_gtk_viewport.h"
 #include "dw_gtk_scrolled_window.h"
@@ -48,13 +56,20 @@
 #include "IO/IO.h"
 #include "IO/Url.h"
 #include "interface.h"
-#include "progressbar.h"
 #include "prefs.h"
 #include "misc.h"
 #include "capi.h"
 #include "html.h"
+#include "i18n.h"
+#include "i18n_gtk.h"
 
-#define DEBUG_LEVEL 10
+#include "gtkframeset.h"
+
+#define DEBUG_EVENT 10
+#define DEBUG_SIZE  10
+#define DEBUG_ALLOC 10
+
+/* #define DEBUG_LEVEL 10 */
 #include "debug.h"
 
 typedef void (*TagFunct) (DilloHtml *Html, char *Tag, gint Tagsize);
@@ -76,10 +91,11 @@
 static void Html_add_widget(DilloHtml *html, DwWidget *widget,
                             char *width_str, char *height_str,
                             DwStyle *style_attrs);
+static gint Html_write_raw(DilloHtml *html, char *buf, gint bufsize, gint Eof);
 static void Html_write(DilloHtml *html, char *Buf, gint BufSize, gint Eof);
 static void Html_close(DilloHtml *html, gint ClientKey);
 static void Html_callback(int Op, CacheClient_t *Client);
-static DilloHtml *Html_new(BrowserWindow *bw, const DilloUrl *url);
+static DilloHtml *Html_new(DilloDoc *dd, const DilloUrl *url);
 static void Html_tag_open_input(DilloHtml *html, char *tag, gint tagsize);
 static void Html_add_input(DilloHtmlForm *form,
                            DilloHtmlInputType type,
@@ -93,18 +109,16 @@
 static void Html_reset_form(GtkWidget *reset, DilloHtmlLB *html_lb);
 static gchar* Html_tags_get_name(gint tag_idx);
 static gchar Html_tags_get_endtag(gint tag_idx);
-
+static void Html_translate(DilloTrans *trans, char *buf, gint bufsize);
+static DilloTrans *Html_translation_new(char *source, char *dest);
+static void Html_translation_free(DilloTrans *trans, gboolean keepbuf);
 
 /*
  * Local Data
  */
 
-/* The following array of font sizes has to be _strictly_ crescent */
-static const gint FontSizes[] = {8, 10, 12, 14, 18, 24};
-static const gint FontSizesNum = 6;
 static const gint FontSizesBase = 2;
 
-
 /*
  * Return the line number of the tag being processed by the parser.
  */
@@ -113,9 +127,14 @@
    gint i, ofs, line;
    const char *p = html->Start_Buf;
 
+   if (html->trans && (gint)html->CurrTagOfs < html->trans->bufsize) {
+      p = html->trans->buffer;
+      ofs = html->trans->bufsize;
+   } else
+      ofs = html->OldTagLine;
+
    g_return_val_if_fail(p != NULL, -1);
 
-   ofs = html->CurrTagOfs;
    line = html->OldTagLine;
    for (i = html->OldTagOfs; i < ofs; ++i)
       if (p[i] == '\n')
@@ -133,14 +152,14 @@
    va_list argp;
    gchar buf[512];
 
-   g_snprintf(buf, 512, "HTML warning: line %d, ",
+   g_snprintf(buf, 512, _("HTML warning: line %d, "),
               Html_get_line_number(html));
    g_string_append(html->linkblock->page_bugs, buf);
    va_start(argp, format);
    vsnprintf(buf, 512, format, argp);
    va_end(argp);
    g_string_append(html->linkblock->page_bugs, buf);
-   a_Interface_bug_meter_update(html->bw, 
+   a_Interface_bug_meter_update(html->dd->bw, 
                                 ++html->linkblock->num_page_bugs);
 }
 
@@ -161,7 +180,7 @@
             (use_base_url) ? base_url : URL_STR_(html->linkblock->base_url),
             flags, posx, posy);
    if ((n_ic = URL_ILLEGAL_CHARS(url)) != 0)
-      MSG_HTML("URL has %d illegal character%s (00-1F, 7F or space)\n",
+      MSG_HTML(_("URL has %d illegal character%s (00-1F, 7F or space)\n"),
                n_ic, (n_ic) > 1 ? "s" : "");
    return url;
 }
@@ -173,7 +192,15 @@
                       void **Data)
 {
    DilloWeb *web = P;
-   DilloHtml *html = Html_new(web->bw, web->url);
+   DilloHtml *html = Html_new(web->dd, web->url);
+
+   /* Actual, HTTP header charset is almost reliable in Japan
+    * at least... however, the HTML 4.01 SPEC recommends
+    * to giving top priority to this. */
+   if ((html->server_charset = strstr(Type, "charset="))
+         && html->server_charset + 8)
+      html->server_charset
+         = a_I18n_fix_charset(g_strdup(html->server_charset + 8));
 
    *Data = (void *) html;
    *Call = (CA_Callback_t) Html_callback;
@@ -184,11 +211,11 @@
 /*
  * We'll make the linkblock first to get it out of the way.
  */
-static DilloHtmlLB *Html_lb_new(BrowserWindow *bw, const DilloUrl *url)
+static DilloHtmlLB *Html_lb_new(DilloDoc *dd, const DilloUrl *url)
 {
    DilloHtmlLB *html_lb = g_new(DilloHtmlLB, 1);
 
-   html_lb->bw = bw;
+   html_lb->dd = dd;
    html_lb->base_url = a_Url_dup(url);
    html_lb->num_forms_max = 1;
    html_lb->num_forms = 0;
@@ -202,6 +229,12 @@
    html_lb->link_color = prefs.link_color;
    html_lb->visited_color = prefs.visited_color;
 
+   html_lb->charset = NULL;
+
+#ifdef ENABLE_META_REFRESH   
+   html_lb->meta_refresh = NULL;
+#endif
+
    html_lb->num_page_bugs = 0;
    html_lb->page_bugs = g_string_new("");
 
@@ -218,12 +251,17 @@
    DilloHtmlLB *html_lb = lb;
 
    DEBUG_MSG(3, "Html_lb_free\n");
-
+#ifdef ENABLE_META_REFRESH
+   if (html_lb->meta_refresh) {
+      *html_lb->meta_refresh = 1;
+   }
+#endif
    a_Url_free(html_lb->base_url);
 
    for (i = 0; i < html_lb->num_forms; i++) {
       form = &html_lb->forms[i];
       a_Url_free(form->action);
+      g_free(form->charset);
       for (j = 0; j < form->num_inputs; j++) {
          g_free(form->inputs[j].name);
          g_free(form->inputs[j].init_str);
@@ -246,6 +284,8 @@
          a_Url_free(html_lb->links[i]);
    g_free(html_lb->links);
 
+   g_free(html_lb->charset);
+
    a_Dw_image_map_list_free(&html_lb->maps);
 
    g_string_free(html_lb->page_bugs, TRUE);
@@ -279,15 +319,19 @@
 
    url = (link == -1) ? NULL : lb->links[link];
    if (url) {
+      gchar *url_str = NULL;
+      if(URL_STR_(url))
+         url_str = a_I18n_convert(lb->charset, DILLO_CHARSET,
+               URL_STR_(url), -1);
       Html_set_link_coordinates(lb, link, x, y);
-      a_Interface_msg(lb->bw, "%s",
-                         URL_ALT_(url) ? URL_ALT_(url) : URL_STR_(url));
+      a_Interface_msg(lb->dd->bw, "%s",
+		      URL_ALT_(url) ? URL_ALT_(url) : url_str);
+      g_free(url_str);
       a_Dw_widget_set_cursor (widget, Dw_cursor_hand);
-      lb->bw->status_is_link = 1;
-
+      lb->dd->bw->status_is_link = 1;
    } else {
-      if (lb->bw->status_is_link)
-         a_Interface_msg(lb->bw, "");
+      if (lb->dd->bw->status_is_link)
+         a_Interface_msg(lb->dd->bw, "");
       a_Dw_widget_set_cursor (widget, NULL);
    }
 }
@@ -303,26 +347,26 @@
 
    if (event->button == 3) {
       Html_set_link_coordinates(lb, link, x, y);
-      a_Menu_popup_set_url(lb->bw, lb->links[link]);
+      a_Menu_popup_set_url(lb->dd->bw, lb->links[link]);
 
       /* if we've got an image, prepare the image popup */
       widget_at_cursor =
          a_Dw_gtk_scrolled_window_widget_at_viewport_point(
-            GTK_DW_SCROLLED_WINDOW (lb->bw->docwin), event->x, event->y);
+            GTK_DW_SCROLLED_WINDOW (lb->dd->docwin), event->x, event->y);
       if (widget_at_cursor && DW_IS_IMAGE (widget_at_cursor)) {
          DwImage *image = DW_IMAGE (widget_at_cursor);
          /* test image->url (it may have not started to arrive yet!) */
          if (image->url) {
             /* use the second URL for this popup */
-            gtk_object_set_data(GTK_OBJECT (lb->bw->menu_popup.over_image),
+            gtk_object_set_data(GTK_OBJECT (lb->dd->bw->menu_popup.over_image),
                                 "url2", GINT_TO_POINTER(2));
-            a_Menu_popup_set_url2(lb->bw, image->url);
+            a_Menu_popup_set_url2(lb->dd->bw, image->url);
             show_oi = TRUE;
          }
       }
-      a_Menu_popup_ol_show_oi(lb->bw, show_oi);
+      a_Menu_popup_ol_show_oi(lb->dd->bw, show_oi);
 
-      gtk_menu_popup(GTK_MENU(lb->bw->menu_popup.over_link), NULL, NULL,
+      gtk_menu_popup(GTK_MENU(lb->dd->bw->menu_popup.over_link), NULL, NULL,
                      NULL, NULL, event->button, event->time);
       return TRUE;
    }
@@ -335,21 +379,60 @@
  * Activate a link ("link_clicked" callback of the page)
  */
 static gboolean Html_link_clicked(DwWidget *widget, gint link, gint x, gint y,
-                                  GdkEventButton *event, DilloHtmlLB *lb)
+                              GdkEventButton *event, DilloHtmlLB *lb)
 {
+   DilloDoc *named_dd;
+   gchar *target;
+   gboolean return_val;
+
+   return_val = FALSE;
+
    Html_set_link_coordinates(lb, link, x, y);
-   if (event->button == 1)
-      a_Nav_push(lb->bw, lb->links[link]);
-   else if (event->button == 2) {
-      a_Nav_push_nw(lb->bw, lb->links[link]);
-   } else {
-      return FALSE;
+
+   switch (event->button) {
+   case 1:
+     if (event->state & GDK_SHIFT_MASK) {
+       /* shift-click: open in new window */
+       a_Menu_popup_set_url(lb->dd->bw, lb->links[link]);
+       a_Commands_open_link_nw_callback(NULL, lb->dd->bw);
+#ifndef DISABLE_TABS
+     } else if (event->state & GDK_CONTROL_MASK) {
+       /* control-click: open in new tab */
+       a_Menu_popup_set_url(lb->dd->bw, lb->links[link]);
+       a_Commands_open_link_nw_tab_callback(NULL, lb->dd->bw);
+#endif /* !DISABLE_TABS */
+     } else {
+       if((target = (gchar *) URL_TARGET_(lb->links[link])))
+	       /* targeted link or base target, open in either existing
+	        * named document or new document */
+          if ((named_dd = a_Doc_get_by_name(lb->dd, (gchar *) target)))
+             a_Nav_push(named_dd, lb->links[link]);
+          else {
+             a_Menu_popup_set_url(lb->dd->bw, lb->links[link]);
+             a_Commands_open_link_nw_callback(NULL, lb->dd->bw);
+          }
+       else
+          a_Nav_push(lb->dd, lb->links[link]);
+     }
+     return_val = TRUE;
+     break;
+   case 2:
+     a_Menu_popup_set_url(lb->dd->bw, lb->links[link]);
+#ifndef DISABLE_TABS
+     if(prefs.tab_instead_of_window)
+        a_Commands_open_link_nw_tab_callback(NULL, lb->dd->bw);
+     else
+#endif /* !DISABLE_TABS */
+       a_Commands_open_link_nw_callback(NULL, lb->dd->bw);
+     return_val = TRUE;
+     break;
+   default:
+     break;
    }
 
    if (DW_IS_PAGE (widget))
       a_Dw_page_change_link_color (DW_PAGE (widget), link, lb->visited_color);
-
-   return TRUE;
+   return return_val;
 }
 
 /*
@@ -357,12 +440,12 @@
  */
 static gboolean Html_image_menu(DwWidget *widget,
                                 gint32 x, gint32 y, GdkEventButton *event,
-                                BrowserWindow *bw)
+                                DilloDoc *dd)
 {
    DwImage *image = DW_IMAGE (widget);
    if (event->button == 3 && image->url) {
-      a_Menu_popup_set_url(bw, image->url);
-      gtk_menu_popup(GTK_MENU(bw->menu_popup.over_image), NULL, NULL,
+      a_Menu_popup_set_url(dd->bw, image->url);
+      gtk_menu_popup(GTK_MENU(dd->bw->menu_popup.over_image), NULL, NULL,
                      NULL, NULL, event->button, event->time);
       return TRUE;
    }
@@ -374,19 +457,62 @@
  * Popup the page menu ("button_press_event" callback of the viewport)
  */
 static int Html_page_menu(GtkWidget *viewport, GdkEventButton *event,
-                          BrowserWindow *bw)
+                          DilloDoc *dd)
 {
    gpointer bug_pix;
-
    if (event->button == 3) {
       /* set the working URL */
-      a_Menu_popup_set_url(bw, a_History_get_url(NAV_TOP(bw)));
+      a_Menu_popup_set_url(dd->bw, a_History_get_url(NAV_TOP(dd)));
+      if(dd->pagemarks_menu) {
+         /* this dd has a pagemarks menu, hook it up to the window's menu */
+         gtk_menu_item_set_submenu(GTK_MENU_ITEM(dd->bw->pagemarks_menuitem),
+               dd->pagemarks_menu);
+         gtk_widget_set_sensitive(dd->bw->pagemarks_menuitem, TRUE);
+      } else {
+         /* remove pagemarks submenu from window's menu */
+         gtk_widget_set_sensitive(dd->bw->pagemarks_menuitem, FALSE);
+      }
+      if(dd->parent) {
+         /* this is a frame or an iframe, create frame menu */
+         if(dd->bw->menu_popup.over_frame) {
+            gtk_widget_destroy(dd->bw->menu_popup.over_frame);
+            dd->bw->menu_popup.over_frame = NULL;
+         }
+         dd->bw->menu_popup.over_frame = a_Menu_popup_of_new(dd);
+         gtk_menu_item_set_submenu(GTK_MENU_ITEM(dd->bw->frame_menuitem),
+               dd->bw->menu_popup.over_frame);
+         gtk_widget_set_sensitive(dd->bw->frame_menuitem, TRUE);
+         if((dd->parent)->parent) {
+            /* this is a nested frame, show frameset menu 
+             * TODO: currently the frameset menu also shows for nested
+             * iframes. It does not do harm, but it is not that useful... */
+            gtk_menu_item_set_submenu(GTK_MENU_ITEM(dd->bw->frameset_menuitem),
+                  a_Menu_popup_ofs_new(dd));
+            gtk_widget_set_sensitive(dd->bw->frameset_menuitem, TRUE);
+            gtk_widget_show(dd->bw->frameset_menuitem);
+         } else {
+            gtk_widget_set_sensitive(dd->bw->frameset_menuitem, FALSE);
+            gtk_widget_hide(dd->bw->frameset_menuitem);
+         }	
+         gtk_widget_show(dd->bw->frame_menuitem);
+      } else {
+         /* this is an unparented document, disable/destroy frame menu */
+         if(dd->bw->menu_popup.over_frame) {
+            gtk_widget_destroy(dd->bw->menu_popup.over_frame);
+            dd->bw->menu_popup.over_frame = NULL;
+         }
+         gtk_widget_set_sensitive(dd->bw->frame_menuitem, FALSE);
+         gtk_widget_hide(dd->bw->frame_menuitem);
+         gtk_widget_set_sensitive(dd->bw->frameset_menuitem, FALSE);
+         gtk_widget_hide(dd->bw->frameset_menuitem);
+      }
+
       /* set "View page Bugs" sensitivity */
-      bug_pix = gtk_object_get_data(GTK_OBJECT(bw->status_bug_meter), "bug");
-      gtk_widget_set_sensitive(bw->viewbugs_menuitem,
+      bug_pix = gtk_object_get_data(GTK_OBJECT(dd->bw->status_bug_meter), "bug");
+      gtk_widget_set_sensitive(dd->bw->viewbugs_menuitem,
                                GTK_WIDGET_VISIBLE(GTK_WIDGET(bug_pix)));
-      gtk_menu_popup(GTK_MENU(bw->menu_popup.over_page), NULL, NULL,
-                     NULL, NULL, event->button, event->time);
+      gtk_menu_popup(GTK_MENU(dd->bw->menu_popup.over_page), NULL, NULL,
+            NULL, NULL, event->button, event->time);
       return TRUE;
    } else
       return FALSE;
@@ -416,6 +542,7 @@
 {
    gint nl;
 
+   a_Url_set_referer(*url, html->linkblock->base_url);
    nl = html->linkblock->num_links;
    a_List_add(html->linkblock->links, nl, html->linkblock->num_links_max);
    html->linkblock->links[nl] = (*url) ? *url : NULL;
@@ -429,7 +556,7 @@
 static gint Html_form_new(DilloHtmlLB *html_lb,
                           DilloHtmlMethod method,
                           const DilloUrl *action,
-                          DilloHtmlEnc enc)
+                          gchar *encoding)
 {
    gint nf;
 
@@ -438,7 +565,7 @@
    nf = html_lb->num_forms;
    html_lb->forms[nf].method = method;
    html_lb->forms[nf].action = a_Url_dup(action);
-   html_lb->forms[nf].enc = enc;
+   html_lb->forms[nf].charset = g_strdup(encoding);
    html_lb->forms[nf].num_inputs = 0;
    html_lb->forms[nf].num_inputs_max = 4;
    html_lb->forms[nf].inputs = NULL;
@@ -463,7 +590,7 @@
       style_attrs = *old_style; \
       style_attrs.var = (val); \
       (html)->stack[(html)->stack_top].style = \
-         a_Dw_style_new (&style_attrs, (html)->bw->main_window->window); \
+         a_Dw_style_new (&style_attrs, (html)->dd->bw->main_window->window); \
       a_Dw_style_unref (old_style); \
    } while (FALSE)
 
@@ -574,13 +701,13 @@
    a_Dw_style_box_set_border_color
       (&style_attrs,
        a_Dw_style_shaded_color_new(style_attrs.color->color_val,
-                                   html->bw->main_window->window));
+                                   html->dd->bw->main_window->window));
    a_Dw_style_box_set_border_style(&style_attrs, DW_STYLE_BORDER_DASHED);
 #endif
 
    style_attrs.margin.left = left;
    style_attrs.margin.right = right;
-   style = a_Dw_style_new (&style_attrs, html->bw->main_window->window);
+   style = a_Dw_style_new (&style_attrs, html->dd->bw->main_window->window);
 
    a_Dw_page_add_parbreak (DW_PAGE (html->dw), space, style);
    a_Dw_page_add_widget (DW_PAGE (html->dw), page, style);
@@ -610,11 +737,11 @@
 {
    gint i, level;
    gdouble normalized_size = fontsize / prefs.font_factor,
-           approximation   = FontSizes[FontSizesNum-1] + 1;
+           approximation   = prefs.font_sizes[D_FONT_SIZE_NUM-1] + 1;
 
-   for (i = level = 0; i < FontSizesNum; i++)
-      if (approximation >= fabs(normalized_size - FontSizes[i])) {
-         approximation = fabs(normalized_size - FontSizes[i]);
+   for (i = level = 0; i < D_FONT_SIZE_NUM; i++)
+      if (approximation >= fabs(normalized_size - prefs.font_sizes[i])) {
+         approximation = fabs(normalized_size - prefs.font_sizes[i]);
          level = i;
       } else {
          break;
@@ -629,9 +756,9 @@
 static gint Html_level_to_fontsize(gint level)
 {
    level = MAX(0, level);
-   level = MIN(FontSizesNum - 1, level);
+   level = MIN(D_FONT_SIZE_NUM - 1, level);
 
-   return rint(FontSizes[level]*prefs.font_factor);
+   return rint(prefs.font_sizes[level]*prefs.font_factor);
 }
 
 /*
@@ -656,12 +783,12 @@
    font.weight = 400;
    font.style = DW_STYLE_FONT_STYLE_NORMAL;
 
-   a_Dw_style_init_values (&style_attrs, html->bw->main_window->window);
+   a_Dw_style_init_values (&style_attrs, html->dd->bw->main_window->window);
    style_attrs.font = a_Dw_style_font_new (&font);
    style_attrs.color = a_Dw_style_color_new (prefs.text_color,
-                                             html->bw->main_window->window);
+                                             html->dd->bw->main_window->window);
    html->stack[0].style = a_Dw_style_new (&style_attrs,
-                                          html->bw->main_window->window);
+                                          html->dd->bw->main_window->window);
 
    html->stack[0].table_cell_style = NULL;
 
@@ -669,17 +796,17 @@
    Html_connect_signals(html, GTK_OBJECT(widget));
 
    gtk_signal_connect_while_alive (
-      GTK_OBJECT(GTK_BIN(html->bw->docwin)->child), "button_press_event",
-      GTK_SIGNAL_FUNC(Html_page_menu), (gpointer)html->bw, GTK_OBJECT (page));
+      GTK_OBJECT(GTK_BIN(html->dd->docwin)->child), "button_press_event",
+      GTK_SIGNAL_FUNC(Html_page_menu), (gpointer)html->dd, GTK_OBJECT (page));
 
    /* Connect the "bug meter" button-press to the linkblock */
    gtk_signal_connect_while_alive(
-      GTK_OBJECT (html->bw->status_bug_meter), "button_press_event",
+      GTK_OBJECT (html->dd->bw->status_bug_meter), "button_press_event",
       GTK_SIGNAL_FUNC (a_Commands_view_page_bugs_callback),
       (gpointer)html->linkblock, GTK_OBJECT (page));
    /* also connect with the "View page Bugs" menuitem */
    gtk_signal_connect_while_alive(
-      GTK_OBJECT (html->bw->viewbugs_menuitem), "button_press_event",
+      GTK_OBJECT (html->dd->bw->viewbugs_menuitem), "button_press_event",
       GTK_SIGNAL_FUNC (a_Commands_view_page_bugs_callback),
       (gpointer)html->linkblock, GTK_OBJECT (page));
 
@@ -692,7 +819,7 @@
 /*
  * Create and initialize a new DilloHtml structure
  */
-static DilloHtml *Html_new(BrowserWindow *bw, const DilloUrl *url)
+static DilloHtml *Html_new(DilloDoc *dd, const DilloUrl *url)
 {
    DilloHtml *html;
 
@@ -706,8 +833,8 @@
    html->OldTagLine = 1;
 
    html->dw = NULL;
-   html->bw = bw;
-   html->linkblock = Html_lb_new(bw, url);
+   html->dd = dd;
+   html->linkblock = Html_lb_new(dd, url);
 
    html->stack_max = 16;
    html->stack_top = 0;
@@ -715,6 +842,8 @@
    html->stack[0].tag = g_strdup("none");
    html->stack[0].parse_mode = DILLO_HTML_PARSE_MODE_INIT;
    html->stack[0].table_mode = DILLO_HTML_TABLE_MODE_NONE;
+   html->stack[0].frame_mode = DILLO_HTML_FRAME_MODE_NONE;
+   html->stack[0].frameset = NULL;
    html->stack[0].cell_text_align_set = FALSE;
    html->stack[0].list_type = HTML_LIST_NONE; /* no <ul> or <ol> open */
    html->stack[0].list_number = 0;
@@ -736,6 +865,9 @@
 
    html->attr_data = g_string_sized_new(1024);
 
+   html->trans = NULL; /* no conversion yet */
+   html->server_charset = NULL;
+
    Html_set_dwpage(html);
 
    return html;
@@ -753,8 +885,8 @@
 
 /* Entities list from the HTML 4.01 DTD */
 typedef struct {
-   char *entity;
-   int isocode;
+   gchar *entity;
+   guint isocode;
 } Ent_t;
 
 #define NumEnt 252
@@ -824,6 +956,40 @@
    {"yuml",0377},  {"zeta",01666},  {"zwj",020015},  {"zwnj",020014}
 };
 
+/* A table for numbered entities. For Latin-1 text this is a 1-1 mapping.
+ * It is more complicated for other character encodings. */
+static char *NumberedEnts[256] = {
+   "?","\001","\002","\003","\004","\005","\006","\007",
+     "\010","\011","\012","\013","\014","\015","\016","\017",
+     "\020","\021","\022","\023","\024","\025","\026","\027",
+     "\030","\031","\032","\033","\034","\035","\036","\037",
+     "\040","!","\042","#","\044","\045","&","\047",
+     "(",")","*","+",",","-",".","/",
+     "0","1","2","3","4","5","6","7",
+     "8","9",":",";","<","=",">","?",
+     "@","A","B","C","D","E","F","G",
+     "H","I","J","K","L","M","N","O",
+     "P","Q","R","S","T","U","V","W",
+     "X","Y","Z","\133","\134","\135","^","_",
+     "\140","a","b","c","d","e","f","g",
+     "h","i","j","k","l","m","n","o",
+     "p","q","r","s","t","u","v","w",
+     "x","y","z","{","\174","}","~","\177",
+     "\200","\201","\202","\203","\204","\205","\206","\207",
+     "\210","\211","\212","\213","\214","\215","\216","\217",
+     "\220","\221","\222","\223","\224","\225","\226","\227",
+     "\230","\231","\232","\233","\234","\235","\236","\237",
+     " ","!", NULL, NULL, "?", NULL, "|", NULL,
+     NULL, "(c)", "a", "<<", NULL, "-", "(R)", 
+     NULL, NULL, NULL, "^2", "^3", NULL,
+     "\xcc\xa6", NULL, NULL, ",", "^1", NULL, ">>", "1/4",
+     "1/2", "3/4", "?", "A`", "A'", "A^", "A~", "A\"", "A", "AE", "C", "E`",
+     "E'", "E^", "E\"", "I`", "I'", "I^", "I\"", "D", "N~", "O`", "O'", "O^",
+     "O~", "O\"", NULL, "O/", "U`", "U'", "U^", "U\"", "Y'", "?", "ss",
+     "a`", "a'", "a^", "a~", "a\"", "a", "ae", "c", "e`", "e'", "e^", "e\"",
+     "i`", "i'", "i^", "i\"", "?", "n~", "o`", "o'", "o^", "o~", "o\"",
+     NULL, "o/", "u`", "u'", "u^", "u\"", "y'", "Io", "y\""
+};
 
 /*
  * Comparison function for binary search
@@ -863,7 +1029,7 @@
       case 0x2039: ret = '<'; break;
       case 0x203a: ret = '>'; break;
       case 0x2022: ret = 176; break;
-      default:     ret = -1;  break;
+      default:     ret = isocode;  break;
    }
    return ret;
 }
@@ -872,40 +1038,76 @@
  * Given an entity, return the ISO-Latin1 character code.
  * (-1 if not a valid entity)
  */
-static gint Html_parse_entity(const gchar *token, gint toksize)
+static char *Html_parse_entity(const gchar *token, gint toksize)
 {
-   gint base, isocode, i, ret;
-   gchar *eoe, *name;
+   gint base, i;
+   guint isocode;
+   gchar *eoe, *name, *ret = NULL;
 
-   g_return_val_if_fail (token[0] == '&', -1);
+   g_return_val_if_fail (token[0] == '&', NULL);
 
-   ret = -1;
    eoe = (toksize) ? memchr(token, ';', toksize) : strchr(token, ';');
    if (eoe) {
       if (token[1] == '#') {
          /* Numeric token */
          base = (token[2] == 'x' || token[2] == 'X') ? 16 : 10;
          isocode = strtol(token + 2 + (base==16), NULL, base);
-         if (isocode > 0 && isocode <= 255) {
-            ret = isocode;
-         } else {
-            /* Try a few UCS translations to Latin1 */
-            ret = Html_try_ucs2latin1(isocode);
-         }
       } else {
          /* Search for named entity */
          name = g_strndup(token + 1, eoe - token - 1);
          i = Html_entity_search(name);
          g_free(name);
-         if (i != -1) {
-            if (Entities[i].isocode > 0 && Entities[i].isocode <= 255)
-               ret = Entities[i].isocode;
-            else
-               ret = Html_try_ucs2latin1(Entities[i].isocode);
-         }
+         if (i == -1) return NULL;
+         isocode = Entities[i].isocode;
+      }
+      /* Try a few UCS translations to Latin1 */
+      isocode = Html_try_ucs2latin1(isocode);
+      /* Try substitute ascii string. this is a temporary measure */
+      if (!a_I18n_has_latin1_charset()) {
+         if (isocode <= 255) ret = NumberedEnts[isocode];
+         /* latin1 */
+         else if (isocode ==  338) ret = "OE";
+         else if (isocode ==  339) ret = "oe";
+         else if (isocode ==  352) ret = "S^";
+         else if (isocode ==  353) ret = "s^";
+         else if (isocode ==  376) ret = "Y\"";
+         else if (isocode ==  402) ret = "f";
+         else if (isocode ==  710) ret = "^";
+         else if (isocode ==  732) ret = "~";
+         
+         else if (isocode >= 8194 && isocode <= 8207) ret = " ";
+         else if (isocode == 8226) ret = "\xe3\x83\xbb"; //google
+         else if (isocode == 8482) ret = "TM";
+         else if (isocode == 8544) ret = "I";
+         else if (isocode == 8545) ret = "II";
+         else if (isocode == 8546) ret = "III";
+         else if (isocode == 8547) ret = "IV";
+         else if (isocode == 8548) ret = "V";
+         else if (isocode == 8549) ret = "VI";
+         else if (isocode == 8550) ret = "VII";
+         else if (isocode == 8551) ret = "VIII";
+         else if (isocode == 8552) ret = "IX";
+         else if (isocode == 8553) ret = "X";
+         else if (isocode == 8554) ret = "XI";
+         else if (isocode == 8555) ret = "XII";
+         else if (isocode == 8722) ret = "-";
+      }
+      else if (isocode == 8656) ret = "<=";
+      else if (isocode == 8727) ret = "*";
+      else if (isocode == 8764) ret = "~";
+      else if (isocode == 8901) ret = ".";
+      else if (isocode == 9001) ret = "<";
+      else if (isocode == 9002) ret = ">";
+      if (ret) return g_strdup(ret);
+
+      /* Change from UCS2 to Dillo internal code. */
+      {
+         guint ucs2le = GUINT_TO_LE(isocode);
+         gchar wc[3] = {((gchar)ucs2le<<8)>>8, ucs2le>>8, 0};
+         return a_I18n_convert("UCS-2LE", DILLO_CHARSET, wc, 2);
       }
    }
-   return ret;
+   return NULL;
 }
 
 /*
@@ -914,8 +1116,8 @@
  */
 static char *Html_parse_entities(gchar *token, gint toksize)
 {
-   gchar *new_str;
-   gint i, j, isocode;
+   gchar *new_str, *subst, *subst_start;
+   gint i, j;
 
    if ( memchr(token, '&', toksize) == NULL )
       return g_strndup(token, toksize);
@@ -923,8 +1125,13 @@
    new_str = g_new(char, toksize + 1);
    for (i = j = 0; i < toksize; i++) {
       if (token[i] == '&' &&
-          (isocode = Html_parse_entity(token + i, toksize - i)) != -1) {
-         new_str[j++] = isocode;
+          (subst_start = Html_parse_entity(token + i, toksize - i)) != NULL) {
+         subst = subst_start;
+         while (*subst != '\0'){ /* insert the actual character */
+            new_str[j++] = *subst;
+            subst++;
+         }
+         g_free(subst_start);
          while (token[++i] != ';');
       } else {
          new_str[j++] = token[i];
@@ -969,7 +1176,7 @@
          case '\n':
             break;
          case '\t':
-            MSG_HTML("TAB character inside <PRE>\n");
+            MSG_HTML(_("TAB character inside <PRE>\n"));
             offset = TAB_SIZE - html->pre_column % TAB_SIZE;
             a_Dw_page_add_text(DW_PAGE (html->dw),
                                g_strnfill(offset, ' '),
@@ -1162,6 +1369,23 @@
 static void Html_tag_cond_cleanup(DilloHtml *html, char *tag, gint tagsize,
                                   gint old_mode)
 {
+#if 1
+   gint stack_idx;
+   for (stack_idx = html->stack_top; stack_idx > 0; stack_idx--) {
+      if (Html_match_tag(html->stack[stack_idx].tag, tag + 2, tagsize - 2)) {
+         while (html->stack_top >= stack_idx) {
+            a_Dw_style_unref (html->stack[html->stack_top].style);
+            if (html->stack[html->stack_top].table_cell_style)
+               a_Dw_style_unref(html->stack[html->stack_top].table_cell_style);
+            g_free(html->stack[html->stack_top--].tag);
+         }
+         Html_eventually_pop_dw(html);
+         return;
+      }
+      if (Html_match_tag(html->stack[stack_idx].tag, "table>", 6))
+         break;
+   }
+#else
    gint stack_idx, cmp = 1;
 
    /* Look for the candidate tag to close */
@@ -1171,6 +1395,8 @@
                         html->stack[stack_idx].tag)) &&
           (old_mode ||
            Html_tags_get_endtag(html->stack[stack_idx].tag_idx) == 'O')){
+      if (Html_match_tag(html->stack[stack_idx].tag, "table>", 6))
+         break;
       --stack_idx;
    }
    if (stack_idx == 0)
@@ -1189,10 +1415,11 @@
 
    } else {
       gchar *stag = g_strndup(tag, tagsize);
-      MSG_HTML("unexpected closing tag: %s. -- expected </%s>\n",
+      MSG_HTML(_("unexpected closing tag: %s. -- expected </%s>\n"),
                stag, html->stack[stack_idx].tag);
       g_free(stag);
    }
+#endif
 }
 
 /*
@@ -1267,7 +1494,7 @@
    else {
       /* allow only whitespaces */
       if (*end && !isspace (*end)) {
-         MSG_HTML("Garbage after length: %s\n", attr);
+         MSG_HTML(_("Garbage after length: %s\n"), attr);
          return DW_STYLE_LENGTH_AUTO;
       }
    }
@@ -1320,7 +1547,7 @@
    gint32 color = a_Color_parse(subtag, default_color, &err);
 
    if (err) {
-      MSG_HTML("color is not in \"#RRGGBB\" format\n");
+      MSG_HTML(_("color is not in \"#RRGGBB\" format\n"));
    }
    return color;
 }
@@ -1331,7 +1558,7 @@
 static void Html_tag_open_head(DilloHtml *html, char *tag, gint tagsize)
 {
    if (html->InFlags & IN_BODY) {
-      MSG_HTML("HEAD element must go before the BODY section\n");
+      MSG_HTML(_("HEAD element must go before the BODY section\n"));
    } else {
       Html_push_tag(html, tag, tagsize);
       html->InFlags |= IN_HEAD;
@@ -1365,10 +1592,10 @@
 {
    if (html->InFlags & IN_HEAD) {
       /* title is only valid inside HEAD */
-      a_Interface_set_page_title(html->linkblock->bw, html->Stash->str);
-      a_History_set_title(NAV_TOP(html->linkblock->bw), html->Stash->str);
+      a_Doc_title_set(html->linkblock->dd, html->Stash->str);
+      a_History_set_title(NAV_TOP(html->linkblock->dd), html->Stash->str);
    } else {
-      MSG_HTML("the TITLE element must be inside the HEAD section\n");
+      MSG_HTML(_("the TITLE element must be inside the HEAD section\n"));
    }
    Html_pop_tag(html, tag, tagsize);
 }
@@ -1424,6 +1651,14 @@
    DwPage *page;
    DwStyle style_attrs, *style;
    gint32 color;
+   /* if document contains frameset, ignore body */
+   if(html->InFlags & IN_FRAMESET) return;
+   /* in body, so hide/remove frameset and show docwin */
+   if(html->dd->frameset && GTK_IS_WIDGET(html->dd->frameset)) {
+     gtk_widget_destroy(html->dd->frameset);
+     html->dd->frameset = NULL;
+     gtk_widget_show(GTK_WIDGET(html->dd->docwin));
+   }
 
    page = DW_PAGE (html->dw);
 
@@ -1438,8 +1673,8 @@
 
          style_attrs = *html->dw->style;
          style_attrs.background_color =
-            a_Dw_style_color_new (color, html->bw->main_window->window);
-         style = a_Dw_style_new (&style_attrs, html->bw->main_window->window);
+            a_Dw_style_color_new (color, html->dd->bw->main_window->window);
+         style = a_Dw_style_new (&style_attrs, html->dd->bw->main_window->window);
          a_Dw_widget_set_style (html->dw, style);
          a_Dw_style_unref (style);
          html->stack[html->stack_top].current_bg_color = color;
@@ -1449,7 +1684,7 @@
          color = Html_color_parse(html, attrbuf, prefs.text_color);
          HTML_SET_TOP_ATTR
             (html, color,
-             a_Dw_style_color_new (color, html->bw->main_window->window));
+             a_Dw_style_color_new (color, html->dd->bw->main_window->window));
       }
 
       if ((attrbuf = Html_get_attr(html, tag, tagsize, "link")))
@@ -1527,7 +1762,7 @@
       (&style_attrs,
        a_Dw_style_shaded_color_new (
           html->stack[html->stack_top].current_bg_color,
-          html->bw->main_window->window));
+          html->dd->bw->main_window->window));
    a_Dw_style_box_set_border_style (&style_attrs, DW_STYLE_BORDER_OUTSET);
    style_attrs.border_spacing = cellspacing;
 
@@ -1551,11 +1786,11 @@
             bgcolor = prefs.bg_color;
          html->stack[html->stack_top].current_bg_color = bgcolor;
          style_attrs.background_color =
-            a_Dw_style_color_new (bgcolor, html->bw->main_window->window);
+            a_Dw_style_color_new (bgcolor, html->dd->bw->main_window->window);
       }
    }
 
-   tstyle = a_Dw_style_new (&style_attrs, html->bw->main_window->window);
+   tstyle = a_Dw_style_new (&style_attrs, html->dd->bw->main_window->window);
 
    /* The style for the cells */
    style_attrs = *html->stack[html->stack_top].style;
@@ -1572,7 +1807,7 @@
 
    old_style = html->stack[html->stack_top].table_cell_style;
    html->stack[html->stack_top].table_cell_style =
-      a_Dw_style_new (&style_attrs, html->bw->main_window->window);
+      a_Dw_style_new (&style_attrs, html->dd->bw->main_window->window);
    if (old_style)
       a_Dw_style_unref (old_style);
 
@@ -1603,11 +1838,11 @@
 
    switch (html->stack[html->stack_top].table_mode) {
    case DILLO_HTML_TABLE_MODE_NONE:
-      MSG_HTML("<td> or <th> outside <table>\n");
+      MSG_HTML(_("<td> or <th> outside <table>\n"));
       return;
 
    case DILLO_HTML_TABLE_MODE_TOP:
-      MSG_HTML("<td> or <th> outside <tr>\n");
+      MSG_HTML(_("<td> or <th> outside <tr>\n"));
       /* a_Dw_table_add_cell takes care that dillo does not crash. */
       /* continues */
    case DILLO_HTML_TABLE_MODE_TR:
@@ -1629,7 +1864,7 @@
          style_attrs.white_space = DW_STYLE_WHITE_SPACE_NORMAL;
 
       html->stack[html->stack_top].style =
-         a_Dw_style_new (&style_attrs, html->bw->main_window->window);
+         a_Dw_style_new (&style_attrs, html->dd->bw->main_window->window);
       a_Dw_style_unref (old_style);
       Html_tag_set_align_attr (html, tag, tagsize);
 
@@ -1654,7 +1889,7 @@
 
             new_style = TRUE;
             style_attrs.background_color =
-               a_Dw_style_color_new (bgcolor, html->bw->main_window->window);
+               a_Dw_style_color_new (bgcolor, html->dd->bw->main_window->window);
             html->stack[html->stack_top].current_bg_color = bgcolor;
          }
       }
@@ -1668,7 +1903,7 @@
          col_page = a_Dw_page_new ();
 
       if (new_style) {
-         style = a_Dw_style_new (&style_attrs, html->bw->main_window->window);
+         style = a_Dw_style_new (&style_attrs, html->dd->bw->main_window->window);
          a_Dw_widget_set_style (col_page, style);
          a_Dw_style_unref (style);
       } else
@@ -1755,9 +1990,9 @@
 
             style_attrs = *html->stack[html->stack_top].style;
             style_attrs.background_color =
-               a_Dw_style_color_new (bgcolor, html->bw->main_window->window);
+               a_Dw_style_color_new (bgcolor, html->dd->bw->main_window->window);
             style =
-               a_Dw_style_new (&style_attrs, html->bw->main_window->window);
+               a_Dw_style_new (&style_attrs, html->dd->bw->main_window->window);
             html->stack[html->stack_top].current_bg_color = bgcolor;
          }
       }
@@ -1776,7 +2011,7 @@
       if (Html_tag_set_valign_attr (html, tag, tagsize, &style_attrs)) {
          old_style = html->stack[html->stack_top].table_cell_style;
          html->stack[html->stack_top].table_cell_style =
-            a_Dw_style_new (&style_attrs, html->bw->main_window->window);
+            a_Dw_style_new (&style_attrs, html->dd->bw->main_window->window);
          a_Dw_style_unref (old_style);
       } else
 
@@ -1794,86 +2029,314 @@
 #endif
 }
 
-/*
- * <FRAME>, <IFRAME>
- * todo: This is just a temporary fix while real frame support
- *       isn't finished. Imitates lynx/w3m's frames.
+static void Html_tag_open_noframes (DilloHtml *html, gchar *tag, gint tagsize)
+{
+   if(html->stack[html->stack_top].frame_mode == DILLO_HTML_FRAME_MODE_NONE)
+      MSG_HTML(_("<noframes> outside of <frameset>!!!\n"));
+   /* This code will allow the misuse of <noframes> which often exists. */
+   html->stack[html->stack_top].frame_mode = DILLO_HTML_FRAME_MODE_NOFRAMES;
+}
+
+/* Warning : this is illegal tag not existing! */
+static void Html_tag_open_noframe (DilloHtml *html, gchar *tag, gint tagsize)
+{
+   MSG_HTML(_("<noframe> is illegal tag !!! use <noframes>.\n"));
+   Html_tag_open_noframes (html, tag, tagsize);
+}
+
+/* 
+ * <IFRAME>
  */
-static void Html_tag_open_frame (DilloHtml *html, gchar *tag, gint tagsize)
+static void Html_tag_open_iframe (DilloHtml *html, gchar *tag, gint tagsize)
 {
    const char *attrbuf;
-   gchar *src, *buf;
    DilloUrl *url;
+   GtkWidget *box;
+   DwWidget *embed;
+   DilloDoc *dd;
    DwPage *page;
-   DwStyle style_attrs, *link_style;
-   DwWidget *bullet;
-   gint buf_size;
+   //   DwStyle style_attrs, *estyle, *fstyle; /* estyle is for embedding widget, fstyle for iframe */
+   DwStyle style_attrs, *estyle;
+   gchar *width_ptr, *height_ptr;
+   gboolean frameborder;
+   guint marginwidth, marginheight;
+   GtkPolicyType scrolling;
+   gchar *attrbuf_enc;
+
+   Html_cleanup_tag(html, "p>");
+   Html_cleanup_tag(html, "frame>");
 
-   page = DW_PAGE(html->dw);
+   Html_push_tag(html, tag, tagsize);
+   Html_tag_set_align_attr(html, tag, tagsize);
+   /* ignore the rest of the text inside the tag
+    *(it is the equivalent of a <noframes> block) */
+   html->stack[html->stack_top].parse_mode = DILLO_HTML_PARSE_MODE_VERBATIM;
+   html->stack[html->stack_top].frame_mode = DILLO_HTML_FRAME_MODE_IFRAME;
 
+   /* no link == return */
    if ( !(attrbuf = Html_get_attr(html, tag, tagsize, "src")) )
       return;
-
-   if (!(url = Html_url_new(html, attrbuf, NULL, 0, 0, 0, 0)))
+   if (strlen(attrbuf) == 0) return;
+   attrbuf_enc = a_I18n_convert(DILLO_CHARSET, html->linkblock->charset,
+         attrbuf, -1);
+   if (!(url = Html_url_new(html, attrbuf_enc, NULL, 0, 0, 0, 0))) {
+      g_free(attrbuf_enc);
       return;
+   }
+   g_free(attrbuf_enc);
+   
+   page = DW_PAGE (html->dw);
+   style_attrs = *html->stack[html->stack_top].style;
 
-   src = g_strdup(attrbuf);
+   /* use default for width (300) and height (150) if not specified */
+   if ((attrbuf = Html_get_attr(html, tag, tagsize, "width")))
+     width_ptr = g_strdup(attrbuf);
+   else
+     width_ptr = g_strdup("300");
 
-   style_attrs = *(html->stack[html->stack_top].style);
+   if ((attrbuf = Html_get_attr(html, tag, tagsize, "height")))
+     height_ptr = g_strdup(attrbuf);
+   else
+     height_ptr = g_strdup("150");
 
-   if (a_Capi_get_buf(url, &buf, &buf_size))  /* visited frame */
-      style_attrs.color = a_Dw_style_color_new
-         (html->linkblock->visited_color, html->bw->main_window->window);
-   else                                /* unvisited frame */
-      style_attrs.color = a_Dw_style_color_new
-         (html->linkblock->link_color,  html->bw->main_window->window);
+   if ((attrbuf = Html_get_attr(html, tag, tagsize, "frameborder")))
+     frameborder = (strtol (attrbuf, NULL, 10) == 0 ? FALSE : TRUE);
+   else
+     frameborder = TRUE;
 
-   style_attrs.text_decoration |= DW_STYLE_TEXT_DECORATION_UNDERLINE;
-   style_attrs.x_link = Html_set_new_link(html, &url);
-   link_style = a_Dw_style_new (&style_attrs,
-                                html->bw->main_window->window);
-
-   a_Dw_page_add_parbreak(page, 5, html->stack[(html)->stack_top].style);
-
-   /* The bullet will be assigned the current list style, which should
-    * be "disc" by default, but may in very weird pages be different.
-    * Anyway, there should be no harm. */
-   bullet = a_Dw_bullet_new();
-   a_Dw_page_add_widget(page, bullet, html->stack[html->stack_top].style);
-   a_Dw_page_add_space(page, html->stack[html->stack_top].style);
-
-   if (tolower(tag[1]) == 'i') {
-      /* IFRAME usually comes with very long advertising/spying URLS,
-       * to not break rendering we will force name="IFRAME" */
-      a_Dw_page_add_text(page, g_strdup("IFRAME"), link_style);
+   if ((attrbuf = Html_get_attr(html, tag, tagsize, "marginwidth")))
+     marginwidth = strtol (attrbuf, NULL, 10);
+   else
+     marginwidth = 0;
 
-   } else {
-      /* FRAME:
-       * If 'name' tag is present use it, if not use 'src' value */
-      if ( !(attrbuf = Html_get_attr(html, tag, tagsize, "name")) ) {
-         a_Dw_page_add_text(page, g_strdup(src), link_style);
-      } else {
-         a_Dw_page_add_text(page, g_strdup(attrbuf), link_style);
-      }
+   if ((attrbuf = Html_get_attr(html, tag, tagsize, "marginheight")))
+     marginheight = strtol (attrbuf, NULL, 10);
+   else
+     marginheight = 0;
+
+   if ((attrbuf = Html_get_attr(html, tag, tagsize, "scrolling")))
+     scrolling = (!g_strcasecmp(attrbuf, "no") ? GTK_POLICY_NEVER :
+		  (!g_strcasecmp(attrbuf, "yes") ? GTK_POLICY_ALWAYS : GTK_POLICY_AUTOMATIC));
+   else
+     scrolling = GTK_POLICY_AUTOMATIC;
+     
+   dd = a_Doc_new();
+   a_Doc_set_parent(dd, (html)->dd);
+   /* set margins */
+   (dd->style)->margin.left = (dd->style)->margin.right = marginwidth;
+   (dd->style)->margin.top = (dd->style)->margin.bottom = marginheight;
+   /* set border */
+   if(!frameborder)
+     a_Dw_style_box_set_val(&((dd->style)->border_width), frameborder);
+
+   box = gtk_hbox_new(TRUE, 0);
+   gtk_container_set_border_width(GTK_CONTAINER(dd->docwin), 0);
+   gtk_container_set_border_width(GTK_CONTAINER(box), 0);
+   gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(dd->docwin), scrolling, scrolling);
+   gtk_box_pack_start(GTK_BOX(box), GTK_WIDGET(dd->docwin), TRUE, TRUE, 0);
+   gtk_widget_show(GTK_WIDGET(box));
+
+   /* style for the embedding widget */
+   a_Dw_style_box_set_border_style(&style_attrs, DW_STYLE_BORDER_NONE);
+   a_Dw_style_box_set_val(&style_attrs.margin, 0);
+   a_Dw_style_box_set_val(&style_attrs.border_width, 0);
+   estyle = a_Dw_style_new (&style_attrs, html->dd->bw->main_window->window);
+
+   embed = a_Dw_embed_gtk_new();
+   a_Dw_embed_gtk_add_gtk(DW_EMBED_GTK(embed), GTK_WIDGET(box));
+   Html_add_widget(html, (DwWidget *) embed, width_ptr, height_ptr, estyle);
+   
+   a_Dw_style_unref(estyle);   
+   g_free(width_ptr);
+   g_free(height_ptr);
+
+   /* set iframe name if specified */
+   if((attrbuf = Html_get_attr(html, tag, tagsize, "name")))
+     a_Doc_set_name(dd, (gchar *) attrbuf);
+   
+   a_Url_set_referer(url, html->linkblock->base_url);
+   a_Nav_push(dd, url);
+}
+
+/*
+ * <FRAME>
+ */
+static void Html_tag_open_frame (DilloHtml *html, gchar *tag, gint tagsize)
+{
+   const char *attrbuf;
+   DilloUrl *url;
+   GtkWidget *box;
+   DilloDoc *dd;
+   gboolean frameborder, noresize;
+   guint marginwidth, marginheight;
+   GtkPolicyType scrolling;
+   gchar *attrbuf_enc;
+
+   Html_cleanup_tag(html, "p>");
+   Html_cleanup_tag(html, "frame>");
+
+   /* no link == return */
+   if ( !(attrbuf = Html_get_attr(html, tag, tagsize, "src")) )
+      return;
+   if (strlen(attrbuf) == 0) 
+      return;
+   attrbuf_enc = a_I18n_convert(DILLO_CHARSET, html->linkblock->charset,
+            attrbuf, -1);
+   if (!(url = Html_url_new(html, attrbuf_enc, NULL, 0, 0, 0, 0))) {
+      g_free(attrbuf_enc);
+      return;
    }
+   g_free(attrbuf_enc);
+   
+
+   if ((attrbuf = Html_get_attr(html, tag, tagsize, "frameborder")))
+     frameborder = (strtol (attrbuf, NULL, 10) == 0 ? FALSE : TRUE);
+   else
+     frameborder = TRUE;
+
+   if ((attrbuf = Html_get_attr(html, tag, tagsize, "noresize")))
+     noresize = TRUE;
+   else
+     noresize = FALSE;
+
+   /* if margins have not been set explicitly, use defaults */
+   if ((attrbuf = Html_get_attr(html, tag, tagsize, "marginwidth")))
+     marginwidth = strtol (attrbuf, NULL, 10);
+   else
+     marginwidth = DOC_DEFAULT_MARGIN;
+
+   if ((attrbuf = Html_get_attr(html, tag, tagsize, "marginheight")))
+     marginheight = strtol (attrbuf, NULL, 10);
+   else
+     marginheight = DOC_DEFAULT_MARGIN;
+
+   if ((attrbuf = Html_get_attr(html, tag, tagsize, "scrolling")))
+     scrolling = (!g_strcasecmp(attrbuf, "no") ? GTK_POLICY_NEVER :
+		  (!g_strcasecmp(attrbuf, "yes") ? GTK_POLICY_ALWAYS : GTK_POLICY_AUTOMATIC));
+   else
+     scrolling = GTK_POLICY_AUTOMATIC;
 
-   a_Dw_page_add_parbreak(page, 5, html->stack[(html)->stack_top].style);
+   DEBUG_MSG(DEBUG_EVENT, "      URL %s\n", attrbuf);
 
-   a_Dw_style_unref(link_style);
-   g_free(src);
+   switch(html->stack[html->stack_top].frame_mode) {
+   case DILLO_HTML_FRAME_MODE_NONE:
+     MSG_HTML(_("<frame> outside of <frameset>\n"));
+     return;
+   case DILLO_HTML_FRAME_MODE_NOFRAMES:
+     MSG_HTML(_("<frame> inside of <noframes>\n"));
+     return;
+   case DILLO_HTML_FRAME_MODE_IFRAME:
+     MSG_HTML(_("<frame> inside of <iframe>\n"));
+     return;
+   case DILLO_HTML_FRAME_MODE_FRAMESET:
+     dd = a_Doc_new();
+     a_Doc_set_parent(dd, (html)->dd);
+     /* set marginwidth & height */
+     (dd->style)->margin.left = (dd->style)->margin.right = marginwidth;
+     (dd->style)->margin.top = (dd->style)->margin.bottom = marginheight;
+     if(!frameborder) {
+       a_Dw_style_box_set_val(&((dd->style)->border_width), 0);
+       a_Dw_style_box_set_border_style(dd->style, DW_STYLE_BORDER_NONE);
+     }
+     box = gtk_hbox_new(TRUE, 0);
+     gtk_box_pack_start(GTK_BOX(box), GTK_WIDGET(dd->docwin), TRUE, TRUE, 0);
+     gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(dd->docwin), scrolling, scrolling);
+     gtk_container_set_border_width(GTK_CONTAINER(dd->docwin), 0);
+     gtk_container_set_border_width(GTK_CONTAINER(box), 0);
+     gtk_widget_show(GTK_WIDGET(box));
+     gtk_container_add_with_args(GTK_CONTAINER(html->stack[html->stack_top].frameset),
+				 GTK_WIDGET(box),
+				 "GtkFrameset::x_padding", 0,
+				 "GtkFrameset::y_padding", 0,
+				 "GtkFrameset::noresize", noresize,
+				 "GtkFrameset::border", frameborder,
+				 NULL);
+     a_Url_set_referer(url, html->linkblock->base_url);
+     a_Nav_push(dd, url);
+
+     /* set frame name if specified */
+     if((attrbuf = Html_get_attr(html, tag, tagsize, "name")))
+       a_Doc_set_name(dd, (gchar *) attrbuf);
+     break;
+     
+   default:
+     return;
+   }
 }
 
 /*
  * <FRAMESET>
- * todo: This is just a temporary fix while real frame support
- *       isn't finished. Imitates lynx/w3m's frames.
  */
 static void Html_tag_open_frameset (DilloHtml *html, gchar *tag, gint tagsize)
 {
+   const char *attrbuf;
+   GtkWidget *frameset;
+   gchar *rows, *cols;
+
+   /* (older versions of) compiler happiness */
+   frameset = NULL;
+
+   /* first, see if this frameset tag is in the right place... */
+   if(html->stack[html->stack_top].parse_mode != DILLO_HTML_PARSE_MODE_INIT) {
+     MSG_HTML(_("incorrectly placed <frameset>\n"));
+     return;
+   }
+
+   /* get frameset attributes */
+   if ((attrbuf = Html_get_attr(html, tag, tagsize, "rows")))
+     rows = g_strdup(attrbuf);
+   else
+     rows = NULL;
+   if ((attrbuf = Html_get_attr(html, tag, tagsize, "cols")))
+     cols = g_strdup(attrbuf);
+   else
+     cols = NULL;
+
+   switch(html->stack[html->stack_top].frame_mode) {
+   case DILLO_HTML_FRAME_MODE_NOFRAMES:
+     MSG_HTML(_("<frameset> inside of <noframes>\n"));
+     g_free(rows);
+     g_free(cols);
+     return;
+   case DILLO_HTML_FRAME_MODE_IFRAME:
+     MSG_HTML(_("<frameset> inside of <iframe>\n"));
+     g_free(rows);
+     g_free(cols);
+     return;
+   case DILLO_HTML_FRAME_MODE_NONE:
+     /* 'root' frameset, so add the frameset to the dd */
+     if(html->dd->frameset)
+       gtk_widget_destroy(html->dd->frameset);
+     frameset = gtk_frameset_new(rows, cols);
+     html->dd->frameset = frameset;
+     gtk_container_add(GTK_CONTAINER(GTK_WIDGET(html->dd->docwin)->parent),
+		       GTK_WIDGET(frameset));
+     /* hide the docwin, show the frameset */     
+     gtk_widget_hide(GTK_WIDGET(html->dd->docwin));
+     gtk_widget_show(GTK_WIDGET(html->dd->frameset));
+     break;
+   case DILLO_HTML_FRAME_MODE_FRAMESET:
+     /* nested frameset */
+     frameset = gtk_frameset_new(rows, cols);
+     gtk_container_add(GTK_CONTAINER(html->stack[html->stack_top].frameset), GTK_WIDGET(frameset));
+     gtk_widget_show(GTK_WIDGET(frameset));
+     break;
+   default:
+     break;
+   }
+
+   g_free(rows);
+   g_free(cols);
+
    Html_par_push_tag(html, tag, tagsize);
-   a_Dw_page_add_text(DW_PAGE(html->dw), g_strdup("--FRAME--"),
-                      html->stack[html->stack_top].style);
-   Html_add_indented(html, 40, 0, 5);
+
+   /* once set, this flag does not get reset, even when the frameset tag
+    * is closed. This is intentional. */
+   html->InFlags |= IN_FRAMESET;
+
+   /* put the current frameset state on the stack */
+   html->stack[html->stack_top].frame_mode = DILLO_HTML_FRAME_MODE_FRAMESET;
+   html->stack[html->stack_top].frameset = frameset;
 }
 
 /*
@@ -1885,13 +2348,13 @@
 
    /* todo: combining these two would be slightly faster */
    Html_set_top_font(html, prefs.vw_fontname,
-                     Html_level_to_fontsize(FontSizesNum - (tag[2] - '0')),
+                     Html_level_to_fontsize(D_FONT_SIZE_NUM - (tag[2] - '0')),
                      1, 3);
    Html_tag_set_align_attr (html, tag, tagsize);
 
    /* First finalize unclosed H tags (we test if already named anyway) */
-   a_Menu_pagemarks_set_text(html->bw, html->Stash->str);
-   a_Menu_pagemarks_add(html->bw, DW_PAGE (html->dw),
+   a_Pagemark_set_text(html->dd, html->Stash->str, html->Stash->len);
+   a_Pagemark_add(html->dd, DW_PAGE (html->dw),
                         html->stack[html->stack_top].style, (tag[2] - '0'));
    Html_stash_init(html);
    html->stack[html->stack_top].parse_mode =
@@ -1903,7 +2366,7 @@
  */
 static void Html_tag_close_h(DilloHtml *html, char *tag, gint tagsize)
 {
-   a_Menu_pagemarks_set_text(html->bw, html->Stash->str);
+   a_Pagemark_set_text(html->dd, html->Stash->str, html->Stash->len);
    Html_pop_tag(html, tag, tagsize);
    a_Dw_page_add_parbreak(DW_PAGE (html->dw), 9,
                           html->stack[(html)->stack_top].style);
@@ -1957,7 +2420,7 @@
    a_Dw_style_box_set_val(&style_attrs.margin, 0);
    a_Dw_style_box_set_val(&style_attrs.border_width, 0);
    a_Dw_style_box_set_val(&style_attrs.padding, 0);
-   style = a_Dw_style_new (&style_attrs, html->bw->main_window->window);
+   style = a_Dw_style_new (&style_attrs, html->dd->bw->main_window->window);
    button = a_Dw_button_new (DW_USES_HINTS, TRUE);
 
    /* The new button is not set button-insensitive, since nested buttons
@@ -1971,7 +2434,7 @@
    a_Dw_style_unref (style);
 
    a_Dw_style_box_set_val(&style_attrs.margin, 5);
-   style = a_Dw_style_new (&style_attrs, html->bw->main_window->window);
+   style = a_Dw_style_new (&style_attrs, html->dd->bw->main_window->window);
    page = a_Dw_page_new ();
    a_Dw_widget_set_style (page, style);
    a_Dw_style_unref (style);
@@ -2040,7 +2503,7 @@
             color = Html_color_parse(
                        html, attrbuf, style_attrs.color->color_val);
             style_attrs.color = a_Dw_style_color_new
-               (color, html->bw->main_window->window);
+               (color, html->dd->bw->main_window->window);
          }
       }
 
@@ -2053,7 +2516,7 @@
 #endif
 
       html->stack[html->stack_top].style =
-         a_Dw_style_new (&style_attrs, html->bw->main_window->window);
+         a_Dw_style_new (&style_attrs, html->dd->bw->main_window->window);
       a_Dw_style_unref (old_style);
    }
 
@@ -2158,7 +2621,7 @@
       alt_ptr = g_strdup(attrbuf);
 
    if ((width_ptr && !height_ptr) || (height_ptr && !width_ptr))
-      MSG_HTML("IMG tag only specifies <%s>\n",
+      MSG_HTML(_("IMG tag only specifies <%s>\n"),
                (width_ptr) ? "width" : "height");
 
    /* Spacing to the left and right */
@@ -2198,15 +2661,16 @@
 {
    DilloWeb *Web;
    gint ClientKey;
+   a_Url_set_referer(url, html->linkblock->base_url);
    /* Fill a Web structure for the cache query */
    Web = a_Web_new(url);
-   Web->bw = html->bw;
+   Web->dd = html->dd;
    Web->Image = Image;
    Web->flags |= WEB_Image;
    /* Request image data from the cache */
    if ((ClientKey = a_Capi_open_url(Web, NULL, NULL)) != 0) {
-      a_Interface_add_client(html->bw, ClientKey, 0);
-      a_Interface_add_url(html->bw, url, WEB_Image);
+      a_Doc_add_client(html->dd, ClientKey, 0);
+      a_Doc_add_url(html->dd, url, WEB_Image);
    }
 }
 
@@ -2222,23 +2686,35 @@
    DwPage *page;
    DwStyle style_attrs;
    const char *attrbuf;
+   gchar *attrbuf_enc;
    gint border;
 
    /* This avoids loading images. Useful for viewing suspicious HTML email. */
    if (URL_FLAGS(html->linkblock->base_url) & URL_SpamSafe)
       return;
 
-   if (!(attrbuf = Html_get_attr(html, tag, tagsize, "src")) ||
-       !(url = Html_url_new(html, attrbuf, NULL, 0, 0, 0, 0)))
+   if (!(attrbuf = Html_get_attr(html, tag, tagsize, "src")))
+      return;
+
+   attrbuf_enc = a_I18n_convert(DILLO_CHARSET, html->linkblock->charset,
+            attrbuf, -1);
+   if(!(url = Html_url_new(html, attrbuf_enc, NULL, 0, 0, 0, 0))) {
+      g_free(attrbuf_enc);
       return;
+   }
+   g_free(attrbuf_enc);
 
    page = DW_PAGE (html->dw);
 
 
    usemap_url = NULL;
-   if ((attrbuf = Html_get_attr(html, tag, tagsize, "usemap")))
+   if ((attrbuf = Html_get_attr(html, tag, tagsize, "usemap"))) {
+      attrbuf_enc = a_I18n_convert(DILLO_CHARSET, html->linkblock->charset,
+            attrbuf, -1);
       /* todo: usemap URLs outside of the document are not used. */
-      usemap_url = Html_url_new(html, attrbuf, NULL, 0, 0, 0, 0);
+      usemap_url = Html_url_new(html, attrbuf_enc, NULL, 0, 0, 0, 0);
+      g_free(attrbuf_enc);
+   }
 
    style_attrs = *html->stack[html->stack_top].style;
 
@@ -2254,21 +2730,23 @@
          a_Dw_style_box_set_border_color
             (&style_attrs,
              a_Dw_style_shaded_color_new (style_attrs.color->color_val,
-                                          html->bw->main_window->window));
+                                          html->dd->bw->main_window->window));
       else
          a_Dw_style_box_set_border_color
             (&style_attrs,
              a_Dw_style_shaded_color_new (html->linkblock->link_color,
-                                          html->bw->main_window->window));
+                                          html->dd->bw->main_window->window));
 
       a_Dw_style_box_set_border_style (&style_attrs, DW_STYLE_BORDER_SOLID);
       a_Dw_style_box_set_val (&style_attrs.border_width, border);
    }
 
    Image = Html_add_new_image(html, tag, tagsize, &style_attrs, TRUE);
+   if (html->stack[html->stack_top].style->x_link != -1)
+     a_Dw_widget_set_button_sensitive(DW_WIDGET(Image->dw), FALSE);
    Html_connect_signals(html, GTK_OBJECT(Image->dw));
    gtk_signal_connect_after(GTK_OBJECT(Image->dw), "button_press_event",
-                            GTK_SIGNAL_FUNC(Html_image_menu), html->bw);
+                            GTK_SIGNAL_FUNC(Html_image_menu), html->dd);
 
    /* Image maps */
    if (Html_get_attr(html, tag, tagsize, "ismap")) {
@@ -2276,7 +2754,7 @@
        * being separated with a word, only the first one is ISMAPed
        */
       a_Dw_image_set_ismap (Image->dw);
-      _MSG("  Html_tag_open_img: server-side map (ISMAP)\n");
+      _MSG(_("  Html_tag_open_img: server-side map (ISMAP)\n"));
    } else if (html->stack[html->stack_top].style->x_link != -1 &&
               usemap_url == NULL)
       /* For simple links, we have to suppress the "image_pressed" signal.
@@ -2298,16 +2776,19 @@
 static void Html_tag_open_map(DilloHtml *html, char *tag, gint tagsize)
 {
    char *hash_name;
-   const char *attrbuf;
+   char *attrbuf_enc;
    DilloUrl *url;
 
    Html_push_tag(html, tag, tagsize);
 
    if (html->InFlags & IN_MAP) {
-      MSG_HTML("nested <map>\n");
+      MSG_HTML(_("nested <map>\n"));
    } else {
-      if ((attrbuf = Html_get_attr(html, tag, tagsize, "name"))) {
-         hash_name = g_strdup_printf("#%s", attrbuf);
+      if ((attrbuf_enc = a_I18n_convert(DILLO_CHARSET,
+                  html->linkblock->charset,
+                  Html_get_attr(html, tag, tagsize, "name"), -1))) {
+         hash_name = g_strdup_printf("#%s", attrbuf_enc);
+         g_free(attrbuf_enc);
          url = Html_url_new(html, hash_name, NULL, 0, 0, 0, 0);
          a_Dw_image_map_list_add_map (&html->linkblock->maps, url);
          a_Url_free (url);
@@ -2353,7 +2834,7 @@
          pending = 0;
       } else {
          if (*newtail != ',') {
-            MSG_HTML("usemap coords MUST be separated with ','\n");
+            MSG_HTML(_("usemap coords MUST be separated with ','\n"));
          }
          tail = newtail + 1;
       }
@@ -2371,6 +2852,7 @@
    GdkPoint point[1024];
    DilloUrl* url;
    const char *attrbuf;
+   gchar *attrbuf_enc;
    gint type = DW_IMAGE_MAP_SHAPE_RECT;
    gint nbpoints, link = -1;
 
@@ -2396,14 +2878,21 @@
 
    if ( Html_get_attr(html, tag, tagsize, "nohref") ) {
       link = -1;
-      _MSG("nohref");
+      _MSG(_("nohref"));
    }
 
    if ((attrbuf = Html_get_attr(html, tag, tagsize, "href"))) {
-      url = Html_url_new(html, attrbuf, NULL, 0, 0, 0, 0);
+      attrbuf_enc = a_I18n_convert(DILLO_CHARSET, html->linkblock->charset,
+            attrbuf, -1);
+      url = Html_url_new(html, attrbuf_enc, NULL, 0, 0, 0, 0);
+      g_free(attrbuf_enc);
       g_return_if_fail ( url != NULL );
       if ((attrbuf = Html_get_attr(html, tag, tagsize, "alt")))
          a_Url_set_alt(url, attrbuf);
+      if ((attrbuf = Html_get_attr(html, tag, tagsize, "target")))
+         a_Url_set_target(url, attrbuf);
+      else if (URL_TARGET_(html->linkblock->base_url))
+	   a_Url_set_target(url, URL_TARGET_(html->linkblock->base_url));
 
       link = Html_set_new_link(html, &url);
    }
@@ -2423,6 +2912,8 @@
    const char *attrbuf;
    gchar *buf;
    gint buf_size;
+   char *s, *e;
+   gchar *attrbuf_enc;
 
    Html_push_tag(html, tag, tagsize);
 
@@ -2432,32 +2923,49 @@
    Html_tag_open_area(html, tag, tagsize);
 
    if ( (attrbuf = Html_get_attr(html, tag, tagsize, "href"))) {
-      url = Html_url_new(html, attrbuf, NULL, 0, 0, 0, 0);
+      if (!strncasecmp(attrbuf, "javascript:", 11)) do {
+         if ((s = strstr(attrbuf + 11, "://")) != NULL) {
+            while (--s > attrbuf && ((*s >= 'A' && *s <= 'Z') ||
+                                     (*s >= 'a' && *s <= 'z')));
+         } else if (!(s = strstr(attrbuf + 11, "'/")))
+            break;
+         for (e = ++s; *e && *e != '\'' && *e != '"'; ++e);
+         *e = 0; attrbuf = s;
+      } while (0);
+      attrbuf_enc = a_I18n_convert(DILLO_CHARSET, html->linkblock->charset,
+            attrbuf, -1);
+      url = Html_url_new(html, attrbuf_enc, NULL, 0, 0, 0, 0);
+      g_free(attrbuf_enc);
       g_return_if_fail ( url != NULL );
 
+      if ((attrbuf = Html_get_attr(html, tag, tagsize, "target")))
+         a_Url_set_target(url, attrbuf);
+      else if (URL_TARGET_(html->linkblock->base_url))
+         a_Url_set_target(url, URL_TARGET_(html->linkblock->base_url));
+
       old_style = html->stack[html->stack_top].style;
       style_attrs = *old_style;
 
       if (a_Capi_get_buf(url, &buf, &buf_size)) {
          html->InVisitedLink = TRUE;
          style_attrs.color = a_Dw_style_color_new
-            (html->linkblock->visited_color, html->bw->main_window->window);
+            (html->linkblock->visited_color, html->dd->bw->main_window->window);
       } else {
          style_attrs.color = a_Dw_style_color_new
-            (html->linkblock->link_color,  html->bw->main_window->window);
+            (html->linkblock->link_color,  html->dd->bw->main_window->window);
       }
 
       style_attrs.text_decoration |= DW_STYLE_TEXT_DECORATION_UNDERLINE;
       style_attrs.x_link = Html_set_new_link(html, &url);
 
       html->stack[html->stack_top].style =
-         a_Dw_style_new (&style_attrs, html->bw->main_window->window);
+         a_Dw_style_new (&style_attrs, html->dd->bw->main_window->window);
       a_Dw_style_unref (old_style);
    }
 
    if ( (attrbuf = Html_get_attr(html, tag, tagsize, "name"))) {
       a_Dw_page_add_anchor(page, attrbuf, html->stack[html->stack_top].style);
-      _MSG("Registering ANCHOR: %s\n", attrbuf);
+       _MSG(_("Registering ANCHOR: %s\n"), attrbuf);
    }
 }
 
@@ -2484,7 +2992,7 @@
    style_attrs = *style;
    style_attrs.text_decoration |= DW_STYLE_TEXT_DECORATION_UNDERLINE;
    html->stack[html->stack_top].style =
-      a_Dw_style_new(&style_attrs, html->bw->main_window->window);
+      a_Dw_style_new(&style_attrs, html->dd->bw->main_window->window);
    a_Dw_style_unref(style);
 }
 
@@ -2502,7 +3010,7 @@
    style_attrs = *style;
    style_attrs.text_decoration |= DW_STYLE_TEXT_DECORATION_LINE_THROUGH;
    html->stack[html->stack_top].style =
-      a_Dw_style_new(&style_attrs, html->bw->main_window->window);
+      a_Dw_style_new(&style_attrs, html->dd->bw->main_window->window);
    a_Dw_style_unref(style);
 }
 
@@ -2626,7 +3134,7 @@
 
    switch (html->stack[html->stack_top].list_type) {
    case HTML_LIST_NONE:
-      MSG_HTML("<li> outside <ul> or <ol>\n");
+      MSG_HTML(_("<li> outside <ul> or <ol>\n"));
       list_item = a_Dw_list_item_new(NULL);
       Html_add_indented_widget(html, list_item, 0, 0, 0 /* or 1 */);
       bullet = a_Dw_bullet_new();
@@ -2699,7 +3207,7 @@
       a_Dw_style_box_set_border_color
          (&style_attrs,
           a_Dw_style_shaded_color_new (style_attrs.color->color_val,
-                                       html->bw->main_window->window));
+                                       html->dd->bw->main_window->window));
       if (size < 1)
          size = 1;
    } else {
@@ -2708,7 +3216,7 @@
          (&style_attrs,
           a_Dw_style_shaded_color_new
              (html->stack[html->stack_top].current_bg_color,
-              html->bw->main_window->window));
+              html->dd->bw->main_window->window));
       if (size < 2)
          size = 2;
    }
@@ -2781,13 +3289,13 @@
 {
    DilloUrl *action;
    DilloHtmlMethod method;
-   DilloHtmlEnc enc;
+   gchar *accept_charset = NULL, *attrbuf_enc;
    const char *attrbuf;
 
    Html_par_push_tag(html, tag, tagsize);
 
    if (html->InFlags & IN_FORM) {
-      MSG_HTML("nested forms\n");
+      MSG_HTML(_("nested forms\n"));
       return;
    }
    html->InFlags |= IN_FORM;
@@ -2798,15 +3306,25 @@
          method = DILLO_HTML_METHOD_POST;
       /* todo: maybe deal with unknown methods? */
    }
-   if ((attrbuf = Html_get_attr(html, tag, tagsize, "action")))
-      action = Html_url_new(html, attrbuf, NULL, 0, 0, 0, 0);
-   else
+   if ((attrbuf = Html_get_attr(html, tag, tagsize, "action"))) {
+      attrbuf_enc = a_I18n_convert(DILLO_CHARSET, html->linkblock->charset,
+            attrbuf, -1);
+      action = a_Url_new(attrbuf_enc, URL_STR_(html->linkblock->base_url), 0, 0, 0);
+      g_free(attrbuf_enc);
+   } else
       action = a_Url_dup(html->linkblock->base_url);
-   enc = DILLO_HTML_ENC_URLENCODING;
-   if ( (attrbuf = Html_get_attr(html, tag, tagsize, "encoding")) ) {
-      /* todo: maybe deal with unknown encodings? */
+
+   if ((attrbuf = Html_get_attr(html, tag, tagsize, "target")))
+     a_Url_set_target(action, attrbuf);
+   else if (URL_TARGET_(html->linkblock->base_url))
+     a_Url_set_target(action, URL_TARGET_(html->linkblock->base_url));
+
+   if(Html_get_attr(html, tag, tagsize, "accept-charset")) {
+      accept_charset = a_I18n_fix_charset(g_strdup(
+               Html_get_attr(html, tag, tagsize, "accept-charset")));
    }
-   Html_form_new(html->linkblock, method, action, enc);
+   Html_form_new(html->linkblock, method, action, accept_charset);
+   g_free(accept_charset);
    a_Url_free(action);
 }
 
@@ -2825,7 +3343,7 @@
       if (form->num_submit_buttons == 0) {
          MSG_HTML("FORM lacks a Submit button\n");
          if (prefs.generate_submit) {
-            MSG_HTML(" (added a submit button internally)\n");
+            MSG_HTML(_(" (added a submit button internally)\n"));
             Html_tag_open_input(html, SubmitTag, strlen(SubmitTag));
             form->num_submit_buttons = 0;
          }
@@ -2849,6 +3367,27 @@
    Html_pop_tag(html, tag, tagsize);
 }
 
+#ifdef ENABLE_META_REFRESH
+/*
+ * Helper function for meta refresh tag.
+ */
+static gboolean Html_tag_meta_refresh(gpointer data)
+{
+   DilloHtmlMetaRefreshData *rdata = (DilloHtmlMetaRefreshData *)data;
+
+   if (!rdata->html_dead) {
+      rdata->lb->meta_refresh = NULL;
+      if ( rdata->url ) {
+         a_Nav_remove_top_url(rdata->lb->dd);
+         a_Nav_push(rdata->lb->dd, rdata->url);
+      }
+   }
+   a_Url_free(rdata->url);
+   g_free(rdata);
+   return FALSE;
+}
+#endif
+
 /*
  * Handle <META>
  * We do not support http-equiv=refresh because it's non standard,
@@ -2861,6 +3400,32 @@
  */
 static void Html_tag_open_meta(DilloHtml *html, char *tag, gint tagsize)
 {
+#ifdef ENABLE_META_REFRESH
+   const gchar *attrbuf;
+
+   if (!(html->InFlags & IN_HEAD) && html->linkblock->meta_refresh) {
+      return;
+   }
+   attrbuf = Html_get_attr(html, tag, tagsize, "http-equiv");
+
+   /* Is this a refresh? */
+   if (attrbuf && !g_strcasecmp(attrbuf, "refresh")) {
+      DilloHtmlMetaRefreshData *data;
+      gint delay;
+      gchar *content;
+ #ifdef SEND_HTML_MSG
+      gchar *html_msg, *url;
+ #endif
+
+      /* check for content */
+      if (!(attrbuf = Html_get_attr(html, tag, tagsize, "content")))
+         return;
+
+      /* check for delay */
+      delay = strtol(attrbuf, &content, 0);
+#else
+   const gchar *equiv, *content;
+ #ifdef SEND_HTML_MSG
    static gint Html_write_raw();
    const gchar *meta_template =
 "<table width='100%%'><tr><td bgcolor='#ee0000'>Warning:</td>\n"
@@ -2870,13 +3435,14 @@
 " <tr><td bgcolor='#a0a0a0' colspan='2'>The author wanted you to go\n"
 " <a href='%s'>here</a>%s</td></tr></table><br>\n";
 
-   const gchar *equiv, *content;
-   gchar *html_msg, delay_str[64];
+   gchar *html_msg;
+ #endif
+   gchar  delay_str[64];
    gint delay;
 
    /* only valid inside HEAD */
    if (!(html->InFlags & IN_HEAD)) {
-      MSG_HTML("META elements must be inside the HEAD section\n");
+      MSG_HTML(_("META elements must be inside the HEAD section\n"));
       return;
    }
 
@@ -2890,14 +3456,48 @@
                     delay, (delay > 1) ? "s" : "");
       else
          sprintf(delay_str, ".");
-
+#endif
       /* Skip to anything after "URL=" */
       while (*content && *(content++) != '=');
-
+#ifdef ENABLE_META_REFRESH
+      data = g_new(DilloHtmlMetaRefreshData, 1);
+      data->lb = html->linkblock;
+      data->html_dead = 0;
+	  
+      if (data->lb->meta_refresh) {
+         *data->lb->meta_refresh = 1;
+      }
+	  
+      data->lb->meta_refresh = &data->html_dead;
+      data->url = a_Url_new(*content ? content :
+                            URL_STR(a_History_get_url(NAV_TOP(data->lb->dd))),
+                            URL_STR_(data->lb->base_url), 0, 0, 0);
+      a_Url_set_flags(data->url, URL_FLAGS(data->url) | URL_E2EReload);
+
+      if (!*content && delay < 7) /* don't refresh itself to often... */
+          delay = 7;
+ 
+      /* Add a timeout which will load the new location */
+      g_timeout_add(delay ? delay * 1000 : 300, Html_tag_meta_refresh,
+					(gpointer)data);
+ #ifdef SEND_HTML_MSG
+      url = URL_STR( data->url );
+      html_msg = g_strdup_printf(
+        	"<p><font color=\"red\">META REFRESH (%d sec): "
+        	"<a href=\"%s\">%s</a></p>",
+        	delay, url, url);
+ #endif
+#else
+ #ifdef SEND_HTML_MSG
       /* Send a custom HTML message */
       html_msg = g_strdup_printf(meta_template, content, delay_str);
+ #endif
+#endif
+ #ifdef SEND_HTML_MSG
       Html_write_raw(html, html_msg, strlen(html_msg), 0);
       g_free(html_msg);
+ #endif
+      MSG_HTML(_("The NON-STANDARD meta refresh tag. The HTML 4.01 SPEC (sec 7.4.4) recommends explicitly to avoid it. The author wanted you to go <%s>\n"), content);
    }
 }
 
@@ -2926,7 +3526,7 @@
    switch (input->type) {
    case DILLO_HTML_INPUT_TEXT:
    case DILLO_HTML_INPUT_PASSWORD:
-      gtk_entry_set_text(GTK_ENTRY(input->widget), input->init_str);
+      a_I18n_gtk_entry_set_text(GTK_ENTRY(input->widget), input->init_str);
       break;
    case DILLO_HTML_INPUT_CHECKBOX:
       gtk_toggle_button_set_state(GTK_TOGGLE_BUTTON(input->widget),
@@ -2970,8 +3570,10 @@
       if (input->init_str != NULL) {
          int pos = 0;
          gtk_editable_delete_text(GTK_EDITABLE(input->widget), 0, -1);
-         gtk_editable_insert_text(GTK_EDITABLE(input->widget), input->init_str,
-                                  strlen(input->init_str), &pos);
+         a_I18n_gtk_editable_insert_text(GTK_EDITABLE(input->widget),
+                                         input->init_str,
+                                         strlen(input->init_str),
+                                         &pos);
       }
       break;
    default:
@@ -3077,6 +3679,7 @@
          g_string_append_c(str, '+');
       } else if (isalnum (val[i]) || strchr(verbatim, val[i])) {
          g_string_append_c(str, val[i]);
+      } else if (val[i] == '\r') {
       } else if (val[i] == '\n') {
          g_string_append(str, "%0D%0A");
       } else {
@@ -3088,21 +3691,6 @@
 }
 
 /*
- * Append a name-value pair to an existing url.
- * (name and value are urlencoded before appending them)
- */
-static void
- Html_append_input(GString *url, const char *name, const char *value)
-{
-   if (name != NULL) {
-      Html_urlencode_append(url, name);
-      g_string_append_c(url, '=');
-      Html_urlencode_append(url, value);
-      g_string_append_c(url, '&');
-   }
-}
-
-/*
  * Append a image button click position to an existing url.
  */
 static void Html_append_clickpos(GString *url, const char *name, int x, int y)
@@ -3116,6 +3704,39 @@
       g_string_sprintfa(url, "x=%d&y=%d&", x, y);
 }
 
+/* 
+ * Append a name-value pair to an existing url.
+ * (name and value are urlencoded before appending them)
+ * This also translates the value to the server character encoding or
+ * Accept_charset, if necessary.
+ */
+static void 
+ Html_translate_append_input(DilloHtmlLB *lb, GString *url, 
+              const char *name, char *value, GtkWidget *submit)
+{
+   if(name != NULL) {
+      Html_urlencode_append(url, name);
+      g_string_append_c(url, '=');
+      if (value != NULL) {
+         int form_index;
+         char *charset, *convValue;
+         /* Search the form that generated the submit event */
+         if ((form_index = Html_find_form(submit, lb)) == -1 ) {
+            charset = lb->charset;
+         } else {
+            DilloHtmlForm *form = &lb->forms[form_index];
+            charset = (form->charset)? form->charset : lb->charset;
+         }
+         convValue = a_I18n_convert(DILLO_CHARSET, 
+                  charset, value, -1);
+         _MSG("append charset%s\n", charset);
+         Html_urlencode_append(url, convValue);
+         g_free(convValue);
+      }
+      g_string_append_c(url, '&');
+   }
+}
+
 /*
  * Submit the form containing the submit input by making a new query URL
  * and sending it with a_Nav_push.
@@ -3131,6 +3752,9 @@
    DilloHtmlInput *input;
    DilloUrl *new_url;
    gchar *url_str, *action_str, *p;
+   DilloDoc *name_dd;
+
+   name_dd = NULL;
 
    /* Search the form that generated the submit event */
    if ( (i = Html_find_form(submit, html_lb)) == -1 )
@@ -3144,29 +3768,33 @@
       DEBUG_MSG(3,"Html_submit_form form->action=%s\n",URL_STR_(form->action));
 
       for (input_index = 0; input_index < form->num_inputs; input_index++) {
+         gchar *enc_buf;
          input = &(form->inputs[input_index]);
          switch (input->type) {
          case DILLO_HTML_INPUT_TEXT:
          case DILLO_HTML_INPUT_PASSWORD:
-            Html_append_input(DataStr, input->name,
-                              gtk_entry_get_text(GTK_ENTRY(input->widget)));
+            enc_buf = a_I18n_gtk_entry_get_text(GTK_ENTRY(input->widget));
+            Html_translate_append_input(html_lb, DataStr, input->name,
+                              enc_buf, submit);
+            g_free(enc_buf);
             break;
          case DILLO_HTML_INPUT_CHECKBOX:
          case DILLO_HTML_INPUT_RADIO:
             if (GTK_TOGGLE_BUTTON(input->widget)->active &&
                 input->name != NULL && input->init_str != NULL) {
-               Html_append_input(DataStr, input->name, input->init_str);
+                Html_translate_append_input(html_lb, DataStr, input->name, input->init_str, submit);
             }
             break;
          case DILLO_HTML_INPUT_HIDDEN:
-            Html_append_input(DataStr, input->name, input->init_str);
+            Html_translate_append_input(html_lb, DataStr, input->name,
+                    input->init_str, submit);
             break;
          case DILLO_HTML_INPUT_SELECT:
             for (i = 0; i < input->select->num_options; i++) {
                if (GTK_CHECK_MENU_ITEM(input->select->options[i].menuitem)->
                    active) {
-                  Html_append_input(DataStr, input->name,
-                                    input->select->options[i].value);
+                   Html_translate_append_input(html_lb, DataStr, input->name,
+                                    input->select->options[i].value, submit);
                   break;
                }
             }
@@ -3175,22 +3803,26 @@
             for (i = 0; i < input->select->num_options; i++) {
                if (input->select->options[i].menuitem->state ==
                    GTK_STATE_SELECTED) {
-                  Html_append_input(DataStr, input->name,
-                                    input->select->options[i].value);
+                   Html_translate_append_input(html_lb, DataStr, input->name,
+                                    input->select->options[i].value, submit);
                }
             }
             break;
          case DILLO_HTML_INPUT_TEXTAREA:
-            Html_append_input(DataStr, input->name,
-               gtk_editable_get_chars(GTK_EDITABLE (input->widget),0,-1));
+            enc_buf = a_I18n_DW_CHARSET_to_DILLO_CHARSET(
+                  gtk_editable_get_chars(GTK_EDITABLE (input->widget),0,-1), -1);
+            Html_translate_append_input(html_lb, DataStr, input->name,
+               enc_buf, submit);
+            g_free(enc_buf);
             break;
          case DILLO_HTML_INPUT_INDEX:
-            Html_urlencode_append(DataStr,
-               gtk_entry_get_text(GTK_ENTRY(input->widget)));
+            enc_buf = a_I18n_gtk_entry_get_text(GTK_ENTRY(input->widget));
+            Html_urlencode_append(DataStr, enc_buf);
+            g_free(enc_buf);
             break;
          case DILLO_HTML_INPUT_IMAGE:
             if (input->widget == submit) {
-               Html_append_input(DataStr, input->name, input->init_str);
+                Html_translate_append_input(html_lb, DataStr, input->name, input->init_str, submit);
                Html_append_clickpos(DataStr, input->name, click_x, click_y);
             }
             break;
@@ -3198,7 +3830,7 @@
          case DILLO_HTML_INPUT_BUTTON_SUBMIT:
             /* Only the button that triggered the submit. */
             if (input->widget == submit && form->num_submit_buttons > 0)
-               Html_append_input(DataStr, input->name, input->init_str);
+                Html_translate_append_input(html_lb, DataStr, input->name, input->init_str, submit);
             break;
          default:
             break;
@@ -3228,12 +3860,21 @@
          g_free(url_str);
       }
 
-      a_Nav_push(html_lb->bw, new_url);
+      a_Url_set_referer(new_url, html_lb->base_url);
+      if(URL_TARGET_(form->action)) {
+	a_Url_set_target(new_url, (gchar *) URL_TARGET_(form->action));
+	name_dd = a_Doc_get_by_name(html_lb->dd, (gchar *) URL_TARGET_(new_url));
+      }
+
+      if(name_dd)
+      	a_Nav_push(name_dd, new_url);
+      else
+	      a_Nav_push(html_lb->dd, new_url);
       g_free(action_str);
       g_string_free(DataStr, TRUE);
       a_Url_free(new_url);
    } else {
-      MSG("Html_submit_form: Method unknown\n");
+      MSG(_("Html_submit_form: Method unknown\n"));
    }
 }
 
@@ -3280,7 +3921,7 @@
    const char *attrbuf;
 
    if ((attrbuf = Html_get_attr(html, tag, tagsize, "src")) &&
-       (url = Html_url_new(html, attrbuf, NULL, 0, 0, 0, 0))) {
+        (url = Html_url_new(html, attrbuf, NULL, 0, 0, 0, 0))) {
       button = a_Dw_button_new (0, FALSE);
       a_Dw_page_add_widget (DW_PAGE (html->dw), button,
                             html->stack[html->stack_top].style);
@@ -3304,7 +3945,7 @@
       }
    }
 
-   DEBUG_MSG(10, "Html_input_image: unable to create image submit.\n");
+   DEBUG_MSG(10, _("Html_input_image: unable to create image submit.\n"));
    a_Url_free(url);
    return NULL;
 }
@@ -3326,7 +3967,7 @@
    gint input_index;
 
    if (!(html->InFlags & IN_FORM)) {
-      MSG_HTML("input camp outside <form>\n");
+      MSG_HTML(_("input camp outside <form>\n"));
       return;
    }
 
@@ -3335,21 +3976,25 @@
 
    /* Get 'value', 'name' and 'type' */
    value = (attrbuf = Html_get_attr(html, tag, tagsize, "value")) ?
-            g_strdup(attrbuf) : NULL;
+            g_strdup(attrbuf)
+            : NULL;
 
    name = (attrbuf = Html_get_attr(html, tag, tagsize, "name")) ?
-           g_strdup(attrbuf) : NULL;
+            g_strdup(attrbuf)
+            : NULL;
 
    type = (attrbuf = Html_get_attr(html, tag, tagsize, "type")) ?
-           g_strdup(attrbuf) : g_strdup("");
+           g_strdup(attrbuf) 
+           : g_strdup("");
 
    init_str = NULL;
    if (!g_strcasecmp(type, "password")) {
       inp_type = DILLO_HTML_INPUT_PASSWORD;
       widget = gtk_entry_new();
       gtk_entry_set_visibility(GTK_ENTRY(widget), FALSE);
-      if (value)
-         init_str = g_strdup(Html_get_attr(html, tag, tagsize, "value"));
+      if (value) {
+         init_str = value;//g_strdup(Html_get_attr(html, tag, tagsize, "value"));
+      }
    } else if (!g_strcasecmp(type, "checkbox")) {
       inp_type = DILLO_HTML_INPUT_CHECKBOX;
       widget = gtk_check_button_new();
@@ -3378,15 +4023,15 @@
          init_str = g_strdup(Html_get_attr(html, tag, tagsize, "value"));
    } else if (!g_strcasecmp(type, "submit")) {
       inp_type = DILLO_HTML_INPUT_SUBMIT;
-      init_str = (value) ? value : g_strdup("submit");
-      widget = gtk_button_new_with_label(init_str);
+      init_str = (value) ? value : g_strdup(_("submit"));
+      widget = a_I18n_gtk_button_new_with_label(init_str);
       gtk_widget_set_sensitive(widget, FALSE); /* Until end of FORM! */
       gtk_signal_connect(GTK_OBJECT(widget), "clicked",
                          GTK_SIGNAL_FUNC(Html_submit_form), html_lb);
    } else if (!g_strcasecmp(type, "reset")) {
       inp_type = DILLO_HTML_INPUT_RESET;
-      init_str = (value) ? value : g_strdup("Reset");
-      widget = gtk_button_new_with_label(init_str);
+      init_str = (value) ? value : g_strdup(_("Reset"));
+      widget = a_I18n_gtk_button_new_with_label(init_str);
       gtk_widget_set_sensitive(widget, FALSE); /* Until end of FORM! */
       gtk_signal_connect(GTK_OBJECT(widget), "clicked",
                          GTK_SIGNAL_FUNC(Html_reset_form), html_lb);
@@ -3395,9 +4040,9 @@
          /* Don't request the image, make a text submit button instead */
          inp_type = DILLO_HTML_INPUT_SUBMIT;
          attrbuf = Html_get_attr(html, tag, tagsize, "alt");
-         label = attrbuf ? attrbuf : value ? value : name ? name : "Submit";
+         label = attrbuf ? attrbuf : value ? value : name ? name : _("Submit");
          init_str = g_strdup(label);
-         widget = gtk_button_new_with_label(init_str);
+         widget = a_I18n_gtk_button_new_with_label(init_str);
          gtk_widget_set_sensitive(widget, FALSE); /* Until end of FORM! */
          gtk_signal_connect(GTK_OBJECT(widget), "clicked",
                             GTK_SIGNAL_FUNC(Html_submit_form), html_lb);
@@ -3412,12 +4057,12 @@
       /* todo: implement it! */
       inp_type = DILLO_HTML_INPUT_FILE;
       init_str = (value) ? value : NULL;
-      MSG("An input of the type \"file\" wasn't rendered!\n");
+      MSG(_("An input of the type \"file\" wasn't rendered!\n"));
    } else if (!g_strcasecmp(type, "button")) {
       inp_type = DILLO_HTML_INPUT_BUTTON;
       if (value) {
          init_str = value;
-         widget = gtk_button_new_with_label(init_str);
+         widget = a_I18n_gtk_button_new_with_label(init_str);
       }
    } else {
       /* Text input, which also is the default */
@@ -3496,7 +4141,7 @@
       action = a_Url_dup(html->linkblock->base_url);
 
    Html_form_new(html->linkblock, DILLO_HTML_METHOD_GET, action,
-                 DILLO_HTML_ENC_URLENCODING);
+                 NULL);
 
    form = &(html_lb->forms[html_lb->num_forms - 1]);
 
@@ -3564,8 +4209,8 @@
 
    form = &(html_lb->forms[html_lb->num_forms - 1]);
    form->inputs[form->num_inputs - 1].init_str = str;
-   gtk_text_insert(GTK_TEXT(form->inputs[form->num_inputs - 1].widget),
-                   NULL, NULL, NULL, str, -1);
+   a_I18n_gtk_text_insert(GTK_TEXT(form->inputs[form->num_inputs - 1].widget),
+                          NULL, NULL, NULL, str, -1);
 
    html->InFlags &= ~IN_TEXTAREA;
    Html_pop_tag(html, tag, tagsize);
@@ -3589,11 +4234,11 @@
    html_lb = html->linkblock;
 
    if (!(html->InFlags & IN_FORM)) {
-      MSG_HTML("<textarea> outside <form>\n");
+      MSG_HTML(_("<textarea> outside <form>\n"));
       return;
    }
    if (html->InFlags & IN_TEXTAREA) {
-      MSG_HTML("nested <textarea>\n");
+      MSG_HTML(_("nested <textarea>\n"));
       return;
    }
    html->InFlags |= IN_TEXTAREA;
@@ -3666,11 +4311,11 @@
    Html_push_tag(html, tag, tagsize);
 
    if (!(html->InFlags & IN_FORM)) {
-      MSG_HTML("<select> outside <form>\n");
+      MSG_HTML(_("<select> outside <form>\n"));
       return;
    }
    if (html->InFlags & IN_SELECT) {
-      MSG_HTML("nested <select>\n");
+      MSG_HTML(_("nested <select>\n"));
       return;
    }
    html->InFlags |= IN_SELECT;
@@ -3725,7 +4370,7 @@
    GtkWidget *menuitem;
    GSList *group;
    DilloHtmlSelect *select;
-
+   
    if (!(html->InFlags & IN_FORM))
       return;
 
@@ -3741,7 +4386,8 @@
       else
          group = gtk_radio_menu_item_group(GTK_RADIO_MENU_ITEM
                                    (select->options[0].menuitem));
-      menuitem = gtk_radio_menu_item_new_with_label(group, html->Stash->str);
+      menuitem = a_I18n_gtk_radio_menu_item_new_with_label(group,
+                                                           html->Stash->str);
       select->options[select->num_options - 1].menuitem = menuitem;
       if ( select->options[select->num_options - 1].value == NULL )
          select->options[select->num_options - 1].value =
@@ -3754,7 +4400,7 @@
                           GTK_SIGNAL_FUNC (a_Interface_scroll_popup),
                           NULL);
    } else if ( input->type == DILLO_HTML_INPUT_SEL_LIST ) {
-      menuitem = gtk_list_item_new_with_label(html->Stash->str);
+      menuitem = a_I18n_gtk_list_item_new_with_label(html->Stash->str);
       select->options[select->num_options - 1].menuitem = menuitem;
       if (select->options[select->num_options - 1].value == NULL)
          select->options[select->num_options - 1].value =
@@ -3884,11 +4530,15 @@
 static void Html_tag_open_base(DilloHtml *html, char *tag, gint tagsize)
 {
    const char *attrbuf;
+   gchar *attrbuf_enc;
    DilloUrl *BaseUrl;
 
    if (html->InFlags & IN_HEAD) {
       if ((attrbuf = Html_get_attr(html, tag, tagsize, "href"))) {
-         BaseUrl = Html_url_new(html, attrbuf, "", 0, 0, 0, 1);
+         attrbuf_enc = a_I18n_convert(DILLO_CHARSET, html->linkblock->charset,
+               attrbuf, -1);
+         BaseUrl = Html_url_new(html, attrbuf_enc, "", 0, 0, 0, 1);
+         g_free(attrbuf_enc);
          if (URL_SCHEME_(BaseUrl)) {
             /* Pass the URL_SpamSafe flag to the new base url */
             a_Url_set_flags(
@@ -3896,12 +4546,14 @@
             a_Url_free(html->linkblock->base_url);
             html->linkblock->base_url = BaseUrl;
          } else {
-            MSG_HTML("base URI is relative (it MUST be absolute)\n");
+            MSG_HTML(_("base URI is relative (it MUST be absolute)\n"));
             a_Url_free(BaseUrl);
          }
       }
+      if ((attrbuf = Html_get_attr(html, tag, tagsize, "target")))
+	      a_Url_set_target(html->linkblock->base_url, attrbuf);
    } else {
-      MSG_HTML("the BASE element must appear in the HEAD section\n");
+      MSG_HTML(_("the BASE element must appear in the HEAD section\n"));
    }
 }
 
@@ -4039,7 +4691,7 @@
   {"del", 'R', Html_tag_open_strike, Html_tag_close_default},
   {"dfn", 'R', Html_tag_open_dfn, Html_tag_close_default},
   /* dir */
-  {"div", 'R', Html_tag_open_div, Html_tag_close_div},  /* todo: complete! */
+  {"div", 'R', Html_tag_open_div, Html_tag_close_div},         /* todo: complete! */
   {"dl", 'R', Html_tag_open_dl, Html_tag_close_par},
   {"dt", 'O', Html_tag_open_dt, Html_tag_close_par},
   {"em", 'R', Html_tag_open_em, Html_tag_close_default},
@@ -4058,7 +4710,7 @@
   {"hr", 'F', Html_tag_open_hr, Html_tag_close_nop},
   /* html */
   {"i", 'R', Html_tag_open_i, Html_tag_close_default},
-  {"iframe", 'R', Html_tag_open_frame, Html_tag_close_nop},
+  {"iframe", 'R', Html_tag_open_iframe, Html_tag_close_par},
   {"img", 'F', Html_tag_open_img, Html_tag_close_nop},
   {"input", 'F', Html_tag_open_input, Html_tag_close_nop},
   /* ins */
@@ -4070,13 +4722,14 @@
   /* link */
   {"map", 'R', Html_tag_open_map, Html_tag_close_map},
   {"meta", 'F', Html_tag_open_meta, Html_tag_close_nop},
-  /* noframes */
+  {"noframe",  'R', Html_tag_open_noframe,  Html_tag_close_default}, /* Illegal tag */
+  {"noframes", 'R', Html_tag_open_noframes, Html_tag_close_default},
   /* noscript */
   /* object */
   {"ol", 'R', Html_tag_open_ol, Html_tag_close_par},
   /* optgroup */
   {"option", 'O', Html_tag_open_option, Html_tag_close_nop},
-  {"p", 'O', Html_tag_open_p, Html_tag_close_default},
+  {"p", 'O', Html_tag_open_p, Html_tag_close_par},
   /* param */
   {"pre", 'R', Html_tag_open_pre, Html_tag_close_par},
   /* q */
@@ -4099,7 +4752,7 @@
   {"th", 'O', Html_tag_open_th, Html_tag_close_default},
   /* thead */
   {"title", 'R', Html_tag_open_title, Html_tag_close_title},
-  {"tr", 'O', Html_tag_open_tr, Html_tag_close_default},
+  {"tr", 'O', Html_tag_open_tr, Html_tag_close_nop},
   {"tt", 'R', Html_tag_open_tt, Html_tag_close_default},
   {"u", 'R', Html_tag_open_u, Html_tag_close_default},
   {"ul", 'R', Html_tag_open_ul, Html_tag_close_par},
@@ -4240,9 +4893,10 @@
                                   const char *attrname,
                                   DilloHtmlTagParsingFlags flags)
 {
-   gint i, isocode, Found = 0, delimiter = 0, attr_pos = 0;
+   gint i, Found = 0, delimiter = 0, attr_pos = 0;
    GString *Buf = html->attr_data;
    DilloHtmlTagParsingState state = SEEK_ATTR_START;
+   gchar *subst;
 
    g_return_val_if_fail(*attrname, NULL);
 
@@ -4292,8 +4946,9 @@
              tag[i] == delimiter) {
             state = FINISHED;
          } else if (tag[i] == '&' && (flags & HTML_ParseEntities)) {
-            if ((isocode = Html_parse_entity(tag+i, tagsize-i)) != -1) {
-               g_string_append_c(Buf, (gchar) isocode);
+            if ((subst = Html_parse_entity(tag+i, tagsize-i))) {
+               g_string_append(Buf, subst);
+               g_free(subst);
                while (tag[++i] != ';');
             } else {
                g_string_append_c(Buf, tag[i]);
@@ -4351,7 +5006,7 @@
       Html_parse_length (html, width_str) : DW_STYLE_LENGTH_AUTO;
    new_style_attrs.height = height_str ?
       Html_parse_length (html, height_str) : DW_STYLE_LENGTH_AUTO;
-   style = a_Dw_style_new (&new_style_attrs, (html)->bw->main_window->window);
+   style = a_Dw_style_new (&new_style_attrs, (html)->dd->bw->main_window->window);
    a_Dw_page_add_widget(DW_PAGE (html->dw), widget, style);
    a_Dw_style_unref (style);
 }
@@ -4385,6 +5040,11 @@
    gint token_start, buf_index;
 
    g_return_val_if_fail ((page = DW_PAGE (html->dw)) != NULL, 0);
+   
+   if(bufsize < 0){
+      _MSG(_("Html_write_raw : bufsize is negative!\n"));
+      bufsize = strlen(buf);
+   }
 
    buf = g_strndup(buf, bufsize);
 
@@ -4460,7 +5120,7 @@
                      if (buf[offset] == ch || !buf[offset]) {
                         buf_index = offset;
                      } else {
-                        MSG_HTML("attribute lacks closing quote\n");
+                        MSG_HTML(_("attribute lacks closing quote\n"));
                         break;
                      }
                   }
@@ -4474,19 +5134,47 @@
             }
          }
       } else {
-         /* A Word: search for whitespace or tag open */
-         while (++buf_index < bufsize) {
-            buf_index += strcspn(buf + buf_index, " <\n\r\t\f\v");
-            if ( buf[buf_index] == '<' && (ch = buf[buf_index + 1]) &&
-                 !isalpha(ch) && !strchr("/!?", ch))
-               continue;
-            break;
-         }
-         if (buf_index < bufsize || Eof) {
-            /* successfully found end of token */
-            Html_process_word(html, buf + token_start,
-                              buf_index - token_start);
-            token_start = buf_index;
+         /* A Word */
+         /* Deal with multibyte characters, treat each character as a word. */
+         if (!IS_ASCII_CHAR(buf[buf_index])) {
+            /* DoES The next byte exist? Is it in the right range? */
+            int wordnum = a_I18n_mblen(&buf[buf_index]);
+            if (wordnum != 0) {
+               buf_index += wordnum;
+               if (buf_index < bufsize || Eof) {
+                  Html_process_word(html, buf + token_start,
+                        buf_index - token_start);
+                  token_start = buf_index;
+               }
+            } else {
+               /* Something broken, but don't want to loop forever. */
+               /* The user is probably looking at non-japanese text. */
+               buf_index++;
+               /* ignore it, unless it is a multibyte character that has not
+                * completely arrived yet */
+               if (buf_index < bufsize || Eof)
+                  token_start = buf_index;
+            }
+         }else {
+            /* otherwise, fall back to ASCII */
+            /* search for whitespace or tag open or multibyte character*/
+            while (++buf_index < bufsize) {
+               while (IS_ASCII_CHAR(buf[buf_index])
+                 && !memchr(" <\n\r\t\f\v&", buf[buf_index], 8))
+                  buf_index++;
+               if ( buf[buf_index] == '<' )
+                  if ((ch = buf[buf_index + 1]))
+                     if (!isalpha(ch))
+                        if (!strchr("/!?",ch))
+                           continue; /* found a tag. */
+               break;
+            }
+            if (buf_index < bufsize || Eof) {
+               /* successfully found end of token */
+               Html_process_word(html, buf + token_start,
+                  buf_index - token_start);
+               token_start = buf_index;
+            }
          }
       }
    }/*while*/
@@ -4497,6 +5185,24 @@
    return token_start;
 }
 
+/* wait for </head> or <body> tag. if waiting, return TRUE*/
+static gboolean Html_wait(char *Buf, gint BufSize, gint Eof)
+{
+   char *head, *body;
+   struct timespec t = {0, 10000000L}; // 10ms
+   
+   if(Eof == 1) return FALSE;
+   
+   head = a_Misc_stristr(Buf, "</head>");
+   if (head && (BufSize - (head - Buf)) > 0) return FALSE;
+   body = a_Misc_stristr(Buf, "<body");
+   if (body && (BufSize - (body - Buf)) > 0) return FALSE;
+
+   DEBUG_MSG(10,"wait..\n");
+   nanosleep(&t, NULL);
+   return TRUE;
+}
+
 /*
  * Process the newly arrived html and put it into the page structure.
  * (This function is called by Html_callback whenever there's new data)
@@ -4504,23 +5210,52 @@
 static void Html_write(DilloHtml *html, char *Buf, gint BufSize, gint Eof)
 {
    DwPage *page;
-   char completestr[32];
    gint token_start;
-   char *buf = Buf + html->Start_Ofs;
-   gint bufsize = BufSize - html->Start_Ofs;
 
    g_return_if_fail ( (page = DW_PAGE (html->dw)) != NULL );
-
+   if (BufSize == 0) return;
    html->Start_Buf = Buf;
-   token_start = Html_write_raw(html, buf, bufsize, Eof);
+
+   /* guess charset */
+   if (!html->trans) {
+      if (html->Start_Ofs == 0) {
+         /* first, wait header, and meta check. */
+         if(Html_wait(Buf, BufSize, Eof)) return;
+         html->linkblock->usingMetaCharset = TRUE;
+      }
+      if (html->Start_Ofs == 0 || !html->linkblock->usingMetaCharset) {
+         g_free(html->linkblock->charset);
+         html->linkblock->charset = (html->server_charset) ?
+            g_strdup(html->server_charset)
+            : a_I18n_get_encoding(Buf, BufSize,
+                  &(html->linkblock->usingMetaCharset));
+         html->trans = Html_translation_new(html->linkblock->charset,
+               DILLO_CHARSET);
+      }
+   }
+
+   if (html->trans) {
+      int bufsize;
+
+      // translation needed and available 
+      Html_translate(html->trans, Buf, BufSize);
+      // note trans->bufsize includes the null byte 
+      bufsize = html->trans->bufsize - html->Start_Ofs;
+      if(bufsize == 0) token_start = 0;
+      else
+         token_start = Html_write_raw(html,
+               html->trans->buffer + html->Start_Ofs, bufsize, Eof);
+   } else {
+	   // translation not needed, or not available 
+      token_start = Html_write_raw(html, Buf + html->Start_Ofs,
+            BufSize - html->Start_Ofs, Eof);
+   }
    html->Start_Ofs += token_start;
 
-   if ( html->bw ) {
-      g_snprintf(
-         completestr, 32, "%s%.1f Kb",
-         PBAR_PSTR(prefs.panel_size == 1),
-         (float)html->Start_Ofs/1024);
-      a_Progressbar_update(html->bw->progress, completestr, 1);
+   if ( html->dd ) {
+      html->dd->progress = html->Start_Ofs/1024;
+      html->dd->ready = FALSE;
+      a_Doc_progress_update(html->dd);
    }
 }
 
@@ -4548,12 +5283,98 @@
    g_string_free(html->attr_data, TRUE);
 
    /* Remove this client from our active list */
-   a_Interface_close_client(html->bw, ClientKey);
-
-   /* Set progress bar insensitive */
-   a_Progressbar_update(html->bw->progress, NULL, 0);
+   a_Doc_close_client(html->dd, ClientKey);
 
+   /* update progress */
+   html->dd->ready = TRUE;
+   a_Doc_progress_update(html->dd);
+
+   /* close the character encoding converter, if present */
+   Html_translation_free(html->trans, FALSE);
+   g_free(html->server_charset);
+   
    g_free(html);
 }
 
+/* 
+ * This translates between character encodings. The results are put into
+ * `trans'. This call can be used repeatedly as new data arrives.
+ */
+static void Html_translate(DilloTrans *trans, char *buf, gint bufsize) {
+   char *source, *dest, *temp;
+   size_t s_left, d_left;
+   int bytesneeded;
+   
+   /* is there nothing new? */
+   if (bufsize == trans->converted) {
+      if (bufsize == 0 && trans->buffer == NULL) {
+         trans->buffer = g_new0(char,1); /* allocate if given empty input */
+         trans->bufsize = 0;
+      }
+      return; /* no new data */
+   }
+   
+   /* allocate a string, leaving enough space for worst-case growth */
+   temp = g_malloc(bufsize * D_CHAR_GROWTH + 1);
+   
+   /* now the proper translation */
+   source = buf + trans->converted;
+   dest = temp;
+   s_left = bufsize - trans->converted;
+   d_left = bufsize * D_CHAR_GROWTH;
+   a_I18n_iconv(trans->conversion,
+         &source, &s_left,
+         &dest, &d_left);
+   trans->converted = bufsize - s_left; /* note how far into the source */
+
+   /* now do the proper allocation */
+   bytesneeded = bufsize * D_CHAR_GROWTH - d_left;
+   if (trans->buffer == NULL) {
+      trans->buffer = g_realloc(temp, bytesneeded + 1); /* cut to size */
+      trans->bufsize = bytesneeded;
+   } else {
+      trans->buffer = g_realloc(trans->buffer, trans->bufsize + bytesneeded + 1);
+      memcpy(trans->buffer + trans->bufsize, temp, bytesneeded + 1);
+      trans->bufsize += bytesneeded;
+      g_free(temp);
+   }
+}
+
+/*
+ * This sets up character encoding translation. It should be done once
+ * for each document that has to be translated.
+ * The inputs are iconv-style encoding names.
+ * This can return NULL if there is an error.
+ */
+static DilloTrans *Html_translation_new(char *source, char *dest) {
+   DilloTrans *trans;
+
+   trans = g_malloc(sizeof(DilloTrans));
+   trans->buffer = NULL;
+   trans->bufsize = 0;
+   trans->converted = 0;
+   if(strncmp(source, "ASCII", 5) == 0) {
+      g_free(trans);
+      return NULL;
+   }
+   trans->conversion = iconv_open(dest, source);
+   if (trans->conversion == (iconv_t)-1) {
+      g_warning (_("could not allocate character encoding converter"));
+      g_free(trans);
+      return NULL;
+   }
+   return trans;
+}
+
+/*
+ * This shuts down character encoding translation.
+ * Set the second parameter to true if you want to keep the translated buffer.
+ */
+static void Html_translation_free(DilloTrans *trans, gboolean keepbuf) {
+   if (trans == NULL) return;
+   iconv_close(trans->conversion);
+   if (!keepbuf) g_free(trans->buffer);
+   g_free(trans);
+}
 
+/* vim: set ts=3 sw=3 sts=3 expandtab:*/
diff -Nur dillo-0.8.0/src/html.h dillo-0.8.0.new/src/html.h
--- dillo-0.8.0/src/html.h	2004-01-25 14:40:39.000000000 +0000
+++ dillo-0.8.0.new/src/html.h	2004-10-13 01:13:29.000000000 +0000
@@ -1,10 +1,11 @@
 #ifndef __HTML_H__
 #define __HTML_H__
 
+#include <iconv.h>
 #include <gdk/gdk.h>
 #include <gtk/gtkcontainer.h>
 
-#include "browser.h"         /* for BrowserWindow */
+#include "browser.h"         /* for DilloDoc */
 #include "dw_widget.h"       /* for DwWidget */
 #include "dw_image.h"        /* for DwImageMapList */
 
@@ -18,6 +19,9 @@
    likely that imagemaps will go here. */
 
 typedef struct _DilloHtmlLB      DilloHtmlLB;
+#ifdef ENABLE_META_REFRESH
+typedef struct _DilloHtmlMetaRefreshData DilloHtmlMetaRefreshData;
+#endif
 
 typedef struct _DilloHtml        DilloHtml;
 typedef struct _DilloHtmlClass   DilloHtmlClass;
@@ -26,30 +30,44 @@
 typedef struct _DilloHtmlOption  DilloHtmlOption;
 typedef struct _DilloHtmlSelect  DilloHtmlSelect;
 typedef struct _DilloHtmlInput   DilloHtmlInput;
-
+typedef struct _DilloTrans       DilloTrans;
 
 struct _DilloHtmlLB {
-   BrowserWindow *bw;
+   DilloDoc *dd;
    DilloUrl *base_url;
- 
+
    DilloHtmlForm *forms;
    gint num_forms;
    gint num_forms_max;
- 
+
    DilloUrl **links;
    gint num_links;
    gint num_links_max;
- 
+
    DwImageMapList maps;
- 
+
    gint32 link_color;
    gint32 visited_color;
 
    gint num_page_bugs;
    GString *page_bugs;
+
+   gchar *charset;
+   gboolean usingMetaCharset;
+#ifdef ENABLE_META_REFRESH
+   gint *meta_refresh;
+#endif
 };
 
 
+#ifdef ENABLE_META_REFRESH
+struct _DilloHtmlMetaRefreshData {
+   DilloHtmlLB *lb;
+   int html_dead;
+   DilloUrl *url;
+};
+#endif
+
 typedef enum {
    DILLO_HTML_PARSE_MODE_INIT,
    DILLO_HTML_PARSE_MODE_STASH,
@@ -82,6 +100,12 @@
    DILLO_HTML_TABLE_MODE_TD     /* inside of <td> */
 } DilloHtmlTableMode;
 
+typedef enum {
+   DILLO_HTML_FRAME_MODE_NONE,     /* no frameset at all */
+   DILLO_HTML_FRAME_MODE_IFRAME,   /* inside of <iframe> */
+   DILLO_HTML_FRAME_MODE_FRAMESET, /* inside of <frameset> */
+   DILLO_HTML_FRAME_MODE_NOFRAMES  /* inside of <noframes> */
+} DilloHtmlFrameMode;
 
 typedef enum {
    IN_HTML        = 1 << 0,
@@ -90,22 +114,24 @@
    IN_FORM        = 1 << 3,
    IN_SELECT      = 1 << 4,
    IN_TEXTAREA    = 1 << 5,
-   IN_MAP         = 1 << 6
+   IN_MAP         = 1 << 6,
+   IN_FRAMESET    = 1 << 7   /* only used for XHTML_DTD_FRAMESET */
 } DilloHtmlProcessingState;
 
-
 struct _DilloHtmlState {
    char *tag;
    DwStyle *style, *table_cell_style;
    DilloHtmlParseMode parse_mode;
    DilloHtmlTableMode table_mode;
+   DilloHtmlFrameMode frame_mode;
+   GtkWidget *frameset;
    gboolean cell_text_align_set;
    enum { HTML_LIST_NONE, HTML_LIST_UNORDERED, HTML_LIST_ORDERED } list_type;
    gint list_number;
- 
+
    /* TagInfo index for the tag that's being processed */
    gint tag_idx;
- 
+
    DwWidget *page, *table;
 
    /* This is used to align list items (especially in enumerated lists) */
@@ -125,17 +151,12 @@
    DILLO_HTML_METHOD_UNKNOWN,
    DILLO_HTML_METHOD_GET,
    DILLO_HTML_METHOD_POST
-} DilloHtmlMethod;
-
-typedef enum {
-   DILLO_HTML_ENC_URLENCODING
-} DilloHtmlEnc;
+}  DilloHtmlMethod;
 
 struct _DilloHtmlForm {
    DilloHtmlMethod method;
    DilloUrl *action;
-   DilloHtmlEnc enc;
- 
+   gchar *charset;
    DilloHtmlInput *inputs;
    gint num_inputs;
    gint num_inputs_max;
@@ -152,7 +173,7 @@
 struct _DilloHtmlSelect {
    GtkWidget *menu;
    gint size;
- 
+
    DilloHtmlOption *options;
    gint num_options;
    gint num_options_max;
@@ -188,32 +209,42 @@
    gboolean init_val; /* only meaningful for buttons */
 };
 
+/* This is used when converting from one character encoding to another */
+struct _DilloTrans {
+   iconv_t conversion; /* iconv conversion handler */
+   char *buffer; /* The converted string. This moves about!! */
+   int bufsize; /* Current length of the buffer, excluding NULL. */
+   int converted; /* number of input bytes converted */
+};
+
 struct _DilloHtml {
    DwWidget *dw;          /* this is duplicated in the stack (page) */
- 
+   DilloTrans *trans;    /* handle for character set conversion */
+   gchar *server_charset;
+
    DilloHtmlLB *linkblock;
    gchar *Start_Buf;
    size_t Start_Ofs;
    size_t CurrTagOfs, CurrTagIdx;
    size_t OldTagOfs, OldTagLine;
- 
+
    DilloHtmlState *stack;
    gint stack_top;        /* Index to the top of the stack [0 based] */
    gint stack_max;
- 
+
    DilloHtmlProcessingState InFlags; /* tracks which tags we are in */
- 
+
    GString *Stash;
    gboolean StashSpace;
- 
+
    gint pre_column;        /* current column, used in PRE tags with tabs */
    gboolean PreFirstChar;  /* used to skip the first CR or CRLF in PRE tags*/
    gboolean PrevWasCR;     /* Flag to help parsing of "\r\n" in PRE tags */
    gboolean InVisitedLink; /* used to 'force_visited_colors' */
- 
+
    GString *attr_data;
- 
-   BrowserWindow *bw;
+
+   DilloDoc *dd;
 };
 
 #ifdef __cplusplus
diff -Nur dillo-0.8.0/src/i18n.c dillo-0.8.0.new/src/i18n.c
--- dillo-0.8.0/src/i18n.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/src/i18n.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,449 @@
+/*
+ * File: i18n.c
+ *
+ * Copyright (C) 2003 Kiyo <kiyo@teki.jpn.ph>
+ * This code referred to Mr. Robert Thomson's code. and created it.
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+/*
+ * guess encoding charset and convert
+ */
+
+#include <config.h>
+#include <ctype.h>
+#include <string.h>
+#include <gtk/gtk.h>
+#include <errno.h>    /* for iconv error codes */
+#include <iconv.h>
+
+#include "intl.h"
+#include "misc.h"
+#include "msg.h"
+#include "i18n.h"
+
+//#define DEBUG_LEVEL 10
+#include "debug.h"
+
+#define MAX_HEADER_LENGTH 10240
+
+static gchar *dw_charset;
+static gboolean detect_ja_charset;
+static gboolean has_latin1_charset;
+
+typedef struct {
+   gchar *lang;
+   gchar *charset;
+} lang_charset;
+
+#define LANG_TBL_N 59
+static lang_charset lang_tbl[LANG_TBL_N] = {
+   {"ZH_TW",	"BIG5"},
+   {"ZH_HK",	"BIG5HKSCS"},
+   {"ZH_CN",	"GBK"},
+   {"YI",	"CP1255"},
+   {"VI",	"TCVN"},
+   {"UR",	"CP1256"},
+   {"UK",	"KOI8-U"},
+   {"TURKISH",	"ISO8859-9"},
+   {"TT",	"TATAR-CYR"},
+   {"TR",	"ISO8859-9"},
+   {"TG",	"KOI8-C"},
+   {"TA",	"TSCII-0"},
+   {"SR_SP",	"ISO8859-2"},
+   {"SR",	"ISO8859-5"},
+   {"SQ",	"ISO8859-2"},
+   {"SP",	"ISO8859-5"},
+   {"SL",	"ISO8859-2"},
+   {"SK",	"ISO8859-2"},
+   {"SH",	"ISO8859-2"},
+   {"SE_NO",	"UTF-8"},
+   {"SERBOCROATIAN",	"ISO8859-2"},
+   {"RU_UA",	"KOI8-U"},
+   {"RU_RU",	"KOI8-R"},
+   {"RUSSIAN",	"ISO8859-5"},
+   {"RUMANIAN",	"ISO8859-2"},
+   {"RU",	"KOI8-R"},
+   {"RO",	"ISO8859-2"},
+   {"POSIX",	"C"},
+   {"POLISH",	"ISO8859-2"},
+   {"PL",	"ISO8859-2"},
+   {"MT",	"ISO8859-3"},
+   {"MK",	"ISO8859-5"},
+   {"LO",	"MULELAO-1"},
+   {"KO",	"EUCKR"},
+   {"KA",	"GEORGIAN-ACADEMY"},
+   {"JP_JP",	"EUCJP"},
+   {"JA",	"EUCJP"},
+   {"IW",	"ISO8859-8"},
+   {"IU",	"NUNACOM-8"},
+   {"HY",	"ARMSCII-8"},
+   {"HU",	"ISO8859-2"},
+   {"HR",	"ISO8859-2"},
+   {"HI",	"ISCII-DEV"},
+   {"HE",	"ISO8859-8"},
+   {"GREEK",	"ISO8859-7"},
+   {"FA",	"UTF-8"},
+   {"EO",	"ISO8859-3"},
+   {"EL",	"ISO8859-7"},
+   {"EE",	"ISO8859-4"},
+   {"CZ",	"ISO8859-2"},
+   {"CS",	"ISO8859-2"},
+   {"CROATIAN",	"ISO8859-2"},
+   {"CHINESE-T",	"EUCTW"},
+   {"CHINESE-S",	"EUCCN"},
+   {"BE",	"CP1251"},
+   {"AZ",	"ISO8859-9E"},
+   {"AR",	"ISO8859-6"},
+   {"AM",	"UTF-8"},
+   {"A3",	"KOI8-C"},
+};
+
+static gchar *I18n_get_charset_from_lang(const gchar *lang) {
+   gint i;
+   gchar u_lang[64];
+
+   strncpy(u_lang, lang, 64);
+   g_strup(u_lang);
+   if (strstr(u_lang, "EURO")) return g_strdup("ISO8859-15");
+   for (i = 0; i < LANG_TBL_N; i++) {
+      if (strncmp(u_lang, lang_tbl[i].lang, strlen(lang_tbl[i].lang)) == 0)
+         return g_strdup(lang_tbl[i].charset);
+   }
+   has_latin1_charset = TRUE;
+   return g_strdup("ISO8859-1");
+}
+
+void a_I18n_set_DW_lang(const gchar *lang) {
+   detect_ja_charset = FALSE;
+   has_latin1_charset = TRUE;
+   if (!lang) {
+      dw_charset = g_strdup("ISO8859-1");
+      return;
+   }
+   if (g_strncasecmp(lang, "JA", 2) == 0) {
+      detect_ja_charset = TRUE;
+      has_latin1_charset = FALSE;
+   }
+   dw_charset = (strchr(lang, '.'))
+           ? a_I18n_fix_charset(g_strdup(strchr(lang, '.')+1))
+           : I18n_get_charset_from_lang(lang);
+}
+
+const gchar *a_I18n_get_DW_charset() { return dw_charset; }
+
+/* If font has latin1, return TRUE. */
+gboolean a_I18n_has_latin1_charset() { return has_latin1_charset; }
+
+/* fix name Html_charset to iconv_charset. for example "x-sjis" to "SJIS"... */
+gchar *a_I18n_fix_charset(gchar *charset) {
+   iconv_t it;
+   if (!charset) return NULL;
+   g_strup(charset);
+   if (strchr(charset, '@'))
+      strchr(charset, '@')[0] = '\0';
+   if (strncmp(charset, "X-", 2) == 0) {
+      gchar *old_charset = charset;
+      charset = g_strdup(charset+2);
+      g_free(old_charset);
+   }
+   if (strncmp(charset, "SHIFTJIS", 8) == 0) {
+      g_free(charset);
+      return g_strdup("SJIS");
+   }
+   if (strncmp(charset, "EUC_JP", 6) == 0) {
+      g_free(charset);
+      return g_strdup("EUC-JP");
+   }
+   if (strncmp(charset, "UNICODE-1-1-UTF-8",17) == 0) {
+      g_free(charset);
+      return g_strdup("UTF-8");
+   }
+   if ((it = iconv_open(charset, charset)) == (iconv_t)-1) {
+      g_free(charset);
+      return NULL;
+   }
+   iconv_close(it);
+   return charset;
+}
+
+/* auto detect Japanese charset. -- SJIS,EUC-JP,ISO-2022-JP */
+gchar *I18n_detect_japanese_charset(const gchar *buf, gint bufsize) {
+   gint i, got_sjis = 0, got_euc = 0, got_jis = 0;
+   if (!buf) return  g_strdup("SJIS");
+   
+   /* check CRLF code. */
+   if (strstr(buf, "\r")) got_sjis += 2;
+         
+   for (i=0; i<bufsize; i++) {
+      if (got_sjis > got_euc && got_sjis >= 40) return g_strdup("SJIS");
+      else if (got_euc > got_sjis && got_euc >= 40) return g_strdup("EUC-JP");
+      else if (got_jis > 3) return g_strdup("ISO-2022-JP");
+      if (buf[i] == 0x1b) {
+         if (buf[i+1] == '$' || buf[i+1] == '(') got_jis++;
+         else got_jis--;
+      } else if (IS_ASCII_CHAR(buf[i])) continue;
+      DEBUG_MSG(10, "e=%d s=%d j=%d %d\n", got_euc, got_sjis, got_jis, i);
+      if (IS_SJIS_CHAR1(buf[i])) {
+         if(IS_SJIS_CHAR2(buf[i+1])) {
+            i++;
+            got_sjis += 2;
+            continue;
+         } else got_euc += 2;
+      }
+      if (IS_EUC_CHAR(buf[i])) {
+         if (IS_EUC_CHAR(buf[i+1])) {
+            got_euc += 2;
+            i++;
+         } else got_sjis += 2;
+      }
+      if (i >= 1)
+         if (IS_HANKANA_CHAR(buf[i - 2])
+               && IS_HANKANA_CHAR(buf[i - 1])
+               && IS_HANKANA_CHAR(buf[i])) {
+            got_sjis++;
+            if (IS_HANKANA_CHAR(buf[i+1])) got_sjis++;
+      }
+   }
+
+   _MSG(_("charset detect may mistake...\n"));
+   if (got_jis > 1)        return g_strdup("ISO-2022-JP");
+   if (got_sjis > got_euc) return g_strdup("SJIS");
+   else if (got_euc >= 1)  return g_strdup("EUC-JP");
+   
+   /* check CRLF code again... */
+   if (strstr(buf, "\r")) return g_strdup("SJIS");
+   else return g_strdup("EUC-JP");
+}
+
+/** get encoding charset.
+ * buf     : check target buffer.
+ * bufsize : buf's size.
+ * usemeta : if use meta tag, this is TRUE. and if using meta tag, return TRUE.
+ * return  : charset
+ */
+gchar *a_I18n_get_encoding(const gchar *buf, gint bufsize, gboolean *usemeta) {
+   gint i, utf_count = 0;
+
+   //*usemeta = FALSE;//for debug
+
+   /* use <meta> tag */
+   if (*usemeta) {
+      gchar  *metaBuf = NULL;
+      size_t metaBufSize;
+      if (bufsize > MAX_HEADER_LENGTH) metaBufSize = MAX_HEADER_LENGTH;
+      else metaBufSize = bufsize;
+      metaBuf = g_strndup(buf, metaBufSize);
+      metaBuf[metaBufSize - 1] = '\0';
+
+      if (metaBuf && a_Misc_stristr(metaBuf,"<meta"))
+         if(a_Misc_stristr(metaBuf,"http-equiv=\"content-type\"")) {
+            gchar *head_end     = a_Misc_stristr(metaBuf, "</head>");
+            gchar *meta_charset = a_Misc_stristr(metaBuf,"charset=");
+            if (meta_charset && head_end && (meta_charset < head_end)) {
+               gchar* charset = NULL;
+               meta_charset += sizeof("charset=") - 1;
+               if ((strpbrk(meta_charset, "\"'> ") - meta_charset) > 0) {
+                  charset = g_strndup(meta_charset,
+                        (strpbrk(meta_charset, "\"'> ") - meta_charset));
+               } else {
+                  MSG("not found ' or \" in <meta> tag!\n");
+                  charset = NULL;
+               }
+               g_free(metaBuf);
+               charset = a_I18n_fix_charset(charset);
+               if (charset) return charset;
+            } else {
+               MSG("<meta> outside of <head>!"
+                     " or not found charset.\n");
+            }
+         }
+      *usemeta = FALSE;
+   }
+
+   /* skip ascii char */
+   {
+      gint old_bufsize = bufsize;
+      for (i=0; i < old_bufsize; i++) {
+         if (IS_ASCII_CHAR(buf[0])
+               && buf[0] != 0x1b) { //for ISO-2022-JP detect
+            buf++;
+            bufsize--;
+         } else
+            break;
+      }
+      if (bufsize == 0) {
+         DEBUG_MSG(10, _("all ascii code\n"));
+         return g_strdup("ASCII");
+      }
+   }
+
+   /* Check UTF-8 code. */
+   for (i = 0; i < bufsize; i++) {
+      if (IS_UTF8_FIRST_CHAR(buf[i])) {
+         if (IS_ASCII_CHAR(buf[i+1])) {
+            utf_count -= 8;
+         } else if (IS_UTF8_2BYTE_FIRST_CHAR(buf[i])) {
+            if (IS_UTF8_NON_FIRST_CHAR(buf[i+1])
+                  && (IS_UTF8_FIRST_CHAR(buf[i+2])
+                     || IS_ASCII_CHAR(buf[i+2])))
+               utf_count++;
+            else
+               utf_count -= 8;
+         } else if (IS_UTF8_3BYTE_FIRST_CHAR(buf[i])) {
+            if (IS_UTF8_NON_FIRST_CHAR(buf[i+1])
+                  && IS_UTF8_NON_FIRST_CHAR(buf[i+2])
+                  && (IS_UTF8_FIRST_CHAR(buf[i+3])
+                     || IS_ASCII_CHAR(buf[i+3])))
+               utf_count+=2;
+            else
+               utf_count -= 8;
+         } else if (IS_UTF8_4BYTE_FIRST_CHAR(buf[i])
+               && IS_UTF8_NON_FIRST_CHAR(buf[i+1])
+               && IS_UTF8_NON_FIRST_CHAR(buf[i+2])
+               && IS_UTF8_NON_FIRST_CHAR(buf[i+3])
+               && (IS_UTF8_FIRST_CHAR(buf[i+4])
+                  || IS_ASCII_CHAR(buf[i+4])))
+            utf_count+=3;
+         else utf_count -= 8;
+         if (utf_count <= -16 || utf_count >= 16) break;
+      }
+   }
+   if (utf_count >= 9) return  g_strdup("UTF-8");
+
+   if (detect_ja_charset) return I18n_detect_japanese_charset(buf, bufsize);
+   else return g_strdup(DW_CHARSET);
+}
+
+/* [hack] iconv with error recovery */
+size_t a_I18n_iconv(iconv_t cd,
+      char **inbuf, size_t *inbytesleft,
+      char **outbuf, size_t *outbytesleft) {
+   size_t error_count = 0;
+   
+   if (iconv(cd, inbuf, inbytesleft, outbuf, outbytesleft)
+       == (size_t)-1 && errno != EINVAL) {
+      _MSG(_("unable to fully convert between character encodings\n"));
+      /*
+       * This just skips past unconvertable characters, putting white square
+       * in the output, then retries the conversion.
+       */
+      while ((int)*inbytesleft > 0 && (int)*outbytesleft > 0 && errno == EILSEQ) {
+         error_count++;
+         (*outbuf)[0]   = '['; /* white square */
+         (*outbuf)[1]   = ']';
+         *outbuf       += 2;
+         *outbytesleft -= 2;
+         *inbuf        += 2;
+         *inbytesleft  -= 2;
+         if ((int)*inbytesleft > 0 && (int)*outbytesleft > 0)
+            iconv(cd, inbuf, inbytesleft, outbuf, outbytesleft);
+      }
+   }
+   *outbuf[0] = '\0';
+   return error_count;
+}
+
+
+/* Charset Transrate. for the part which gives priority to speed.*/
+gchar *a_I18n_convert_raw(iconv_t it, const gchar* buf, size_t bufsize)
+{
+   gint outLeft, outSize;
+   gchar *outStart, *in, *out;
+
+   outLeft = bufsize * D_CHAR_GROWTH;
+   outSize = outLeft + 1;
+   if (!buf || outSize < 0) return NULL;
+
+   outStart = (gchar *)g_malloc(outSize);
+   in  = (gchar *)buf;
+   out = outStart;
+
+   if (!it || it==(iconv_t)-1) {
+      g_warning(_("no support enc\n"));
+      it = iconv_open("ASCII", DILLO_CHARSET);
+   }
+   a_I18n_iconv(it, &in, &bufsize, &out, &outLeft);
+   _MSG("free %d bytes.\n", outSize - outLeft);
+   return outStart = g_realloc(outStart, outSize - outLeft);
+}
+
+/* Charset Transrate. for simple text or string.
+ * if buf is nul-terminated, can set bufsize -1 */
+gchar *a_I18n_convert(const gchar* from, const gchar* to, const gchar* buf, gint bufsize)
+{
+   iconv_t it = iconv_open(to,from);
+   gchar *outStart;
+
+   if (!buf) return NULL;
+   outStart = a_I18n_convert_raw(it, buf,
+         (bufsize == -1) ? strlen(buf) : (size_t)bufsize);
+   _MSG("%s\n", from);
+   iconv_close(it);
+   return outStart;
+}
+
+/* Convert to Toolkit's charset. */
+gchar *a_I18n_DW_CHARSET_from_DILLO_CHARSET(const gchar* buf, gint bufsize) {
+   return a_I18n_convert(DILLO_CHARSET, DW_CHARSET, buf, bufsize);
+}
+
+/* Convert to internal charset. */
+gchar *a_I18n_DW_CHARSET_to_DILLO_CHARSET(const gchar* buf, gint bufsize) {
+   return a_I18n_convert(DW_CHARSET, DILLO_CHARSET, buf, bufsize);
+}
+
+/* For gettext string. */
+gchar *a_I18n_locale_to_DILLO_CHARSET(const gchar* buf) {
+   return a_I18n_convert(LOCALE_CHARSET, DILLO_CHARSET, buf, -1);
+}
+
+/* mblen() only for UTF-8 stream */
+gint a_I18n_mblen(gchar *str) {
+   if (IS_UTF8_3BYTE_FIRST_CHAR(str[0])) {
+      if (IS_UTF8_NON_FIRST_CHAR(str[1]))
+         if (IS_UTF8_NON_FIRST_CHAR(str[2]))
+            return 3;
+   } else if(IS_UTF8_2BYTE_FIRST_CHAR(str[0])) {
+      if (IS_UTF8_NON_FIRST_CHAR(str[1]))
+         return 2;
+   } else if(IS_UTF8_4BYTE_FIRST_CHAR(str[0])) {
+      if (IS_UTF8_NON_FIRST_CHAR(str[1]))
+         if (IS_UTF8_NON_FIRST_CHAR(str[2]))
+            if (IS_UTF8_NON_FIRST_CHAR(str[3]))
+               return 4;
+   }
+   return 0;
+}
+
+/*
+ * check invalid string, and repair.
+ */
+gchar *a_I18n_string_check(const gchar *input, const gchar *charset)
+{
+   gint i, len;
+   gchar *ret, *str;
+   GString *out = g_string_new("");
+   
+   /* invalid char will be replaced to white square. */
+   str = a_I18n_convert(charset, charset, input, -1);
+   len = strlen(str);
+
+   /* skip white square. */
+   for(i = 0; i < len; i++) {
+      if((guchar)str[i] == '[' 
+              && (guchar)str[i+1] == ']') {
+		  i++;
+      } else g_string_append_c(out, str[i]);
+   }
+   g_free(str);
+   ret = out->str;
+   g_string_free(out, FALSE);
+   return ret;
+}
+
+/* vim: set ts=3 sw=3 sts=3 expandtab:*/
diff -Nur dillo-0.8.0/src/i18n_gtk.c dillo-0.8.0.new/src/i18n_gtk.c
--- dillo-0.8.0/src/i18n_gtk.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/src/i18n_gtk.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,107 @@
+/*
+ * File: i18n_gtk.c
+ *
+ * Copyright (C) 2003 Kiyo <kiyo@teki.jpn.ph>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+/* gtk+ UTF-8 wrapper. */
+#include <string.h>
+#include <gtk/gtk.h>
+#include "i18n_gtk.h"
+#include "i18n.h"
+
+#ifndef DISABLE_I18N
+void a_I18n_gtk_label_set_text(GtkLabel *label, const gchar *str) {
+    gchar *locale_str = a_I18n_locale_from_DILLO_CHARSET(str, -1);
+    gtk_label_set_text(label, locale_str);
+    g_free(locale_str);
+}
+
+void a_I18n_gtk_window_set_title(GtkWindow *window, const gchar *title) {
+    gchar *locale_str = a_I18n_locale_from_DILLO_CHARSET(title, -1);
+    gtk_window_set_title(window, locale_str);
+    g_free(locale_str);
+}
+
+gchar* a_I18n_gtk_editable_get_chars(GtkEditable *editable,
+					gint start_pos, gint end_pos) {
+    gchar *locale_str = gtk_editable_get_chars(editable, start_pos, end_pos);
+    gchar *utf8_str = a_I18n_locale_to_DILLO_CHARSET(locale_str);
+    g_free(locale_str);
+    return utf8_str;
+}
+
+void a_I18n_gtk_editable_insert_text(GtkEditable *editable,
+					const gchar *new_text, gint new_text_length,
+					gint *position) {
+    gchar *locale_str = a_I18n_locale_from_DILLO_CHARSET(new_text,
+            new_text_length);
+    gtk_editable_insert_text(editable,
+            locale_str, strlen(locale_str), position);
+    g_free(locale_str);
+}
+
+GtkWidget* a_I18n_gtk_radio_menu_item_new_with_label(GSList *group,
+        const gchar *label) {
+    gchar *locale_str = a_I18n_locale_from_DILLO_CHARSET(label, -1);
+    GtkWidget* widget = gtk_radio_menu_item_new_with_label(group, locale_str);
+    g_free(locale_str);
+    return widget;
+}
+
+GtkWidget* a_I18n_gtk_list_item_new_with_label(const gchar *label) {
+    gchar *locale_str = a_I18n_locale_from_DILLO_CHARSET(label, -1);
+    GtkWidget* widget = gtk_list_item_new_with_label(locale_str);
+    g_free(locale_str);
+    return widget;
+}
+
+void a_I18n_gtk_text_insert(GtkText *text, GdkFont *font,
+				     GdkColor *fore, GdkColor *back,
+				     const char *chars, gint length) {
+    gchar *locale_str = a_I18n_locale_from_DILLO_CHARSET(chars, length);
+    gtk_text_insert(text, font, fore, back, locale_str, strlen(locale_str));
+    g_free(locale_str);
+}
+
+GtkWidget* a_I18n_gtk_button_new_with_label(const gchar *label) {
+    gchar *locale_str = a_I18n_locale_from_DILLO_CHARSET(label, -1);
+    GtkWidget* widget = gtk_button_new_with_label(locale_str);
+    g_free(locale_str);
+    return widget;
+}
+
+void a_I18n_gtk_entry_set_text(GtkEntry *entry, const gchar *text) {
+    gchar *locale_str = a_I18n_locale_from_DILLO_CHARSET(text, -1);
+    gtk_entry_set_text(entry, locale_str);
+    g_free(locale_str);
+}
+
+gchar* a_I18n_gtk_entry_get_text(GtkEntry *entry) {
+    gchar *locale_str = gtk_entry_get_text(entry);
+    gchar *utf8_str = a_I18n_locale_to_DILLO_CHARSET(locale_str);
+    return utf8_str;
+}
+
+GtkWidget* a_I18n_gtk_menu_item_new_with_label(const gchar *label) {
+    gchar *locale_str = a_I18n_locale_from_DILLO_CHARSET(label, -1);
+    GtkWidget* widget = gtk_menu_item_new_with_label(locale_str);
+    g_free(locale_str);
+    return widget;
+}
+void a_I18n_gdk_draw_string (GdkDrawable *drawable,
+        GdkFont *font,
+        GdkGC *gc,
+        gint x,
+        gint y,
+        const gchar *string) {
+    gchar *locale_str = a_I18n_locale_from_DILLO_CHARSET(string, -1);
+    gdk_draw_string (drawable, font, gc, x, y, locale_str);   
+    g_free(locale_str);
+}
+#endif /* DISABLE_I18n */
+
diff -Nur dillo-0.8.0/src/i18n_gtk.h dillo-0.8.0.new/src/i18n_gtk.h
--- dillo-0.8.0/src/i18n_gtk.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/src/i18n_gtk.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,72 @@
+#ifndef __GTK_I18N__
+#define __GTK_I18N__
+
+#include <gtk/gtk.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+//#define DISABLE_I18N
+#ifndef DISABLE_I18N
+
+/* GTK */
+void a_I18n_gtk_label_set_text (GtkLabel *label, const gchar *str);
+void a_I18n_gtk_window_set_title (GtkWindow *window, const gchar *title);
+gchar* a_I18n_gtk_editable_get_chars (GtkEditable *editable,
+					gint start_pos, gint end_pos);
+void a_I18n_gtk_editable_insert_text (GtkEditable *editable,
+					const gchar *new_text, gint new_text_length,
+					gint *position);
+GtkWidget* a_I18n_gtk_radio_menu_item_new_with_label (GSList *group,
+        const gchar *label);
+GtkWidget* a_I18n_gtk_list_item_new_with_label (const gchar *label);
+void a_I18n_gtk_text_insert (GtkText *text, GdkFont *font,
+				     GdkColor *fore, GdkColor *back,
+				     const char *chars, gint length);
+GtkWidget* a_I18n_gtk_button_new_with_label (const gchar *label);
+void a_I18n_gtk_entry_set_text (GtkEntry *entry, const gchar *text);
+gchar* a_I18n_gtk_entry_get_text (GtkEntry *entry);
+GtkWidget* a_I18n_gtk_menu_item_new_with_label (const gchar *label);
+
+/* GDK */
+void a_I18n_gdk_draw_string (GdkDrawable *drawable,
+        GdkFont *font,
+        GdkGC *gc,
+        gint x,
+        gint y,
+        const gchar *string);
+
+#else
+#define a_I18n_gtk_label_set_text(label, str) gtk_label_set_text(label, str)
+#define a_I18n_gtk_window_set_title(window, title) \
+        gtk_window_set_title(window, title)
+#define a_I18n_gtk_editable_get_chars(editable, start_pos, end_pos) \
+        gtk_editable_get_chars(editable, start_pos, end_pos)
+#define a_I18n_gtk_editable_insert_text(editable, new_text, \
+            new_text_length, position) \
+        gtk_editable_insert_text(editable, new_text, \
+            new_text_length, position)
+#define a_I18n_gtk_radio_menu_item_new_with_label(group, label) \
+        gtk_radio_menu_item_new_with_label(group, label)
+#define a_I18n_gtk_list_item_new_with_label(label) \
+        gtk_list_item_new_with_label(label)
+#define a_I18n_gtk_text_insert(text, font, fore, back, chars, length) \
+        gtk_text_insert(text, font, fore, back, chars, length)
+#define a_I18n_gtk_button_new_with_label(label) \
+        gtk_button_new_with_label(label)
+#define a_I18n_gtk_entry_set_text(entry, text) gtk_entry_set_text(entry, text)
+#define a_I18n_gtk_entry_get_text(entry) gtk_entry_get_text(entry)
+#define a_I18n_gtk_menu_item_new_with_label(label) \
+        gtk_menu_item_new_with_label(label)
+#define a_I18n_gdk_draw_string (drawable, font, gc, x, y,string) \
+        gdk_draw_string (drawable, font, gc, x, y, string)
+#endif /* DISABLE_I18n */
+
+#define a_I18n_gtk_label_set a_I18n_gtk_label_set_text
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __GTK_I18N__ */
diff -Nur dillo-0.8.0/src/i18n.h dillo-0.8.0.new/src/i18n.h
--- dillo-0.8.0/src/i18n.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/src/i18n.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,75 @@
+#ifndef __ENCODING_H__
+#define __ENCODING_H__
+
+#include <gtk/gtk.h>
+#include <stdlib.h> /* for getenv() */
+#include <iconv.h>
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#define IS_UTF8_FIRST_CHAR(c) ((((unsigned char)(c)) >> 6) == 0x03)
+#define IS_UTF8_NON_FIRST_CHAR(c) ((((unsigned char)(c)) >> 6) == 0x02)
+#define IS_UTF8_2BYTE_FIRST_CHAR(c) ((((unsigned char)(c)) >> 5) == 0x06)
+#define IS_UTF8_3BYTE_FIRST_CHAR(c) ((((unsigned char)(c)) >> 4) == 0x0E)
+#define IS_UTF8_4BYTE_FIRST_CHAR(c) ((((unsigned char)(c)) >> 3) == 0x1E)
+
+#define IS_HANKANA_CHAR(c) \
+   (((unsigned char)(c))>=0xa1 && ((unsigned char)(c))<=0xdf)
+
+#define IS_EUC_CHAR(c) \
+((((unsigned char)(c))>=0xa0 && ((unsigned char)(c))<=0xfe) \
+   || ((unsigned char)(c) == 0x8E)) //hankaku kana
+#define IS_EUC_HANKANA_CHAR(c) (((unsigned char)(c))==0x8E)
+#define IS_EUC_ZENASCII_CHAR(c) (((unsigned char)(c))==0xa3)
+#define IS_EUC_HIRA_CHAR(c) (((unsigned char)(c))==0xa4)
+#define IS_EUC_ZENKANA_CHAR(c) (((unsigned char)(c))==0xa5) 
+#define IS_EUC_KANJI_CHAR(c) \
+(((unsigned char)(c))>=0xb0 && ((unsigned char)(c))<=0xfe)
+
+#define IS_SJIS_CHAR1(c) \
+   ((((unsigned char)(c))>=0x81 && ((unsigned char)(c))<=0x9f) \
+    || (((unsigned char)(c))>=0xe0 && ((unsigned char)(c))<=0xef))
+#define IS_SJIS_CHAR2(c) \
+   (((unsigned char)(c))>=0x40 && ((unsigned char)(c))<=0xfc)
+
+#define MAX_WORD_LENGTH 20
+
+#define IS_ASCII_CHAR(c) (!(((unsigned char)(c)) & 0x80))
+
+#define DILLO_CHARSET "UTF-8"
+#define D_CHAR_GROWTH 3
+#define LOCALE_CHARSET (a_I18n_get_DW_charset())
+#define DW_CHARSET LOCALE_CHARSET
+#ifndef DISABLE_ANTI_ALIAS
+ #define RENDER_CHARSET "UTF-8"
+#else
+ #define RENDER_CHARSET DW_CHARSET
+#endif
+
+void   a_I18n_set_DW_lang(const gchar *lang);
+const gchar *a_I18n_get_DW_charset();
+gboolean a_I18n_has_latin1_charset();
+gchar *a_I18n_fix_charset(gchar *charset);
+gchar *a_I18n_get_encoding(const gchar *buf, gint bufsize, gboolean *usemeta);
+size_t a_I18n_iconv(iconv_t cd,
+      char **inbuf, size_t *inbytesleft,
+      char **outbuf, size_t *outbytesleft);
+gchar *a_I18n_convert_raw(iconv_t it, const gchar* buf, size_t bufsize);
+gchar *a_I18n_convert(const gchar* from, const gchar* to, const gchar* buf, gint bufsize);
+gchar *a_I18n_DW_CHARSET_from_DILLO_CHARSET(const gchar* buf, gint bufsize);
+gchar *a_I18n_DW_CHARSET_to_DILLO_CHARSET(const gchar* buf, gint bufsize);
+gchar *a_I18n_locale_to_DILLO_CHARSET(const gchar* buf);
+#define a_I18n_locale_from_DILLO_CHARSET a_I18n_DW_CHARSET_from_DILLO_CHARSET
+gint a_I18n_mblen(gchar *str);
+gchar *a_I18n_string_check(const gchar *input, const gchar *charset);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+
+#endif /* __ENCODING_H__ */
+
+/* vim: set ts=3 sw=3 sts=3 expandtab:*/
diff -Nur dillo-0.8.0/src/image.c dillo-0.8.0.new/src/image.c
--- dillo-0.8.0/src/image.c	2003-11-15 21:52:45.000000000 +0000
+++ dillo-0.8.0.new/src/image.c	2004-10-13 01:13:29.000000000 +0000
@@ -50,7 +50,7 @@
    Image->State = IMG_Empty;
 
    Image->RefCount = 1;
-
+ 
    return Image;
 }
 
diff -Nur dillo-0.8.0/src/interface.c dillo-0.8.0.new/src/interface.c
--- dillo-0.8.0/src/interface.c	2004-02-03 19:10:42.000000000 +0000
+++ dillo-0.8.0.new/src/interface.c	2004-10-13 01:13:29.000000000 +0000
@@ -20,18 +20,24 @@
 #include <sys/time.h>
 #include <fcntl.h>
 
+#include "intl.h"
 #include "msg.h"
 #include "list.h"
 #include "misc.h"
+#include "i18n.h"
+#include "i18n_gtk.h"
 #include "dillo.h"
 #include "history.h"
 #include "nav.h"
+#include "doc.h"
 #include "IO/Url.h"
 #include "IO/IO.h"
 #include "interface.h"
+#ifndef DISABLE_TABS
+#include "tab.h"
+#endif /* !DISABLE_TABS */
 #include "commands.h"
 #include "menu.h"
-#include "bookmark.h"
 #include "prefs.h"
 #include "url.h"
 #include "capi.h"
@@ -43,6 +49,10 @@
 #include "dw_container.h"
 #include "progressbar.h"
 
+#ifdef ENABLE_USER_AGENT
+#include "user_agent.h"
+#endif
+
 #include "pixmaps.h"
 #include <gdk/gdkkeysyms.h>
 
@@ -61,6 +71,8 @@
 /* We need only one of them. */
 static GtkTooltips *tooltips = NULL;
 
+/* Keep to close find_text_dialog. */
+static GtkWidget *find_text_window;
 
 /*
  * Initialize global data
@@ -73,93 +85,8 @@
    tooltips = gtk_tooltips_new ();
 }
 
-/*
- * Stop all active connections in the browser window (except downloads)
- */
-void a_Interface_stop(BrowserWindow *bw)
-{
-   DEBUG_MSG(3, "a_Interface_stop: hi!\n");
-
-   /* Remove root clients */
-   while ( bw->NumRootClients ) {
-      a_Cache_stop_client(bw->RootClients[0]);
-      a_List_remove(bw->RootClients, 0, bw->NumRootClients);
-   }
-   /* Remove image clients */
-   while ( bw->NumImageClients ) {
-      a_Cache_stop_client(bw->ImageClients[0]);
-      a_List_remove(bw->ImageClients, 0, bw->NumImageClients);
-   }
-}
-
-/*
- * Empty RootClients, ImageClients and PageUrls lists and
- * reset progress bar data.
- */
-void a_Interface_clean(BrowserWindow *bw)
-{
-   g_return_if_fail ( bw != NULL );
-
-   while ( bw->NumRootClients )
-      a_List_remove(bw->RootClients, 0, bw->NumRootClients);
-
-   while ( bw->NumImageClients )
-      a_List_remove(bw->ImageClients, 0, bw->NumImageClients);
-
-   while ( bw->NumPageUrls ) {
-      a_Url_free(bw->PageUrls[0].Url);
-      a_List_remove(bw->PageUrls, 0, bw->NumPageUrls);
-   }
-
-   /* Zero image-progressbar data */
-   bw->NumImages = 0;
-   bw->NumImagesGot = 0;
-}
-
 /*=== Browser Window Interface Updating =====================================*/
 /*
- * Remove the cache-client from the bw list
- * (client can be a image or a html page)
- */
-void a_Interface_remove_client(BrowserWindow *bw, gint ClientKey)
-{
-   gint i;
-   gboolean Found = FALSE;
-
-   for ( i = 0; !Found && i < bw->NumRootClients; ++i)
-      if ( bw->RootClients[i] == ClientKey ) {
-         a_List_remove(bw->RootClients, i, bw->NumRootClients);
-         Found = TRUE;
-      }
-
-   for ( i = 0; !Found && i < bw->NumImageClients; ++i)
-      if ( bw->ImageClients[i] == ClientKey ) {
-         a_List_remove(bw->ImageClients, i, bw->NumImageClients);
-         bw->NumImagesGot++;
-         Found = TRUE;
-      }
-
-   a_Interface_set_button_sens(bw);
-}
-
-/*
- * Remove the cache-client from the bw list
- * (client can be a image or a html page)
- */
-void a_Interface_close_client(BrowserWindow *bw, gint ClientKey)
-{
-   gchar numstr[32];
-
-   a_Interface_remove_client(bw, ClientKey);
-
-   /* --Progress bars stuff-- */
-   g_snprintf(numstr, 32, "%s%d of %d", PBAR_ISTR(prefs.panel_size == 1),
-              bw->NumImagesGot, bw->NumImages);
-   a_Progressbar_update(bw->imgprogress, numstr,
-                        (bw->NumImagesGot == bw->NumImages) ? 0 : 1 );
-}
-
-/*
  * Set the sensitivity on back/forw buttons and menu entries.
  */
 static gint Interface_sens_idle_func(BrowserWindow *bw)
@@ -167,16 +94,24 @@
    gboolean back_sensitive, forw_sensitive, stop_sensitive;
 
    /* Stop button */
-   stop_sensitive = (bw->NumRootClients > 0);
+   stop_sensitive = (bw->dd->NumRootClients > 0);
    gtk_widget_set_sensitive(bw->stop_button, stop_sensitive);
 
+
    /* Back and Forward buttons */
-   back_sensitive = a_Nav_stack_ptr(bw) > 0;
+   back_sensitive = a_Nav_stack_ptr(bw->dd) > 0;
    gtk_widget_set_sensitive(bw->back_button, back_sensitive);
-   forw_sensitive = (a_Nav_stack_ptr(bw) < a_Nav_stack_size(bw) - 1 &&
-                     !bw->nav_expecting);
+   forw_sensitive = (a_Nav_stack_ptr(bw->dd) < a_Nav_stack_size(bw->dd) - 1 &&
+                     !bw->dd->nav_expecting);
    gtk_widget_set_sensitive(bw->forw_button, forw_sensitive);
 
+   if(prefs.show_popup_navigation) {
+     /* adjust popup menu buttons */
+     gtk_widget_set_sensitive(bw->stop_op_menu_button, stop_sensitive);
+     gtk_widget_set_sensitive(bw->back_op_menu_button, back_sensitive);
+     gtk_widget_set_sensitive(bw->forw_op_menu_button, forw_sensitive);
+   }
+
    bw->sens_idle_id = 0;
    return FALSE;
 }
@@ -192,85 +127,18 @@
 }
 
 /*
- * Add a reference to the cache-client in the browser window's list.
- * This helps us keep track of which are active in the window so that it's
- * possible to abort them.
- * (Root: Flag, whether a Root URL or not)
- */
-void a_Interface_add_client(BrowserWindow *bw, gint Key, gint Root)
-{
-   gint nc;
-   char numstr[32];
-
-   g_return_if_fail ( bw != NULL );
-
-   if ( Root ) {
-      nc = bw->NumRootClients;
-      a_List_add(bw->RootClients, nc, bw->MaxRootClients);
-      bw->RootClients[nc] = Key;
-      bw->NumRootClients++;
-      a_Interface_set_button_sens(bw);
-   } else {
-      nc = bw->NumImageClients;
-      a_List_add(bw->ImageClients, nc, bw->MaxImageClients);
-      bw->ImageClients[nc] = Key;
-      bw->NumImageClients++;
-      bw->NumImages++;
-      a_Interface_set_button_sens(bw);
-
-      /* --Progress bar stuff-- */
-      g_snprintf(numstr, 32, "%s%d of %d", PBAR_ISTR(prefs.panel_size == 1),
-                 bw->NumImagesGot, bw->NumImages);
-      a_Progressbar_update(bw->imgprogress, numstr, 1);
-   }
-}
-
-/*
- * Add an URL to the browser window's list.
- * This helps us keep track of page requested URLs so that it's
- * possible to stop, abort and reload them.)
- *   Flags: Chosen from {BW_Root, BW_Image, BW_Download}
- */
-void a_Interface_add_url(BrowserWindow *bw, const DilloUrl *Url, gint Flags)
-{
-   gint nu, i;
-   gboolean found = FALSE;
-
-   g_return_if_fail ( bw != NULL && Url != NULL );
-
-   nu = bw->NumPageUrls;
-   for ( i = 0; i < nu; i++ ) {
-      if ( !a_Url_cmp(Url, bw->PageUrls[i].Url) ) {
-         found = TRUE;
-         break;
-      }
-   }
-   if ( !found ) {
-      a_List_add(bw->PageUrls, nu, bw->MaxPageUrls);
-      bw->PageUrls[nu].Url = a_Url_dup(Url);
-      bw->PageUrls[nu].Flags = Flags;
-      bw->NumPageUrls++;
-   }
-
-   /* test:
-   MSG("Urls:\n");
-   for (i = 0; i < bw->NumPageUrls; i++)
-      MSG("%s\n", bw->PageUrls[i].Url);
-   MSG("---\n");
-   */
-}
-
-/*
- * Remove a single browser window. This includes all its open childs,
+ * Remove a single browser window. This includes all its open documents,
  * freeing all resources associated with them, and exiting gtk
  * if no browser windows are left.
  */
 static gboolean Interface_quit(GtkWidget *widget, BrowserWindow *bw)
 {
    gint i;
-
-   /* stop/abort open connections. */
-   a_Interface_stop(bw);
+   a_Interface_findtext_dialog_close();
+   /* destroy the container. It should take all its contents with
+    * it, relying on callbacks to destroy non-widget data
+    */
+   gtk_widget_destroy(GTK_WIDGET(bw->container));
 
    g_slist_free(bw->PanelHandles);
 
@@ -280,12 +148,14 @@
       gtk_widget_destroy(bw->openfile_dialog_window);
    if (bw->quit_dialog_window != NULL)
       gtk_widget_destroy(bw->quit_dialog_window);
+   if (bw->question_dialog_window != NULL)
+      gtk_widget_destroy(bw->question_dialog_window);
    if (bw->findtext_dialog_window != NULL)
       gtk_widget_destroy(bw->findtext_dialog_window);
    if (bw->search_dialog_window != NULL)
       gtk_widget_destroy(bw->search_dialog_window);
-   if (bw->question_dialog_window != NULL)
-      gtk_widget_destroy(bw->question_dialog_window);
+   if (bw->passwd_dialog_window != NULL)
+      gtk_widget_destroy(bw->passwd_dialog_window);
 
    if (bw->menu_popup.over_page)
       gtk_widget_destroy(bw->menu_popup.over_page);
@@ -298,29 +168,25 @@
       gtk_widget_destroy(bw->menu_popup.over_forw);
    if (bw->menu_popup.over_bug)
       gtk_widget_destroy(bw->menu_popup.over_bug);
+#ifndef DISABLE_TABS
+   if (bw->menu_popup.over_tab)
+      gtk_widget_destroy(bw->menu_popup.over_tab);
+#endif /* !DISABLE_TABS */
    if (bw->menu_popup.url)
       a_Url_free(bw->menu_popup.url);
    if (bw->menu_popup.url2)
       a_Url_free(bw->menu_popup.url2);
-
+  
    if (bw->sens_idle_id)
       gtk_idle_remove(bw->sens_idle_id);
 
+
    for (i = 0; i < num_bw; i++)
       if (browser_window[i] == bw) {
          browser_window[i] = browser_window[--num_bw];
          break;
       }
 
-   /* free nav_stack and nav_expect stuff */
-   a_Nav_free(bw);
-
-   g_free(bw->RootClients);
-   g_free(bw->ImageClients);
-
-   for (i = 0; i < bw->NumPageUrls; i++)
-      a_Url_free(bw->PageUrls[i].Url);
-   g_free(bw->PageUrls);
    g_free(bw);
 
    if (num_bw == 0)
@@ -361,21 +227,6 @@
 }
 
 /*
- * Set the bw's cursor type
- */
-void a_Interface_set_cursor(BrowserWindow *bw, GdkCursorType CursorType)
-{
-   GdkCursor *cursor;
-
-   if ( bw->CursorType != CursorType ) {
-      cursor = gdk_cursor_new(CursorType);
-      gdk_window_set_cursor(bw->docwin->window, cursor);
-      gdk_cursor_destroy(cursor);
-      bw->CursorType = CursorType;
-   }
-}
-
-/*
  * Connect button's "clicked" event with (key, key_mod) pair.
  */
 static void Interface_set_button_accel(GtkButton *button,
@@ -411,7 +262,7 @@
 
    bw->clear_url_button = gtk_toolbar_append_item(
                              GTK_TOOLBAR(toolbar_l),
-                             NULL, "Clear the url-box!", "Toolbar/New",
+                             NULL, _("Clear the url-box!"), "Toolbar/New",
                              Interface_pixmap_new(bw->main_window, s_new_xpm),
                              NULL, NULL);
    gtk_signal_connect_object(GTK_OBJECT(bw->clear_url_button), "clicked",
@@ -425,7 +276,7 @@
 
    bw->search_button = gtk_toolbar_append_item(
                           GTK_TOOLBAR(toolbar_r),
-                          NULL, "Search the Web", "toolbar/New",
+                          NULL, _("Search the Web"), "toolbar/New",
                           Interface_pixmap_new(bw->main_window, search_xpm),
                           GTK_SIGNAL_FUNC(a_Interface_search_dialog),
                           bw);
@@ -457,8 +308,8 @@
    /* back button */
    bw->back_button = gtk_toolbar_append_item(
                         GTK_TOOLBAR(toolbar),
-                        label ? "Back" : NULL,
-                        "Go to previous page", "Toolbar/Back",
+                        label ? _("Back") : NULL,
+                        _("Go to previous page"), "Toolbar/Back",
                         Interface_pixmap_new(bw->main_window,
                                              s ? s_left_xpm : left_xpm),
                         (GtkSignalFunc) a_Commands_back_callback, bw);
@@ -471,8 +322,8 @@
    /* forward button */
    bw->forw_button = gtk_toolbar_append_item(
                         GTK_TOOLBAR(toolbar),
-                        label ? "Forward" : NULL,
-                        "Go to next page", "Toolbar/Forward",
+                        label ? _("Forward") : NULL,
+                        _("Go to next page"), "Toolbar/Forward",
                         Interface_pixmap_new(bw->main_window,
                                              s ? s_right_xpm : right_xpm),
                         (GtkSignalFunc) a_Commands_forw_callback, bw);
@@ -485,8 +336,8 @@
    /* home button */
    bw->home_button = gtk_toolbar_append_item(
                         GTK_TOOLBAR(toolbar),
-                        label ? "Home" : NULL,
-                        "Go to the Home page", "Toolbar/Home",
+                        label ? _("Home") : NULL,
+                        _("Go to the Home page"), "Toolbar/Home",
                         Interface_pixmap_new(bw->main_window,
                                              s ? s_home_xpm : home_xpm),
                         (GtkSignalFunc) a_Commands_home_callback, bw);
@@ -496,37 +347,41 @@
    /* reload button */
    bw->reload_button = gtk_toolbar_append_item(
                           GTK_TOOLBAR(toolbar),
-                          label ? "Reload" : NULL,
-                          "Reload this page", "Toolbar/Reload",
+                          label ? _("Reload") : NULL,
+                          _("Reload this page"), "Toolbar/Reload",
                           Interface_pixmap_new(bw->main_window,
                                                s ? s_reload_xpm : reload_xpm),
                           (GtkSignalFunc) a_Commands_reload_callback, bw);
    Interface_set_button_accel(GTK_BUTTON(bw->reload_button), GDK_r,
                               GDK_CONTROL_MASK, bw->accel_group);
+   Interface_set_button_accel(GTK_BUTTON(bw->reload_button), GDK_F5,
+                              0, bw->accel_group);
 
    /* save button */
    bw->save_button = gtk_toolbar_append_item(
                         GTK_TOOLBAR(toolbar),
-                        label ? "Save" : NULL,
-                        "Save this page", "Toolbar/Save",
+                        label ? _("Save") : NULL,
+                        _("Save this page"), "Toolbar/Save",
                         Interface_pixmap_new(bw->main_window,
                                              s ? s_save_xpm : save_xpm),
                         (GtkSignalFunc) a_Commands_save_callback, bw);
    /* stop button */
    bw->stop_button = gtk_toolbar_append_item(
                         GTK_TOOLBAR(toolbar),
-                        label ? "Stop" : NULL,
-                        "Stop the current transfer", "Toolbar/Stop",
+                        label ? _("Stop") : NULL,
+                        _("Stop the current transfer"), "Toolbar/Stop",
                         Interface_pixmap_new(bw->main_window,
                                              s ? s_stop_xpm : stop_xpm),
                         (GtkSignalFunc) a_Commands_stop_callback, bw);
    gtk_widget_set_sensitive(bw->stop_button, FALSE);
+   Interface_set_button_accel(GTK_BUTTON(bw->stop_button), GDK_Escape,
+                              0, bw->accel_group);
 
    /* bookmarks button */
    bw->bookmarks_button = gtk_toolbar_append_item(
                              GTK_TOOLBAR(toolbar),
-                             label ? "Book" : NULL,
-                             "View bookmarks", "Toolbar/Bookmarks",
+                             label ? _("Book") : NULL,
+                             _("View bookmarks"), "Toolbar/Bookmarks",
                              Interface_pixmap_new(bw->main_window,
                                                   s ? s_bm_xpm : bm_xpm),
                              (GtkSignalFunc) a_Commands_viewbm_callback, bw);
@@ -560,25 +415,73 @@
    return (progbox);
 }
 
+#ifdef ENABLE_USER_AGENT
+/*
+ * Create User-Agent box
+ */
+static GtkWidget *Interface_useragent_new(BrowserWindow *bw, gint small_label)
+{
+   GtkWidget *combo, *label, *hbox, *handlebox;
+   GList *list = NULL;
+   gint i;
+
+   handlebox = gtk_handle_box_new();
+   label = gtk_label_new((small_label)? "UA:" : "User Agent:");
+   combo = gtk_combo_new();
+
+   gtk_signal_connect(GTK_OBJECT(GTK_COMBO(combo)->entry), "changed",
+                      (GtkSignalFunc) a_Commands_useragent_callback, bw);
+   if (prefs.user_agent) {
+      list = g_list_append(list, prefs.user_agent);
+   }
+   i = 0;
+   while ( strcmp(user_agent_text[i], "") ) {
+      list = g_list_append(list, user_agent_text[i]);
+      i++;
+   }
+   gtk_combo_set_popdown_strings(GTK_COMBO(combo), list);
+ 
+   hbox = gtk_hbox_new(FALSE, 0);
+   gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, TRUE, 10);
+   gtk_widget_show(label);
+   gtk_box_pack_start(GTK_BOX(hbox), combo, TRUE, TRUE, 0);
+   gtk_widget_show(combo);
+   gtk_container_add(GTK_CONTAINER(handlebox), hbox);
+   gtk_widget_show(hbox);
+   return handlebox;
+}
+#endif
+
 /*
  * Hide/Unhide this bw's control panels.
  * toggle: Flag [toggle or set].
  */
-void Interface_toggle_panel(BrowserWindow *bw, gint toggle)
+void a_Interface_toggle_panel(BrowserWindow *bw, gboolean toggle)
 {
    if (toggle)
       bw->fullwindow = !bw->fullwindow;
 
    if (bw->fullwindow) {
       g_slist_foreach(bw->PanelHandles, (GFunc)gtk_widget_hide, NULL);
+#ifdef ENABLE_USER_AGENT
+      gtk_widget_hide(bw->useragent_box);
+#endif
       gtk_widget_hide(bw->status_box);
       gtk_widget_show (bw->full_screen_off_button);
-      gtk_widget_grab_focus(GTK_BIN(bw->docwin)->child);
+      gtk_widget_grab_focus(GTK_BIN(bw->dd->docwin)->child);
    } else {
       g_slist_foreach(bw->PanelHandles, (GFunc)gtk_widget_show, NULL);
+#ifdef ENABLE_USER_AGENT
+      if ( prefs.show_user_agent )
+          gtk_widget_show(bw->useragent_box);
+#endif
       gtk_widget_show(bw->status_box);
       gtk_widget_hide (bw->full_screen_off_button);
    }
+#ifndef DISABLE_TABS
+   a_Tab_visibility_update(bw);
+#endif /* !DISABLE_TABS */
+
 }
 
 /*
@@ -610,52 +513,13 @@
       gtk_widget_hide(bw->search_button);
    if ( !prefs.show_progress_box )
       gtk_widget_hide(bw->progress_box);
+#ifdef ENABLE_USER_AGENT
+   if ( !prefs.show_user_agent )
+      gtk_widget_hide(bw->useragent_box);
+#endif
 
    bw->fullwindow = prefs.fullwindow_start;
-   Interface_toggle_panel(bw, FALSE);
-}
-
-static void Interface_full_screen_callback (BrowserWindow *bw)
-{
-   Interface_toggle_panel(bw, TRUE);
-}
-
-/*
- * Handler for double-mouse-clicks that don't belong to the viewport.
- */
-static gint Interface_click_callback(BrowserWindow *bw, GdkEventButton *event)
-{
-   if (event->type == GDK_2BUTTON_PRESS && event->button == 1)
-      Interface_toggle_panel(bw, TRUE);
-   return TRUE;
-}
-
-/*
- * Handler for key presses that don't belong to the viewport.
- * (Used to customize the interface a bit)
- */
-static void Interface_key_press_handler(GtkWidget *widget,
-                                        GdkEventKey *event,
-                                        gpointer client_data)
-{
-   BrowserWindow *bw = client_data;
-
-   switch (event->keyval) {
-   case GDK_BackSpace:
-      /* This key is handled here because GTK accel group ignores it */
-      if (event->state & GDK_SHIFT_MASK)
-         a_Commands_forw_callback(NULL, bw);
-      else
-         a_Commands_back_callback(NULL, bw);
-      break;
-   case GDK_slash:
-      /* This key is handled here because GTK accel group ignores it */
-      a_Commands_findtext_callback(NULL, bw);
-      break;
-   default:
-      _MSG(">> Key pressed!\n");
-      break;
-   }
+   a_Interface_toggle_panel(bw, FALSE);
 }
 
 /*
@@ -678,7 +542,8 @@
 
    button = gtk_button_new ();
    gtk_button_set_relief (GTK_BUTTON (button), GTK_RELIEF_NONE);
-   gtk_tooltips_set_tip (tooltips, button, "Hide Controls", "Show Controls");
+   gtk_tooltips_set_tip (tooltips, button,
+           _("Hide Controls"), _("Show Controls"));
    GTK_WIDGET_UNSET_FLAGS (button, GTK_CAN_FOCUS);
    gtk_box_pack_start (GTK_BOX (vbox), button, FALSE, FALSE, 0);
    gtk_widget_show (button);
@@ -689,9 +554,13 @@
 
    gtk_signal_connect_object
       (GTK_OBJECT (button), "clicked",
-       GTK_SIGNAL_FUNC (Interface_full_screen_callback), (gpointer)bw);
+       GTK_SIGNAL_FUNC (a_Commands_full_screen_callback), (gpointer)bw);
 }
 
+/*******************
+ * browser windows *
+ *******************/
+
 /*
  * Create a new browser window and return it.
  * (the new window is stored in browser_window[])
@@ -701,6 +570,9 @@
 {
    GtkWidget *box1, *hbox, *button, *label,
              *progbox, *toolbar, *handlebox, *menubar, *locbox, *pixmap;
+#ifdef DISABLE_TABS
+   GtkWidget *box2;
+#endif /* DISABLE_TABS */
    BrowserWindow *bw;
    char buf[64];
 
@@ -709,14 +581,17 @@
    a_List_add(browser_window, num_bw, num_bw_max);
    browser_window[num_bw++] = bw;
 
-   /* initialize nav_stack struct in browser_window struct */
-   a_Nav_init(bw);
-
    if (!xid)
        bw->main_window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
    else
        bw->main_window = gtk_plug_new(xid);
 
+   /* set tooltips.
+    * TODO: this is a global, change to browser-window local?
+    */
+   bw->tooltips = tooltips;
+   gtk_tooltips_enable(bw->tooltips);
+
    gtk_window_set_policy(GTK_WINDOW(bw->main_window), TRUE, TRUE, FALSE);
    gtk_signal_connect(GTK_OBJECT(bw->main_window), "delete_event",
                       GTK_SIGNAL_FUNC(gtk_object_destroy), bw);
@@ -726,6 +601,8 @@
 
    gtk_window_set_wmclass(GTK_WINDOW(bw->main_window), "dillo", "Dillo");
 
+   gtk_widget_set_usize(bw->main_window, width, height);
+
    /* -RL :: I must realize the window to see it correctly */
    gtk_widget_realize(bw->main_window);
 
@@ -733,10 +610,6 @@
    bw->accel_group = gtk_accel_group_new();
    gtk_window_add_accel_group(GTK_WINDOW(bw->main_window), bw->accel_group);
 
-   /* set window title */
-   g_snprintf(buf, 64, "Version %s", VERSION);
-   a_Interface_set_page_title(bw, buf);
-
    box1 = gtk_vbox_new(FALSE, 0);
 
    /* setup the control panel */
@@ -752,6 +625,10 @@
       locbox = Interface_locbar_new(bw);
       /* progress bars */
       progbox = Interface_progressbox_new(bw, 0);
+#ifdef ENABLE_USER_AGENT
+      /* User Agent entry */
+      bw->useragent_box = Interface_useragent_new(bw, 1);
+#endif
 
       gtk_box_pack_start(GTK_BOX(hbox), toolbar, FALSE, FALSE, 0);
       gtk_widget_show(toolbar);
@@ -765,8 +642,10 @@
       gtk_widget_show(hbox);
       gtk_box_pack_start(GTK_BOX(box1), handlebox, FALSE, FALSE, 0);
       gtk_widget_show(handlebox);
-
    } else if (prefs.panel_size == 2) {
+#ifdef ENABLE_USER_AGENT
+      bw->useragent_box = Interface_useragent_new(bw, 0);
+#endif
       handlebox = gtk_handle_box_new();
       bw->PanelHandles = g_slist_append(bw->PanelHandles, handlebox);
       hbox = gtk_hbox_new(FALSE, 0);
@@ -797,6 +676,9 @@
       gtk_widget_show(handlebox);
 
    } else {
+#ifdef ENABLE_USER_AGENT
+      bw->useragent_box = Interface_useragent_new(bw, 0);
+#endif
       handlebox = gtk_handle_box_new();
       bw->PanelHandles = g_slist_append(bw->PanelHandles, handlebox);
       menubar = a_Menu_mainbar_new(bw, 0);
@@ -822,69 +704,98 @@
 
       handlebox = gtk_handle_box_new();
       bw->PanelHandles = g_slist_append(bw->PanelHandles, handlebox);
+      hbox = gtk_hbox_new(FALSE, 0);
       locbox = Interface_locbar_new(bw);
-      gtk_container_add(GTK_CONTAINER(handlebox), locbox);
+      gtk_box_pack_start(GTK_BOX(hbox), locbox, TRUE, TRUE, 0);
       gtk_widget_show(locbox);
+      gtk_container_add(GTK_CONTAINER(handlebox), hbox);
+      gtk_widget_show(hbox);
       gtk_box_pack_start(GTK_BOX(box1), handlebox, FALSE, FALSE, 0);
       gtk_widget_show(handlebox);
    }
 
+#ifdef ENABLE_USER_AGENT
+   gtk_box_pack_start(GTK_BOX(box1), bw->useragent_box, FALSE, FALSE, 0);
+   gtk_widget_show(bw->useragent_box);
+#endif
    /* Add box1 */
    gtk_container_add(GTK_CONTAINER(bw->main_window), box1);
 
-   /* Now the main document window */
-   bw->docwin = a_Dw_gtk_scrolled_window_new();
-   gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(bw->docwin),
-                                  GTK_POLICY_AUTOMATIC, GTK_POLICY_AUTOMATIC);
-   gtk_box_pack_start(GTK_BOX(box1), bw->docwin, TRUE, TRUE, 0);
-   gtk_widget_show(bw->docwin);
+   /* Create the full_screen_off_button. This button is shared between all
+    * documents in a tabbed browser. On switching tabs it is reparented
+    * to the new current tab */
+   bw->full_screen_off_button = gtk_button_new ();
+   gtk_button_set_relief (GTK_BUTTON (bw->full_screen_off_button),
+                          GTK_RELIEF_NONE);
+   gtk_tooltips_set_tip (tooltips, bw->full_screen_off_button,
+                         _("Show Controls"), _("Hide Controls"));
+   GTK_WIDGET_UNSET_FLAGS (bw->full_screen_off_button, GTK_CAN_FOCUS);
+
+   pixmap = Interface_pixmap_new(bw->main_window, full_screen_off_xpm);
+   gtk_container_add (GTK_CONTAINER (bw->full_screen_off_button), pixmap);
+   gtk_widget_show (pixmap);
+
+   gtk_signal_connect_object
+      (GTK_OBJECT (bw->full_screen_off_button), "clicked",
+       GTK_SIGNAL_FUNC (a_Commands_full_screen_callback), (gpointer)bw);
+
+#ifndef DISABLE_TABS
+   /* add tab browser */
+   bw->container = a_Tab_browser_new(bw);
+   /* Add initial tab*/
+   a_Tab_new(bw);
+#else
+   /* add document container */
+   bw->dd = a_Doc_new();
+   a_Doc_set_browserwindow(bw->dd, bw);
+   /* add box2, which will contain the docwin and the frameset.
+    * Usually, only one of these is visible at any time */
+   box2 = gtk_hbox_new(TRUE, 0);
+   gtk_container_set_border_width(GTK_CONTAINER(box2), 0);
+   gtk_box_pack_start(GTK_BOX(box2), GTK_WIDGET(bw->dd->docwin), TRUE, TRUE, 0);
+   /* as this is a new document, the frameset will be empty so there
+    * is no need to pack it in the box */
+   gtk_widget_show(box2);
+
+   /* point bw->container at the box containing dd's docwin. 
+    * This ensures that the docwin (and, through its callback,
+    * the associated DilloDoc) is destroyed when the window is closed */
+   bw->container = GTK_CONTAINER(box2);
 
    /* todo (GTK2): this call is a bit of a workaround to missing focus
     * between the location box and the docwin. It's fixed in GTK2:
     * http://mail.gnome.org/archives/gtk-list/2003-June/msg00307.html  */
-   gtk_widget_grab_focus(GTK_BIN(bw->docwin)->child);
+   gtk_widget_grab_focus(GTK_BIN(bw->dd->docwin)->child);
 
    /* Full screen mode via double click is done in two ways: First,
     * a feature of the selection is used, since in complex pages,
     * getting events back to the viewport is quite difficult. Second,
     * a simple callback, called e.g. when viewing image resources. */
    a_Selection_set_dclick_callback(
-      GTK_DW_VIEWPORT(GTK_BIN(GTK_BIN(bw->docwin)->child)->child)->selection,
-      (void(*)(gpointer))Interface_full_screen_callback, bw);
+      GTK_DW_VIEWPORT(GTK_BIN(GTK_BIN(bw->dd->docwin)->child)->child)->selection,
+      (void(*)(gpointer))a_Commands_full_screen_callback, bw);
    /* Selection requires an owner widget */
    a_Selection_set_owner(
-      GTK_DW_VIEWPORT(GTK_BIN(GTK_BIN(bw->docwin)->child)->child)->selection,
-      GTK_BIN(bw->docwin)->child);
+      GTK_DW_VIEWPORT(GTK_BIN(GTK_BIN(bw->dd->docwin)->child)->child)->selection,
+      GTK_BIN(bw->dd->docwin)->child);
 
-   gtk_signal_connect_object_after(GTK_OBJECT(GTK_BIN(bw->docwin)->child),
+   gtk_signal_connect_object_after(GTK_OBJECT(GTK_BIN(bw->dd->docwin)->child),
                                    "button_press_event",
-                                   GTK_SIGNAL_FUNC(Interface_click_callback),
+                                   GTK_SIGNAL_FUNC(a_Commands_click_callback),
                                    (gpointer)bw);
 
-   bw->full_screen_off_button = gtk_button_new ();
-   gtk_button_set_relief (GTK_BUTTON (bw->full_screen_off_button),
-                          GTK_RELIEF_NONE);
-   gtk_tooltips_set_tip (tooltips, bw->full_screen_off_button,
-                         "Show Controls", "Hide Controls");
-   GTK_WIDGET_UNSET_FLAGS (bw->full_screen_off_button, GTK_CAN_FOCUS);
-   a_Dw_gtk_scrolled_window_add_gadget (GTK_DW_SCROLLED_WINDOW (bw->docwin),
-                                        bw->full_screen_off_button);
-   pixmap = Interface_pixmap_new(bw->main_window, full_screen_off_xpm);
-   gtk_container_add (GTK_CONTAINER (bw->full_screen_off_button), pixmap);
-   gtk_widget_show (pixmap);
-
-   gtk_signal_connect_object
-      (GTK_OBJECT (bw->full_screen_off_button), "clicked",
-       GTK_SIGNAL_FUNC (Interface_full_screen_callback), (gpointer)bw);
+   a_Dw_gtk_scrolled_window_add_gadget(GTK_DW_SCROLLED_WINDOW (bw->dd->docwin),
+                                       bw->full_screen_off_button);
    Interface_set_button_accel(GTK_BUTTON(bw->full_screen_off_button), GDK_h,
                               GDK_CONTROL_MASK, bw->accel_group);
-
+   
    /* Catch key_press event */
-   gtk_signal_connect(GTK_OBJECT(GTK_BIN(bw->docwin)->child),
+   gtk_signal_connect(GTK_OBJECT(GTK_BIN(bw->dd->docwin)->child),
                       "key_press_event",
-                      GTK_SIGNAL_FUNC(Interface_key_press_handler), bw);
-
-   gtk_widget_set_usize(bw->main_window, width, height);
+                      GTK_SIGNAL_FUNC(a_Commands_key_press_handler), bw);
+#endif /* !DISABLE_TABS */
+   gtk_box_pack_start(GTK_BOX(box1), GTK_WIDGET(bw->container), TRUE, TRUE, 0);
+   gtk_widget_show(GTK_WIDGET(bw->container));
 
    /* status widget */
    bw->status = a_Dw_gtk_statuslabel_new("");
@@ -906,7 +817,7 @@
    gtk_box_pack_start(GTK_BOX(hbox), label, FALSE, FALSE, 0);
    gtk_container_add (GTK_CONTAINER (button), hbox);
    gtk_widget_show(hbox);
-   gtk_tooltips_set_tip (tooltips, button, "Show HTML bugs", "");
+   gtk_tooltips_set_tip (tooltips, button, _("Show HTML bugs"), "");
 
    bw->status_box = gtk_hbox_new(FALSE, 0);
    gtk_box_pack_start(GTK_BOX(bw->status_box), bw->status, TRUE, TRUE, 2);
@@ -923,38 +834,6 @@
    gtk_widget_show(box1);
 
    /* initialize the rest of the bw's data. */
-   bw->pagemarks_menuitem = NULL;
-   bw->pagemarks_menu = NULL;
-   bw->pagemarks_last = NULL;
-   bw->viewbugs_menuitem = NULL;
-
-   /* the image menu is created first because it is used by the link menu */
-   bw->menu_popup.over_image = a_Menu_popup_oi_new(bw);
-   bw->menu_popup.over_link = a_Menu_popup_ol_new(bw);
-   bw->menu_popup.over_page = a_Menu_popup_op_new(bw);
-   bw->menu_popup.over_bug  = a_Menu_popup_ob_new(bw);
-   bw->menu_popup.over_back = NULL;
-   bw->menu_popup.over_forw = NULL;
-   bw->menu_popup.url = NULL;
-   bw->menu_popup.url2 = NULL;
-   bw->sens_idle_id = 0;
-
-   bw->CursorType = -1;
-
-   bw->RootClients = NULL;
-   bw->NumRootClients = 0;
-   bw->MaxRootClients = 8;
-
-   bw->ImageClients = NULL;
-   bw->NumImageClients = 0;
-   bw->MaxImageClients = 8;
-   bw->NumImages = 0;
-   bw->NumImagesGot = 0;
-
-   bw->PageUrls = NULL;
-   bw->NumPageUrls = 0;
-   bw->MaxPageUrls = 8;
-
    bw->open_dialog_window = NULL;
    bw->open_dialog_entry = NULL;
    bw->openfile_dialog_window = NULL;
@@ -968,15 +847,58 @@
    bw->search_dialog_entry = NULL;
    bw->question_dialog_window = NULL;
    bw->question_dialog_data = NULL;
+   bw->passwd_dialog_window = NULL;
+   bw->passwd_dialog_uentry = NULL;
+   bw->passwd_dialog_pentry = NULL;
    bw->viewsource_window = NULL;
    bw->pagebugs_window = NULL;
 
+   bw->pagemarks_menuitem = NULL;
+   bw->viewbugs_menuitem = NULL;
+   bw->frame_menuitem = NULL;
+   bw->frameset_menuitem = NULL;
+   bw->menu_popup.over_frame = NULL;
+   bw->back_op_menu_button = NULL;
+   bw->forw_op_menu_button = NULL;
+   bw->stop_op_menu_button = NULL;
+
+   /* the image menu is created first because it is used by the link menu */
+   bw->menu_popup.over_image = a_Menu_popup_oi_new(bw);
+   bw->menu_popup.over_page = a_Menu_popup_op_new(bw);
+   bw->menu_popup.over_link = a_Menu_popup_ol_new(bw);
+   bw->menu_popup.over_back = NULL;
+   bw->menu_popup.over_forw = NULL;
+
+#ifndef DISABLE_TABS
+   bw->menu_popup.over_tab = NULL;
+#endif /* !DISABLE_TABS */
+   bw->menu_popup.url = NULL;
+
+   bw->found = FALSE;
+   bw->dd_list = NULL;
+   bw->dd_list_index = 0;
+
+   bw->menu_popup.url2 = NULL;
+   bw->sens_idle_id = 0;
+
+   /* set focus to location bar */
+   if(prefs.focus_location_on_new)
+      gtk_widget_grab_focus(bw->location);
+   else
+      gtk_widget_grab_focus(GTK_BIN(bw->dd->docwin)->child);
+
+   /* set document (and window) title */
+   g_snprintf(buf, 64, "Version %s", VERSION);
+   a_Doc_title_set(bw->dd, buf);
+
    /* now that the bw is made, let's customize it.. */
    Interface_browser_window_customize(bw);
 
    return bw;
 }
 
+
+
 /*
  * Set the title of the browser window to start with "Dillo: "
  * prepended to it.
@@ -989,7 +911,7 @@
 
    buf = g_string_new("");
    g_string_sprintfa(buf, "Dillo: %s", title);
-   gtk_window_set_title(GTK_WINDOW(bw->main_window), buf->str);
+   a_I18n_gtk_window_set_title(GTK_WINDOW(bw->main_window), buf->str);
    g_string_free(buf, TRUE);
 }
 
@@ -1030,7 +952,7 @@
       va_start(argp, format);
       vsnprintf(msg, 1024, format, argp);
       va_end(argp);
-      gtk_label_set_text(GTK_LABEL(bw->status), msg);
+      a_I18n_gtk_label_set_text(GTK_LABEL(bw->status), msg);
       bw->status_is_link = 0;
    }
 }
@@ -1148,7 +1070,7 @@
    Cfn = (s = a_Misc_escape_chars(fn, "% ")) ? s : fn;
    g_string_sprintf(UrlStr, "file:%s", Cfn);
    url = a_Url_new(UrlStr->str, NULL, 0, 0, 0);
-   a_Nav_push(bw, url);
+   a_Nav_push(bw->dd, url);
    a_Url_free(url);
    g_string_free(UrlStr, TRUE);
    g_free(s);
@@ -1163,35 +1085,29 @@
  */
 static gchar *Interface_make_search_url(const gchar *str)
 {
-   gchar *p, *keys, *new_str;
-
-   keys = g_new(gchar, 3*strlen(str)+1);
-
-   for (p = keys; *str; str++) {
-      switch(*str) {
-      case ' ':
-         *p++ = '+';
-         break;
-      case '"':
-         *p++ = '%';
-         *p++ = '2';
-         *p++ = '2';
-         break;
-      case '+':
-         *p++ = '%';
-         *p++ = '2';
-         *p++ = 'B';
-         break;
-      default:
-         *p++ = *str;
-      }
+   gchar *enc_str, *keys, *url_str;
+   gint i, j;
+   static const char *hex = "0123456789ABCDEF";
+   
+   enc_str = a_I18n_convert(DILLO_CHARSET, prefs.search_charset, str, -1);
+   keys = g_new(gchar, strlen(enc_str) * 3 + 1);
+   for (i = 0, j = 0; enc_str[i] != '\0'; i++) {
+       if (enc_str[i] == ' ') keys[j++] = '+';
+       else if (isalnum (enc_str[i]) || strchr("-_.*", enc_str[i]))
+           keys[j++] = enc_str[i];
+       else {
+           keys[j++] = '%';
+           keys[j++] = hex[(enc_str[i] >> 4) & 15];
+           keys[j++] = hex[enc_str[i] & 15];
+       }
    }
-   *p = '\0';
+   keys[j] = '\0';
 
-   new_str = g_strdup_printf(prefs.search_url, keys);
+   url_str = g_strdup_printf(prefs.search_url, keys);
    g_free(keys);
+   g_free(enc_str);
 
-   return new_str;
+   return url_str;
 }
 
 /*
@@ -1210,14 +1126,14 @@
 
       url = a_Url_new(new_text, NULL, 0, 0, 0);
       if (url) {
-         a_Nav_push(bw, url);
+         a_Nav_push(bw->dd, url);
          a_Url_free(url);
       }
       g_free(new_text);
    }
 
    /* let the rendered area have focus */
-   gtk_widget_grab_focus(GTK_BIN(bw->docwin)->child);
+   gtk_widget_grab_focus(GTK_BIN(bw->dd->docwin)->child);
 }
 
 /*
@@ -1248,7 +1164,7 @@
    if (!bw->openfile_dialog_window) {
       Interface_make_choose_file_dialog(
          &(bw->openfile_dialog_window),
-         "openfile_dialog", "Dillo", "Dillo: Open File",
+         "openfile_dialog", "Dillo", _("Dillo: Open File"),
          (GtkSignalFunc) Interface_openfile_ok_callback, (void *)bw);
    }
 
@@ -1318,7 +1234,7 @@
                              (GtkSignalFunc) gtk_widget_grab_default,
                              GTK_OBJECT(button));
 
-   button = gtk_button_new_with_label("Clear");
+   button = gtk_button_new_with_label(_("Clear"));
    gtk_signal_connect_object(GTK_OBJECT(button), "clicked",
                              (GtkSignalFunc) Interface_entry_clear,
                              GTK_OBJECT(entry));
@@ -1326,7 +1242,7 @@
    gtk_box_pack_start(GTK_BOX(box2), button, FALSE, TRUE, 0);
    gtk_widget_show(button);
 
-   button = gtk_button_new_with_label("Cancel");
+   button = gtk_button_new_with_label(_("Cancel"));
    gtk_signal_connect_object(GTK_OBJECT(button), "clicked",
                              (GtkSignalFunc) gtk_widget_destroy,
                              GTK_OBJECT(*DialogWindow));
@@ -1370,14 +1286,14 @@
    gtk_box_pack_start(GTK_BOX(box1), frame, TRUE, TRUE, 0);
 
    box2 = gtk_hbox_new(TRUE, 5);
-   button = gtk_button_new_with_label("OK");
+   button = gtk_button_new_with_label(_("OK"));
    gtk_signal_connect_object(GTK_OBJECT(button), "clicked",
                              OkCallback, OkCbData);
    gtk_signal_connect(GTK_OBJECT(button), "clicked",
                       (GtkSignalFunc) Interface_destroy_window, DialogWindow);
    gtk_widget_show(button);
    gtk_box_pack_start(GTK_BOX(box2), button, FALSE, TRUE, 0);
-   button = gtk_button_new_with_label("Cancel");
+   button = gtk_button_new_with_label(_("Cancel"));
    gtk_signal_connect_object(GTK_OBJECT(button), "clicked",
                              CancelCallback, CancelCbData);
    gtk_signal_connect(GTK_OBJECT(button), "clicked",
@@ -1394,6 +1310,102 @@
 }
 
 /*
+ * Make a password-dialog with two entries, OK and Cancel.
+ */
+void Interface_make_passwd_dialog(
+        GtkWidget **DialogWindow, char *WmName, char *WmClass,
+        char *WTitle, char *Context,
+        GtkWidget **passwd_dialog_uentry,
+        GtkWidget **passwd_dialog_pentry,
+        GtkSignalFunc OkCallback, void *OkCbData,
+        GtkSignalFunc CancelCallback, void *CancelCbData)
+{
+   GtkWidget *label,
+      *label_user,
+      *label_pass,
+      *button,
+      *box_l,
+      *box_u,
+      *box_p,
+      *box_b;
+
+   *DialogWindow = gtk_window_new(GTK_WINDOW_DIALOG);
+   gtk_window_set_wmclass(GTK_WINDOW(*DialogWindow), WmName, WmClass);
+   gtk_window_set_title(GTK_WINDOW(*DialogWindow), WTitle);
+   gtk_container_border_width(GTK_CONTAINER(*DialogWindow), 10);
+   gtk_signal_connect(GTK_OBJECT(*DialogWindow), "destroy",
+                      (GtkSignalFunc) Interface_destroy_window, DialogWindow);
+
+   box_l = gtk_vbox_new(FALSE, 5);
+   label = gtk_label_new(Context);
+   gtk_label_set_justify(GTK_LABEL(label), GTK_JUSTIFY_FILL);
+   gtk_box_pack_start(GTK_BOX(box_l), label, FALSE, FALSE, 0);
+   gtk_widget_show(label);
+   box_u = gtk_hbox_new(FALSE, 5);
+   label_user = gtk_label_new(_("User Name:"));
+   gtk_box_pack_start(GTK_BOX(box_u), label_user, FALSE, FALSE, 0);
+   gtk_widget_show(label_user);
+   *passwd_dialog_uentry=gtk_entry_new();
+   /* This makes the entry insensible for input. Why?
+      GTK_WIDGET_SET_FLAGS(*passwd_dialog_uentry, GTK_HAS_FOCUS); */
+   gtk_box_pack_start(GTK_BOX(box_u),*passwd_dialog_uentry, TRUE, TRUE, 0);
+   gtk_widget_show(*passwd_dialog_uentry);
+   box_p = gtk_hbox_new(FALSE, 5);
+   label_pass = gtk_label_new(_("Password:"));
+   gtk_box_pack_start(GTK_BOX(box_p), label_pass, FALSE, FALSE, 0);
+   gtk_widget_show(label_pass);
+   *passwd_dialog_pentry=gtk_entry_new();
+   gtk_entry_set_visibility(GTK_ENTRY(*passwd_dialog_pentry), FALSE);
+   gtk_box_pack_start(GTK_BOX(box_p),*passwd_dialog_pentry, TRUE, TRUE, 0);
+   gtk_widget_show(*passwd_dialog_pentry);
+
+   box_b = gtk_hbox_new(TRUE, 5);
+   button = gtk_button_new_with_label(_("OK"));
+   gtk_signal_connect_object(GTK_OBJECT(button), "clicked", 
+                             OkCallback, OkCbData);
+   gtk_signal_connect(GTK_OBJECT(button), "clicked",
+                      (GtkSignalFunc) Interface_destroy_window, DialogWindow);
+   gtk_widget_show(button);
+   gtk_box_pack_start(GTK_BOX(box_b), button, FALSE, TRUE, 0);
+   button = gtk_button_new_with_label(_("Cancel"));
+   gtk_signal_connect_object(GTK_OBJECT(button), "clicked",
+                             CancelCallback, CancelCbData);
+   gtk_signal_connect(GTK_OBJECT(button), "clicked",
+                      (GtkSignalFunc) Interface_destroy_window, DialogWindow);
+   gtk_widget_show(button);
+   gtk_box_pack_start(GTK_BOX(box_b), button, TRUE, TRUE, 0);
+   gtk_box_pack_start(GTK_BOX(box_l), box_u, TRUE, FALSE, 0);
+   gtk_box_pack_start(GTK_BOX(box_l), box_p, TRUE, FALSE, 0);
+   gtk_box_pack_start(GTK_BOX(box_l), box_b, TRUE, FALSE, 0);
+   gtk_container_add(GTK_CONTAINER(*DialogWindow), box_l);
+
+   gtk_widget_show(box_b);
+   gtk_widget_show(box_p);
+   gtk_widget_show(box_u);
+   gtk_widget_show(box_l);
+   gtk_widget_grab_focus(button);
+   gtk_widget_show(*DialogWindow);
+}
+
+/*
+ * Create and show a user/passwd dialog
+ */
+void a_Interface_passwd_dialog(
+        BrowserWindow *bw, gchar *Context,
+        GtkSignalFunc OkCallback, void *OkCbData,
+        GtkSignalFunc CancelCallback, void *CancelCbData)
+{
+   if (!bw->passwd_dialog_window) {
+      Interface_make_passwd_dialog(&(bw->passwd_dialog_window),
+         "passwd_dialog", "Dillo", _("Dillo: Enter Authentication"), Context,
+         &(bw->passwd_dialog_uentry), &(bw->passwd_dialog_pentry),
+         OkCallback, OkCbData, CancelCallback, CancelCbData);
+   } else {
+      gtk_widget_destroy(bw->passwd_dialog_window);
+   }
+}
+
+/*
  * Create and show an [OK|Cancel] question dialog
  */
 void a_Interface_question_dialog(
@@ -1403,7 +1415,7 @@
 {
    if (!bw->question_dialog_window) {
       Interface_make_question_dialog(&(bw->question_dialog_window),
-         "question_dialog", "Dillo", "Dillo: Question", QuestionTxt,
+         "question_dialog", "Dillo", _("Dillo: Question"), QuestionTxt,
          OkCallback, OkCbData, CancelCallback, CancelCbData);
    } else {
       gtk_widget_destroy(bw->question_dialog_window);
@@ -1417,9 +1429,9 @@
 {
    if (!bw->open_dialog_window) {
       Interface_make_dialog(&(bw->open_dialog_window),
-         "open_dialog", "Dillo", "Dillo: Open URL",
+         "open_dialog", "Dillo", _("Dillo: Open URL"),
          &(bw->open_dialog_entry), "", NULL, NULL,
-         "OK", (GtkSignalFunc) a_Interface_entry_open_url, (void *)bw);
+         _("OK"), (GtkSignalFunc) a_Interface_entry_open_url, (void *)bw);
       if (prefs.transient_dialogs)
          gtk_window_set_transient_for(GTK_WINDOW(bw->open_dialog_window),
                                       GTK_WINDOW(bw->main_window));
@@ -1441,11 +1453,13 @@
 
    if ( Op ){
       struct stat st;
+      gchar *msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("File saved (%d Bytes)"));
 
       fflush(Web->stream);
       fstat(fileno(Web->stream), &st);
       fclose(Web->stream);
-      a_Interface_msg(Web->bw, "File saved (%d Bytes)", st.st_size);
+      a_Interface_msg(Web->dd->bw, msg_enc, st.st_size);
+      g_free(msg_enc);
    } else {
       if ( (Bytes = Client->BufSize - Web->SavedBytes) > 0 ) {
          Bytes = fwrite(Client->Buf + Web->SavedBytes, 1, Bytes, Web->stream);
@@ -1468,11 +1482,11 @@
    choosefile = GTK_FILE_SELECTION(bw->save_dialog_window);
    entry_url = GTK_ENTRY(bw->location);
    name = gtk_file_selection_get_filename(choosefile);
-   url = a_Url_dup(a_History_get_url(NAV_TOP(bw)));
+   url = a_Url_dup(a_History_get_url(NAV_TOP(bw->dd)));
 
    if ( strlen(name) && (out = fopen(name, "w")) != NULL ) {
       DilloWeb *Web = a_Web_new(url);
-      Web->bw = bw;
+      Web->dd = bw->dd;
       Web->stream = out;
       Web->flags |= WEB_Download;
       /* todo: keep track of this client */
@@ -1510,13 +1524,13 @@
       /* Cached! Save from the cache */
       if ( strlen(name) && (out = fopen(name, "w")) != NULL ) {
          DilloWeb *Web = a_Web_new(url);
-         Web->bw = bw;
+         Web->dd = bw->dd;
          Web->stream = out;
          Web->flags |= WEB_Download;
          /* todo: keep track of this client */
          a_Capi_open_url(Web, Interface_save_callback, Web);
       } else
-         g_printerr("Error trying to save: %s\n", name);
+         g_printerr(_("Error trying to save: %s\n"), name);
    }
 
    gtk_widget_destroy(bw->save_link_dialog_window);
@@ -1545,7 +1559,7 @@
    if (!bw->save_dialog_window) {
       Interface_make_choose_file_dialog(
          &bw->save_dialog_window,
-         "save_dialog", "Dillo", "Dillo: Save URL as File...",
+         "save_dialog", "Dillo", _("Dillo: Save URL as File..."),
          (GtkSignalFunc) Interface_file_save_url, (void *)bw );
    }
    url = a_Url_new(a_Interface_get_location_text(bw), NULL, 0, 0, 0);
@@ -1572,7 +1586,7 @@
       Interface_make_choose_file_dialog(
          &bw->save_link_dialog_window,
          "save_link_dialog", "Dillo",
-         "Dillo: Save link as File...",
+         _("Dillo: Save link as File..."),
          (GtkSignalFunc) Interface_file_save_link,
          (void *)bw);
    }
@@ -1594,46 +1608,102 @@
 {
    char *string;
    gboolean case_sens;
+   DilloDoc *dd;
 
-   string = gtk_editable_get_chars(GTK_EDITABLE(bw->findtext_dialog_entry),
-                                   0, -1);
+   string = a_I18n_gtk_editable_get_chars(GTK_EDITABLE(bw->findtext_dialog_entry),
+				   0, -1);
    case_sens = gtk_toggle_button_get_active
-      (GTK_TOGGLE_BUTTON(bw->findtext_dialog_check));
-   switch(a_Dw_gtk_scrolled_window_search(GTK_DW_SCROLLED_WINDOW(bw->docwin),
-                                          string, case_sens)) {
+     (GTK_TOGGLE_BUTTON(bw->findtext_dialog_check));
+
+   /* get the document to search from dd_list */
+   dd = g_list_nth_data(bw->dd_list, bw->dd_list_index);
+   
+   switch(a_Dw_gtk_scrolled_window_search(GTK_DW_SCROLLED_WINDOW(dd->docwin),
+					  string, case_sens)) {
    case FINDTEXT_RESTART:
-      a_Interface_message_window("Dillo: Find text",
-                                 "No further occurence of \"%s\". "
-                                 "Restarting from the beginning.", string);
-      break;
    case FINDTEXT_NOT_FOUND:
-      a_Interface_message_window("Dillo: Find text",
-                                 "Cannot find \"%s\".", string);
-      break;
+     a_Dw_gtk_scrolled_window_reset_search((void *) dd->docwin);
+     if(++(bw->dd_list_index) < g_list_length(bw->dd_list)) {
+       /* recursively repeat search in next document */
+       Interface_entry_search(widget, bw);
+     } else {
+       if(!bw->found)
+          a_Interface_message_window(_("Dillo: Find text"),
+                _("Cannot find \"%s\"."), string);
+       else
+          a_Interface_message_window(_("Dillo: Find text"),
+				    _("No further occurence of \"%s\". "
+				    "Restarting from the beginning."), string);
+       bw->found = FALSE;
+       bw->dd_list_index = 0;
+     }
+     break;
+   case FINDTEXT_SUCCESS:
+     bw->found = TRUE;
+     break;
+   default:
+     g_print(_("Unexpected return from a_Dw_gtk_scrolled_window_search(), in interface.c:1621...\n"));
+     break;
    }
+
    g_free(string);
 }
 
 /*
+ * Callback for findtext destroy, resets search and destroys dd_list
+ */
+void a_Interface_findtext_dialog_destroy(BrowserWindow *bw)
+{
+   DilloDoc *dd = NULL;
+
+   dd = g_list_nth_data(bw->dd_list, bw->dd_list_index);
+   /* reset the search */
+   a_Dw_gtk_scrolled_window_reset_search((void *) dd->docwin);
+   /* destroy the list */
+   g_list_free(bw->dd_list);
+   bw->dd_list = NULL;
+   bw->dd_list_index = 0;
+   bw->found = FALSE;
+   find_text_window = NULL;
+}
+
+/* 
+ * Close the dialog interface for finding text in a page
+ */
+void a_Interface_findtext_dialog_close(){
+   if (find_text_window == NULL) return;
+
+   gtk_widget_destroy(find_text_window);
+}
+
+/*
  * Show the dialog interface for finding text in a page
  */
 void a_Interface_findtext_dialog(BrowserWindow *bw)
 {
+   /* make search list if it has not been defined yet */
+   if(bw->dd_list == NULL)
+     bw->dd_list = a_Doc_get_visible_children(bw->dd);
+   bw->dd_list_index = 0;
+   /* reset found state */
+   bw->found = FALSE;
+
    if (!bw->findtext_dialog_window) {
       Interface_make_dialog(&(bw->findtext_dialog_window),
-         "findtext_dialog", "Dillo", "Dillo: Find text in page",
+         "findtext_dialog", "Dillo", _("Dillo: Find text in page"),
          &(bw->findtext_dialog_entry), "",
-         &(bw->findtext_dialog_check), "Case sensitive",
-         "Find", (GtkSignalFunc) Interface_entry_search, (void *)bw);
+         &(bw->findtext_dialog_check), _("Case sensitive"),
+         _("Find"), (GtkSignalFunc) Interface_entry_search, (void *)bw);
       if (prefs.transient_dialogs)
          gtk_window_set_transient_for(GTK_WINDOW(bw->findtext_dialog_window),
                                       GTK_WINDOW(bw->main_window));
       gtk_signal_connect_object
          (GTK_OBJECT(bw->findtext_dialog_window), "destroy",
-          (GtkSignalFunc) a_Dw_gtk_scrolled_window_reset_search,
-          (void*)bw->docwin);
+          (GtkSignalFunc) a_Interface_findtext_dialog_destroy,
+          (void*) bw);
       gtk_window_set_position(GTK_WINDOW(bw->findtext_dialog_window),
                               GTK_WIN_POS_NONE);
+      find_text_window = bw->findtext_dialog_window;
    }
 
    a_Interface_set_nice_window_pos(bw->findtext_dialog_window,
@@ -1652,7 +1722,7 @@
 {
    gchar *keyw, *url_str;
 
-   keyw = gtk_editable_get_chars(GTK_EDITABLE(bw->search_dialog_entry), 0, -1);
+   keyw = a_I18n_gtk_editable_get_chars(GTK_EDITABLE(bw->search_dialog_entry), 0, -1);
    if (keyw) { 
       url_str = Interface_make_search_url(keyw);
       Interface_open_url_string(url_str, bw);
@@ -1670,9 +1740,9 @@
 {
    if (!bw->search_dialog_window) {
       Interface_make_dialog(&(bw->search_dialog_window),
-         "search_dialog", "Dillo", "Dillo: Search the Web",
+         "search_dialog", _("Dillo"), _("Dillo: Search the Web"),
          &(bw->search_dialog_entry), "", NULL, NULL,
-         "Search", (GtkSignalFunc)Interface_search_callback, (void *)bw);
+         _("Search"), (GtkSignalFunc)Interface_search_callback, (void *)bw);
       if (prefs.transient_dialogs)
          gtk_window_set_transient_for(GTK_WINDOW(bw->search_dialog_window),
                                       GTK_WINDOW(bw->main_window));
@@ -1748,7 +1818,7 @@
    gtk_widget_show(frame);
    gtk_box_pack_start(GTK_BOX(box), frame, TRUE, TRUE, 0);
 
-   button = gtk_button_new_with_label("Close");
+   button = gtk_button_new_with_label(_("Close"));
    gtk_signal_connect_object(GTK_OBJECT(button), "clicked",
                              (GtkSignalFunc)gtk_widget_destroy, (void*)window);
    gtk_widget_add_accelerator(button, "clicked",
@@ -1773,6 +1843,8 @@
 {
    gint xsize, ysize;
    GtkWidget *window, *box1, *button, *scrolled_window, *text;
+   char *enc_buf, *charset;
+   gboolean usemeta = TRUE;
 
    if (*text_widget)
       gtk_widget_destroy (*text_widget);
@@ -1811,10 +1883,16 @@
       gtk_widget_show (text);
 
       gtk_text_freeze (GTK_TEXT (text));
-      gtk_text_insert (GTK_TEXT (text), NULL, NULL, NULL, buf, buf_size);
+
+      charset = a_I18n_get_encoding(buf, buf_size, &usemeta);
+      enc_buf = a_I18n_convert(charset, DW_CHARSET, buf, buf_size);
+      g_free(charset);
+      
+      gtk_text_insert (GTK_TEXT (text),
+			  NULL, NULL, NULL, enc_buf, strlen(enc_buf));
       gtk_text_thaw (GTK_TEXT (text));
 
-      button = gtk_button_new_with_label ("close");
+      button = gtk_button_new_with_label (_("close"));
       gtk_signal_connect_object (GTK_OBJECT (button), "clicked",
                                  GTK_SIGNAL_FUNC(gtk_widget_destroy),
                                  GTK_OBJECT (window));
@@ -1872,3 +1950,5 @@
          gtk_widget_set_uposition(win1, (sh - h1) / 2, 0);
    }
 }
+
+/* vim: set ts=3 sw=3 sts=3 expandtab:*/
diff -Nur dillo-0.8.0/src/interface.h dillo-0.8.0.new/src/interface.h
--- dillo-0.8.0/src/interface.h	2004-01-19 19:21:49.000000000 +0000
+++ dillo-0.8.0.new/src/interface.h	2004-10-13 01:13:29.000000000 +0000
@@ -4,14 +4,8 @@
 #include "browser.h"
 
 void a_Interface_init(void);
-void a_Interface_stop(BrowserWindow *bw);
-void a_Interface_clean(BrowserWindow *bw);
-void a_Interface_quit_all(void);
 
-void a_Interface_add_client(BrowserWindow *bw, gint Key, gint Root);
-void a_Interface_remove_client(BrowserWindow *bw, gint ClientKey);
-void a_Interface_add_url(BrowserWindow *bw, const DilloUrl *Url, gint Flags);
-void a_Interface_close_client(BrowserWindow *bw, gint ClientKey);
+void a_Interface_quit_all(void);
 
 void a_Interface_msg(BrowserWindow *bw, const char *format, ... );
 void a_Interface_bug_meter_update(BrowserWindow *bw, gint num_err);
@@ -21,6 +15,8 @@
 void a_Interface_save_dialog(GtkWidget *widget, BrowserWindow *bw);
 void a_Interface_save_link_dialog(GtkWidget *widget, BrowserWindow *bw);
 void a_Interface_search_dialog(GtkWidget *widget, BrowserWindow *bw);
+void Interface_findtext_dialog_destroy(BrowserWindow *bw);
+void a_Interface_findtext_dialog_close();
 void a_Interface_findtext_dialog(BrowserWindow *bw);
 void a_Interface_quit_dialog(BrowserWindow *bw);
 
@@ -29,7 +25,15 @@
 gchar *a_Interface_get_location_text(BrowserWindow *bw);
 void a_Interface_reset_progress_bars(BrowserWindow *bw);
 void a_Interface_entry_open_url(GtkWidget *widget, BrowserWindow *bw);
-void a_Interface_set_cursor(BrowserWindow *bw, GdkCursorType CursorType);
+#ifdef ENABLE_USER_AGENT
+void a_Interface_entry_set_useragent(GtkWidget *widget, BrowserWindow *bw);
+#endif
+
+void a_Interface_toggle_panel(BrowserWindow *bw, gboolean toggle);
+
+/* content (scrolled_frame and everything in it) focus callback */
+void a_Interface_content_focus_callback(BrowserWindow *bw);
+
 BrowserWindow *
 a_Interface_browser_window_new(gint width, gint height, guint32 xid);
 
@@ -49,5 +53,10 @@
 
 void a_Interface_set_nice_window_pos(GtkWidget *win1, GtkWidget *win2);
 
+void a_Interface_passwd_dialog(BrowserWindow *bw,
+        gchar *Context,
+        GtkSignalFunc OkCallback, void *OkCbData,
+        GtkSignalFunc CancelCallback, void *CancelCbData);
+ 
 
 #endif /* __INTERFACE_H__ */
diff -Nur dillo-0.8.0/src/intl.h dillo-0.8.0.new/src/intl.h
--- dillo-0.8.0/src/intl.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/src/intl.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,23 @@
+#ifndef __INTL_H__
+#define __INTL_H__
+
+#ifdef ENABLE_NLS
+#  include <libintl.h>
+#  define _(String) dgettext(PACKAGE,String)
+#  ifdef gettext_noop
+#    define N_(String) gettext_noop(String)
+#  else
+#    define N_(String) (String)
+#  endif /* gettext_noop */
+#else
+#  define _(String) (String)
+#  define N_(String) (String)
+#  define textdomain(String) (String)
+#  define gettext(String) (String)
+#  define dgettext(Domain,String) (String)
+#  define dcgettext(Domain,String,Type) (String)
+#  define bindtextdomain(Domain,Directory) (Domain) 
+#  define bind_textdomain_codeset(Domain,Codeset) (Domain) 
+#endif /* ENABLE_NLS */
+
+#endif /* __INTL_H__ */
diff -Nur dillo-0.8.0/src/IO/about.c dillo-0.8.0.new/src/IO/about.c
--- dillo-0.8.0/src/IO/about.c	2004-02-08 13:14:49.000000000 +0000
+++ dillo-0.8.0.new/src/IO/about.c	2004-10-13 01:13:29.000000000 +0000
@@ -13,6 +13,7 @@
 #include <pthread.h>
 
 #include <config.h>
+#include "../intl.h"
 #include "Url.h"
 #include "../nav.h"
 #include "../web.h"
@@ -29,12 +30,12 @@
  * HTML text for startup screen
  */
 static char *Splash=
-"Content-type: text/html\n"
+N_("Content-type: text/html\n"
 "\n"
 "<!DOCTYPE HTML PUBLIC '-//W3C//DTD HTML 4.01 Transitional//EN'>\n"
 "<html>\n"
 "<head>\n"
-"<title>Splash screen for dillo-" VERSION "</title>\n"
+"<title>Splash screen for dillo-0.8.0-i18n-misc</title>\n"
 "</head>\n"
 "<body bgcolor='#778899' text='#000000' link='#000000' vlink='#000000'>\n"
 "\n"
@@ -51,7 +52,7 @@
 "     <table width='100%' border='0' bgcolor='#ffffff'>\n"
 "     <tr>\n"
 "       <td valign='top' align='left'>\n"
-"         <h1>&nbsp;Welcome to Dillo " VERSION "&nbsp;</h1>\n"
+"         <h1>&nbsp;Welcome to Dillo 0.8.0-i18n-misc&nbsp;</h1>\n"
 "       </td>\n"
 "     </tr>\n"
 "     </table>\n"
@@ -60,7 +61,8 @@
 " </td></tr>\n"
 "</table>\n"
 "\n"
-"<!-- a small horizontal spacer -->\n"
+"<font color='RED'>This is Unofficial Version.&nbsp;Please do not "
+"ask the dillo team.</font><br><!-- a small horizontal spacer -->\n"
 "<br>\n"
 "\n"
 "\n"
@@ -470,7 +472,7 @@
 "<hr size='2'>\n"
 "</center>\n"
 "</body>\n"
-"</html>\n";
+"</html>\n");
 
 
 
@@ -493,7 +495,7 @@
 
    /* send splash */
    io1 = a_IO_new(IOWrite, SpInfo->FD_Write);
-   a_IO_set_buf(io1, Splash, strlen(Splash));
+   a_IO_set_buf(io1, _(Splash), strlen(_(Splash)));
    io1->Flags |= (IOFlag_ForceClose + IOFlag_SingleWrite);
    a_Chain_link_new(Info, a_About_ccc, BCK, a_IO_ccc, 1, 1);
    a_Chain_bcb(OpStart, Info, io1, NULL);
@@ -538,7 +540,7 @@
       loc = "http://www.google.com/";
 
    LocUrl = a_Url_new(loc, NULL, 0, 0, 0);
-   a_Nav_push(web->bw, LocUrl);
+   a_Nav_push(web->dd, LocUrl);
    a_Url_free(LocUrl);
    return -1;
 }
diff -Nur dillo-0.8.0/src/IO/DBIO.c dillo-0.8.0.new/src/IO/DBIO.c
--- dillo-0.8.0/src/IO/DBIO.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/src/IO/DBIO.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,290 @@
+/*
+ * File: DBIO.c
+ *
+ * Copyright (C) 2000, 2001 Jorge Arellano Cid <jcid@inf.utfsm.cl>
+ * Copyright (C) 2002       Jonathan P Springer <jonathan.springer@verizon.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * In addition, as a special exception, Jorge Arellano Cid and Jonathan
+ * Springer give permission to link the code of this program with the OpenSSL
+ * library (or modified versions of OpenSSL that use the same license as
+ * OpenSSL), and distribute linked combinations including the two.  You must
+ * obey the GNU General Public License in all respects for all of the code
+ * used other than OpenSSL.  If you modify this file, you may extend this
+ * exception to your version of the file, but you are not obligated to do so.
+ * If you do not wish to do so, delete this exception from your version.  
+ *
+ */
+
+/*
+ * Dillo's signal driven BIO engine
+ */
+
+#include <config.h>
+
+#ifdef DILLO_SSL 
+
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/uio.h>
+#include <sys/socket.h>
+#include <glib.h>
+#include <gdk/gdk.h>
+#include "../chain.h"
+#include "DBIO.h"
+
+#include <openssl/bio.h>
+#include <openssl/err.h>
+
+//#define DEBUG_LEVEL 3
+#include "../debug.h"
+
+
+/*
+ * Symbolic defines for shutdown() function
+ * (Not defined in the same header file, for all distros --Jcid)
+ */
+#define IO_StopRd   0
+#define IO_StopWr   1
+#define IO_StopRdWr 2
+
+extern void IO_submit(IOData_t *r_io);
+extern void IO_del(IOData_t *io);
+extern void IO_ins(IOData_t *io);
+extern IOData_t *IO_get(gint Key);
+
+/*
+ * IO-module data
+ */
+
+
+/*
+ * Return a newly created, and initialized, 'io' struct
+ */
+IOData_t *a_DBIO_new(BIO *bioin)
+{
+   IOData_t *io = g_new0(IOData_t, 1);
+   io->GioCh = NULL;
+   io->FD = -1;
+   io->Flags = 0;
+   io->bio = bioin;
+   return io;
+}
+
+/*
+ * Free an 'io' struct
+ */
+void DBIO_free(IOData_t *io)
+{
+  if (io->Flags & IOFlag_FreeIOBuf) g_free(io->Buf);
+  g_free(io);
+}
+
+/*
+ * Close an open BIO, and remove io controls.
+ * (This function can be used for Close and Abort operations)
+ */
+void DBIO_close_fd(IOData_t *io, gint CloseCode)
+{
+  if (io->bio) BIO_free_all(io->bio);
+
+  IO_del(io);
+}
+
+/*
+ * Abort an open FD.
+ *  This function is called to abort a BIO connection due to an IO error
+ *  or just because the connection is not required anymore.
+ */
+gboolean DBIO_abort(IOData_t *io)
+{
+   /* Close and finish this FD's activity */
+   DBIO_close_fd(io, IO_StopRdWr);
+
+   return FALSE;
+}
+
+/*
+ * Read data from a BIO into a specific buffer
+ */
+gboolean DBIO_Callback_Read(gpointer data)
+{
+  ssize_t St;
+  gboolean ret;
+  IOData_t *io = (IOData_t *) data;
+
+  DEBUG_MSG(3, "  IO_read2\n");
+
+  /* Sometimes glib delivers events on already aborted FDs  --Jcid */
+  if ( IO_get(io->Key) == NULL ) return FALSE;
+
+  St = BIO_read(io->bio, io->Buf, io->BufSize);
+
+  if ( St < 0 ) {
+    if (BIO_should_retry(io->bio)) {
+      ret = TRUE;
+    } else {
+      io->Status = ERR_get_error();
+      ret = FALSE;
+    }
+  } else if ( St == 0 ) {
+    if (BIO_should_retry(io->bio)) {
+      ret = TRUE;
+    } else {
+      a_DBIO_ccc(OpEnd, 2,0, io->Info, io, NULL);
+      ret = FALSE;
+    }
+  } else {
+    io->Status = St;  /* Status is used for length */
+    a_DBIO_ccc(OpSend, 2,0, io->Info, io, NULL);
+    ret = TRUE;
+  }
+
+  return ret;
+}
+
+/*
+ * Write data, from a specific buffer, into a file descriptor
+ * (** Write operations MUST NOT free the buffer because the buffer
+ *     start is modified.)
+ * todo: Implement IOWrites, remove the constraint stated above.
+ */
+gboolean DBIO_Callback_Write(gpointer data)
+{
+  ssize_t St;
+  gboolean ret = FALSE;
+  IOData_t *io = (IOData_t *) data;
+
+  DEBUG_MSG(3, "  IO_write\n");
+
+  /* Sometimes glib delivers events on already aborted FDs  --Jcid */
+  if ( IO_get(io->Key) == NULL ) return FALSE;
+
+  St = BIO_write(io->bio, io->Buf, io->BufSize);
+  io->Status = St;
+
+  DEBUG_MSG(3, "  IO_write: %s [errno %d] [St %d]\n",
+	    g_strerror(errno), errno, St);
+
+  if ( St <= 0 ) {
+    if (BIO_should_retry(io->bio)) {
+      ret = TRUE;
+    } else {
+      io->Status = ERR_get_error();
+      ret = FALSE;
+    }
+  } else if ( St < io->BufSize ){
+    // Not all data written
+    io->BufSize  -= St;
+    io->Buf = ((gchar *)io->Buf) + St;
+    ret = TRUE;
+  } else {
+    // All data in buffer written
+    if ( io->Op == IOWrite ) {
+      /* Single write */
+      a_DBIO_ccc(OpEnd, 1,0, io->Info, io, NULL);
+      ret = FALSE;
+    } else if ( io->Op == IOWrites ) {
+      /* todo: Writing in small chunks (not implemented) */
+    }
+  }
+
+  return ret;
+}
+
+/*
+ * Receive an IO request (IORead | IOWrite | IOWrites),
+ */
+void DBIO_submit(IOData_t *r_io)
+{
+  if ( r_io->Op == IORead ) {
+    g_idle_add(DBIO_Callback_Read, (gpointer) r_io);
+  } else if (r_io->Op == IOWrite || r_io->Op == IOWrites ) {
+    g_idle_add(DBIO_Callback_Write, (gpointer) r_io);
+  }
+  
+  /* Add a reference pointer to this request */
+  IO_ins(r_io);
+}
+
+/*
+ * CCC function for the IO module
+ * ( Data = IOData_t* ; ExtraData = NULL )
+ */
+void a_DBIO_ccc(int Op, int Branch,int Dir, ChainLink *Info, void *Data, void *ExtraData)
+{
+   IOData_t *io = Data;
+
+   if ( Branch == 1 ) {
+      /* Send query */
+      switch (Op) {
+      case OpStart:
+         io->Info = Info;
+         Info->LocalKey = io;
+         DBIO_submit(io);
+         break;
+      case OpEnd:
+         a_Chain_fcb(OpEnd, Info, io, NULL);
+         DBIO_free(io);
+         break;
+      case OpAbort:
+         a_Chain_fcb(OpAbort, Info, NULL, NULL);
+         DBIO_free(io);
+         break;
+      }
+
+   } else if ( Branch == 2 ) {
+      /* Receive answer */
+      switch (Op) {
+      case OpStart:
+         io->Info = Info;
+         Info->LocalKey = io;
+         a_Chain_link_new(Info, a_DBIO_ccc, FWD, a_Cache_ccc,2,2);
+         a_Chain_fcb(OpStart, Info, io, io->ExtData);
+         DBIO_submit(io);
+         break;
+      case OpSend:
+         a_Chain_fcb(OpSend, Info, io, NULL);
+         break;
+      case OpEnd:
+         a_Chain_fcb(OpEnd, Info, io, NULL);
+         DBIO_free(io);
+         break;
+      case OpAbort:
+         a_Chain_fcb(OpAbort, Info, io, NULL);
+         DBIO_free(io);
+         break;
+      }
+
+   } else if ( Branch == -1 ) {
+      /* Backwards call */
+      switch (Op) {
+      case OpAbort:
+         DEBUG_MSG(3, "IO   : OpAbort [-1]\n");
+         io = Info->LocalKey;
+         DBIO_abort(io);
+         DBIO_free(io);
+         g_free(Info);
+         break;
+      }
+   }
+}
+
+#endif
+
diff -Nur dillo-0.8.0/src/IO/DBIO.h dillo-0.8.0.new/src/IO/DBIO.h
--- dillo-0.8.0/src/IO/DBIO.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/src/IO/DBIO.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,22 @@
+#ifndef __DBIO_h
+#define __DBIO_h
+
+#include <config.h>
+
+#ifdef DILLO_SSL
+
+#include <openssl/bio.h>
+
+#include "IO.h"
+
+/*
+ * Exported functions
+ */
+IOData_t* a_DBIO_new(BIO *bio);
+void a_DBIO_ccc(int Op, int Br,int Dir, ChainLink *Info, void *Data, void *ExtraData);
+
+#endif /* DILLO_SSL */
+
+#endif /* __DBIO_h */
+
+
diff -Nur dillo-0.8.0/src/IO/dpi.c dillo-0.8.0.new/src/IO/dpi.c
--- dillo-0.8.0/src/IO/dpi.c	2004-01-29 20:32:01.000000000 +0000
+++ dillo-0.8.0.new/src/IO/dpi.c	2004-10-13 01:13:29.000000000 +0000
@@ -19,6 +19,7 @@
  */
 
 
+#include <config.h>
 #include <unistd.h>
 #include <stdlib.h>
 #include <sys/types.h>
@@ -35,6 +36,7 @@
 #include <arpa/inet.h>
 #include <netdb.h>
 
+#include "../intl.h"
 #include "../msg.h"
 #include "Url.h"
 #include "IO.h"
@@ -184,9 +186,9 @@
       /* search for start of tag */
 /*
 gchar *pbuf=NULL;
-MSG("conn->BufIdx = %d; conn->BufSize = %d\n", conn->BufIdx,conn->BufSize);
+MSG(_("conn->BufIdx = %d; conn->BufSize = %d\n"), conn->BufIdx,conn->BufSize);
 pbuf = g_strndup(buf, conn->BufSize - conn->BufIdx);
-MSG("buf: [%s]\n", pbuf);
+MSG(_("buf: [%s]\n"), pbuf);
 g_free(pbuf);
 */
       while (conn->BufIdx < conn->BufSize && buf[conn->BufIdx] != '<')
@@ -196,7 +198,7 @@
          conn->InTag = 1;
          conn->Tok = buf + conn->BufIdx;
       } else {
-         MSG("ERROR: [Dpi_get_token] Can't find token start\n");
+         MSG(_("ERROR: [Dpi_get_token] Can't find token start\n"));
          conn->FreeBuf = 1;
          return Dpi_get_token(conn);
       }
@@ -226,7 +228,7 @@
          resp = 0;
       } else {
          /* srch end of data */
-         MSG("ERROR: [Dpi_get_token] *** NULL code here ***\n");
+         MSG(_("ERROR: [Dpi_get_token] *** NULL code here ***\n"));
          while (conn->BufIdx < conn->BufSize)
             ++conn->BufIdx;
          resp = -1;
@@ -253,7 +255,7 @@
    }
 
    tag = g_strndup(conn->Tok, conn->TokSize);
-   MSG("Dpi_parse_token: [%s]\n", tag);
+   _MSG(_("Dpi_parse_token: [%s]\n"), tag);
    g_free(tag);
 
    cmd = Get_attr_value(conn->Tok, conn->TokSize, "cmd");
@@ -311,7 +313,7 @@
       }
 
    } else if (Op == IOClose) {
-      MSG("Dpi: [Dpi_process_io] IOClose\n");
+      DEBUG_MSG(3, _("Dpi: [Dpi_process_io] IOClose\n"));
    }
 }
 
@@ -337,7 +339,7 @@
       if (execl(path1, "dpid", NULL) == -1) {
          g_free(path1);
          if (execlp("dpid", "dpid", NULL) == -1) {
-            DEBUG_MSG(4, "Dpi_start_dpid (child): %s\n", g_strerror(errno));
+            DEBUG_MSG(4, _("Dpi_start_dpid (child): %s\n"), g_strerror(errno));
             write(st_pipe[1], "ERROR", 5);
             close(st_pipe[1]);
             _exit (EXIT_FAILURE);
@@ -345,16 +347,16 @@
       }
    } else if (pid < 0) {
       /* The fork failed.  Report failure.  */
-      DEBUG_MSG(4, "Dpi_start_dpid: %s\n", g_strerror(errno));
+      DEBUG_MSG(4, _("Dpi_start_dpid: %s\n"), g_strerror(errno));
    } else {
       /* This is the parent process, check our child status... */
       close(st_pipe[1]);
       n = read(st_pipe[0], buf, 16);
-      DEBUG_MSG(2, "Dpi_start_dpid: n = %d\n", n);
+      DEBUG_MSG(2, _("Dpi_start_dpid: n = %d\n"), n);
       if (n != 5)
          ret = 0;
       else
-         DEBUG_MSG(4, "Dpi_start_dpid: %s\n", g_strerror(errno));
+         DEBUG_MSG(4, _("Dpi_start_dpid: %s\n"), g_strerror(errno));
    }
 
    return ret;
@@ -377,7 +379,7 @@
    
       if ((SockFD = socket(AF_LOCAL, SOCK_STREAM, 0)) == -1 ||
           connect(SockFD, (void*)&pun, D_SUN_LEN(&pun)) == -1) {
-         DEBUG_MSG(4, "Dpi_check_uds: %s %s\n", g_strerror(errno), uds_name);
+         DEBUG_MSG(4, _("Dpi_check_uds: %s %s\n"), g_strerror(errno), uds_name);
       } else {
          close(SockFD);
          ret = 0;
@@ -655,7 +657,7 @@
             g_free(Info);
             break;
          case OpAbort:
-            MSG("a_Dpi_ccc: OpAbort[2B], Not implemented\n");
+            DEBUG_MSG(4, _(" Not implemented\n"));
             break;
          }
       } else {  /* FWD */
@@ -667,8 +669,7 @@
             break;
          case OpSend:
          case OpAbort:
-            a_Chain_fcb(OpAbort, Info, Data1, NULL);
-            g_free(Info);
+            DEBUG_MSG(4, _(" Not implemented\n"));
             break;
          }
       }
@@ -687,7 +688,7 @@
             a_Chain_fcb(OpEnd, Info, NULL, NULL);
             break;
          case OpAbort:
-            MSG(" Not implemented\n");
+            MSG("a_Dpi_ccc: OpAbort[2B], Not implemented\n");
             break;
          }
       } else {  /* BCK */
@@ -717,7 +718,9 @@
             }
             break;
          case OpAbort:
-            MSG(" Not implemented\n");
+            //a_Chain_fcb(OpAbort, Info, Data1, NULL);
+            //g_free(Info);
+            MSG(_(" Not implemented\n"));
             break;
          }
       }
@@ -747,11 +750,11 @@
    sa.sun_family = AF_LOCAL;
 
    if ((new_socket = socket(AF_LOCAL, SOCK_STREAM, 0)) == -1) {
-      DEBUG_MSG(4, "a_Dpi_bye_dpid: %s\n", g_strerror(errno));
+      DEBUG_MSG(4, _("a_Dpi_bye_dpid: %s\n"), g_strerror(errno));
    }
    strncpy(sa.sun_path, srs_name, sizeof (sa.sun_path));
    if (connect(new_socket, (struct sockaddr *) &sa, addr_len) == -1) {
-      DEBUG_MSG(4, "a_Dpi_bye_dpid: %s\n", g_strerror(errno));
+      DEBUG_MSG(4, _("a_Dpi_bye_dpid: %s\n"), g_strerror(errno));
       fprintf(stderr, "%s\n", sa.sun_path);
    } 
    (void) write(new_socket, DpiBye_cmd, strlen(DpiBye_cmd));
diff -Nur dillo-0.8.0/src/IO/file.c dillo-0.8.0.new/src/IO/file.c
--- dillo-0.8.0/src/IO/file.c	2004-02-02 15:26:06.000000000 +0000
+++ dillo-0.8.0.new/src/IO/file.c	2004-10-13 01:13:29.000000000 +0000
@@ -16,6 +16,7 @@
  * With new HTML layout.
  */
 
+#include <config.h>
 #include <pthread.h>
 #include <ctype.h>           /* for tolower */
 #include <unistd.h>
@@ -31,8 +32,10 @@
 #include <math.h>            /* for rint */
 
 #include <errno.h>           /* for errno */
+#include "../intl.h"
 #include "Url.h"
 #include "IO.h"
+#include "../i18n.h"
 #include "../list.h"
 #include "../misc.h"
 #include "../web.h"
@@ -273,7 +276,7 @@
                     "file:", Hdirname);
    write(Ddir->FD_Write, gstr->str, gstr->len);
    g_string_sprintf(gstr, "<BODY><H1>%s %s</H1>\n<pre>\n",
-                    "Directory listing of", Hdirname);
+                    _("Directory listing of"), Hdirname);
    write(Ddir->FD_Write, gstr->str, gstr->len);
    g_free(s2);
    g_free(s1);
@@ -481,7 +484,7 @@
          Hparent = (s1 = File_html_escape(parent)) ? s1 : parent;
          CHparent = (s2 = a_Misc_escape_chars(Hparent, "% ")) ? s2 : Hparent;
          g_string_sprintf(gstr, "<a href='file:%s'>%s</a>\n<p>\n",
-                          CHparent, "Parent directory");
+                          CHparent, _("Parent directory"));
          g_free(s2);
          g_free(s1);
          g_free(parent);
@@ -645,11 +648,13 @@
  */
 static void File_not_found_msg(DilloWeb *web, const char *filename, int fd)
 {
+   gchar *msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("ERROR: Can't find %s %s"));
    if ( web->flags & WEB_RootUrl )
-      a_Interface_msg(web->bw, "ERROR: Can't find %s %s",
+      a_Interface_msg(web->dd->bw, msg_enc,
                          (fd == -2) ? "" : "file", filename);
    else
-      DEBUG_MSG(4, "Warning: Can't find <%s>\n", filename);
+      DEBUG_MSG(4, _("Warning: Can't find <%s>\n"), filename);
+   g_free(msg_enc);
 }
 
 /*
diff -Nur dillo-0.8.0/src/IO/http.c dillo-0.8.0.new/src/IO/http.c
--- dillo-0.8.0/src/IO/http.c	2004-01-05 19:25:46.000000000 +0000
+++ dillo-0.8.0.new/src/IO/http.c	2004-10-13 01:13:29.000000000 +0000
@@ -27,8 +27,10 @@
 #include <netinet/in.h>         /* for ntohl and stuff */
 #include <arpa/inet.h>          /* for inet_ntop */
 
+#include "../intl.h"
 #include "Url.h"
 #include "IO.h"
+#include "../i18n.h"
 #include "../klist.h"
 #include "../dns.h"
 #include "../cache.h"
@@ -36,6 +38,7 @@
 #include "../interface.h"
 #include "../cookies.h"
 #include "../prefs.h"
+#include "../auth.h"
 
 /* Check the Unix98 goodie */
 #ifndef socklen_t
@@ -46,7 +49,7 @@
 #define BW_MSG(web, root, fmt...)                                     \
 G_STMT_START {                                                        \
    if (a_Web_valid((web)) && (!(root) || (web)->flags & WEB_RootUrl)) \
-      a_Interface_msg((web)->bw, fmt);                                \
+      a_Interface_msg((web)->dd->bw, fmt);                                \
 } G_STMT_END
 
 #define DEBUG_LEVEL 5
@@ -128,17 +131,21 @@
 /*
  * Make the http query string
  */
-static char *Http_query(const DilloUrl *url, gboolean use_proxy)
+char *Http_query(const DilloUrl *url, gboolean use_proxy)
 {
    gchar *str, *ptr, *cookies;
    GString *s_port    = g_string_new(""),
            *query     = g_string_new(""),
-           *full_path = g_string_new("");
+           *referer   = g_string_new(""),
+           *full_path = g_string_new(""),
+           *auth;
 
    /* Sending the default port in the query may cause a 302-answer.  --Jcid */
    if (URL_PORT(url) && URL_PORT(url) != DILLO_URL_HTTP_PORT)
       g_string_sprintfa(s_port, ":%d", URL_PORT(url));
 
+   auth = a_Auth_byurl((DilloUrl *) url);
+
    if (use_proxy) {
       g_string_sprintfa(full_path, "%s%s",
                         URL_STR(url),
@@ -153,21 +160,35 @@
                         (URL_PATH_(url) || URL_QUERY_(url)) ? "" : "/");
    }
 
+   if (url->referer != NULL) {
+     g_string_sprintfa(referer, "Referer: %s\r\n", url->referer);
+   }
+
+   DEBUG_MSG(4,_("Getting %s, referer %s\n"), URL_STR(url), referer->str);
+
    cookies = a_Cookies_get(url);
    if ( URL_FLAGS(url) & URL_Post ){
       g_string_sprintfa(
          query,
          "POST %s HTTP/1.0\r\n"
          "Host: %s%s\r\n"
-         "User-Agent: Dillo/%s\r\n"
+         "User-Agent: %s\r\n"
          "Cookie2: $Version=\"1\"\r\n"
-         "%s"
+         "%s%s%s%s"
          "Content-type: application/x-www-form-urlencoded\r\n"
          "Content-length: %ld\r\n"
+         "%s"
          "\r\n"
          "%s",
-         full_path->str, URL_HOST(url), s_port->str, VERSION, cookies,
+         full_path->str,
+         URL_HOST(url), s_port->str,
+         (prefs.user_agent)? prefs.user_agent : "Dillo/" VERSION,
+         cookies,
+         (auth != NULL ? "Authorization: " : ""),
+         (auth != NULL ? auth->str : ""),
+         (auth != NULL ? "\r\n" : ""),
          (glong)strlen(URL_DATA(url)),
+         referer->str,
          URL_DATA(url));
 
    } else {
@@ -176,23 +197,36 @@
          "GET %s HTTP/1.0\r\n"
          "%s"
          "Host: %s%s\r\n"
-         "User-Agent: Dillo/%s\r\n"
-         "Cookie2: $Version=\"1\"\r\n"
+         "User-Agent: %s\r\n"
+		 "Accept-Language: %s\r\n"
+		 "Accept-Encoding:gzip\r\n"
+		 "Accept-Charset:utf-8,%s\r\n"
          "%s"
+         "Cookie2: $Version=\"1\"\r\n"
+         "%s%s%s%s"
          "\r\n",
          full_path->str,
          (URL_FLAGS(url) & URL_E2EReload) ?
             "Cache-Control: no-cache\r\nPragma: no-cache\r\n" : "",
-         URL_HOST(url), s_port->str, VERSION,
-         cookies);
+         URL_HOST(url), s_port->str,
+         (prefs.user_agent)? prefs.user_agent : "Dillo/" VERSION,
+         prefs.accept_language,
+         DW_CHARSET,
+         referer->str,
+         cookies,
+         (auth != NULL ? "Authorization: " : ""),
+         (auth != NULL ? auth->str : ""),
+         (auth != NULL ? "\r\n" : "")
+         );
    }
    g_free(cookies);
 
    str = query->str;
    g_string_free(query, FALSE);
    g_string_free(s_port, TRUE);
+   g_string_free(referer, TRUE);
    g_string_free(full_path, TRUE);
-   DEBUG_MSG(4, "Query:\n%s", str);
+   DEBUG_MSG(4, _("Query:\n%s"), str);
    return str;
 }
 
@@ -207,38 +241,43 @@
    ChainLink *Info;
    SocketData_t *S;
    gint SKey = GPOINTER_TO_INT(data);
+   gchar *msg_enc;
 
    DEBUG_MSG(3, "Http_use_socket: %s [errno %d] [GIOcond %d]\n",
              g_strerror(errno), errno, cond);
 
    /* This check is required because glib may asynchronously
-    * call this function with data that's no longer used  --Jcid   */
+    * call tg_has_latin1_charsethis function with data that's no longer used  --Jcid   */
    if ( !(S = a_Klist_get_data(ValidSocks, SKey)) )
       return FALSE;
 
    Info = S->Info;
    if ( cond & G_IO_HUP ) {
-      DEBUG_MSG(3, "--Connection broken\n");
+      DEBUG_MSG(3, _("--Connection broken\n"));
       /* get rid of S->GioCh */
-      g_io_channel_close(S->GioCh);
       g_io_channel_unref(S->GioCh);
       S->GioCh = NULL;
       if (S->addr_list_iter->next) {
          S->addr_list_iter = S->addr_list_iter->next;
          if (Http_connect_socket(Info) < 0) {
-            BW_MSG(S->web, 0, "ERROR: unable to connect to remote host");
+            msg_enc = a_I18n_locale_to_DILLO_CHARSET(
+                    _("ERROR: unable to connect to remote host"));
+            BW_MSG(S->web, 0, msg_enc);
+            g_free(msg_enc);
             Http_socket_free(SKey);
             a_Chain_fcb(OpAbort, Info, NULL, NULL);
          }
       }
    } else if ( S->Err ) {
-      BW_MSG(S->web, 0, "ERROR: %s", g_strerror(S->Err));
+	  msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("ERROR: %s"));
+      BW_MSG(S->web, 0, msg_enc, g_strerror(S->Err));
+	  g_free(msg_enc);
       DEBUG_MSG(3, "Http_use_socket ERROR: %s\n", g_strerror(S->Err));
       a_Chain_fcb(OpAbort, Info, NULL, NULL);
       g_io_channel_close(S->GioCh);
       Http_socket_free(SKey);
    } else if ( cond & G_IO_OUT ) {
-      DEBUG_MSG(3, "--Connection established\n");
+      DEBUG_MSG(3, _("--Connection established\n"));
       g_io_channel_unref(S->GioCh);
       S->GioCh = NULL;
       Http_send_query(Info, S);
@@ -263,6 +302,7 @@
    SocketData_t *S;
    DilloHost *dh;
    socklen_t socket_len = 0;
+   gchar *msg_enc;
 
    S = a_Klist_get_data(ValidSocks, GPOINTER_TO_INT(Info->LocalKey));
 
@@ -270,7 +310,7 @@
 
    if ( (S->SockFD = socket(dh->af, SOCK_STREAM, IPPROTO_TCP)) < 0 ) {
       S->Err = errno;
-      DEBUG_MSG(5, "Http_connect_socket ERROR: %s\n", g_strerror(errno));
+      DEBUG_MSG(5, _("Http_connect_socket ERROR: %s\n"), g_strerror(errno));
       return -1;
    }
    /* set NONBLOCKING and close on exec. */
@@ -291,7 +331,7 @@
       sin->sin_port = S->port ? htons(S->port) : htons(DILLO_URL_HTTP_PORT);
       memcpy(&sin->sin_addr, dh->data, dh->alen);
       if (a_Web_valid(S->web) && (S->web->flags & WEB_RootUrl))
-         DEBUG_MSG(5, "Connecting to %s\n", inet_ntoa(sin->sin_addr));
+         DEBUG_MSG(4, _("Connecting to %s\n"), inet_ntoa(sin->sin_addr));
       break;
    }
 #ifdef ENABLE_IPV6
@@ -305,7 +345,7 @@
       memcpy(&sin6->sin6_addr, dh->data, dh->alen);
       inet_ntop(dh->af, dh->data, buf, sizeof(buf));
       if (a_Web_valid(S->web) && (S->web->flags & WEB_RootUrl))
-         DEBUG_MSG(5, "Connecting to %s\n", buf);
+         DEBUG_MSG(5, _("Connecting to %s\n"), buf);
       break;
    }
 #endif
@@ -323,8 +363,10 @@
       S->Err = errno;
       return -1;
    }
-
-   BW_MSG(S->web, 1, "Contacting host...");
+	
+   msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("Contacting host..."));
+   BW_MSG(S->web, 1, msg_enc);
+   g_free(msg_enc);
 
    return 0; /* Success */
 }
@@ -336,14 +378,16 @@
 static void Http_send_query(ChainLink *Info, SocketData_t *S)
 {
    IOData_t *io;
-   gchar *query;
+   gchar *query, *msg_enc;
    void *link;
 
    /* Create the query */
    query = Http_query(S->Url, S->use_proxy);
 
    /* send query */
-   BW_MSG(S->web, 1, "Sending query to %s...", URL_HOST_(S->Url));
+   msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("Sending query to %s..."));
+   BW_MSG(S->web, 1, msg_enc, URL_HOST_(S->Url));
+   g_free(msg_enc);
    io = a_IO_new(IOWrite, S->SockFD);
    a_IO_set_buf(io, query, strlen(query));
    io->Flags |= IOFlag_FreeIOBuf;
@@ -386,7 +430,7 @@
    void *link;
    const DilloUrl *Url = Data1;
    SocketData_t *S;
-   gchar *hostname;
+   gchar *hostname, *msg_enc;
 
    S = a_Klist_get_data(ValidSocks, GPOINTER_TO_INT(Info->LocalKey));
 
@@ -410,7 +454,9 @@
    S->Url = Url;
 
    /* Let the user know what we'll do */
-   BW_MSG(S->web, 1, "DNS solving %s", URL_HOST_(S->Url));
+   msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("DNS solving %s"));
+   BW_MSG(S->web, 1, msg_enc, URL_HOST_(S->Url));
+   g_free(msg_enc);
 
    /* Let the DNS engine solve the hostname, and when done,
     * we'll try to connect the socket */
@@ -429,6 +475,7 @@
 {
    gint SKey = GPOINTER_TO_INT(Info->LocalKey);
    SocketData_t *S = a_Klist_get_data(ValidSocks, SKey);
+   gchar *msg_enc;
 
    a_Chain_debug_msg("a_Http_ccc", Op, Branch, Dir);
 
@@ -441,7 +488,9 @@
             Info->LocalKey = GINT_TO_POINTER(SKey);
             if (Http_get(Info, Data1, Data2) < 0) {
                S = a_Klist_get_data(ValidSocks, SKey);
-               BW_MSG(S->web, 1, "ERROR: %s", g_strerror(S->Err));
+			   msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("ERROR: %s"));
+               BW_MSG(S->web, 1, msg_enc, g_strerror(S->Err));
+			   g_free(msg_enc);
                Http_socket_free(SKey);
                a_Chain_fcb(OpAbort, Info, NULL, NULL);
             }
@@ -470,7 +519,9 @@
                a_Chain_del_link(Info, BCK);
                /* start connecting the socket */
                if (Http_connect_socket(Info) < 0) {
-                  BW_MSG(S->web, 1, "ERROR: %s", g_strerror(S->Err));
+				  msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("ERROR: %s"));
+                  BW_MSG(S->web, 1, msg_enc, g_strerror(S->Err));
+				  g_free(msg_enc);
                   Http_socket_free(SKey);
                   a_Chain_fcb(OpAbort, Info, NULL, NULL);
                }
@@ -481,8 +532,10 @@
             if (S) {
                /* Unlink DNS_Info */
                a_Chain_del_link(Info, BCK);
-               BW_MSG(S->web, 0, "ERROR: Dns can't solve %s",
+			   msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("ERROR: Dns can't solve %s"));
+               BW_MSG(S->web, 0, msg_enc,
                   (S->use_proxy) ? URL_HOST_(HTTP_Proxy) : URL_HOST_(S->Url));
+			   g_free(msg_enc);
                Http_socket_free(SKey);
                /* send abort message to higher-level functions */
                a_Chain_fcb(OpAbort, Info, NULL, NULL);
@@ -506,7 +559,9 @@
             if (S) {
                a_Chain_del_link(Info, BCK);
                a_Chain_fcb(OpEnd, Info, (void *)S->SockFD, (void *)S->Url);
-               BW_MSG(S->web, 1, "Query sent, waiting for reply...");
+			   msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("Query sent, waiting for reply..."));
+               BW_MSG(S->web, 1, msg_enc);
+			   g_free(msg_enc);
                Http_socket_free(SKey);
             }
             break;
@@ -532,6 +587,7 @@
  */
 void a_Http_freeall(void)
 {
+   a_Auth_freeall();
    a_Klist_free(&ValidSocks);
    a_Url_free(HTTP_Proxy);
 }
diff -Nur dillo-0.8.0/src/IO/https.c dillo-0.8.0.new/src/IO/https.c
--- dillo-0.8.0/src/IO/https.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/src/IO/https.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,464 @@
+/*
+ * File: https.c
+ *
+ * Copyright (C) 2000, 2001 Jorge Arellano Cid <jcid@inf.utfsm.cl>
+ * Copyright (C) 2002       Jonathan P Springer <jonathan.springer@verizon.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc., 59
+ * Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ * In addition, as a special exception, Jorge Arellano Cid and Jonathan
+ * Springer give permission to link the code of this program with the OpenSSL
+ * library (or modified versions of OpenSSL that use the same license as
+ * OpenSSL), and distribute linked combinations including the two.  You must
+ * obey the GNU General Public License in all respects for all of the code
+ * used other than OpenSSL.  If you modify this file, you may extend this
+ * exception to your version of the file, but you are not obligated to do so.
+ * If you do not wish to do so, delete this exception from your version.  
+ *
+ */
+
+/*
+ * This program exploits code originally published under the OpenSSL demos/bio
+ * directory.  I am uncertain as to the copyright status of this code, as no
+ * notice was included.  If you own the copyright on this code and object to
+ * its use in this GPL program, please contact me.  -- JPS
+ */
+
+/*
+ * HTTPS connect functions
+ */
+
+#include <config.h>
+
+#ifdef DILLO_SSL
+
+#include <unistd.h>
+#include <errno.h>              /* for errno */
+#include <string.h>             /* for strstr */
+#include <stdlib.h>
+#include <signal.h>
+#include <fcntl.h>
+#include <sys/wait.h>
+#include <sys/socket.h>         /* for lots of socket stuff */
+#include <netinet/in.h>         /* for ntohl and stuff */
+#include <openssl/ssl.h>
+#include <openssl/err.h>
+
+#include <glib.h>
+
+#include "../intl.h"
+#include "../i18n.h"
+#include "Url.h"
+#include "DBIO.h"
+#include "../klist.h"
+#include "../dns.h"
+#include "../cache.h"
+#include "../web.h"
+#include "../interface.h"
+extern char *Http_query(const DilloUrl *url, gboolean use_proxy);
+
+
+/* Used to send a message to the bw's status bar */
+#define BW_MSG(web, root, fmt...) \
+   (a_Web_valid(web) && (!(root) || (web)->flags & WEB_RootUrl)) ? \
+   a_Interface_msg((web)->dd->bw, fmt) : (root)
+
+#define DEBUG_LEVEL 5
+#include "../debug.h"
+
+
+/* 'Url' and 'web' are just references (no need to deallocate them here). */
+typedef struct {
+  BIO* bio;
+  SSL* ssl;
+  const DilloUrl *Url;    /* reference to original URL */
+  DilloWeb *web;          /* reference to client's web structure */
+  guint32 ip_addr;        /* Holds the DNS answer */
+  gint Err;               /* Holds the errno of the connect() call */
+  ChainLink *Info;        /* Used for CCC asynchronous operations */
+} SSLData_t;
+
+
+/*
+ * Local data
+ */
+static Klist_t *ValidSSLs = NULL;  /* Active sockets list. It holds pointers to
+				    * SSLData_t structures. */
+
+static gboolean Https_init = FALSE;
+
+static SSL_CTX* ssl_ctx;
+
+/*
+ * Forward declarations
+ */
+static void Https_send_query(ChainLink *Info, SSLData_t *S);
+static void Https_expect_answer(SSLData_t *S);
+
+/*
+ *  If it hasn't been initialized already, initialize
+ *  the SSL-specific stuff.
+ */
+void Https_SSL_init(void)
+{
+  if (!Https_init) {
+    SSL_load_error_strings();
+    OpenSSL_add_ssl_algorithms();
+    ssl_ctx = SSL_CTX_new(SSLv23_client_method());
+    Https_init = TRUE;
+  }
+}
+    
+/*
+ * Create and init a new SSLData_t struct, insert into ValidSSLs,
+ * and return a primary key for it.
+ */
+gint Https_SSL_new(void)
+{
+  SSLData_t *S = g_new0(SSLData_t, 1);
+  return a_Klist_insert(&ValidSSLs, (gpointer)S);
+}
+
+/*
+ * Free SSLData_t struct
+ */
+void Https_SSL_free(gint SKey)
+{
+  SSLData_t *S;
+
+  if ((S = a_Klist_get_data(ValidSSLs, SKey))) {
+    a_Klist_remove(ValidSSLs, SKey);
+    if (S->bio) BIO_free_all(S->bio);
+    g_free(S);
+  }
+}
+
+/*
+ * This function is called after the socket has been successfuly connected,
+ * or upon an error condition on the connecting process.
+ * Task: use the socket to send the HTTP-query and expect its answer
+ */
+static gboolean Https_Callback_Use(gpointer data)
+{
+  ChainLink *Info;
+  SSLData_t *S;
+  gint SKey = (gint) data;
+  gchar *msg_enc;
+
+  DEBUG_MSG(3, "Https_Callback_Use\n");
+
+  /* This check is required because glib may asynchronously
+   * call this function with data that's no longer used  --Jcid   */
+  if ( !(S = a_Klist_get_data(ValidSSLs, SKey)) ) return FALSE;
+
+  Info = S->Info;
+  if ( S->Err ) {
+    DEBUG_MSG(3, _("--Error detected\n"));
+    DEBUG_MSG(3, "%d:%s:%s:%s\n", S->Err, 
+	      ERR_lib_error_string(S->Err), 
+	      ERR_func_error_string(S->Err),
+	      ERR_reason_error_string(S->Err));
+	msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("ERROR: unable to connect to remote host"));
+    BW_MSG(S->web, 0, msg_enc);
+	g_free(msg_enc);
+    a_Chain_fcb(OpAbort, Info, NULL, NULL);
+    Https_SSL_free(SKey);
+  } else {
+    DEBUG_MSG(3, _("--Connection established\n"));
+    Https_send_query(Info, S);
+    Https_expect_answer(S);
+  }
+  return FALSE;
+}
+
+gboolean Https_Callback_Connect(gpointer data) {
+
+  gint SKey = (gint) data;
+  SSLData_t *S;
+  gchar *msg_enc;
+
+  /* This check is required because glib may asynchronously
+   * call this function with data that's no longer used  --Jcid   */
+  if ( !(S = a_Klist_get_data(ValidSSLs, SKey)) ) return FALSE;
+  
+  S->Err = 0;
+  if (BIO_do_connect(S->bio) != 1) {
+    if (BIO_should_retry(S->bio)) return TRUE;
+    S->Err = ERR_get_error();
+    DEBUG_MSG(3, "%d:%s:%s:%s\n", S->Err, 
+	      ERR_lib_error_string(S->Err), 
+	      ERR_func_error_string(S->Err),
+	      ERR_reason_error_string(S->Err));
+	msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("ERROR: unable to connect to remote host"));
+    BW_MSG(S->web, 0, msg_enc);
+	g_free(msg_enc);
+    return FALSE;
+  }
+  g_idle_add(Https_Callback_Use, data);
+  return FALSE;
+}
+
+/*
+ * This function gets called after the DNS succeeds solving a hostname.
+ * Task: Finish socket setup and start connecting the socket.
+ * Return value: 0 on success;  -1 on error.
+*/
+static int Https_connect_SSL(ChainLink *Info)
+{
+  SSLData_t *S = a_Klist_get_data(ValidSSLs, (gint)Info->LocalKey);
+
+  BIO *ssl_bio;
+  union {
+    guint32 i;
+    guchar c[4];
+  } U;
+  gchar *tmp_str;
+  int port = DILLO_URL_HTTPS_PORT;
+
+  /* TODO - Better error checking */
+
+  /* Initialize some SSL stuff if this is our first connection */
+  Https_SSL_init();
+
+  /* Create an SSL structure */
+  S->ssl = SSL_new(ssl_ctx);
+  SSL_set_connect_state(S->ssl);
+
+  /* Create a BIO structure */
+  ssl_bio = BIO_new(BIO_f_ssl());
+  BIO_set_ssl(ssl_bio, S->ssl, BIO_CLOSE);
+
+  /* Create and configure the connection BIO */
+  S->bio = BIO_new(BIO_s_connect());
+
+#if 0
+  U.i = htonl(S->ip_addr);
+#else
+  U.i = S->ip_addr; /* should already be in the right order */
+#endif
+  tmp_str = g_strdup_printf("%u.%u.%u.%u", U.c[0], U.c[1], U.c[2], U.c[3]);
+  BIO_set_conn_hostname(S->bio, tmp_str);
+  g_free(tmp_str);
+  BIO_set_conn_int_port(S->bio, &port);
+
+  BIO_set_nbio(S->bio, 1); /* non-blocking ON */
+
+  /* Chain the socket & SSL BIOs together */
+  S->bio = BIO_push(ssl_bio, S->bio); /* chain this with the SSL BIO */
+
+  /* And set up a looping idle event to connect it... */
+  g_idle_add(Https_Callback_Connect, (gpointer) Info->LocalKey);
+
+  return 0; /* Success */
+}
+
+/*
+ * Create and submit the HTTP query to the IO engine
+ */
+static void Https_send_query(ChainLink *Info, SSLData_t *S)
+{
+  IOData_t *io;
+  gchar *query, *msg_enc;
+  void *link;
+
+  /* Create the query */
+  query = Http_query(S->Url, FALSE);
+
+  /* send query */
+  msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("Sending query to %s..."));
+  BW_MSG(S->web, 1, msg_enc, URL_HOST(S->Url));
+  g_free(msg_enc);
+  io = a_DBIO_new(S->bio);
+  io->Op = IOWrite;
+  a_IO_set_buf(io, query, strlen(query));
+  io->Flags |= IOFlag_FreeIOBuf;
+  io->ExtData = NULL;
+  link = a_Chain_link_new(Info, a_Https_ccc, BCK, a_DBIO_ccc,2,2);
+  a_DBIO_ccc(OpStart, 1,0, link, io, NULL);
+}
+
+/*
+ * Expect the HTTP query's answer
+ */
+static void Https_expect_answer(SSLData_t *S)
+{
+  IOData_t *io2;
+
+  /* receive answer */
+  io2 = a_DBIO_new(S->bio);
+  io2->Op = IORead;
+  a_IO_set_buf(io2,g_malloc(IOBufLen_Http),IOBufLen_Http);
+  io2->Flags |= IOFlag_FreeIOBuf;
+  io2->ExtData = (void *) S->Url;
+  a_DBIO_ccc(OpStart, 2, 0,a_Chain_new(), io2, NULL);
+}
+
+/*
+ * Asynchronously create a new http connection for 'Url'
+ * We'll set some socket parameters; the rest will be set later
+ * when the IP is known.
+ * ( Data = Requested Url; ExtraData = Web structure )
+ * Return value: 0 on success, -1 otherwise
+ */
+gint Https_get(ChainLink *Info, void *Data, void *ExtraData)
+{
+  void *link;
+  const DilloUrl *Url = Data;
+  SSLData_t *S = a_Klist_get_data(ValidSSLs, (gint)Info->LocalKey);
+  gchar hostname[256], *Host = hostname, *msg_enc;
+
+  /* Reference Info data */
+  S->Info = Info;
+  /* Reference Web data */
+  S->web = ExtraData;
+
+  Host = (gchar *)URL_HOST(Url);
+  
+  /* Set more socket parameters */
+  S->Url = Url;
+
+  /* Let the user know what we'll do */
+  msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("DNS solving %s"));
+  BW_MSG(S->web, 1, msg_enc, URL_HOST(S->Url));
+  g_free(msg_enc);
+
+  /* Let the DNS engine solve the hostname, and when done,
+   * we'll try to connect the socket */
+  link = a_Chain_link_new(Info, a_Https_ccc, BCK, a_Dns_ccc, 1, 1);
+  a_Chain_bcb(OpStart,Info, Host,NULL);
+  
+  return 0;
+}
+
+/*
+ * CCC function for the HTTP module
+ */
+void
+a_Https_ccc(int Op, int Branch, int Dir, ChainLink *Info, void *Data, void *ExtraData)
+{
+  gint SKey = (gint)Info->LocalKey;
+  SSLData_t *S = a_Klist_get_data(ValidSSLs, SKey);
+  gchar *msg_enc;
+
+  if ( Branch == 1 ) {
+    /* DNS query branch */
+      switch (Op) {  
+      case OpStart:
+	Info->LocalKey = (void *) SKey = Https_SSL_new();
+	if (Https_get(Info, Data, ExtraData) < 0) {
+	  DEBUG_MSG(2, _(" HTTP: new abort handler! #2\n"));
+	  S = a_Klist_get_data(ValidSSLs, SKey);
+	  msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("ERROR: %s"));
+	  BW_MSG(S->web, 1, msg_enc, g_strerror(S->Err));
+	  g_free(msg_enc);
+	  Https_SSL_free(SKey);
+	  a_Chain_fcb(OpAbort, Info, NULL, NULL);
+	}
+      break;
+      case OpSend:
+	/* Successful DNS answer; save the IP */
+	if (S)
+	  {
+	    DilloHost *dh=(DilloHost *)(((GSList *)Data)->data);
+	    S->ip_addr = *(int *)dh->data;
+	  }
+	break;
+      case OpEnd:
+      if (S) {
+	/* Unlink DNS_Info */
+	a_Chain_del_link(Info, BCK);
+	/* start connecting the socket */
+	if (Https_connect_SSL(Info) < 0) {
+	  DEBUG_MSG(2, _(" HTTP: new abort handler! #1\n"));
+	  msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("ERROR: %s"));
+	  BW_MSG(S->web, 1, msg_enc, g_strerror(S->Err));
+	  g_free(msg_enc);
+	  Https_SSL_free(SKey);
+	  a_Chain_fcb(OpAbort, Info, NULL, NULL);
+	}
+      }
+      break;
+    case OpAbort:
+      /* DNS wasn't able to resolve the hostname */
+      if (S) {
+	/* Unlink DNS_Info */
+	a_Chain_del_link(Info, BCK);
+	msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("ERROR: Dns can't solve %s"));
+	BW_MSG(S->web, 0, msg_enc, URL_HOST(S->Url));
+	g_free(msg_enc);
+	BIO_free_all(S->bio);
+	Https_SSL_free(SKey);
+	/* send abort message to higher-level functions */
+	a_Chain_fcb(OpAbort, Info, NULL, NULL);
+      }
+      break;
+      
+      }
+  
+  } else if ( Branch == 2 ) {
+    /* IO send-query branch */
+    switch (Op) {
+    case OpStart:
+      /* LocalKey was set by branch 1 */
+      break;
+    case OpEnd:
+      /* finished sending the HTTP query */
+      if (S) {
+		  msg_enc = a_I18n_locale_to_DILLO_CHARSET(_("Query sent, waiting for reply..."));
+	BW_MSG(S->web, 1, msg_enc);
+	g_free(msg_enc);
+	a_Chain_del_link(Info, BCK);
+	a_Chain_fcb(OpEnd, Info, NULL, NULL);
+      }
+      break;
+    case OpAbort:
+      /* something bad happened... */
+      /* unlink IO_Info */
+      if (S) {
+	a_Chain_del_link(Info, BCK);
+	a_Chain_fcb(OpAbort, Info, NULL, NULL);
+	Https_SSL_free(SKey);
+      }
+      break;
+    }
+
+  } else if ( Branch == -1 ) {
+    /* Backwards abort */
+    switch (Op) {
+    case OpAbort:
+      /* something bad happened... */
+      DEBUG_MSG(2, "Http: OpAbort [-1]\n");
+      Https_SSL_free(SKey);
+      a_Chain_bcb(OpAbort, Info, NULL, NULL);
+      g_free(Info);
+      break;
+    }
+  }
+}
+
+
+
+/*
+ * Deallocate memory used by http module
+ * (Call this one at exit time)
+ */
+void a_Https_freeall(void)
+{
+  if (ssl_ctx) SSL_CTX_free(ssl_ctx);
+  a_Klist_free(&ValidSSLs);
+}
+
+#endif
+
diff -Nur dillo-0.8.0/src/IO/IO.c dillo-0.8.0.new/src/IO/IO.c
--- dillo-0.8.0/src/IO/IO.c	2003-11-21 19:53:32.000000000 +0000
+++ dillo-0.8.0.new/src/IO/IO.c	2004-10-13 01:13:29.000000000 +0000
@@ -81,6 +81,9 @@
    io->GioCh = g_io_channel_unix_new(fd);
    io->Flags = 0;
    io->Key = 0;
+#ifdef DILLO_SSL 
+   io->bio = NULL;
+#endif
    return io;
 }
 
@@ -336,7 +339,7 @@
 /*
  * Register an IO in ValidIOs
  */
-static void IO_ins(IOData_t *io)
+void IO_ins(IOData_t *io)
 {
    io->Key = a_Klist_insert(&ValidIOs, (gpointer)io);
 }
@@ -344,7 +347,7 @@
 /*
  * Remove an IO from ValidIOs
  */
-static void IO_del(IOData_t *io)
+void IO_del(IOData_t *io)
 {
    a_Klist_remove(ValidIOs, io->Key);
 }
@@ -352,7 +355,7 @@
 /*
  * Return a io by its Key (NULL if not found)
  */
-static IOData_t *IO_get(gint Key)
+IOData_t *IO_get(gint Key)
 {
    return a_Klist_get_data(ValidIOs, Key);
 }
@@ -557,7 +560,7 @@
  * Receive an IO request (IORead | IOWrite | IOWrites),
  * Set the GIOChannel and let it flow!
  */
-static void IO_submit(IOData_t *r_io)
+void IO_submit(IOData_t *r_io)
 {
    /* Insert this IO in ValidIOs */
    IO_ins(r_io);
diff -Nur dillo-0.8.0/src/IO/IO.h dillo-0.8.0.new/src/IO/IO.h
--- dillo-0.8.0/src/IO/IO.h	2003-11-21 19:54:00.000000000 +0000
+++ dillo-0.8.0.new/src/IO/IO.h	2004-10-13 01:13:29.000000000 +0000
@@ -1,9 +1,15 @@
 #ifndef __IO_H__
 #define __IO_H__
 
+#include<config.h>
+
 #include<unistd.h>
 #include<sys/uio.h>
 
+#ifdef DILLO_SSL
+#include <openssl/bio.h>
+#endif
+
 #include "../chain.h"
 
 /*
@@ -30,6 +36,7 @@
 #define IOBufLen_File    4096
 #define IOBufLen_Proto   4096
 #define IOBufLen_About   4096
+#define IOBufLen_Matrix  4096
 
 
 typedef struct {
@@ -45,6 +52,9 @@
 
    void *ExtData;         /* External data reference (not used by IO.c) */
    void *Info;            /* CCC Info structure for this IO */
+#ifdef DILLO_SSL
+   BIO *bio;
+#endif
    GIOChannel *GioCh;     /* IO channel */
    guint watch_id;        /* glib's event source id */
 } IOData_t;
diff -Nur dillo-0.8.0/src/IO/Makefile.am dillo-0.8.0.new/src/IO/Makefile.am
--- dillo-0.8.0/src/IO/Makefile.am	2004-01-29 20:34:05.000000000 +0000
+++ dillo-0.8.0.new/src/IO/Makefile.am	2004-10-13 01:13:29.000000000 +0000
@@ -4,6 +4,9 @@
 noinst_LIBRARIES = libDio.a
 
 libDio_a_SOURCES = \
+	https.c \
+	DBIO.h \
+	DBIO.c \
 	mime.c \
 	mime.h \
 	about.c \
diff -Nur dillo-0.8.0/src/IO/Makefile.in dillo-0.8.0.new/src/IO/Makefile.in
--- dillo-0.8.0/src/IO/Makefile.in	2004-02-08 12:57:37.000000000 +0000
+++ dillo-0.8.0.new/src/IO/Makefile.in	2004-10-13 01:20:01.000000000 +0000
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.7 from Makefile.am.
+# Makefile.in generated by automake 1.7.3 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -39,6 +39,7 @@
 host_triplet = @host@
 target_triplet = @target@
 ACLOCAL = @ACLOCAL@
+ALLOCA = @ALLOCA@
 AMDEP_FALSE = @AMDEP_FALSE@
 AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
@@ -46,12 +47,15 @@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
+BUILD_INCLUDED_LIBINTL = @BUILD_INCLUDED_LIBINTL@
+CATOBJEXT = @CATOBJEXT@
 CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CYGPATH_W = @CYGPATH_W@
+DATADIRNAME = @DATADIRNAME@
 DEFS = @DEFS@
 DEPDIR = @DEPDIR@
 ECHO_C = @ECHO_C@
@@ -59,9 +63,12 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+GENCAT = @GENCAT@
+GLIBC21 = @GLIBC21@
 GLIB_CFLAGS = @GLIB_CFLAGS@
 GLIB_CONFIG = @GLIB_CONFIG@
 GLIB_LIBS = @GLIB_LIBS@
+GMSGFMT = @GMSGFMT@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_CONFIG = @GTK_CONFIG@
 GTK_LIBS = @GTK_LIBS@
@@ -69,7 +76,17 @@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+INSTOBJEXT = @INSTOBJEXT@
+INTLBISON = @INTLBISON@
+INTLLIBS = @INTLLIBS@
+INTLOBJS = @INTLOBJS@
+INTL_LIBTOOL_SUFFIX_PREFIX = @INTL_LIBTOOL_SUFFIX_PREFIX@
+KRB5_CONFIG = @KRB5_CONFIG@
 LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBICONV_CFLAGS = @LIBICONV_CFLAGS@
+LIBICONV_LIBS = @LIBICONV_LIBS@
+LIBINTL = @LIBINTL@
 LIBJPEG_CPPFLAGS = @LIBJPEG_CPPFLAGS@
 LIBJPEG_LDFLAGS = @LIBJPEG_LDFLAGS@
 LIBJPEG_LIBS = @LIBJPEG_LIBS@
@@ -78,8 +95,13 @@
 LIBPNG_LIBS = @LIBPNG_LIBS@
 LIBS = @LIBS@
 LIBZ_LIBS = @LIBZ_LIBS@
+LTLIBICONV = @LTLIBICONV@
+LTLIBINTL = @LTLIBINTL@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
+MKINSTALLDIRS = @MKINSTALLDIRS@
+MSGFMT = @MSGFMT@
+MSGMERGE = @MSGMERGE@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -88,11 +110,16 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+POSUB = @POSUB@
 RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
+USE_INCLUDED_LIBINTL = @USE_INCLUDED_LIBINTL@
+USE_NLS = @USE_NLS@
 VERSION = @VERSION@
+XFT_CONFIG = @XFT_CONFIG@
+XGETTEXT = @XGETTEXT@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
@@ -119,6 +146,7 @@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 oldincludedir = @oldincludedir@
@@ -138,6 +166,9 @@
 noinst_LIBRARIES = libDio.a
 
 libDio_a_SOURCES = \
+	https.c \
+	DBIO.h \
+	DBIO.c \
 	mime.c \
 	mime.h \
 	about.c \
@@ -151,7 +182,6 @@
 	IO.h
 
 subdir = src/IO
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
@@ -159,24 +189,25 @@
 
 libDio_a_AR = $(AR) cru
 libDio_a_LIBADD =
-am_libDio_a_OBJECTS = mime.$(OBJEXT) about.$(OBJEXT) Url.$(OBJEXT) \
-	proto.$(OBJEXT) file.$(OBJEXT) http.$(OBJEXT) dpi.$(OBJEXT) \
-	IO.$(OBJEXT)
+am_libDio_a_OBJECTS = https.$(OBJEXT) DBIO.$(OBJEXT) mime.$(OBJEXT) \
+	about.$(OBJEXT) Url.$(OBJEXT) proto.$(OBJEXT) file.$(OBJEXT) \
+	http.$(OBJEXT) dpi.$(OBJEXT) IO.$(OBJEXT)
 libDio_a_OBJECTS = $(am_libDio_a_OBJECTS)
 
 DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
-@AMDEP_TRUE@DEP_FILES = ./$(DEPDIR)/IO.Po ./$(DEPDIR)/Url.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/about.Po ./$(DEPDIR)/dpi.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/file.Po ./$(DEPDIR)/http.Po \
+@AMDEP_TRUE@DEP_FILES = ./$(DEPDIR)/DBIO.Po ./$(DEPDIR)/IO.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/Url.Po ./$(DEPDIR)/about.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/dpi.Po ./$(DEPDIR)/file.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/http.Po ./$(DEPDIR)/https.Po \
 @AMDEP_TRUE@	./$(DEPDIR)/mime.Po ./$(DEPDIR)/proto.Po
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
 DIST_SOURCES = $(libDio_a_SOURCES)
-DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
+DIST_COMMON = Makefile.am Makefile.in
 SOURCES = $(libDio_a_SOURCES)
 
 all: all-am
@@ -204,19 +235,24 @@
 distclean-compile:
 	-rm -f *.tab.c
 
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/DBIO.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/IO.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Url.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/about.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dpi.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/file.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/http.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/https.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mime.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/proto.Po@am__quote@
 
+distclean-depend:
+	-rm -rf ./$(DEPDIR)
+
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
+@am__fastdepCC_TRUE@	then mv "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
 @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; \
 @am__fastdepCC_TRUE@	fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
@@ -227,7 +263,7 @@
 .c.obj:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `if test -f '$<'; then $(CYGPATH_W) '$<'; else $(CYGPATH_W) '$(srcdir)/$<'; fi`; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
+@am__fastdepCC_TRUE@	then mv "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
 @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; \
 @am__fastdepCC_TRUE@	fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
@@ -326,6 +362,7 @@
 all-am: Makefile $(LIBRARIES)
 
 installdirs:
+
 install: install-am
 install-exec: install-exec-am
 install-data: install-data-am
@@ -345,7 +382,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f $(CONFIG_CLEAN_FILES)
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -355,11 +392,9 @@
 clean-am: clean-generic clean-noinstLIBRARIES mostlyclean-am
 
 distclean: distclean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
 
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-tags
+distclean-am: clean-am distclean-compile distclean-depend \
+	distclean-generic distclean-tags
 
 dvi: dvi-am
 
@@ -380,8 +415,6 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
-	-rm -rf ./$(DEPDIR)
-	-rm -f Makefile
 
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
@@ -401,13 +434,14 @@
 
 .PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
 	clean-noinstLIBRARIES ctags distclean distclean-compile \
-	distclean-generic distclean-tags distdir dvi dvi-am info \
-	info-am install install-am install-data install-data-am \
-	install-exec install-exec-am install-info install-info-am \
-	install-man install-strip installcheck installcheck-am \
-	installdirs maintainer-clean maintainer-clean-generic \
-	mostlyclean mostlyclean-compile mostlyclean-generic pdf pdf-am \
-	ps ps-am tags uninstall uninstall-am uninstall-info-am
+	distclean-depend distclean-generic distclean-tags distdir dvi \
+	dvi-am info info-am install install-am install-data \
+	install-data-am install-exec install-exec-am install-info \
+	install-info-am install-man install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
+	uninstall-am uninstall-info-am
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Nur dillo-0.8.0/src/IO/Url.c dillo-0.8.0.new/src/IO/Url.c
--- dillo-0.8.0/src/IO/Url.c	2004-01-29 20:32:01.000000000 +0000
+++ dillo-0.8.0.new/src/IO/Url.c	2004-10-13 01:13:29.000000000 +0000
@@ -16,6 +16,7 @@
  * This module selects the apropriate CCC-function for a given URL.
  */
 
+#include <config.h>
 
 #include <glib.h>
 #include <stdlib.h>
@@ -83,6 +84,9 @@
 ChainFunction_t a_Url_get_ccc_funct(const DilloUrl *Url)
 {
    static UrlMethod2_t cccList[] = { {"http" , a_Http_ccc},
+#ifdef DILLO_SSL
+                                     {"https", a_Https_ccc},
+#endif
                                      {"file" , a_File_ccc},
                                      {"about", a_About_ccc},
                                      {"dpi" , a_Dpi_ccc},
diff -Nur dillo-0.8.0/src/IO/Url.h dillo-0.8.0.new/src/IO/Url.h
--- dillo-0.8.0/src/IO/Url.h	2003-10-18 16:16:37.000000000 +0000
+++ dillo-0.8.0.new/src/IO/Url.h	2004-10-13 01:13:29.000000000 +0000
@@ -46,6 +46,10 @@
 void a_Dpi_ccc  (int Op, int Branch, int Dir, ChainLink *Info,
                  void *Data1, void *Data2);
 void a_Dpi_bye_dpid();
+#ifdef DILLO_SSL
+void a_Https_ccc(int Op, int Br,int Dir, ChainLink *Info, void *Data, void *ExtraData);
+void a_Https_freeall(void);
+#endif
 
 
 #ifdef __cplusplus
diff -Nur dillo-0.8.0/src/Makefile.am dillo-0.8.0.new/src/Makefile.am
--- dillo-0.8.0/src/Makefile.am	2004-01-29 20:34:05.000000000 +0000
+++ dillo-0.8.0.new/src/Makefile.am	2004-10-13 01:13:29.000000000 +0000
@@ -1,28 +1,47 @@
-AM_CPPFLAGS=-DDILLORC_SYS='"$(sysconfdir)/dillorc"' @LIBJPEG_CPPFLAGS@
-AM_CFLAGS = @GTK_CFLAGS@ @LIBPNG_CFLAGS@
+AM_CPPFLAGS=-DDILLORC_SYS='"$(sysconfdir)/dillorc"' @LIBJPEG_CPPFLAGS@ -DLOCALEDIR='"$(localedir)"' -D__NO_STRING_INLINES
+AM_CFLAGS = @GTK_CFLAGS@ @LIBPNG_CFLAGS@ @LIBICONV_CFLAGS@
 
 SUBDIRS = IO
 
 bin_PROGRAMS = dillo
 
-dillo_LDADD = IO/libDio.a @LIBJPEG_LIBS@ @LIBPNG_LIBS@ @GTK_LIBS@ @LIBZ_LIBS@
+dillo_LDADD = IO/libDio.a @LIBJPEG_LIBS@ @LIBPNG_LIBS@ @GTK_LIBS@ @LIBZ_LIBS@ @LIBICONV_LIBS@
 
 dillo_LDFLAGS = @LIBJPEG_LDFLAGS@
 
 dillo_SOURCES = \
 	msg.h \
 	acconfig.h \
-	chain.h \
-	chain.c \
-	commands.c \
-	commands.h \
+	auth.c \
+	auth.h \
+	bitvec.c \
+	bitvec.h \
+	bookmark.c \
+	bookmark.h \
+	browser.h \
 	cache.c	\
 	cache.h	\
 	capi.c \
 	capi.h \
+	chain.c \
+	chain.h \
+	colors.c \
+	colors.h \
+	commands.c \
+	commands.h \
+	cookies.c \
+	cookies.h \
 	debug.h \
-	dw.h \
+	dicache.c \
+	dicache.h \
+	dillo.c \
+	dillo.h \
+	dns.c \
+	dns.h \
+	doc.c \
+	doc.h \
 	dw.c \
+	dw.h \
 	dw_aligned_page.c \
 	dw_aligned_page.h \
 	dw_bullet.c \
@@ -33,8 +52,8 @@
 	dw_container.h \
 	dw_embed_gtk.c	\
 	dw_embed_gtk.h	\
-	dw_ext_iterator.h \
 	dw_ext_iterator.c \
+	dw_ext_iterator.h \
 	dw_gtk_scrolled_frame.c \
 	dw_gtk_scrolled_frame.h \
 	dw_gtk_scrolled_window.c \
@@ -63,56 +82,53 @@
 	dw_tooltip.h \
 	dw_widget.c \
 	dw_widget.h \
+	i18n.c \
+	i18n.h \
+	i18n_gtk.c \
+	i18n_gtk.h \
 	findtext.c \
 	findtext.h \
-	selection.c \
-	selection.h \
-	web.c	\
-	web.h	\
-	progressbar.c \
-	progressbar.h \
-	dillo.c \
-	dillo.h \
-	bookmark.c \
-	bookmark.h \
-	browser.h \
-	dicache.c \
-	dicache.h \
-	dns.c \
-	dns.h \
 	gif.c \
-	jpeg.c \
-	png.c \
+	gtkframeset.c \
+	gtkframeset.h \
+	history.c \
+	history.h \
 	html.c \
 	html.h \
 	image.c \
 	image.h \
+	interface.c \
+	interface.h \
+	intl.h \
+	jpeg.c \
+	klist.c \
+	klist.h \
+	strbuf.c \
+	strbuf.h \
+	list.h \
+	menu.c \
+	menu.h \
 	misc.c \
 	misc.h \
-	interface.h \
-	interface.c \
-	history.c \
-	history.h \
 	nav.c \
 	nav.h \
+	pagemark.c \
+	pagemark.h \
+	pixmaps.h \
 	plain.c \
-	menu.c \
-	menu.h \
+	png.c \
 	prefs.c \
 	prefs.h \
-	colors.c \
-	colors.h \
-	bitvec.c \
-	bitvec.h \
-	klist.c \
-	klist.h \
-	strbuf.c \
-	strbuf.h \
+	progressbar.c \
+	progressbar.h \
+	selection.c \
+	selection.h \
+	tab.c \
+	tab.h \
 	url.c \
 	url.h \
-	cookies.c \
-	cookies.h \
-	list.h \
-	pixmaps.h
+	user_agent.h \
+	web.c	\
+	web.h	
 
 EXTRA_DIST = chg srch
diff -Nur dillo-0.8.0/src/Makefile.in dillo-0.8.0.new/src/Makefile.in
--- dillo-0.8.0/src/Makefile.in	2004-02-08 12:57:23.000000000 +0000
+++ dillo-0.8.0.new/src/Makefile.in	2004-10-13 01:20:01.000000000 +0000
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.7.7 from Makefile.am.
+# Makefile.in generated by automake 1.7.3 from Makefile.am.
 # @configure_input@
 
 # Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@@ -39,6 +39,7 @@
 host_triplet = @host@
 target_triplet = @target@
 ACLOCAL = @ACLOCAL@
+ALLOCA = @ALLOCA@
 AMDEP_FALSE = @AMDEP_FALSE@
 AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
@@ -46,12 +47,15 @@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
+BUILD_INCLUDED_LIBINTL = @BUILD_INCLUDED_LIBINTL@
+CATOBJEXT = @CATOBJEXT@
 CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CFLAGS = @CFLAGS@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CYGPATH_W = @CYGPATH_W@
+DATADIRNAME = @DATADIRNAME@
 DEFS = @DEFS@
 DEPDIR = @DEPDIR@
 ECHO_C = @ECHO_C@
@@ -59,9 +63,12 @@
 ECHO_T = @ECHO_T@
 EGREP = @EGREP@
 EXEEXT = @EXEEXT@
+GENCAT = @GENCAT@
+GLIBC21 = @GLIBC21@
 GLIB_CFLAGS = @GLIB_CFLAGS@
 GLIB_CONFIG = @GLIB_CONFIG@
 GLIB_LIBS = @GLIB_LIBS@
+GMSGFMT = @GMSGFMT@
 GTK_CFLAGS = @GTK_CFLAGS@
 GTK_CONFIG = @GTK_CONFIG@
 GTK_LIBS = @GTK_LIBS@
@@ -69,7 +76,17 @@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+INSTOBJEXT = @INSTOBJEXT@
+INTLBISON = @INTLBISON@
+INTLLIBS = @INTLLIBS@
+INTLOBJS = @INTLOBJS@
+INTL_LIBTOOL_SUFFIX_PREFIX = @INTL_LIBTOOL_SUFFIX_PREFIX@
+KRB5_CONFIG = @KRB5_CONFIG@
 LDFLAGS = @LDFLAGS@
+LIBICONV = @LIBICONV@
+LIBICONV_CFLAGS = @LIBICONV_CFLAGS@
+LIBICONV_LIBS = @LIBICONV_LIBS@
+LIBINTL = @LIBINTL@
 LIBJPEG_CPPFLAGS = @LIBJPEG_CPPFLAGS@
 LIBJPEG_LDFLAGS = @LIBJPEG_LDFLAGS@
 LIBJPEG_LIBS = @LIBJPEG_LIBS@
@@ -78,8 +95,13 @@
 LIBPNG_LIBS = @LIBPNG_LIBS@
 LIBS = @LIBS@
 LIBZ_LIBS = @LIBZ_LIBS@
+LTLIBICONV = @LTLIBICONV@
+LTLIBINTL = @LTLIBINTL@
 LTLIBOBJS = @LTLIBOBJS@
 MAKEINFO = @MAKEINFO@
+MKINSTALLDIRS = @MKINSTALLDIRS@
+MSGFMT = @MSGFMT@
+MSGMERGE = @MSGMERGE@
 OBJEXT = @OBJEXT@
 PACKAGE = @PACKAGE@
 PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
@@ -88,11 +110,16 @@
 PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
+POSUB = @POSUB@
 RANLIB = @RANLIB@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
 STRIP = @STRIP@
+USE_INCLUDED_LIBINTL = @USE_INCLUDED_LIBINTL@
+USE_NLS = @USE_NLS@
 VERSION = @VERSION@
+XFT_CONFIG = @XFT_CONFIG@
+XGETTEXT = @XGETTEXT@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_RANLIB = @ac_ct_RANLIB@
 ac_ct_STRIP = @ac_ct_STRIP@
@@ -119,6 +146,7 @@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+localedir = @localedir@
 localstatedir = @localstatedir@
 mandir = @mandir@
 oldincludedir = @oldincludedir@
@@ -132,31 +160,50 @@
 target_cpu = @target_cpu@
 target_os = @target_os@
 target_vendor = @target_vendor@
-AM_CPPFLAGS = -DDILLORC_SYS='"$(sysconfdir)/dillorc"' @LIBJPEG_CPPFLAGS@
-AM_CFLAGS = @GTK_CFLAGS@ @LIBPNG_CFLAGS@
+AM_CPPFLAGS = -DDILLORC_SYS='"$(sysconfdir)/dillorc"' @LIBJPEG_CPPFLAGS@ -DLOCALEDIR='"$(localedir)"' -D__NO_STRING_INLINES
+AM_CFLAGS = @GTK_CFLAGS@ @LIBPNG_CFLAGS@ @LIBICONV_CFLAGS@
 
 SUBDIRS = IO
 
 bin_PROGRAMS = dillo
 
-dillo_LDADD = IO/libDio.a @LIBJPEG_LIBS@ @LIBPNG_LIBS@ @GTK_LIBS@ @LIBZ_LIBS@
+dillo_LDADD = IO/libDio.a @LIBJPEG_LIBS@ @LIBPNG_LIBS@ @GTK_LIBS@ @LIBZ_LIBS@ @LIBICONV_LIBS@
 
 dillo_LDFLAGS = @LIBJPEG_LDFLAGS@
 
 dillo_SOURCES = \
 	msg.h \
 	acconfig.h \
-	chain.h \
-	chain.c \
-	commands.c \
-	commands.h \
+	auth.c \
+	auth.h \
+	bitvec.c \
+	bitvec.h \
+	bookmark.c \
+	bookmark.h \
+	browser.h \
 	cache.c	\
 	cache.h	\
 	capi.c \
 	capi.h \
+	chain.c \
+	chain.h \
+	colors.c \
+	colors.h \
+	commands.c \
+	commands.h \
+	cookies.c \
+	cookies.h \
 	debug.h \
-	dw.h \
+	dicache.c \
+	dicache.h \
+	dillo.c \
+	dillo.h \
+	dns.c \
+	dns.h \
+	doc.c \
+	doc.h \
 	dw.c \
+	dw.h \
 	dw_aligned_page.c \
 	dw_aligned_page.h \
 	dw_bullet.c \
@@ -167,8 +214,8 @@
 	dw_container.h \
 	dw_embed_gtk.c	\
 	dw_embed_gtk.h	\
-	dw_ext_iterator.h \
 	dw_ext_iterator.c \
+	dw_ext_iterator.h \
 	dw_gtk_scrolled_frame.c \
 	dw_gtk_scrolled_frame.h \
 	dw_gtk_scrolled_window.c \
@@ -197,71 +244,70 @@
 	dw_tooltip.h \
 	dw_widget.c \
 	dw_widget.h \
+	i18n.c \
+	i18n.h \
+	i18n_gtk.c \
+	i18n_gtk.h \
 	findtext.c \
 	findtext.h \
-	selection.c \
-	selection.h \
-	web.c	\
-	web.h	\
-	progressbar.c \
-	progressbar.h \
-	dillo.c \
-	dillo.h \
-	bookmark.c \
-	bookmark.h \
-	browser.h \
-	dicache.c \
-	dicache.h \
-	dns.c \
-	dns.h \
 	gif.c \
-	jpeg.c \
-	png.c \
+	gtkframeset.c \
+	gtkframeset.h \
+	history.c \
+	history.h \
 	html.c \
 	html.h \
 	image.c \
 	image.h \
+	interface.c \
+	interface.h \
+	intl.h \
+	jpeg.c \
+	klist.c \
+	klist.h \
+	strbuf.c \
+	strbuf.h \
+	list.h \
+	menu.c \
+	menu.h \
 	misc.c \
 	misc.h \
-	interface.h \
-	interface.c \
-	history.c \
-	history.h \
 	nav.c \
 	nav.h \
+	pagemark.c \
+	pagemark.h \
+	pixmaps.h \
 	plain.c \
-	menu.c \
-	menu.h \
+	png.c \
 	prefs.c \
 	prefs.h \
-	colors.c \
-	colors.h \
-	bitvec.c \
-	bitvec.h \
-	klist.c \
-	klist.h \
-	strbuf.c \
-	strbuf.h \
+	progressbar.c \
+	progressbar.h \
+	selection.c \
+	selection.h \
+	tab.c \
+	tab.h \
 	url.c \
 	url.h \
-	cookies.c \
-	cookies.h \
-	list.h \
-	pixmaps.h
+	user_agent.h \
+	web.c	\
+	web.h	
 
 
 EXTRA_DIST = chg srch
 subdir = src
-ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
 CONFIG_HEADER = $(top_builddir)/config.h
 CONFIG_CLEAN_FILES =
 bin_PROGRAMS = dillo$(EXEEXT)
 PROGRAMS = $(bin_PROGRAMS)
 
-am_dillo_OBJECTS = chain.$(OBJEXT) commands.$(OBJEXT) cache.$(OBJEXT) \
-	capi.$(OBJEXT) dw.$(OBJEXT) dw_aligned_page.$(OBJEXT) \
-	dw_bullet.$(OBJEXT) dw_button.$(OBJEXT) dw_container.$(OBJEXT) \
+am_dillo_OBJECTS = auth.$(OBJEXT) bitvec.$(OBJEXT) bookmark.$(OBJEXT) \
+	cache.$(OBJEXT) capi.$(OBJEXT) chain.$(OBJEXT) colors.$(OBJEXT) \
+	commands.$(OBJEXT) cookies.$(OBJEXT) dicache.$(OBJEXT) \
+	dillo.$(OBJEXT) dns.$(OBJEXT) doc.$(OBJEXT) dw.$(OBJEXT) \
+	dw_aligned_page.$(OBJEXT) dw_bullet.$(OBJEXT) \
+	dw_button.$(OBJEXT) dw_container.$(OBJEXT) \
 	dw_embed_gtk.$(OBJEXT) dw_ext_iterator.$(OBJEXT) \
 	dw_gtk_scrolled_frame.$(OBJEXT) \
 	dw_gtk_scrolled_window.$(OBJEXT) dw_gtk_statuslabel.$(OBJEXT) \
@@ -269,27 +315,27 @@
 	dw_image.$(OBJEXT) dw_list_item.$(OBJEXT) dw_marshal.$(OBJEXT) \
 	dw_page.$(OBJEXT) dw_style.$(OBJEXT) dw_table.$(OBJEXT) \
 	dw_table_cell.$(OBJEXT) dw_tooltip.$(OBJEXT) \
-	dw_widget.$(OBJEXT) findtext.$(OBJEXT) selection.$(OBJEXT) \
-	web.$(OBJEXT) progressbar.$(OBJEXT) dillo.$(OBJEXT) \
-	bookmark.$(OBJEXT) dicache.$(OBJEXT) dns.$(OBJEXT) \
-	gif.$(OBJEXT) jpeg.$(OBJEXT) png.$(OBJEXT) html.$(OBJEXT) \
-	image.$(OBJEXT) misc.$(OBJEXT) interface.$(OBJEXT) \
-	history.$(OBJEXT) nav.$(OBJEXT) plain.$(OBJEXT) menu.$(OBJEXT) \
-	prefs.$(OBJEXT) colors.$(OBJEXT) bitvec.$(OBJEXT) \
-	klist.$(OBJEXT) strbuf.$(OBJEXT) url.$(OBJEXT) \
-	cookies.$(OBJEXT)
+	dw_widget.$(OBJEXT) i18n.$(OBJEXT) i18n_gtk.$(OBJEXT) \
+	findtext.$(OBJEXT) gif.$(OBJEXT) gtkframeset.$(OBJEXT) \
+	history.$(OBJEXT) html.$(OBJEXT) image.$(OBJEXT) \
+	interface.$(OBJEXT) jpeg.$(OBJEXT) klist.$(OBJEXT) \
+	strbuf.$(OBJEXT) menu.$(OBJEXT) misc.$(OBJEXT) nav.$(OBJEXT) \
+	pagemark.$(OBJEXT) plain.$(OBJEXT) png.$(OBJEXT) \
+	prefs.$(OBJEXT) progressbar.$(OBJEXT) selection.$(OBJEXT) \
+	tab.$(OBJEXT) url.$(OBJEXT) web.$(OBJEXT)
 dillo_OBJECTS = $(am_dillo_OBJECTS)
 dillo_DEPENDENCIES = IO/libDio.a
 
 DEFAULT_INCLUDES =  -I. -I$(srcdir) -I$(top_builddir)
 depcomp = $(SHELL) $(top_srcdir)/depcomp
 am__depfiles_maybe = depfiles
-@AMDEP_TRUE@DEP_FILES = ./$(DEPDIR)/bitvec.Po ./$(DEPDIR)/bookmark.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/cache.Po ./$(DEPDIR)/capi.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/chain.Po ./$(DEPDIR)/colors.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/commands.Po ./$(DEPDIR)/cookies.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/dicache.Po ./$(DEPDIR)/dillo.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/dns.Po ./$(DEPDIR)/dw.Po \
+@AMDEP_TRUE@DEP_FILES = ./$(DEPDIR)/auth.Po ./$(DEPDIR)/bitvec.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/bookmark.Po ./$(DEPDIR)/cache.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/capi.Po ./$(DEPDIR)/chain.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/colors.Po ./$(DEPDIR)/commands.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/cookies.Po ./$(DEPDIR)/dicache.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/dillo.Po ./$(DEPDIR)/dns.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/doc.Po ./$(DEPDIR)/dw.Po \
 @AMDEP_TRUE@	./$(DEPDIR)/dw_aligned_page.Po \
 @AMDEP_TRUE@	./$(DEPDIR)/dw_bullet.Po ./$(DEPDIR)/dw_button.Po \
 @AMDEP_TRUE@	./$(DEPDIR)/dw_container.Po \
@@ -306,15 +352,17 @@
 @AMDEP_TRUE@	./$(DEPDIR)/dw_table_cell.Po \
 @AMDEP_TRUE@	./$(DEPDIR)/dw_tooltip.Po ./$(DEPDIR)/dw_widget.Po \
 @AMDEP_TRUE@	./$(DEPDIR)/findtext.Po ./$(DEPDIR)/gif.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/history.Po ./$(DEPDIR)/html.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/image.Po ./$(DEPDIR)/interface.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/jpeg.Po ./$(DEPDIR)/klist.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/menu.Po ./$(DEPDIR)/misc.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/nav.Po ./$(DEPDIR)/plain.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/gtkframeset.Po ./$(DEPDIR)/history.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/html.Po ./$(DEPDIR)/i18n.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/i18n_gtk.Po ./$(DEPDIR)/image.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/interface.Po ./$(DEPDIR)/jpeg.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/klist.Po ./$(DEPDIR)/menu.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/misc.Po ./$(DEPDIR)/nav.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/pagemark.Po ./$(DEPDIR)/plain.Po \
 @AMDEP_TRUE@	./$(DEPDIR)/png.Po ./$(DEPDIR)/prefs.Po \
 @AMDEP_TRUE@	./$(DEPDIR)/progressbar.Po ./$(DEPDIR)/selection.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/strbuf.Po ./$(DEPDIR)/url.Po \
-@AMDEP_TRUE@	./$(DEPDIR)/web.Po
+@AMDEP_TRUE@	./$(DEPDIR)/strbuf.Po ./$(DEPDIR)/tab.Po \
+@AMDEP_TRUE@	./$(DEPDIR)/url.Po ./$(DEPDIR)/web.Po
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
@@ -326,7 +374,7 @@
 	all-recursive install-data-recursive install-exec-recursive \
 	installdirs-recursive install-recursive uninstall-recursive \
 	check-recursive installcheck-recursive
-DIST_COMMON = $(srcdir)/Makefile.in Makefile.am
+DIST_COMMON = Makefile.am Makefile.in
 DIST_SUBDIRS = $(SUBDIRS)
 SOURCES = $(dillo_SOURCES)
 
@@ -373,6 +421,7 @@
 distclean-compile:
 	-rm -f *.tab.c
 
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/auth.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bitvec.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/bookmark.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/cache.Po@am__quote@
@@ -384,6 +433,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dicache.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dillo.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dns.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/doc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dw.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dw_aligned_page.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dw_bullet.Po@am__quote@
@@ -407,8 +457,11 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dw_widget.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findtext.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gif.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/gtkframeset.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/history.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/html.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/i18n.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/i18n_gtk.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/image.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/interface.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/jpeg.Po@am__quote@
@@ -416,19 +469,24 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/menu.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/misc.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nav.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/pagemark.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/plain.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/png.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/prefs.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/progressbar.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/selection.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/strbuf.Po@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tab.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/url.Po@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/web.Po@am__quote@
 
+distclean-depend:
+	-rm -rf ./$(DEPDIR)
+
 .c.o:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `test -f '$<' || echo '$(srcdir)/'`$<; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
+@am__fastdepCC_TRUE@	then mv "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
 @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; \
 @am__fastdepCC_TRUE@	fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
@@ -439,7 +497,7 @@
 .c.obj:
 @am__fastdepCC_TRUE@	if $(COMPILE) -MT $@ -MD -MP -MF "$(DEPDIR)/$*.Tpo" \
 @am__fastdepCC_TRUE@	  -c -o $@ `if test -f '$<'; then $(CYGPATH_W) '$<'; else $(CYGPATH_W) '$(srcdir)/$<'; fi`; \
-@am__fastdepCC_TRUE@	then mv -f "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
+@am__fastdepCC_TRUE@	then mv "$(DEPDIR)/$*.Tpo" "$(DEPDIR)/$*.Po"; \
 @am__fastdepCC_TRUE@	else rm -f "$(DEPDIR)/$*.Tpo"; exit 1; \
 @am__fastdepCC_TRUE@	fi
 @AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
@@ -528,15 +586,9 @@
 		$(TAGS_FILES) $(LISP)
 	tags=; \
 	here=`pwd`; \
-	if (etags --etags-include --version) >/dev/null 2>&1; then \
-	  include_option=--etags-include; \
-	else \
-	  include_option=--include; \
-	fi; \
 	list='$(SUBDIRS)'; for subdir in $$list; do \
 	  if test "$$subdir" = .; then :; else \
-	    test -f $$subdir/TAGS && \
-	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	    test -f $$subdir/TAGS && tags="$$tags -i $$here/$$subdir/TAGS"; \
 	  fi; \
 	done; \
 	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
@@ -642,7 +694,7 @@
 clean-generic:
 
 distclean-generic:
-	-rm -f $(CONFIG_CLEAN_FILES)
+	-rm -f Makefile $(CONFIG_CLEAN_FILES)
 
 maintainer-clean-generic:
 	@echo "This command is intended for maintainers to use"
@@ -652,11 +704,9 @@
 clean-am: clean-binPROGRAMS clean-generic mostlyclean-am
 
 distclean: distclean-recursive
-	-rm -rf ./$(DEPDIR)
 
-	-rm -f Makefile
-distclean-am: clean-am distclean-compile distclean-generic \
-	distclean-tags
+distclean-am: clean-am distclean-compile distclean-depend \
+	distclean-generic distclean-tags
 
 dvi: dvi-recursive
 
@@ -677,9 +727,7 @@
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
-	-rm -rf ./$(DEPDIR)
 
-	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
 mostlyclean: mostlyclean-recursive
@@ -700,10 +748,10 @@
 
 .PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am check check-am clean \
 	clean-binPROGRAMS clean-generic clean-recursive ctags \
-	ctags-recursive distclean distclean-compile distclean-generic \
-	distclean-recursive distclean-tags distdir dvi dvi-am \
-	dvi-recursive info info-am info-recursive install install-am \
-	install-binPROGRAMS install-data install-data-am \
+	ctags-recursive distclean distclean-compile distclean-depend \
+	distclean-generic distclean-recursive distclean-tags distdir \
+	dvi dvi-am dvi-recursive info info-am info-recursive install \
+	install-am install-binPROGRAMS install-data install-data-am \
 	install-data-recursive install-exec install-exec-am \
 	install-exec-recursive install-info install-info-am \
 	install-info-recursive install-man install-recursive \
diff -Nur dillo-0.8.0/src/menu.c dillo-0.8.0.new/src/menu.c
--- dillo-0.8.0/src/menu.c	2004-02-03 19:03:11.000000000 +0000
+++ dillo-0.8.0.new/src/menu.c	2004-10-13 01:13:29.000000000 +0000
@@ -20,31 +20,69 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include <config.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <gtk/gtk.h>
 #include <gdk/gdkkeysyms.h>
+#include "intl.h"
+#include "i18n.h"
+#include "i18n_gtk.h"
 #include "history.h"
 #include "nav.h"
 #include "commands.h"
-#include "dw_gtk_scrolled_window.h"
-#include "dw_page.h"         /* for a_Dw_page_add_anchor */
 #include "bookmark.h"
 #include "interface.h"
 #include "menu.h"
 #include "selection.h"
+#include "prefs.h"
 
+/* NOTE: default charset is DW_CHARSET */
+
+/* CALLBACKS */
 /*
- * Forward declarations
+ * Called when the user selects "Copy Link Location" in the link menu.
  */
-static void Menu_pagemarks_goto_pagemark(GtkWidget *widget,
-                                         gpointer client_data);
+void a_Menu_popup_select_url_callback(GtkWidget *widget, gpointer client_data)
+{
+   BrowserWindow *bw = (BrowserWindow *)client_data;
+   a_Selection_set_selection(widget, URL_STR(a_Menu_popup_get_url(bw)));
+}
+
+/*
+ * Put the url in the status bar when moving cursor over menuitem.
+ */
+static void
+Menu_popup_history_select_callback(GtkWidget *widget, gpointer data)
+{
+   gint idx;
+   BrowserWindow *bw = data;
+
+   idx = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT (widget), "nav_idx"));
+   if (idx >= 0 && idx < a_Nav_stack_size(bw->dd)) {
+      a_Interface_msg(bw, "%s", URL_STR_(a_History_get_url(NAV_IDX(bw->dd,idx))));
+      bw->status_is_link = 1;
+   }
+}
+
+/*
+ * Remove the url in the status bar when removing cursor from menuitem.
+ */
+static void
+Menu_popup_history_deselect_callback(GtkWidget *widget, gpointer data) {
+   BrowserWindow *bw = data;
+
+   a_Interface_msg(bw, "");
+}
+
+/* PRIVATE FUNCTIONS */
 
 /*
  * Make a new menu, insert it into the menu bar, and return it.
  */
-static GtkWidget* Menu_new(GtkWidget *menubar, const char *name,
+static GtkWidget *
+Menu_new(GtkWidget *menubar, const char *name,
                            gboolean right_justify, BrowserWindow *bw)
 {
    GtkWidget *menu;
@@ -85,7 +123,7 @@
  * implemented), and a callback function for activation.
  */
 static GtkWidget *
- Menu_add (GtkWidget *menu, const char *name, const char *accel,
+Menu_add (GtkWidget *menu, const char *name, const char *accel,
            BrowserWindow *bw,
            void (*callback) (GtkWidget *widget, void *data), void *data)
 {
@@ -130,6 +168,8 @@
    gtk_widget_show(widget);
 }
 
+/* PUBLIC FUNCTIONS */
+
 /*
  * Make up a new menubar for a main browser window. The accelerator table
  * is stored in bw->accel_group.
@@ -140,31 +180,54 @@
 {
    GtkWidget *menubar;
    GtkWidget *file_menu;
+   GtkWidget *view_menu;
+
    /* GtkWidget *help_menu; */
 
    bw->menubar = menubar = gtk_menu_bar_new();
 
    /* FILE MENU */
-   file_menu = Menu_new(menubar, tiny ? "_F" : "_File", FALSE, bw);
-   Menu_add(file_menu, "_New Browser", "<ctrl>N", bw,
+   file_menu = Menu_new(menubar, tiny ? "_F" : _("_File"), FALSE, bw);
+   Menu_add(file_menu, _("_New Window"), "<ctrl>N", bw,
             a_Commands_new_callback, bw);
-   Menu_add(file_menu, "_Open File...", "<ctrl>O", bw,
+#ifndef DISABLE_TABS
+   Menu_add(file_menu, _("New _Tab"), "<ctrl>T", bw,
+            a_Commands_new_tab_callback, bw);
+   Menu_sep(file_menu);
+#endif /* !DISABLE_TABS */
+   Menu_add(file_menu, _("_Open File..."), "<ctrl>O", bw,
             a_Commands_openfile_callback, bw);
-   Menu_add(file_menu, "Open _URL...", "<ctrl>L", bw,
+   Menu_add(file_menu, _("Open _URL..."), "<ctrl>L", bw,
             a_Commands_openurl_callback, bw);
    /*
-   Menu_add(file_menu, "_Preferences", "<ctrl>E", bw,
+   Menu_add(file_menu, _("_Preferences"), "<ctrl>E", bw,
             a_Commands_prefs_callback, bw);
    */
-   Menu_add(file_menu, "Close Window", "<ctrl>Q", bw,
+   Menu_add(file_menu, _("Close Window"), "<ctrl>Q", bw,
             a_Commands_close_callback, bw);
+#ifndef DISABLE_TABS
+   Menu_add(file_menu, _("Close Tab"), "<ctrl>W", bw,
+            a_Commands_close_current_tab_callback, bw);
+#endif /* !DISABLE_TABS */
    Menu_sep(file_menu);
-   Menu_add(file_menu, "Exit Dillo", "<alt>Q", bw,
+   Menu_add(file_menu, _("Exit Dillo"), "<alt>Q", bw,
             a_Commands_exit_callback, bw);
 
+   /* VIEW MENU */
+   view_menu = Menu_new(menubar, tiny? "_V" : _("_View"), FALSE, bw);
+#ifndef DISABLE_TABS
+   Menu_add(view_menu, _("Previous tab"), "<ctrl>comma", bw,
+            a_Commands_tab_prev_callback, bw);
+   Menu_add(view_menu, _("Next tab"), "<ctrl>period", bw,
+            a_Commands_tab_next_callback, bw);
+   Menu_sep(view_menu);
+#endif /* !DISABLE_TABS */
+   Menu_add(view_menu, _("_Options..."), NULL, bw,
+            a_Commands_prefs_callback, bw);
+
    /* HELP MENU
-   help_menu = Menu_new(menubar, "_Help", TRUE, bw);
-   Menu_add(help_menu, "Dillo _Home", NULL, bw,
+   help_menu = Menu_new(menubar, _("_Help"), TRUE, bw);
+   Menu_add(help_menu, _("Dillo _Home"), NULL, bw,
             a_Commands_helphome_callback, bw);
    */
    return menubar;
@@ -179,138 +242,117 @@
 
    menu = gtk_menu_new();
    Menu_sep(menu);
-   Menu_add(menu, "       PAGE OPTIONS", NULL, bw, NULL, NULL);
-   Menu_sep(menu);
-   Menu_add(menu, "View page Source", NULL, bw,
+   //Menu_add(menu, _("       PAGE OPTIONS"), NULL, bw, NULL, NULL);
+   //Menu_sep(menu);
+   if(prefs.show_popup_navigation) {
+     bw->back_op_menu_button = Menu_add(menu, _("Back"), NULL, bw,
+					a_Commands_back_callback, bw);
+     bw->forw_op_menu_button = Menu_add(menu, _("Forward"), NULL, bw,
+					a_Commands_forw_callback, bw);
+     bw->stop_op_menu_button = Menu_add(menu, _("Stop"), NULL, bw,
+					a_Commands_stop_callback, bw);
+     Menu_add(menu, _("_Reload"), "<ctrl>r", bw,
+	      a_Commands_reload_callback, bw);
+     Menu_sep(menu);
+   }
+   Menu_add(menu, _("View page So_urce"), NULL, bw,
             a_Commands_viewsource_callback, bw);
-   bw->viewbugs_menuitem = Menu_add(menu, "View page Bugs", NULL,bw, NULL,bw);
-
-   Menu_add(menu, "Bookmark this page", NULL, bw,
+   bw->viewbugs_menuitem = Menu_add(menu, _("View page Bugs"), NULL,bw, NULL,bw);
+   Menu_add(menu, _("_Bookmark this Page"), NULL, bw,
             a_Commands_addbm_callback, bw);
    Menu_sep(menu);
-   Menu_add(menu, "_Find Text", "<ctrl>F", bw,
+   Menu_add(menu, _("Duplicate this Page"), "<alt>n", bw,
+            a_Commands_duplicate_callback, bw);
+#ifndef DISABLE_TABS
+   Menu_add(menu, _("Duplicate this tab"), "<alt>t", bw,
+            a_Commands_duplicate_tab_callback, bw);
+#endif /* !DISABLE_TABS */
+   Menu_sep(menu);
+   Menu_add(menu, _("_Find Text"), "<ctrl>F", bw,
             a_Commands_findtext_callback, bw);
 
-   bw->pagemarks_menuitem = Menu_add(menu, "Jump to...", NULL, bw, NULL, bw);
+   bw->pagemarks_menuitem = Menu_add(menu, _("Jump to..."), NULL, bw, NULL, NULL);
+#ifndef XHTML_DTD_STRICT
+   bw->frame_menuitem = Menu_add(menu, _("This Frame..."), NULL, bw, NULL, NULL);
+   bw->frameset_menuitem = Menu_add(menu, _("This Frameset..."), NULL, bw, NULL, NULL);
+#endif /* !XHTML_DTD_STRICT */
 
    Menu_sep(menu);
-   Menu_add(menu, "Save page As...", NULL, bw,
+   Menu_add(menu, _("Save Page As..."), "<ctrl>s", bw,
             a_Commands_save_callback, bw);
 
    return menu;
 }
 
+#ifndef XHTML_DTD_STRICT
 /*
- * Set the popup's primary DilloUrl
+ * Make a new frame menu and return it
  */
-void a_Menu_popup_set_url(BrowserWindow *bw, DilloUrl *url)
+GtkWidget *a_Menu_popup_of_new(DilloDoc *dd)
 {
-   if (bw->menu_popup.url)
-      a_Url_free(bw->menu_popup.url);
-   bw->menu_popup.url = a_Url_dup(url);
-}
-
-/*
- * Set the popup's secondary DilloUrl
- * Note: this URL is used by the image submenu of the link popup.
- * (If the need arises, this can be extended using an URL array in the popup
- * structure, and by setting the to-be-picked-URL-index in the popup)
- */
-void a_Menu_popup_set_url2(BrowserWindow *bw, DilloUrl *url)
-{
-   if (bw->menu_popup.url2)
-      a_Url_free(bw->menu_popup.url2);
-   bw->menu_popup.url2 = a_Url_dup(url);
-}
-
-/*
- * Get the popup's DilloUrl
- */
-DilloUrl *a_Menu_popup_get_url(BrowserWindow *bw)
-{
-   return bw->menu_popup.url;
-}
-
-/*
- * Put the url in the status bar when moving cursor over menuitem.
- */
-static void
-Menu_popup_history_select_callback(GtkWidget *widget, gpointer data)
-{
-   gint idx;
-   BrowserWindow *bw = data;
-
-   idx = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT (widget), "nav_idx"));
-   if (idx >= 0 && idx < a_Nav_stack_size(bw)) {
-      a_Interface_msg(bw, "%s", URL_STR_(a_History_get_url(NAV_IDX(bw,idx))));
-      bw->status_is_link = 1;
-   }
-}
-
-/*
- * Remove the url in the status bar when removing cursor from menuitem.
- */
-static void
-Menu_popup_history_deselect_callback(GtkWidget *widget, gpointer data) {
-   BrowserWindow *bw = data;
-
-   a_Interface_msg(bw, "");
-}
-
-/*
- * Make a new popup menu for history browsing
- * direction: {backward = -1, forward = 1}
- */
-GtkWidget *a_Menu_popup_history_new(BrowserWindow *bw, gint direction)
-{
-   int i;
-   GtkWidget *menu, *menu_item;
-   GString *text = g_string_sized_new(128);
-
-   menu = gtk_menu_new();
-   Menu_sep(menu);
-   if (direction>0) {
-      Menu_add(menu, "     FOLLOWING PAGES     ", NULL, bw, NULL, NULL);
-      i = a_Nav_stack_ptr(bw) + 1;
-   } else {
-      Menu_add(menu, "     PREVIOUS PAGES     ", NULL, bw, NULL, NULL);
-      i = a_Nav_stack_ptr(bw) - 1;
-   }
-   Menu_sep(menu);
+  GtkWidget *menu;
 
-   for ( ; i >= 0 && i < a_Nav_stack_size(bw); i+=direction ) {
-      if (a_History_get_title(NAV_IDX(bw,i))) {
-         g_string_assign(text, a_History_get_title(NAV_IDX(bw,i)));
-      } else {
-         g_string_assign(text, URL_STR(a_History_get_url(NAV_IDX(bw,i))));
-      }
-      if ( text->len > 64 ) {
-         g_string_truncate(text, 64);
-         g_string_append(text, "...");
-      }
-      menu_item = Menu_add(menu, text->str, NULL, bw, NULL, NULL);
-      /* attach the nav_stack index to the menu item */
-      gtk_object_set_data(GTK_OBJECT (menu_item), "nav_idx",
-                          GINT_TO_POINTER(i));
+  menu = gtk_menu_new();
+  Menu_sep(menu);
+  //Menu_add(menu, _("    FRAME OPTIONS"), NULL, dd->bw, NULL, NULL);
+  //Menu_sep(menu);
+  Menu_add(menu, _("View frame Source"), NULL, dd->bw,
+	   a_Commands_viewsource_doc_callback, dd);
+  Menu_add(menu, _("Bookmark this Frame"), NULL, dd->bw,
+	   a_Commands_addbm_doc_callback, dd);
+  Menu_add(menu, _("Reload this Frame"), NULL, dd->bw,
+	   a_Commands_reload_doc_callback, dd);
+  Menu_sep(menu);
+  Menu_add(menu, _("Show only this Frame"), NULL, dd->bw,
+	   a_Commands_showonly_doc_callback, dd);
+  Menu_add(menu, _("Open Frame in new Window"), NULL, dd->bw,
+	   a_Commands_open_link_nw_callback, dd->bw);
+#ifndef DISABLE_TABS
+  Menu_add(menu, _("Open Frame in new Tab"), NULL, dd->bw,
+	   a_Commands_open_link_nw_tab_callback, dd->bw);
+#endif /* !DISABLE_TABS */
+  Menu_sep(menu);
+  Menu_add(menu, _("_Find Text in this Frame..."), NULL, dd->bw,
+	   a_Commands_findtext_doc_callback, dd);
+  Menu_sep(menu);
+  Menu_add(menu, _("Save Frame As..."), NULL, dd->bw,
+	   a_Commands_save_doc_callback, dd);
+  
+  return menu;
+}
+
+/*
+ * Make a new frameset menu and return it
+ *
+ */
+GtkWidget *a_Menu_popup_ofs_new(DilloDoc *dd)
+{
+  GtkWidget *frameset_menu;
+
+  frameset_menu = gtk_menu_new();
+  Menu_sep(frameset_menu);
+  //Menu_add(frameset_menu, _("    FRAMESET OPTIONS"), NULL, dd->bw, NULL, NULL);
+  //Menu_sep(frameset_menu);
+  Menu_add(frameset_menu, _("View Frameset Source"), NULL, dd->bw,
+	   a_Commands_viewsource_doc_callback, dd->parent);
+  Menu_add(frameset_menu, _("Bookmark this Frameset"), NULL, dd->bw,
+	   a_Commands_addbm_doc_callback, dd->parent);
+  Menu_add(frameset_menu, _("Reload this Frameset"), NULL, dd->bw,
+	   a_Commands_reload_doc_callback, dd->parent);
+  Menu_sep(frameset_menu);
+  Menu_add(frameset_menu, _("Show only this Frameset"), NULL, dd->bw,
+	   a_Commands_showonly_doc_callback, dd->parent);
+  Menu_sep(frameset_menu);
+  Menu_add(frameset_menu, _("_Find Text in this Frameset..."), NULL, dd->bw,
+	   a_Commands_findtext_doc_callback, dd->parent);
+  Menu_sep(frameset_menu);
+  Menu_add(frameset_menu, _("Save Frame As..."), NULL, dd->bw,
+	   a_Commands_save_doc_callback, dd->parent);
 
-      gtk_signal_connect (
-         GTK_OBJECT (menu_item), "select",
-         GTK_SIGNAL_FUNC (a_Interface_scroll_popup), NULL);
-      gtk_signal_connect (
-         GTK_OBJECT (menu_item), "select",
-         GTK_SIGNAL_FUNC (Menu_popup_history_select_callback), bw);
-      gtk_signal_connect (
-         GTK_OBJECT (menu_item), "deselect",
-         GTK_SIGNAL_FUNC (Menu_popup_history_deselect_callback), bw);
-      gtk_signal_connect (
-         GTK_OBJECT (menu_item), "button-press-event",
-         GTK_SIGNAL_FUNC (a_Commands_historypress_callback), bw);
-   }
-
-   g_string_free(text, TRUE);
-   return menu;
+  return frameset_menu;
 }
 
+#endif /* !XHTML_DTD_STRICT */
 /*
  * Make a new popup menu for when the mouse is over a link.
  */
@@ -322,23 +364,29 @@
 
    menu = gtk_menu_new();
    Menu_sep(menu);
-   Menu_add(menu, "       LINK OPTIONS", NULL, bw, NULL, NULL);
-   Menu_sep(menu);
-   Menu_add(menu, "Open Link in New Window", NULL, bw,
+   //Menu_add(menu, _("       LINK OPTIONS"), NULL, bw, NULL, NULL);
+   //Menu_sep(menu);
+   Menu_add(menu, _("Open Link in New Window"), NULL, bw,
             a_Commands_open_link_nw_callback, bw);
-   Menu_add(menu, "Bookmark this Link", NULL, bw,
-            a_Commands_addbm_callback, bw);
-
-   copy = Menu_add(menu, "Copy Link location", NULL, bw,
-                   a_Commands_select_popup_url_callback, bw);
+#ifndef DISABLE_TABS
+   Menu_add(menu, _("Open Link in New Tab"), NULL, bw,
+            a_Commands_open_link_nw_tab_callback, bw);
+#endif /* !DISABLE_TABS */
+   Menu_add(menu, _("Open Link"), NULL, bw,
+            a_Commands_open_link_callback, bw);
+   Menu_sep(menu);
+   Menu_add(menu, _("Bookmark this Link"), NULL, bw,
+            a_Commands_addbm_link_callback, bw);
+   copy = Menu_add(menu, _("Copy Link location"), NULL, bw,
+                   a_Menu_popup_select_url_callback, bw);
    a_Selection_init_selection(copy);
 
    Menu_sep(menu);
-   Menu_add(menu, "Save Link As...", NULL, bw,
+   Menu_add(menu, _("Save Link As..."), NULL, bw,
             a_Commands_save_link_callback, bw);
 
    Menu_sep(menu);
-   menuitem = Menu_add(menu, "Image Menu...", NULL, bw, NULL, bw);
+   menuitem = Menu_add(menu, _("Image Menu..."), NULL, bw, NULL, bw);
    gtk_menu_item_set_submenu(GTK_MENU_ITEM(menuitem),
                              bw->menu_popup.over_image);
    bw->menu_popup.ol_oi_submenu = menuitem;
@@ -356,20 +404,25 @@
 
    menu = gtk_menu_new();
    Menu_sep(menu);
-   Menu_add(menu, "       IMAGE OPTIONS", NULL, bw, NULL, NULL);
-   Menu_sep(menu);
-   Menu_add(menu, "Isolate Image", NULL, bw,
-            a_Commands_open_link_callback, bw);
-   Menu_add(menu, "Open Image in New Window", NULL, bw,
+   //Menu_add(menu, _("       IMAGE OPTIONS"), NULL, bw, NULL, NULL);
+   //Menu_sep(menu);
+   Menu_add(menu, _("Open Image in New Window"), NULL, bw,
             a_Commands_open_link_nw_callback, bw);
-   Menu_add(menu, "Bookmark this Image", NULL, bw,
-            a_Commands_addbm_callback, bw);
-   copy = Menu_add(menu, "Copy Image location", NULL, bw,
-                   a_Commands_select_popup_url_callback, bw);
+#ifndef DISABLE_TABS
+   Menu_add(menu, _("Open Image in New Tab"), NULL, bw,
+            a_Commands_open_link_nw_tab_callback, bw);
+#endif /* !DISABLE_TABS */
+   Menu_add(menu, _("Open Image"), NULL, bw,
+           a_Commands_open_link_callback, bw);
+   Menu_sep(menu);
+   Menu_add(menu, _("Bookmark this Image"), NULL, bw,
+            a_Commands_addbm_link_callback, bw);
+   copy = Menu_add(menu, _("Copy Image location"), NULL, bw,
+                   a_Menu_popup_select_url_callback, bw);
    a_Selection_init_selection(copy);
 
    Menu_sep(menu);
-   Menu_add(menu, "Save Image As...", NULL, bw,
+   Menu_add(menu, _("Save Image As..."), NULL, bw,
             a_Commands_save_link_callback, bw);
    return menu;
 }
@@ -383,14 +436,14 @@
 
    menu = gtk_menu_new();
    Menu_sep(menu);
-   Menu_add(menu, "    BUG METER OPTIONS", NULL, bw, NULL, NULL);
+   Menu_add(menu, _("    BUG METER OPTIONS"), NULL, bw, NULL, NULL);
    Menu_sep(menu);
-   Menu_add(menu, "Validate URL with W3C", NULL, bw,
+   Menu_add(menu, _("Validate URL with W3C"), NULL, bw,
             a_Commands_ob_w3c_callback, bw);
-   Menu_add(menu, "Validate URL with WDG", NULL, bw,
+   Menu_add(menu, _("Validate URL with WDG"), NULL, bw,
             a_Commands_ob_wdg_callback, bw);
    Menu_sep(menu);
-   Menu_add(menu, "About Bug Meter...", NULL, bw,
+   Menu_add(menu, _("About Bug Meter..."), NULL, bw,
             a_Commands_ob_info_callback, bw);
    return menu;
 }
@@ -407,82 +460,119 @@
 }
 
 /*
- * Functions to manipulate Pagemarks menu.
- * Should this be in a separate "pagemark.c" ?
+ * Make a new popup menu for history browsing
+ * direction: {backward = -1, forward = 1}
  */
+GtkWidget *a_Menu_popup_history_new(BrowserWindow *bw, gint direction)
+{
+   int i;
+   GtkWidget *menu, *menu_item;
+   GString *text = g_string_sized_new(128);
+   gchar *text_enc;
+
+   menu = gtk_menu_new();
+   Menu_sep(menu);
+   if (direction>0) {
+      //Menu_add(menu, _("     FOLLOWING PAGES     "), NULL, bw, NULL, NULL);
+      i = a_Nav_stack_ptr(bw->dd) + 1;
+   } else {
+      //Menu_add(menu, _("     PREVIOUS PAGES     "), NULL, bw, NULL, NULL);
+      i = a_Nav_stack_ptr(bw->dd) - 1;
+   }
+   //Menu_sep(menu);
 
+   for ( ; i >= 0 && i < a_Nav_stack_size(bw->dd); i+=direction ) {
+      if (a_History_get_title(NAV_IDX(bw->dd,i))) {
+         g_string_assign(text, a_History_get_title(NAV_IDX(bw->dd,i)));
+      } else {
+         g_string_assign(text, URL_STR(a_History_get_url(NAV_IDX(bw->dd,i))));
+      }
+      if ( text->len > 64 ) {
+		 int max_len = 64;
+		 while (IS_UTF8_NON_FIRST_CHAR(text->str[max_len - 1]))
+			 max_len--;
+		 if (IS_UTF8_FIRST_CHAR(text->str[max_len - 1]))
+			 max_len--;
+         g_string_truncate(text, max_len);
+         g_string_append(text, "...");
+      }
+	  text_enc = a_I18n_DW_CHARSET_from_DILLO_CHARSET(text->str, text->len);
+      menu_item = Menu_add(menu, text_enc, NULL, bw, NULL, NULL);
+	  g_free(text_enc);
+      /* attach the nav_stack index to the menu item */
+      gtk_object_set_data(GTK_OBJECT (menu_item), "nav_idx",
+                          GINT_TO_POINTER(i));
+
+      gtk_signal_connect (
+         GTK_OBJECT (menu_item), "select",
+         GTK_SIGNAL_FUNC (a_Interface_scroll_popup), NULL);
+      gtk_signal_connect (
+         GTK_OBJECT (menu_item), "select",
+         GTK_SIGNAL_FUNC (Menu_popup_history_select_callback), bw);
+      gtk_signal_connect (
+         GTK_OBJECT (menu_item), "deselect",
+         GTK_SIGNAL_FUNC (Menu_popup_history_deselect_callback), bw);
+      gtk_signal_connect (
+         GTK_OBJECT (menu_item), "button-press-event",
+         GTK_SIGNAL_FUNC (a_Commands_historypress_callback), bw);
+   }
+
+   g_string_free(text, TRUE);
+   return menu;
+}
+
+#ifndef DISABLE_TABS
 /*
- * make the page scroll to the pagemark
+ * Make a new popup menu for when the mouse is over a tab
  */
-static void Menu_pagemarks_goto_pagemark(GtkWidget *widget,
-                                         gpointer client_data)
+GtkWidget *a_Menu_popup_tab_new(DilloDoc *dd)
 {
-   BrowserWindow *bw = (BrowserWindow *) client_data;
-   char anchor[32];
+   GtkWidget *menu;
 
-   g_snprintf (anchor, 32, "#%ld", (long int)widget);
-   a_Dw_gtk_scrolled_window_set_anchor(GTK_DW_SCROLLED_WINDOW(bw->docwin),
-                                       anchor);
+   menu = gtk_menu_new();
+   Menu_sep(menu);
+   //Menu_add(menu, _("TAB OPTIONS"), NULL, dd->bw, NULL, NULL);
+   //Menu_sep(menu);
+   Menu_add(menu, _("Close Tab"), NULL, dd->bw,
+            a_Commands_close_tab_callback, dd);
+   Menu_add(menu, _("New Tab"), NULL, dd->bw,
+            a_Commands_new_tab_callback, dd->bw);
+   Menu_add(menu, _("Reload Tab"), NULL, dd->bw,
+            a_Commands_reload_doc_callback, dd);
+   return menu;
 }
 
+#endif /* !DISABLE_TABS */
+
 /*
- * Deallocate the memory used by a pagemarks menu and create a new one
+ * Set the popup's primary DilloUrl
  */
-void a_Menu_pagemarks_new(BrowserWindow *bw)
+void a_Menu_popup_set_url(BrowserWindow *bw, DilloUrl *url)
 {
-   gtk_widget_set_sensitive(bw->pagemarks_menuitem, FALSE);
-
-   if (bw->pagemarks_menu)
-      gtk_widget_destroy(bw->pagemarks_menu);
-   bw->pagemarks_menu = gtk_menu_new();
-   bw->pagemarks_last = NULL;
-
-   gtk_menu_item_set_submenu(GTK_MENU_ITEM(bw->pagemarks_menuitem),
-                             bw->pagemarks_menu);
+   if (bw->menu_popup.url)
+      a_Url_free(bw->menu_popup.url);
+   bw->menu_popup.url = a_Url_dup(url);
 }
 
 /*
- * Add a new pagemark (opening H tag).
- * The text can be set only at the closing H tag.
- * level is the level of the heading (1-6).
+ * Set the popup's secondary DilloUrl
+ * Note: this URL is used by the image submenu of the link popup.
+ * (If the need arises, this can be extended using an URL array in the popup
+ * structure, and by setting the to-be-picked-URL-index in the popup)
  */
-void a_Menu_pagemarks_add(BrowserWindow *bw, void *page, void *style,
-                          gint level)
+void a_Menu_popup_set_url2(BrowserWindow *bw, DilloUrl *url)
 {
-   char anchor[32], spaces[32], name[32];
-
-   gtk_widget_set_sensitive(bw->pagemarks_menuitem, TRUE);
-   g_snprintf(spaces, 32, "%*s", 3 * (level - 1), "");
-   bw->pagemarks_last = Menu_add(bw->pagemarks_menu, spaces, NULL, bw,
-                                 Menu_pagemarks_goto_pagemark, bw);
-   g_snprintf(anchor, 32, "#%ld", (glong)(bw->pagemarks_last));
-   a_Dw_page_add_anchor(page, anchor, style);
-   gtk_signal_connect (GTK_OBJECT (bw->pagemarks_last), "select",
-                       GTK_SIGNAL_FUNC (a_Interface_scroll_popup), NULL);
-   g_snprintf(name, 32, "dilloHeading%d", level);
-   gtk_widget_set_name(bw->pagemarks_last, name);
+   if (bw->menu_popup.url2)
+      a_Url_free(bw->menu_popup.url2);
+   bw->menu_popup.url2 = a_Url_dup(url);
 }
 
+
 /*
- * Set the text for the last created pagemark.
+ * Get the popup's DilloUrl
  */
-void a_Menu_pagemarks_set_text(BrowserWindow *bw, const char *str)
+DilloUrl *a_Menu_popup_get_url(BrowserWindow *bw)
 {
-   GString *text;
-   GtkWidget *child;
-
-   /* Avoid problems with lonely closing tags and nested headings */
-   if ( bw->pagemarks_last &&
-       (child = GTK_BIN (bw->pagemarks_last)->child) &&
-       GTK_IS_LABEL (child) ) {
-      text = g_string_new(GTK_LABEL(child)->label);
-      g_string_append(text, str);
-      if ( text->len > 64 ) {
-         g_string_truncate(text, 64);
-         g_string_append(text, "...");
-      }
-      gtk_label_set_text(GTK_LABEL (child), text->str);
-      g_string_free(text, 1);
-      bw->pagemarks_last = NULL;
-   }
+   return bw->menu_popup.url;
 }
+
diff -Nur dillo-0.8.0/src/menu.h dillo-0.8.0.new/src/menu.h
--- dillo-0.8.0/src/menu.h	2004-01-22 20:24:59.000000000 +0000
+++ dillo-0.8.0.new/src/menu.h	2004-10-13 01:13:29.000000000 +0000
@@ -8,16 +8,18 @@
 GtkWidget *a_Menu_popup_ol_new (BrowserWindow *bw);
 GtkWidget *a_Menu_popup_oi_new (BrowserWindow *bw);
 GtkWidget *a_Menu_popup_ob_new (BrowserWindow *bw);
+#ifndef DISABLE_FRAMES
+GtkWidget *a_Menu_popup_of_new (DilloDoc *dd);
+GtkWidget *a_Menu_popup_ofs_new (DilloDoc *dd);
+#endif /* !DISABLE_FRAMES */
 GtkWidget *a_Menu_popup_history_new(BrowserWindow *bw, gint direction);
+#ifndef DISABLE_TABS
+GtkWidget *a_Menu_popup_tab_new(DilloDoc *dd);
+#endif
 void a_Menu_popup_ol_show_oi(BrowserWindow *bw, gboolean show);
 void a_Menu_popup_set_url(BrowserWindow *bw, DilloUrl *url);
 void a_Menu_popup_set_url2(BrowserWindow *bw, DilloUrl *url);
 DilloUrl *a_Menu_popup_get_url(BrowserWindow *bw);
 
-void a_Menu_pagemarks_new (BrowserWindow *bw);
-void a_Menu_pagemarks_destroy (BrowserWindow *bw);
-void a_Menu_pagemarks_add(BrowserWindow *bw, void *page, void *style,
-                          gint level);
-void a_Menu_pagemarks_set_text(BrowserWindow *bw, const char *str);
 
 #endif /* MENU_H */
diff -Nur dillo-0.8.0/src/misc.c dillo-0.8.0.new/src/misc.c
--- dillo-0.8.0/src/misc.c	2003-12-13 14:53:55.000000000 +0000
+++ dillo-0.8.0.new/src/misc.c	2004-10-13 01:13:29.000000000 +0000
@@ -10,6 +10,7 @@
  * (at your option) any later version.
  */
 
+#include <config.h>
 #include <gtk/gtk.h>
 
 #include <stdio.h>
@@ -18,8 +19,12 @@
 #include <string.h>
 #include <ctype.h>
 
+#include "intl.h"
 #include "msg.h"
 #include "misc.h"
+#include "prefs.h"
+#include "i18n.h"
+
 
 /*
  * Prepend the users home-dir to 'file' string i.e,
@@ -296,3 +301,174 @@
    return ret;
 }
 
+/*
+ * check invalid string, and repair.
+ */
+gchar *a_Misc_string_check(const gchar *input, const gchar *charset)
+{
+   gint i, len;
+   gchar *ret, *str;
+   GString *out = g_string_new("");
+   
+   /* invalid char will be replaced to white square. */
+   str = a_I18n_convert(charset, charset, input, -1);
+   len = strlen(str);
+
+   /* skip white square. */
+   for(i = 0; i < len; i++) {
+      if((unsigned char)str[i] == '[' 
+              && (unsigned char)str[i+1] == ']') {
+		  i++;
+      } else g_string_append_c(out, str[i]);
+   }
+   g_free(str);
+   ret = out->str;
+   g_string_free(out, FALSE);
+   return ret;
+}
+
+#ifndef DISABLE_TABS
+
+/*
+ * (adapted from Galeon's misc_string_shorten_name())
+ * try to shorten a string to target_length or less
+ * this is quite language-specific, ie. it will not work
+ * with non indo-european languages
+ *
+ * minimum returned string length is 1, even if target_length
+ * is set to a lower value
+ *
+ * caller has to free the returned string
+ */
+gchar *
+a_Misc_string_compress(const gchar *input, gint target_length)
+{
+   gint i, j, length;
+   gchar *name, **common_prefixes = prefs.compress_common_prefixes_vec;
+   gchar *shortened_name;
+   char c;
+
+   /* it does not make sense to compress a string into nothing... */
+   if (target_length < 1)
+     target_length = 1;
+   
+   if (input == NULL)
+     return (a_Misc_string_shorten(g_strdup(_("Untitled")),target_length));
+   
+   /* copy and clean name */
+   name = g_strdup (input);
+   g_strstrip (name);
+   length = strlen (name);
+
+   /* remove common prefixes from string */
+   if (common_prefixes)
+     for(i=0; common_prefixes[i]; ++i)
+       if(strncasecmp(name, common_prefixes[i],strlen(common_prefixes[i])) == 0) {
+         length -= strlen(common_prefixes[i]);
+         memmove(name, name + strlen(common_prefixes[i]), length + 1);
+       }
+
+   /* remove trailing whitespace, if any */
+   g_strchug(name);
+   
+   /* remove vowels from string */
+   for (i = length - 1, j = length - 1; i >= 0; i--) {
+     c = name[i];
+     /* keep the letter if the string is short enough
+      * already, if the letter is at the beginning of a
+      * word, or if it's not a lowercase vowel */
+     if (length <= target_length || i == 0 ||
+         (i > 0 && name[i - 1] == ' ') ||
+         /* prefs.compress_vowels contains those characters
+            that can be skipped without making a word totally
+            irrecognizable. In most languages, those are the
+            vowels (with and without accents) */
+         !strchr (prefs.compress_vowels, c))
+       {
+         name[j] = c;
+         j--;
+       }
+     else
+       {
+         length--;
+       }
+   }
+   /* shift */
+   memmove(name, name + j + 1, length + 1);
+
+   /* short enough yet? */
+   if (length <= target_length)
+     {
+       return name;
+     }
+
+   /* no - try chopping out whole words */
+   for (i = target_length; i > 0; i--) {
+     if (ispunct((int) name[i]) || isspace((int) name[i]))
+       {
+         while (ispunct((int) name[i]) || isspace((int) name[i]))
+           {
+             i--;
+           }
+         /* this will do */
+         name[i + 1] = '\0';
+         g_strchomp (name);
+         return name;
+       }
+   }
+
+   /* still too long - use shortening on the compressed string */
+   shortened_name = a_Misc_string_shorten(name, target_length);
+   g_free(name);
+   return shortened_name;
+}
+
+/*
+ * shorten a string to no more than target_length characters
+ * by replacing part of the middle of the string by
+ * three ellipsis ('...').
+ *
+ * minimum returned string length is 3, even if target_length
+ * is set to a lower value.
+ *
+ * caller must free returned string
+ */
+gchar *
+a_Misc_string_shorten(const gchar *input, gint target_length)
+{
+   gchar *output;
+   gint actual_length, first_length, second_length;
+   
+   if (!input) return NULL;
+   
+   /* target length can not be smaller than 3 */
+   if (target_length < 3)
+     target_length = 3;
+   
+   actual_length = strlen (input);
+   
+   /* if the string is already short enough, or if it's too short for
+    * us to shorten it, return a new copy */
+   if (actual_length <= target_length ||
+       actual_length <= 3)
+     return g_strdup (input);
+   
+   /* allocate new string */
+   output = g_new (gchar, target_length + 1);
+   
+   /* calc lengths to take from beginning and ending of input */
+   second_length = (target_length - 3) / 2;
+   if(second_length%2 != 0) second_length++;
+   first_length = target_length - 3 - second_length;
+   
+   /* create string */
+   strncpy (output, input, first_length);
+   strncpy (output + first_length, "...", 3);
+   strncpy (output + first_length + 3,
+            input + actual_length - second_length, second_length);
+   output[target_length] = '\0';
+   
+   return output;
+}
+
+#endif /* !DISABLE_TABS */
diff -Nur dillo-0.8.0/src/misc.h dillo-0.8.0.new/src/misc.h
--- dillo-0.8.0/src/misc.h	2003-12-13 14:29:56.000000000 +0000
+++ dillo-0.8.0.new/src/misc.h	2004-10-13 01:13:29.000000000 +0000
@@ -13,7 +13,11 @@
 gint *a_Misc_strsplitposdup(gint *pos);
 const gchar *a_Misc_get_content_type_from_data(void *Data, size_t Size);
 gint a_Misc_parse_geometry(gchar *geom, gint *x, gint *y, gint *w, gint *h);
-
+gchar *a_Misc_string_check(const gchar *input, const gchar *charset);
+#ifndef DISABLE_TABS
+gchar *a_Misc_string_compress(const gchar *input, gint target_length);
+gchar *a_Misc_string_shorten(const gchar *input, gint target_length);
+#endif /* !DISABLE_TABS */
 /* Return a NULL-terminated string containing the characters from p1 to p2. */
 #define a_Misc_strpdup(s, p1, p2) g_strndup((s) + (p1), (p2) - (p1))
 
diff -Nur dillo-0.8.0/src/nav.c dillo-0.8.0.new/src/nav.c
--- dillo-0.8.0/src/nav.c	2004-01-05 19:25:46.000000000 +0000
+++ dillo-0.8.0.new/src/nav.c	2004-10-13 01:13:29.000000000 +0000
@@ -12,50 +12,54 @@
 
 /* Support for a navigation stack */
 
+#include <config.h>
 #include <stdio.h>
 #include <gtk/gtk.h>
+#include "intl.h"
 #include "msg.h"
 #include "list.h"
 #include "nav.h"
 #include "history.h"
 #include "web.h"
+#include "doc.h"
 #include "menu.h"
+#include "pagemark.h"
 #include "interface.h"
 #include "dw_gtk_scrolled_window.h"
 #include "prefs.h"
 #include "commands.h"
 #include "capi.h"
 
-//#define DEBUG_LEVEL 3
+#define DEBUG_LEVEL 6
 #include "debug.h"
 
 /*
  * Forward declarations
  */
-static void Nav_reload(BrowserWindow *bw);
-void a_Nav_cancel_expect(BrowserWindow *bw);
+static void Nav_reload(DilloDoc *dd);
+void a_Nav_cancel_expect(DilloDoc *dd);
 
 
 /*
  * Initialize the navigation structure with safe values
  */
-void a_Nav_init(BrowserWindow *bw)
+void a_Nav_init(DilloDoc *dd)
 {
-   bw->nav_stack_size = 0;
-   bw->nav_stack_size_max = 16;
-   bw->nav_stack = NULL;
-   bw->nav_stack_ptr = -1;
-   bw->nav_expecting = FALSE;
-   bw->nav_expect_url = NULL;
+   dd->nav_stack_size = 0;
+   dd->nav_stack_size_max = 16;
+   dd->nav_stack = NULL;
+   dd->nav_stack_ptr = -1;
+   dd->nav_expecting = FALSE;
+   dd->nav_expect_url = NULL;
 }
 
 /*
  * Free memory used by this module
  */
-void a_Nav_free(BrowserWindow *bw)
+void a_Nav_free(DilloDoc *dd)
 {
-   a_Nav_cancel_expect(bw);
-   g_free(bw->nav_stack);
+   a_Nav_cancel_expect(dd);
+   g_free(dd->nav_stack);
 }
 
 
@@ -64,79 +68,79 @@
 /*
  * Return current nav_stack pointer [0 based; -1 = empty]
  */
-gint a_Nav_stack_ptr(BrowserWindow *bw)
+gint a_Nav_stack_ptr(DilloDoc *dd)
 {
-   return bw->nav_stack_ptr;
+   return dd->nav_stack_ptr;
 }
 
 /*
  * Move the nav_stack pointer
  */
-static void Nav_stack_move_ptr(BrowserWindow *bw, gint offset)
+static void Nav_stack_move_ptr(DilloDoc *dd, gint offset)
 {
    gint nptr;
 
-   g_return_if_fail (bw != NULL);
+   g_return_if_fail (dd != NULL);
    if (offset != 0) {
-      nptr = bw->nav_stack_ptr + offset;
-      g_return_if_fail (nptr >= 0 && nptr < bw->nav_stack_size);
-      bw->nav_stack_ptr = nptr;
+      nptr = dd->nav_stack_ptr + offset;
+      g_return_if_fail (nptr >= 0 && nptr < dd->nav_stack_size);
+      dd->nav_stack_ptr = nptr;
    }
 }
 
 /*
  * Return size of nav_stack [1 based]
  */
-gint a_Nav_stack_size(BrowserWindow *bw)
+gint a_Nav_stack_size(DilloDoc *dd)
 {
-   return bw->nav_stack_size;
+   return dd->nav_stack_size;
 }
 
 /*
  * Add an URL-index in the navigation stack.
  */
-static void Nav_stack_add(BrowserWindow *bw, gint idx)
+static void Nav_stack_add(DilloDoc *dd, gint idx)
 {
-   g_return_if_fail (bw != NULL);
+   g_return_if_fail (dd != NULL);
 
-   ++bw->nav_stack_ptr;
-   if ( bw->nav_stack_ptr == bw->nav_stack_size) {
-      a_List_add(bw->nav_stack, bw->nav_stack_size, bw->nav_stack_size_max);
-      ++bw->nav_stack_size;
+   ++dd->nav_stack_ptr;
+   if ( dd->nav_stack_ptr == dd->nav_stack_size) {
+      a_List_add(dd->nav_stack, dd->nav_stack_size, dd->nav_stack_size_max);
+      ++dd->nav_stack_size;
    } else {
-      bw->nav_stack_size = bw->nav_stack_ptr + 1;
+      dd->nav_stack_size = dd->nav_stack_ptr + 1;
    }
-   bw->nav_stack[bw->nav_stack_ptr] = idx;
+   dd->nav_stack[dd->nav_stack_ptr] = idx;
 }
 
 /*
  * Remove an URL-index from the navigation stack.
  */
-static void Nav_stack_remove(BrowserWindow *bw, gint idx)
+static void Nav_stack_remove(DilloDoc *dd, gint idx)
 {
-   gint sz = a_Nav_stack_size(bw);
+   gint sz = a_Nav_stack_size(dd);
 
-   g_return_if_fail (bw != NULL && idx >=0 && idx < sz);
+   g_return_if_fail (dd != NULL && idx >=0 && idx < sz);
 
    for (  ; idx < sz - 1; ++idx)
-      bw->nav_stack[idx] = bw->nav_stack[idx + 1];
-   if ( bw->nav_stack_ptr == --bw->nav_stack_size )
-      --bw->nav_stack_ptr;
+      dd->nav_stack[idx] = dd->nav_stack[idx + 1];
+   if ( dd->nav_stack_ptr == --dd->nav_stack_size )
+      --dd->nav_stack_ptr;
 }
 
 /*
- * Remove equal adyacent URLs at the top of the stack.
+ * Remove equal adjacent URLs at the top of the stack.
  * (It may happen with redirections)
  */
-static void Nav_stack_clean(BrowserWindow *bw)
+static void Nav_stack_clean(DilloDoc *dd)
 {
    gint i;
 
-   g_return_if_fail (bw != NULL);
+   g_return_if_fail (dd != NULL);
 
-   if ((i = a_Nav_stack_size(bw)) >= 2 &&
-       bw->nav_stack[i-2] == bw->nav_stack[i-1])
-         Nav_stack_remove(bw, i - 1);
+   if ((i = a_Nav_stack_size(dd)) >= 2 &&
+       dd->nav_stack[i-2] == dd->nav_stack[i-1])
+         Nav_stack_remove(dd, i - 1);
 }
 
 
@@ -148,7 +152,7 @@
  * This function requests the page's root-URL; images and related stuff
  * are fetched directly by the HTML module.
  */
-static void Nav_open_url(BrowserWindow *bw, const DilloUrl *url, gint offset)
+static void Nav_open_url(DilloDoc *dd, const DilloUrl *url, gint offset)
 {
    DilloUrl *old_url = NULL;
    gboolean MustLoad;
@@ -156,55 +160,59 @@
    DilloWeb *Web;
    gboolean ForceReload = (URL_FLAGS(url) & URL_E2EReload);
 
-   MSG("Nav_open_url: Url=>%s<\n", URL_STR_(url));
+   _MSG("Nav_open_url: Url=>%s<\n", URL_STR_(url));
 
    /* Get the url of the current page */
-   if ( a_Nav_stack_ptr(bw) != -1 )
-      old_url = a_History_get_url(NAV_TOP(bw));
+   if ( a_Nav_stack_ptr(dd) != -1 )
+      old_url = a_History_get_url(NAV_TOP(dd));
 
    /* Record current scrolling position
-    * (the strcmp check is necessary because of redirections) */
+    * (the strcmp check is necessary because of redirections)
+    *
+    * TODO: how does this cope with background/(i)frame load? The
+    * comparison with a_Interface_get_location_text() is not valid then... */
    if (old_url &&
-       !strcmp(URL_STR(old_url), a_Interface_get_location_text(bw))) {
+       !strcmp(URL_STR(old_url), a_Interface_get_location_text(dd->bw))) {
       old_url->scrolling_position_x =
         a_Dw_gtk_scrolled_window_get_scrolling_position_x(
-           GTK_DW_SCROLLED_WINDOW(bw->docwin));
+           GTK_DW_SCROLLED_WINDOW(dd->docwin));
       old_url->scrolling_position_y =
         a_Dw_gtk_scrolled_window_get_scrolling_position_y(
-           GTK_DW_SCROLLED_WINDOW(bw->docwin));
+           GTK_DW_SCROLLED_WINDOW(dd->docwin));
    }
 
    /* Update navigation-stack-pointer (offset may be zero) */
-   Nav_stack_move_ptr(bw, offset);
+   Nav_stack_move_ptr(dd, offset);
 
    /* Page must be reloaded, if old and new url (without anchor) differ */
    MustLoad = ForceReload || !old_url;
    if (old_url){
       MustLoad |= a_Url_cmp(old_url, url);
-      MustLoad |= strcmp(URL_STR(old_url), a_Interface_get_location_text(bw));
+      /* TODO: possible issue with background/(i)frame load, see above */
+      MustLoad |= strcmp(URL_STR(old_url), a_Interface_get_location_text(dd->bw));
    }
 
    if ( MustLoad ) {
-      a_Interface_stop(bw);
-      a_Interface_clean(bw);
+      a_Doc_stop(dd);
+      a_Doc_clean(dd);
 
-      a_Menu_pagemarks_new(bw);
+      a_Pagemark_new(dd);
 
       Web = a_Web_new(url);
-      Web->bw = bw;
+      Web->dd = dd;
       Web->flags |= WEB_RootUrl;
       if ((ClientKey = a_Capi_open_url(Web, NULL, NULL)) != 0) {
-         a_Interface_add_client(bw, ClientKey, 1);
-         a_Interface_add_url(bw, url, WEB_RootUrl);
+         a_Doc_add_client(dd, ClientKey, 1);
+         a_Doc_add_url(dd, url, WEB_RootUrl);
       }
-      a_Interface_set_cursor(bw, GDK_LEFT_PTR);
+      a_Doc_set_cursor(dd, GDK_LEFT_PTR);
    }
 
    /* Jump to #anchor position */
    if (URL_FRAGMENT_(url)) {
       /* todo: push on stack */
       a_Dw_gtk_scrolled_window_set_anchor(
-         GTK_DW_SCROLLED_WINDOW(bw->docwin), URL_FRAGMENT_(url));
+         GTK_DW_SCROLLED_WINDOW(dd->docwin), URL_FRAGMENT_(url));
    }
 }
 
@@ -212,191 +220,215 @@
  * Cancel the last expected url if present. The responsibility
  * for actually aborting the data stream remains with the caller.
  */
-void a_Nav_cancel_expect(BrowserWindow *bw)
+void a_Nav_cancel_expect(DilloDoc *dd)
 {
-   if (bw->nav_expecting) {
-      if (bw->nav_expect_url) {
-         a_Url_free(bw->nav_expect_url);
-         bw->nav_expect_url = NULL;
+   if (dd->nav_expecting) {
+      if (dd->nav_expect_url) {
+         a_Url_free(dd->nav_expect_url);
+         dd->nav_expect_url = NULL;
       }
-      bw->nav_expecting = FALSE;
+      dd->nav_expecting = FALSE;
    }
 }
 
 /*
  * We have an answer! Set things accordingly.
  */
-void a_Nav_expect_done(BrowserWindow *bw)
+void a_Nav_expect_done(DilloDoc *dd)
 {
    gint idx;
    DilloUrl *url;
 
-   g_return_if_fail(bw != NULL);
+   g_return_if_fail(dd != NULL);
 
-   if (bw->nav_expecting) {
-      url = bw->nav_expect_url;
+   if (dd->nav_expecting) {
+      url = dd->nav_expect_url;
       /* unset E2EReload before adding this url to history */
       a_Url_set_flags(url, URL_FLAGS(url) & ~URL_E2EReload);
       idx = a_History_add_url(url);
-      Nav_stack_add(bw, idx);
+      Nav_stack_add(dd, idx);
 
       a_Url_free(url);
-      bw->nav_expect_url = NULL;
-      bw->nav_expecting = FALSE;
+      dd->nav_expect_url = NULL;
+      dd->nav_expecting = FALSE;
    }
-   Nav_stack_clean(bw);
-   a_Interface_set_button_sens(bw);
+   Nav_stack_clean(dd);
+   a_Doc_progress_update(dd);
 }
 
 /*
  * Remove top-URL from the navigation stack.
  * (Used to remove URLs that force redirection)
  */
-void a_Nav_remove_top_url(BrowserWindow *bw)
+void a_Nav_remove_top_url(DilloDoc *dd)
 {
-   g_return_if_fail (bw != NULL);
+   g_return_if_fail (dd != NULL);
 
    /* Deallocate the URL a the top of the stack */
-   Nav_stack_remove(bw, a_Nav_stack_size(bw) - 1);
+   Nav_stack_remove(dd, a_Nav_stack_size(dd) - 1);
 }
 
 /*
  * Make 'url' the current browsed page (upon data arrival)
- * - Set bw to expect the URL data
+ * - Set dd to expect the URL data
  * - Ask the cache to feed back the requested URL (via Nav_open_url)
  */
-void a_Nav_push(BrowserWindow *bw, const DilloUrl *url)
+void a_Nav_push(DilloDoc *dd, const DilloUrl *url)
 {
-   g_return_if_fail (bw != NULL);
+   g_return_if_fail (dd != NULL);
 
-   if (bw->nav_expecting && a_Url_cmp(bw->nav_expect_url, url) == 0 &&
-       URL_STRCAMP_EQ(URL_FRAGMENT_(bw->nav_expect_url), URL_FRAGMENT_(url))) {
+   if (dd->nav_expecting && a_Url_cmp(dd->nav_expect_url, url) == 0 &&
+       URL_STRCAMP_EQ(URL_FRAGMENT_(dd->nav_expect_url), URL_FRAGMENT_(url))) {
       /* we're already expecting that url (most probably a double-click) */
       return;
    }
-   a_Nav_cancel_expect(bw);
-   bw->nav_expect_url = a_Url_dup(url);
-   bw->nav_expecting = TRUE;
-   Nav_open_url(bw, url, 0);
+   a_Nav_cancel_expect(dd);
+   dd->nav_expect_url = a_Url_dup(url);
+   dd->nav_expecting = TRUE;
+#ifndef XHTML_DTD_STRICT
+   /* is this is a targeted URL, (re)name the document after it */
+   if(URL_TARGET_(url))
+     a_Doc_set_name(dd, (gchar *) URL_TARGET_(url));
+#endif /* !XHTML_DTD_STRICT */
+   Nav_open_url(dd, url, 0);
 }
 
 /*
  * Same as a_Nav_push() but in a new window.
  */
-void a_Nav_push_nw(BrowserWindow *bw, const DilloUrl *url)
+void a_Nav_push_nw(DilloDoc *dd, const DilloUrl *url)
 {
    gint width, height;
    BrowserWindow *newbw;
 
-   gdk_window_get_size (bw->main_window->window, &width, &height);
+   gdk_window_get_size (dd->bw->main_window->window, &width, &height);
    newbw = a_Interface_browser_window_new(width, height, 0);
-   a_Nav_push(newbw, url);
+   a_Nav_push(newbw->dd, url);
 }
 
 /*
  * Wraps a_Nav_push to match 'DwPage->link' function type
  */
-void a_Nav_vpush(void *vbw, const DilloUrl *url)
+void a_Nav_vpush(void *vdd, const DilloUrl *url)
 {
-   a_Nav_push(vbw, url);
+   a_Nav_push(vdd, url);
 }
 
 /*
  * Send the browser back to previous page
  */
-void a_Nav_back(BrowserWindow *bw)
+void a_Nav_back(DilloDoc *dd)
 {
-   gint idx = a_Nav_stack_ptr(bw);
+   gint idx = a_Nav_stack_ptr(dd);
 
-   a_Nav_cancel_expect(bw);
+   a_Nav_cancel_expect(dd);
    if ( --idx >= 0 ){
-      a_Interface_msg(bw, "");
-      Nav_open_url(bw, a_History_get_url(NAV_IDX(bw,idx)), -1);
+      a_Interface_msg(dd->bw, "");
+      Nav_open_url(dd, a_History_get_url(NAV_IDX(dd,idx)), -1);
    }
 }
 
 /*
  * Send the browser to next page in the history list
  */
-void a_Nav_forw(BrowserWindow *bw)
+void a_Nav_forw(DilloDoc *dd)
 {
-   gint idx = a_Nav_stack_ptr(bw);
+   gint idx = a_Nav_stack_ptr(dd);
 
-   a_Nav_cancel_expect(bw);
-   if (++idx < a_Nav_stack_size(bw)) {
-      a_Interface_msg(bw, "");
-      Nav_open_url(bw, a_History_get_url(NAV_IDX(bw,idx)), +1);
+   a_Nav_cancel_expect(dd);
+   if (++idx < a_Nav_stack_size(dd)) {
+      a_Interface_msg(dd->bw, "");
+      Nav_open_url(dd, a_History_get_url(NAV_IDX(dd,idx)), +1);
    }
 }
 
 /*
  * Redirect the browser to the HOME page!
  */
-void a_Nav_home(BrowserWindow *bw)
+void a_Nav_home(DilloDoc *dd)
 {
-   a_Nav_push(bw, prefs.home);
+   a_Nav_push(dd, prefs.home);
 }
 
 /*
  * Jump to an URL within the stack history
- * NewBw: {0 = same window, 1 = new window}
+#ifndef DISABLE_TABS
+ * NewDd: {0 = same window, 1 = new window, 2 = new tab}
+#else
+ * NewDd: {0 = same window, 1 = new window}
+#endif
  */
-void a_Nav_jump_callback(GtkWidget *widget, gpointer client_data, gint NewBw)
+void a_Nav_jump_callback(GtkWidget *widget, gpointer client_data, gint NewDd)
 {
    int idx;
-   BrowserWindow *bw = client_data;
+   DilloDoc *dd = client_data;
 
    idx = GPOINTER_TO_INT(gtk_object_get_data(GTK_OBJECT (widget), "nav_idx"));
-   if (idx >= 0 && idx < a_Nav_stack_size(bw)) {
-      if (NewBw == 1) {
-         a_Nav_push_nw(bw, a_History_get_url(NAV_IDX(bw,idx)));
-      } else {
-         Nav_open_url(bw, a_History_get_url(NAV_IDX(bw,idx)),
-                      idx - a_Nav_stack_ptr(bw));
-      }
+   if (idx >= 0 && idx < a_Nav_stack_size(dd)) {
+     switch (NewDd) {
+     case 0:
+       /* Open link in same bw */
+       Nav_open_url(dd, a_History_get_url(NAV_IDX(dd,idx)),
+                    idx - a_Nav_stack_ptr(dd));
+       break;
+     case 1:
+       /* Open link in a new bw */
+       a_Menu_popup_set_url(dd->bw, a_History_get_url(NAV_IDX(dd,idx)));
+       a_Commands_open_link_nw_callback(widget, dd->bw);
+       break;
+#ifndef DISABLE_TABS
+     case 2:
+       /* Open link in a new tab */
+       a_Menu_popup_set_url(dd->bw, a_History_get_url(NAV_IDX(dd,idx)));
+       a_Commands_open_link_nw_tab_callback(widget, dd->bw);
+       break;
+#endif
+     default:
+       g_error(_("Unhandled switch type %d in a_Nav_jump_callback in src/nav.c\n"), NewDd);
+     }
    }
 }
 
 /*
  * Callback for reload confirmation
  */
-static void Nav_reload_confirmed(BrowserWindow *bw)
+static void Nav_reload_confirmed(DilloDoc *dd)
 {
    DEBUG_MSG(3, "Nav_reload_confirmed\n");
-   if ( a_Nav_stack_size(bw) &&
-        bw->question_dialog_data == a_History_get_url(NAV_TOP(bw)) ) {
+   if ( a_Nav_stack_size(dd) &&
+        dd->bw->question_dialog_data == a_History_get_url(NAV_TOP(dd)) ) {
       /* a genuine confirmation! */
       DEBUG_MSG(3, "Nav_reload_confirmed test: OK\n");
-      bw->question_dialog_data = NULL;
-      Nav_reload(bw);
+      dd->bw->question_dialog_data = NULL;
+      Nav_reload(dd);
    }
 }
 
 /*
  * Callback for reload refusal
  */
-static void Nav_reload_refused(BrowserWindow *bw)
+static void Nav_reload_refused(DilloDoc *dd)
 {
    DEBUG_MSG(3, "Nav_reload_refused\n");
-   bw->question_dialog_data = NULL;
+   dd->bw->question_dialog_data = NULL;
 }
 
 /*
  * This one does a_Nav_reload's job!
  */
-static void Nav_reload(BrowserWindow *bw)
+static void Nav_reload(DilloDoc *dd)
 {
    DilloUrl *url, *ReqURL;
 
-   a_Nav_cancel_expect(bw);
-   if ( a_Nav_stack_size(bw) ) {
-      url = a_History_get_url(NAV_TOP(bw));
-      ReqURL = a_Url_dup(a_History_get_url(NAV_TOP(bw)));
+   a_Nav_cancel_expect(dd);
+   if ( a_Nav_stack_size(dd) ) {
+      url = a_History_get_url(NAV_TOP(dd));
+      ReqURL = a_Url_dup(a_History_get_url(NAV_TOP(dd)));
       /* Let's make reload be end-to-end */
       a_Url_set_flags(ReqURL, URL_FLAGS(ReqURL) | URL_E2EReload);
       /* This is an explicit reload, so clear the SpamSafe flag */
       a_Url_set_flags(ReqURL, URL_FLAGS(ReqURL) & ~URL_SpamSafe);
-      Nav_open_url(bw, ReqURL, 0);
+      Nav_open_url(dd, ReqURL, 0);
       a_Url_free(ReqURL);
    }
 }
@@ -405,22 +437,22 @@
  * Implement the RELOAD button functionality.
  * (We haven't defined it yet ;)
  */
-void a_Nav_reload(BrowserWindow *bw)
+void a_Nav_reload(DilloDoc *dd)
 {
    DilloUrl *url;
 
-   a_Nav_cancel_expect(bw);
-   if ( a_Nav_stack_size(bw) ) {
-      url = a_History_get_url(NAV_TOP(bw));
+   a_Nav_cancel_expect(dd);
+   if ( a_Nav_stack_size(dd) ) {
+      url = a_History_get_url(NAV_TOP(dd));
       if (URL_FLAGS(url) & URL_Post) {
          /* Attempt to repost data, let's confirm... */
-         bw->question_dialog_data = (gpointer)url;
-         a_Interface_question_dialog(bw, "Repost form data?",
-                                     Nav_reload_confirmed, bw,
-                                     Nav_reload_refused, bw);
+         dd->bw->question_dialog_data = (gpointer)url;
+         a_Interface_question_dialog(dd->bw, _("Repost form data?"),
+                                     Nav_reload_confirmed, dd,
+                                     Nav_reload_refused, dd);
 
       } else {
-         Nav_reload(bw);
+         Nav_reload(dd);
       }
    }
 }
diff -Nur dillo-0.8.0/src/nav.h dillo-0.8.0.new/src/nav.h
--- dillo-0.8.0/src/nav.h	2003-09-24 12:28:21.000000000 +0000
+++ dillo-0.8.0.new/src/nav.h	2004-10-13 01:13:29.000000000 +0000
@@ -6,29 +6,29 @@
 
 
 /* useful macros for the navigation stack */
-#define NAV_IDX(bw, i)   (bw)->nav_stack[i]
-#define NAV_TOP(bw)      (bw)->nav_stack[(bw)->nav_stack_ptr]
+#define NAV_IDX(dd, i)   (dd)->nav_stack[i]
+#define NAV_TOP(dd)      (dd)->nav_stack[(dd)->nav_stack_ptr]
 
 
 #ifdef __cplusplus
 extern "C" {
 #endif /* __cplusplus */
 
-void a_Nav_push(BrowserWindow *bw, const DilloUrl *url);
-void a_Nav_push_nw(BrowserWindow *bw, const DilloUrl *url);
-void a_Nav_vpush(void *vbw, const DilloUrl *url);
-void a_Nav_back(BrowserWindow *bw);
-void a_Nav_forw(BrowserWindow *bw);
-void a_Nav_home(BrowserWindow *bw);
-void a_Nav_reload(BrowserWindow *bw);
-void a_Nav_init(BrowserWindow *bw);
-void a_Nav_free(BrowserWindow *bw);
-void a_Nav_cancel_expect (BrowserWindow *bw);
-void a_Nav_expect_done(BrowserWindow *bw);
-void a_Nav_remove_top_url(BrowserWindow *bw);
-void a_Nav_jump_callback(GtkWidget *widget, gpointer client_data, gint NewBw);
-gint a_Nav_stack_ptr(BrowserWindow *bw);
-gint a_Nav_stack_size(BrowserWindow *bw);
+void a_Nav_push(DilloDoc *dd, const DilloUrl *url);
+void a_Nav_push_nw(DilloDoc *dd, const DilloUrl *url);
+void a_Nav_vpush(void *vdd, const DilloUrl *url);
+void a_Nav_back(DilloDoc *dd);
+void a_Nav_forw(DilloDoc *dd);
+void a_Nav_home(DilloDoc *dd);
+void a_Nav_reload(DilloDoc *dd);
+void a_Nav_init(DilloDoc *dd);
+void a_Nav_free(DilloDoc *dd);
+void a_Nav_cancel_expect (DilloDoc *dd);
+void a_Nav_expect_done(DilloDoc *dd);
+void a_Nav_remove_top_url(DilloDoc *dd);
+void a_Nav_jump_callback(GtkWidget *widget, gpointer client_data, gint NewDd);
+gint a_Nav_stack_ptr(DilloDoc *dd);
+gint a_Nav_stack_size(DilloDoc *dd);
 
 
 #ifdef __cplusplus
diff -Nur dillo-0.8.0/src/pagemark.c dillo-0.8.0.new/src/pagemark.c
--- dillo-0.8.0/src/pagemark.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/src/pagemark.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,156 @@
+/*
+ * Dillo
+ *
+ * Some code copied from:
+ * The GIMP -- an image manipulation program
+ * Copyright (C) 1995 Spencer Kimball and Peter Mattis
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <gtk/gtk.h>
+#include <gdk/gdkkeysyms.h>
+#include "dw_gtk_scrolled_window.h"
+#include "browser.h"
+#include "interface.h"
+#include "dw_page.h"         /* for a_Dw_page_add_anchor */
+#include "i18n.h"
+#include "misc.h"
+
+/*
+ * Functions to manipulate Pagemarks menu.
+ */
+
+/*
+ * make the page scroll to the pagemark
+ */
+static void Pagemark_goto_pagemark(GtkWidget *widget,
+                                         gpointer client_data)
+{
+   DilloDoc *dd = (DilloDoc *) client_data;
+   char anchor[32];
+
+   g_snprintf (anchor, 32, "#%ld", (long int)widget);
+   a_Dw_gtk_scrolled_window_set_anchor(GTK_DW_SCROLLED_WINDOW(dd->docwin),
+                                       anchor);
+}
+
+/*
+ * Deallocate memory used by a pagemark menu
+ */
+void a_Pagemark_destroy(DilloDoc *dd)
+{
+  /* set pagemarks menu insensitive if this is the current tab */
+  if(dd->bw->dd == dd)
+    gtk_widget_set_sensitive(dd->bw->pagemarks_menuitem, FALSE);
+  if (GTK_IS_WIDGET(dd->pagemarks_menu))
+    {
+      gtk_object_unref(GTK_OBJECT(dd->pagemarks_menu));
+      dd->pagemarks_menu = NULL;
+      dd->pagemarks_last = NULL;
+    }
+}
+
+/*
+ * Deallocate the memory used by a pagemarks menu and create a new one
+ */
+void a_Pagemark_new(DilloDoc *dd)
+{
+   a_Pagemark_destroy(dd);
+   dd->pagemarks_menu = gtk_menu_new();
+   /* add a reference to the object, otherwise it will be destroyed
+    * when the document (tab) is switched */
+   gtk_object_ref(GTK_OBJECT(dd->pagemarks_menu));
+   dd->pagemarks_last = NULL;
+
+   /* add to bw's menu only if this is the current tab */
+   if(dd->bw->dd == dd)
+     gtk_menu_item_set_submenu(GTK_MENU_ITEM(dd->bw->pagemarks_menuitem),
+                               dd->pagemarks_menu);
+
+   /* todo: add a scroller so one can access  all menu entries,
+    * even if there's a lot of pagemarks. */
+   /* --EG: I haven't found a way to pass a scroller
+    * as widget for the submenu */
+}
+
+/*
+ * Add a new pagemark (opening H tag).
+ * The text can be set only at the closing H tag.
+ * level is the level of the heading (1-6).
+ */
+void a_Pagemark_add(DilloDoc *dd, void *page, void *style,
+                          gint level)
+{
+   char anchor[32], spaces[32], name[32];
+
+   /* set pagemarks menu sensitive if this is the current tab */
+   if(dd->bw->dd == dd)
+     gtk_widget_set_sensitive(dd->bw->pagemarks_menuitem, TRUE);
+   g_snprintf(spaces, 32, "%*s", 3 * (level - 1), "");
+   dd->pagemarks_last = gtk_menu_item_new_with_label(spaces);
+   gtk_menu_append(GTK_MENU(dd->pagemarks_menu),dd->pagemarks_last);
+   gtk_widget_show(dd->pagemarks_last);
+   gtk_signal_connect(GTK_OBJECT(dd->pagemarks_last), "activate",
+                      (GtkSignalFunc) Pagemark_goto_pagemark, dd);
+   /* was:
+    * Menu_add(dd->pagemarks_menu, spaces, NULL, dd,
+    *          Pagemark_goto_pagemark, dd);
+    * but Menu_add is a private function for menu.c so... */
+   g_snprintf(anchor, 32, "#%ld", (glong)(dd->pagemarks_last));
+   a_Dw_page_add_anchor(page, anchor, style);
+   gtk_signal_connect (GTK_OBJECT (dd->pagemarks_last), "select",
+                       GTK_SIGNAL_FUNC (a_Interface_scroll_popup), NULL);
+   g_snprintf(name, 32, "dilloHeading%d", level);
+   gtk_widget_set_name(dd->pagemarks_last, name);
+}
+
+/*
+ * Set the text for the last created pagemark.
+ */
+void a_Pagemark_set_text(DilloDoc *dd, const char *str, int len)
+{
+   GString *text;
+   GtkWidget *child;
+   char *label_text;
+   char *str_enc;
+
+   /* Avoid problems with lonely closing tags and nested headings */
+   if ( dd->pagemarks_last &&
+       (child = GTK_BIN (dd->pagemarks_last)->child) &&
+       GTK_IS_LABEL (child) ) {
+      text = g_string_new(GTK_LABEL(child)->label);
+      g_string_append(text, str);
+      if ( text->len > 64 ) {
+		 int max_len = 64;
+		 while (IS_UTF8_NON_FIRST_CHAR(text->str[max_len - 1]))
+			 max_len--;
+		 if (IS_UTF8_FIRST_CHAR(text->str[max_len - 1]))
+			 max_len--;
+         g_string_truncate(text, max_len);
+         g_string_append(text, "...");
+      }
+      label_text = a_I18n_DW_CHARSET_from_DILLO_CHARSET(text->str, text->len);
+	  str_enc = a_Misc_string_check(label_text, DW_CHARSET);
+      gtk_label_set_text(GTK_LABEL (child), str_enc);
+	  g_free(label_text);
+      g_string_free(text, 1);
+      g_free(str_enc);
+      dd->pagemarks_last = NULL;
+   }
+}
diff -Nur dillo-0.8.0/src/pagemark.h dillo-0.8.0.new/src/pagemark.h
--- dillo-0.8.0/src/pagemark.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/src/pagemark.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,13 @@
+#ifndef __PAGEMARK_H__
+#define __PAGEMARK_H__
+
+#include <gtk/gtk.h>
+
+void a_Pagemark_new (DilloDoc *dd);
+void a_Pagemark_destroy (DilloDoc *dd);
+void a_Pagemark_add(DilloDoc *dd, void *page, void *style,
+                          gint level);
+void a_Pagemark_set_text(DilloDoc *dd, const char *str, int len);
+
+
+#endif /* __PAGEMARK_H__ */
diff -Nur dillo-0.8.0/src/plain.c dillo-0.8.0.new/src/plain.c
--- dillo-0.8.0/src/plain.c	2003-10-24 19:45:27.000000000 +0000
+++ dillo-0.8.0.new/src/plain.c	2004-10-13 01:13:29.000000000 +0000
@@ -18,13 +18,13 @@
 #include <math.h>       /* for rint() */
 #include <gtk/gtk.h>
 
+#include "i18n.h"
 #include "prefs.h"
 #include "dw_page.h"
 #include "cache.h"
 #include "browser.h"
 #include "web.h"
-#include "interface.h"
-#include "progressbar.h"
+#include "doc.h"
 #include "misc.h"
 #include "history.h"
 #include "nav.h"
@@ -35,8 +35,9 @@
    DwWidget *dw;
    size_t Start_Ofs;    /* Offset of where to start reading next */
    DwStyle *style;
-   BrowserWindow *bw;
+   DilloDoc *dd;
    gint state;
+   gchar *charset;
 } DilloPlain;
 
 /* FSM states */
@@ -59,7 +60,7 @@
                            BrowserWindow *bw)
 {
    if (event->button == 3) {
-      a_Menu_popup_set_url(bw, a_History_get_url(NAV_TOP(bw)));
+      a_Menu_popup_set_url(bw, a_History_get_url(NAV_TOP(bw->dd)));
       gtk_menu_popup(GTK_MENU(bw->menu_popup.over_page), NULL, NULL,
                      NULL, NULL, event->button, event->time);
       return TRUE;
@@ -70,7 +71,7 @@
 /*
  * Create and initialize a new DilloPlain structure.
  */
-static DilloPlain *Plain_new(BrowserWindow *bw)
+static DilloPlain *Plain_new(DilloDoc *dd)
 {
    DilloPlain *plain;
    DwPage *page;
@@ -78,30 +79,30 @@
    DwStyleFont font_attrs;
 
    plain = g_new(DilloPlain, 1);
+   plain->charset = NULL;
    plain->state = ST_SeekingEol;
    plain->Start_Ofs = 0;
-   plain->bw = bw;
+   plain->dd = dd;
    plain->dw = a_Dw_page_new();
    page = (DwPage *) plain->dw;
 
    /* Create the font and attribute for the page. */
    font_attrs.name = prefs.fw_fontname;
-   font_attrs.size = rint(12.0 * prefs.font_factor);
+   font_attrs.size = rint(prefs.font_sizes[2] * prefs.font_factor);
    font_attrs.weight = 400;
    font_attrs.style = DW_STYLE_FONT_STYLE_NORMAL;
-
-   a_Dw_style_init_values (&style_attrs, plain->bw->main_window->window);
+   a_Dw_style_init_values (&style_attrs, plain->dd->bw->main_window->window);
    style_attrs.font = a_Dw_style_font_new (&font_attrs);
    style_attrs.color = a_Dw_style_color_new (prefs.text_color,
-                                             plain->bw->main_window->window);
+                                             plain->dd->bw->main_window->window);
    plain->style = a_Dw_style_new (&style_attrs,
-                                  plain->bw->main_window->window);
+                                  plain->dd->bw->main_window->window);
    //a_Dw_widget_set_style (plain->dw, plain->style);
 
    /* The context menu */
    gtk_signal_connect_while_alive
-      (GTK_OBJECT(GTK_BIN(plain->bw->docwin)->child),"button_press_event",
-       GTK_SIGNAL_FUNC(Plain_page_menu), (gpointer)plain->bw,
+      (GTK_OBJECT(GTK_BIN(plain->dd->docwin)->child),"button_press_event",
+       GTK_SIGNAL_FUNC(Plain_page_menu), (gpointer)plain->dd->bw,
        GTK_OBJECT (page));
 
    return plain;
@@ -114,7 +115,7 @@
                        void **Data)
 {
    DilloWeb *web = P;
-   DilloPlain *plain = Plain_new(web->bw);
+   DilloPlain *plain = Plain_new(web->dd);
 
    *Call = (CA_Callback_t)Plain_callback;
    *Data = (void*)plain;
@@ -135,11 +136,10 @@
       if (plain->Start_Ofs < Client->BufSize)
          Plain_write(plain, Client->Buf, Client->BufSize, 1);
       /* remove this client from our active list */
-      a_Interface_close_client(plain->bw, Client->Key);
-      /* set progress bar insensitive */
-      a_Progressbar_update(plain->bw->progress, NULL, 0);
-
+      plain->dd->ready = TRUE;
+      a_Doc_close_client(plain->dd, Client->Key);
       a_Dw_style_unref (plain->style);
+      g_free(plain->charset);
       g_free(plain);
    } else {
       Plain_write(plain, Client->Buf, Client->BufSize, 0);
@@ -158,7 +158,10 @@
    char *Start;
    char *data;
    gint i, len, MaxBytes;
+   gboolean usemeta = FALSE;
 
+   if(!plain->charset)
+       plain->charset = a_I18n_get_encoding(Buf, BufSize, &usemeta);
    Start = (char*)Buf + plain->Start_Ofs;
    MaxBytes = BufSize - plain->Start_Ofs;
    i = len = 0;
@@ -172,7 +175,8 @@
          }
          break;
       case ST_Eol:
-         data = g_strndup(Start + i - len, len);
+         data = a_I18n_convert(plain->charset, DILLO_CHARSET,
+                 Start + i - len, len);
          a_Dw_page_add_text(page, a_Misc_expand_tabs(data), plain->style);
          g_free(data);
          a_Dw_page_add_parbreak(page, 0, plain->style);
@@ -185,19 +189,17 @@
    }
    plain->Start_Ofs += i - len;
    if ( Eof && len ) {
-      data = g_strndup(Start + i - len, len);
+      data = a_I18n_convert(plain->charset, DILLO_CHARSET,
+              Start + i - len, len);
       a_Dw_page_add_text(page, a_Misc_expand_tabs(data), plain->style);
       g_free(data);
       a_Dw_page_add_parbreak(page, 0, plain->style);
       plain->Start_Ofs += len;
    }
 
-   if ( plain->bw ) {
-      gchar completestr[32];
-      g_snprintf(
-         completestr, 32, "%s%.1f Kb",
-         PBAR_PSTR(prefs.panel_size == 1),
-         (float)plain->Start_Ofs/1024);
-      a_Progressbar_update(plain->bw->progress, completestr, 1);
+   if ( plain->dd ) {
+      plain->dd->progress = plain->Start_Ofs/1024;
+      plain->dd->ready = FALSE;
+      a_Doc_progress_update(plain->dd);
    }
 }
diff -Nur dillo-0.8.0/src/prefs.c dillo-0.8.0.new/src/prefs.c
--- dillo-0.8.0/src/prefs.c	2004-01-25 15:17:53.000000000 +0000
+++ dillo-0.8.0.new/src/prefs.c	2004-10-13 01:13:29.000000000 +0000
@@ -18,18 +18,25 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
+#include <config.h>
+
 #include <glib.h>
 #include <sys/types.h>
 #include <sys/stat.h>
+#include <stdio.h>        /* for sscanf */
 #include <stdlib.h>
 #include <string.h>       /* for strchr */
 #include <fcntl.h>
 #include <unistd.h>
 #include <locale.h>       /* for setlocale */
+#include "intl.h"
 #include "prefs.h"
 #include "colors.h"
 #include "misc.h"
 
+#define DEBUG_LEVEL 5
+#include "debug.h"
+
 /* symbol array */
 static const struct {
    gchar *name;
@@ -38,6 +45,7 @@
    { "geometry", DRC_TOKEN_GEOMETRY },
    { "http_proxy", DRC_TOKEN_PROXY },
    { "no_proxy", DRC_TOKEN_NOPROXY },
+   { "user_agent", DRC_TOKEN_USER_AGENT },
    { "link_color", DRC_TOKEN_LINK_COLOR },
    { "visited_color", DRC_TOKEN_VISITED_COLOR, },
    { "bg_color", DRC_TOKEN_BG_COLOR },
@@ -46,12 +54,15 @@
    { "force_visited_color", DRC_TOKEN_FORCE_VISITED_COLOR },
    { "text_color", DRC_TOKEN_TEXT_COLOR },
    { "use_oblique", DRC_TOKEN_USE_OBLIQUE },
+   { "startup", DRC_TOKEN_STARTUP },
    { "home", DRC_TOKEN_HOME },
    { "show_tooltip", DRC_TOKEN_SHOW_TOOLTIP },
    { "panel_size", DRC_TOKEN_PANEL_SIZE },
    { "small_icons", DRC_TOKEN_SMALL_ICONS },
    { "limit_text_width", DRC_TOKEN_LIMIT_TEXT_WIDTH },
+   { "limit_font_decoration", DRC_TOKEN_LIMIT_FONT_DECORATION },
    { "font_factor", DRC_TOKEN_FONT_FACTOR },
+   { "font_sizes", DRC_TOKEN_FONT_SIZES },
    { "use_dicache", DRC_TOKEN_USE_DICACHE },
    { "show_back", DRC_TOKEN_SHOW_BACK },
    { "show_forw", DRC_TOKEN_SHOW_FORW },
@@ -65,15 +76,37 @@
    { "show_url", DRC_TOKEN_SHOW_URL },
    { "show_search", DRC_TOKEN_SHOW_SEARCH },
    { "show_progress_box", DRC_TOKEN_SHOW_PROGRESS_BOX },
+   { "show_popup_navigation", DRC_TOKEN_SHOW_POPUP_NAVIGATION },
+//#ifdef ENABLE_USER_AGENT
+   { "show_user_agent", DRC_TOKEN_SHOW_USER_AGENT },
+//#endif
    { "fullwindow_start", DRC_TOKEN_FULLWINDOW_START },
    { "transient_dialogs", DRC_TOKEN_TRANSIENT_DIALOGS },
+   { "popup_dialogs", DRC_TOKEN_POPUP_DIALOGS },
+   { "vw_aafontname", DRC_TOKEN_VW_AAFONT },
+   { "fw_aafontname", DRC_TOKEN_FW_AAFONT },
    { "vw_fontname", DRC_TOKEN_VW_FONT },
    { "fw_fontname", DRC_TOKEN_FW_FONT },
    { "generate_submit", DRC_TOKEN_GENERATE_SUBMIT },
    { "enterpress_forces_submit", DRC_TOKEN_ENTERPRESS_FORCES_SUBMIT },
    { "search_url", DRC_TOKEN_SEARCH_URL },
+   { "search_charset", DRC_TOKEN_SEARCH_CHARSET },
    { "show_msg", DRC_TOKEN_SHOW_MSG },
-   { "use_old_parser", DRC_TOKEN_USE_OLD_PARSER }
+   { "use_old_parser", DRC_TOKEN_USE_OLD_PARSER },
+   { "focus_location_on_new", DRC_TOKEN_FOCUS_LOCATION_ON_NEW },
+   { "accept_language", DRC_TOKEN_ACCEPT_LANGUAGE },
+#ifndef DISABLE_TABS
+   { "tab_load_in_background", DRC_TOKEN_TAB_LOAD_IN_BACKGROUND },
+   { "tab_instead_of_window", DRC_TOKEN_TAB_INSTEAD_OF_WINDOW },
+   { "tab_bar_show_fullscreen", DRC_TOKEN_TAB_BAR_SHOW_FULLSCREEN },
+   { "tab_bar_show_single_tab", DRC_TOKEN_TAB_BAR_SHOW_SINGLE_TAB },
+   { "tab_bar_scroller", DRC_TOKEN_TAB_BAR_SCROLLER },
+   { "tab_bar_homogeneous", DRC_TOKEN_TAB_BAR_HOMOGENEOUS },
+   { "tab_title_compress", DRC_TOKEN_TAB_TITLE_COMPRESS },
+   { "tab_close_middle_click", DRC_TOKEN_TAB_CLOSE_MIDDLE_CLICK },
+   { "compress_vowels", DRC_TOKEN_COMPRESS_VOWELS },
+   { "compress_common_prefixes", DRC_TOKEN_COMPRESS_COMMON_PREFIXES },
+#endif /* !DISABLE_TABS */
 };
 
 static const guint n_symbols = sizeof (symbols) / sizeof (symbols[0]);
@@ -122,6 +155,18 @@
       prefs.no_proxy = g_strdup(scanner->value.v_string);
       prefs.no_proxy_vec = g_strsplit(prefs.no_proxy, " ", 0);
       break;
+   case DRC_TOKEN_USER_AGENT:
+   {
+      gchar *prefs_value = g_strdup(scanner->value.v_string);
+      gchar *option = NULL;
+      g_free(prefs.user_agent);
+      if((option = strstr(prefs_value, "%v"))) {
+         option[1] = 's';
+         prefs.user_agent = g_strdup_printf(prefs_value, VERSION);
+      } else prefs.user_agent = prefs_value;
+      DEBUG_MSG(4, "Setting User-Agent: \"%s\"\n", prefs.user_agent);
+      break;
+   }
    case DRC_TOKEN_LINK_COLOR:
       prefs.link_color = a_Color_parse(scanner->value.v_string,
                                        prefs.link_color, &st);
@@ -166,15 +211,36 @@
       a_Url_free(prefs.home);
       prefs.home = a_Url_new(scanner->value.v_string, NULL, 0, 0, 0);
       break;
+   case DRC_TOKEN_STARTUP:
+      a_Url_free(prefs.startup);
+      prefs.startup = a_Url_new(scanner->value.v_string, NULL, 0, 0, 0);
+      break;
    case DRC_TOKEN_SHOW_TOOLTIP:
       prefs.show_tooltip = (strcmp(scanner->value.v_string, "YES") == 0);
       break;
    case DRC_TOKEN_FONT_FACTOR:
       prefs.font_factor = strtod(scanner->value.v_string, NULL);
       break;
+   case DRC_TOKEN_FONT_SIZES:
+   {
+      int sizes[D_FONT_SIZE_NUM];
+      if (sscanf(scanner->value.v_string,
+               "%d %d %d %d %d %d",
+               &sizes[0],
+               &sizes[1],
+               &sizes[2],
+               &sizes[3],
+               &sizes[4],
+               &sizes[5]) == D_FONT_SIZE_NUM) {
+         memcpy(prefs.font_sizes, sizes, sizeof(int) * D_FONT_SIZE_NUM);
+      }
+   }
    case DRC_TOKEN_LIMIT_TEXT_WIDTH:
       prefs.limit_text_width = (strcmp(scanner->value.v_string, "YES") == 0);
       break;
+   case DRC_TOKEN_LIMIT_FONT_DECORATION:
+      prefs.limit_font_decoration = (strcmp(scanner->value.v_string, "YES") == 0);
+      break;
    case DRC_TOKEN_USE_DICACHE:
       prefs.use_dicache = (strcmp(scanner->value.v_string, "YES") == 0);
       break;
@@ -214,17 +280,36 @@
    case DRC_TOKEN_SHOW_PROGRESS_BOX:
       prefs.show_progress_box = (strcmp(scanner->value.v_string, "YES") == 0);
       break;
+   case DRC_TOKEN_SHOW_POPUP_NAVIGATION:
+      prefs.show_popup_navigation = (strcmp(scanner->value.v_string, "YES") == 0);
+      break;
+#ifdef ENABLE_USER_AGENT
+   case DRC_TOKEN_SHOW_USER_AGENT:
+      prefs.show_user_agent = (strcmp(scanner->value.v_string, "YES") == 0);
+      break;
+#endif
    case DRC_TOKEN_FULLWINDOW_START:
       prefs.fullwindow_start = (strcmp(scanner->value.v_string, "YES") == 0);
       break;
    case DRC_TOKEN_TRANSIENT_DIALOGS:
       prefs.transient_dialogs = (strcmp(scanner->value.v_string, "YES") == 0);
       break;
+   case DRC_TOKEN_POPUP_DIALOGS:
+      prefs.popup_dialogs = (strcmp(scanner->value.v_string, "YES") == 0);
+      break;
+#ifdef DISABLE_ANTI_ALIAS
    case DRC_TOKEN_FW_FONT:
+#else
+   case DRC_TOKEN_FW_AAFONT:
+#endif
       g_free(prefs.fw_fontname);
       prefs.fw_fontname = g_strdup(scanner->value.v_string);
       break;
+#ifdef DISABLE_ANTI_ALIAS
    case DRC_TOKEN_VW_FONT:
+#else
+   case DRC_TOKEN_VW_AAFONT:
+#endif
       g_free(prefs.vw_fontname);
       prefs.vw_fontname = g_strdup(scanner->value.v_string);
       break;
@@ -239,6 +324,10 @@
       g_free(prefs.search_url);
       prefs.search_url = g_strdup(scanner->value.v_string);
       break;
+   case DRC_TOKEN_SEARCH_CHARSET:
+      g_free(prefs.search_charset);
+      prefs.search_charset = g_strdup(scanner->value.v_string);
+      break;
    case DRC_TOKEN_SHOW_MSG:
       prefs.show_msg =
          (strcmp(scanner->value.v_string, "YES") == 0);
@@ -247,6 +336,60 @@
       prefs.use_old_parser =
          (strcmp(scanner->value.v_string, "YES") == 0);
       break;
+   case DRC_TOKEN_FOCUS_LOCATION_ON_NEW:
+      prefs.focus_location_on_new =
+         (strcmp(scanner->value.v_string, "YES") == 0);
+      break;
+   case DRC_TOKEN_ACCEPT_LANGUAGE:
+      if (strlen(scanner->value.v_string) != 0) {
+         g_free(prefs.accept_language);
+         prefs.accept_language = g_strdup(scanner->value.v_string);
+      }
+      break;
+#ifndef DISABLE_TABS
+   case DRC_TOKEN_TAB_LOAD_IN_BACKGROUND:
+      prefs.tab_load_in_background =
+         (strcmp(scanner->value.v_string, "YES") == 0);
+      break;
+   case DRC_TOKEN_TAB_INSTEAD_OF_WINDOW:
+      prefs.tab_instead_of_window =
+         (strcmp(scanner->value.v_string, "YES") == 0);
+      break;
+   case DRC_TOKEN_TAB_BAR_SHOW_FULLSCREEN:
+      prefs.tab_bar_show_fullscreen =
+         (strcmp(scanner->value.v_string, "YES") == 0);
+      break;
+   case DRC_TOKEN_TAB_BAR_SHOW_SINGLE_TAB:
+      prefs.tab_bar_show_single_tab =
+         (strcmp(scanner->value.v_string, "YES") == 0);
+      break;
+   case DRC_TOKEN_TAB_BAR_SCROLLER:
+      prefs.tab_bar_scroller =
+         (strcmp(scanner->value.v_string, "YES") == 0);
+      break;
+   case DRC_TOKEN_TAB_BAR_HOMOGENEOUS:
+      prefs.tab_bar_homogeneous =
+         (strcmp(scanner->value.v_string, "YES") == 0);
+      break;
+   case DRC_TOKEN_TAB_TITLE_COMPRESS:
+      prefs.tab_title_compress =
+         (strcmp(scanner->value.v_string, "YES") == 0);
+      break;
+   case DRC_TOKEN_TAB_CLOSE_MIDDLE_CLICK:
+      prefs.tab_close_middle_click =
+         (strcmp(scanner->value.v_string, "YES") == 0);
+      break;
+   case DRC_TOKEN_COMPRESS_VOWELS:
+      g_free(prefs.compress_vowels);
+      prefs.compress_vowels = g_strdup(scanner->value.v_string);
+      break;
+   case DRC_TOKEN_COMPRESS_COMMON_PREFIXES:
+      g_free(prefs.compress_common_prefixes);
+      prefs.compress_common_prefixes = g_strdup(scanner->value.v_string);
+      prefs.compress_common_prefixes_vec = 
+        g_strsplit(prefs.compress_common_prefixes, ";", 0);
+      break;
+#endif /*DISABLE_TABS */
    default:
       break;   /* Not reached */
    }
@@ -349,11 +492,13 @@
    prefs.http_proxy = NULL;
    prefs.no_proxy = NULL;
    prefs.no_proxy_vec = NULL;
+   prefs.user_agent = NULL;
    prefs.link_color = DW_COLOR_DEFAULT_BLUE;
    prefs.visited_color = DW_COLOR_DEFAULT_PURPLE;
    prefs.bg_color = DW_COLOR_DEFAULT_BGND;
    prefs.text_color = DW_COLOR_DEFAULT_BLACK;
    prefs.use_oblique = FALSE;
+   prefs.startup = NULL;
    prefs.home = a_Url_new(DILLO_HOME, NULL, 0, 0, 0);
    prefs.allow_white_bg = TRUE;
    prefs.force_my_colors = FALSE;
@@ -362,7 +507,14 @@
    prefs.panel_size = 1;
    prefs.small_icons = FALSE;
    prefs.limit_text_width = FALSE;
+   prefs.limit_font_decoration = FALSE;
    prefs.font_factor = 1.0;
+   prefs.font_sizes[0] = D_FONT_SIZE_1;
+   prefs.font_sizes[1] = D_FONT_SIZE_2;
+   prefs.font_sizes[2] = D_FONT_SIZE_3;
+   prefs.font_sizes[3] = D_FONT_SIZE_4;
+   prefs.font_sizes[4] = D_FONT_SIZE_5;
+   prefs.font_sizes[5] = D_FONT_SIZE_6;
    prefs.use_dicache = FALSE;
    prefs.show_back=TRUE;
    prefs.show_forw=TRUE;
@@ -376,16 +528,37 @@
    prefs.show_url=TRUE;
    prefs.show_search=TRUE;
    prefs.show_progress_box=TRUE;
+   prefs.show_popup_navigation=TRUE;
+#ifdef ENABLE_USER_AGENT
+   prefs.show_user_agent=TRUE;
+#endif
    prefs.fullwindow_start=FALSE;
    prefs.transient_dialogs=FALSE;
-   prefs.vw_fontname = g_strdup("helvetica");
-   prefs.fw_fontname = g_strdup("courier");
+   prefs.popup_dialogs=TRUE;
+   prefs.vw_fontname = g_strdup(D_DEFAULT_VW_FONT);
+   prefs.fw_fontname = g_strdup(D_DEFAULT_FW_FONT);
    prefs.generate_submit = FALSE;
    prefs.enterpress_forces_submit = FALSE;
-   prefs.search_url = g_strdup("http://www.google.com/search?q=%s");
+   prefs.search_url = g_strdup(DILLO_SEARCH_URL);
+   prefs.search_charset = g_strdup(DILLO_SEARCH_CHARSET);
    prefs.show_msg = TRUE;
    prefs.use_old_parser = FALSE;
-
+   prefs.focus_location_on_new = TRUE;
+   prefs.accept_language = g_strdup(DILLO_ACCEPT_LANGUAGE);
+#ifndef DISABLE_TABS
+   prefs.tab_load_in_background = FALSE;
+   prefs.tab_instead_of_window = FALSE;
+   prefs.tab_bar_show_fullscreen = FALSE;
+   prefs.tab_bar_show_single_tab = FALSE;
+   prefs.tab_bar_scroller = FALSE;
+   prefs.tab_bar_homogeneous = TRUE;
+   prefs.tab_title_compress = TRUE;
+   prefs.tab_close_middle_click = TRUE;
+   prefs.compress_vowels = g_strdup(COMPRESS_VOWELS);
+   prefs.compress_common_prefixes = g_strdup(COMPRESS_COMMON_PREFIXES);
+   prefs.compress_common_prefixes_vec = 
+     g_strsplit(prefs.compress_common_prefixes, ";", 0);
+#endif /* DISABLE_TABS */
    /* this locale stuff is to avoid parsing problems with float numbers */
    old_locale = g_strdup (setlocale (LC_NUMERIC, NULL));
    setlocale (LC_NUMERIC, "C");
@@ -403,11 +576,22 @@
 void a_Prefs_freeall(void)
 {
    g_free(prefs.no_proxy);
-   if (prefs.no_proxy_vec)
-      g_strfreev(prefs.no_proxy_vec);
+   if (prefs.no_proxy_vec) g_strfreev(prefs.no_proxy_vec);
    a_Url_free(prefs.http_proxy);
+   g_free(prefs.user_agent);
    g_free(prefs.fw_fontname);
    g_free(prefs.vw_fontname);
    a_Url_free(prefs.home);
    g_free(prefs.search_url);
+   g_free(prefs.search_charset);
+   //a_Url_free(prefs.startup); /* Why crash ? */
+   g_free(prefs.accept_language);
+#ifndef DISABLE_TABS
+   g_free(prefs.compress_vowels);
+   g_free(prefs.compress_common_prefixes);
+   if (prefs.compress_common_prefixes_vec)
+      g_strfreev(prefs.compress_common_prefixes_vec);
+#endif /* DISABLE_TABS */
 }
+
+/* vim: set ts=3 sw=3 sts=3 expandtab:*/
diff -Nur dillo-0.8.0/src/prefs.h dillo-0.8.0.new/src/prefs.h
--- dillo-0.8.0/src/prefs.h	2004-01-25 15:17:37.000000000 +0000
+++ dillo-0.8.0.new/src/prefs.h	2004-10-13 01:13:29.000000000 +0000
@@ -7,7 +7,11 @@
 extern "C" {
 #endif /* __cplusplus */
 
+#define DILLO_STARTUP "http://www.google.com/"
 #define DILLO_HOME "http://www.dillo.org/"
+#define DILLO_SEARCH_URL "http://www.google.com/search?ie=UTF-8&oe=UTF-8&q="
+#define DILLO_SEARCH_CHARSET "UTF-8"
+#define DILLO_ACCEPT_LANGUAGE "en-us, ja"
 #define D_GEOMETRY_DEFAULT_WIDTH   640
 #define D_GEOMETRY_DEFAULT_HEIGHT  550
 #define D_GEOMETRY_DEFAULT_XPOS  -9999
@@ -19,6 +23,28 @@
 #define DW_COLOR_DEFAULT_PURPLE 0x800080
 #define DW_COLOR_DEFAULT_BGND   0xd6d6c0
 
+#define COMPRESS_VOWELS "aeiouyAEIOUY"
+#define COMPRESS_COMMON_PREFIXES "index of ;re: ;fwd: ;www.;welcome to ;the "
+
+#ifdef DISABLE_ANTI_ALIAS
+ #define D_DEFAULT_VW_FONT "*-*"
+ #define D_DEFAULT_FW_FONT "*-*"
+ #define D_FONT_SIZE_BASE  8
+#else
+ #define D_DEFAULT_VW_FONT "*"
+ #define D_DEFAULT_FW_FONT "*"
+ #define D_FONT_SIZE_BASE  6
+#endif
+
+/* The following array of font sizes has to be _strictly_ crescent */
+#define D_FONT_SIZE_1 (D_FONT_SIZE_BASE + 2)
+#define D_FONT_SIZE_2 (D_FONT_SIZE_BASE + 4)
+#define D_FONT_SIZE_3 (D_FONT_SIZE_BASE + 6)
+#define D_FONT_SIZE_4 (D_FONT_SIZE_BASE + 8)
+#define D_FONT_SIZE_5 (D_FONT_SIZE_BASE + 12)
+#define D_FONT_SIZE_6 (D_FONT_SIZE_BASE + 16)
+#define D_FONT_SIZE_NUM 6
+
 /* define enumeration values to be returned */
 enum {
    PARSE_OK = 0,
@@ -31,6 +57,7 @@
    DRC_TOKEN_GEOMETRY,
    DRC_TOKEN_PROXY,
    DRC_TOKEN_NOPROXY,
+   DRC_TOKEN_USER_AGENT,
    DRC_TOKEN_LINK_COLOR,
    DRC_TOKEN_VISITED_COLOR,
    DRC_TOKEN_BG_COLOR,
@@ -39,12 +66,15 @@
    DRC_TOKEN_FORCE_VISITED_COLOR,
    DRC_TOKEN_TEXT_COLOR,
    DRC_TOKEN_USE_OBLIQUE,
+   DRC_TOKEN_STARTUP,
    DRC_TOKEN_HOME,
    DRC_TOKEN_PANEL_SIZE,
    DRC_TOKEN_SMALL_ICONS,
    DRC_TOKEN_FONT_FACTOR,
+   DRC_TOKEN_FONT_SIZES,
    DRC_TOKEN_SHOW_TOOLTIP,
    DRC_TOKEN_LIMIT_TEXT_WIDTH,
+   DRC_TOKEN_LIMIT_FONT_DECORATION,
    DRC_TOKEN_USE_DICACHE,
    DRC_TOKEN_SHOW_BACK,
    DRC_TOKEN_SHOW_FORW,
@@ -58,15 +88,37 @@
    DRC_TOKEN_SHOW_URL,
    DRC_TOKEN_SHOW_SEARCH,
    DRC_TOKEN_SHOW_PROGRESS_BOX,
+   DRC_TOKEN_SHOW_POPUP_NAVIGATION,
+//#ifdef ENABLE_USER_AGENT
+   DRC_TOKEN_SHOW_USER_AGENT,
+//#endif
    DRC_TOKEN_FULLWINDOW_START,
    DRC_TOKEN_TRANSIENT_DIALOGS,
+   DRC_TOKEN_POPUP_DIALOGS,
    DRC_TOKEN_FW_FONT,
    DRC_TOKEN_VW_FONT,
+   DRC_TOKEN_FW_AAFONT,
+   DRC_TOKEN_VW_AAFONT,
    DRC_TOKEN_GENERATE_SUBMIT,
    DRC_TOKEN_ENTERPRESS_FORCES_SUBMIT,
    DRC_TOKEN_SEARCH_URL,
+   DRC_TOKEN_SEARCH_CHARSET,
    DRC_TOKEN_SHOW_MSG,
    DRC_TOKEN_USE_OLD_PARSER,
+   DRC_TOKEN_FOCUS_LOCATION_ON_NEW,
+   DRC_TOKEN_ACCEPT_LANGUAGE,
+#ifndef DISABLE_TABS
+   DRC_TOKEN_TAB_LOAD_IN_BACKGROUND,
+   DRC_TOKEN_TAB_INSTEAD_OF_WINDOW,
+   DRC_TOKEN_TAB_BAR_SHOW_FULLSCREEN,
+   DRC_TOKEN_TAB_BAR_SHOW_SINGLE_TAB,
+   DRC_TOKEN_TAB_BAR_SCROLLER,
+   DRC_TOKEN_TAB_BAR_HOMOGENEOUS,
+   DRC_TOKEN_TAB_TITLE_COMPRESS,
+   DRC_TOKEN_TAB_CLOSE_MIDDLE_CLICK,
+   DRC_TOKEN_COMPRESS_VOWELS,
+   DRC_TOKEN_COMPRESS_COMMON_PREFIXES,
+#endif /* !DISABLE_TABS */
 
    DRC_TOKEN_LAST
 } Dillo_Rc_TokenType;
@@ -81,6 +133,8 @@
    DilloUrl *http_proxy;
    gchar *no_proxy;
    gchar **no_proxy_vec;
+   gchar *user_agent;
+   DilloUrl *startup;
    DilloUrl *home;
    guint32 link_color;
    guint32 visited_color;
@@ -94,7 +148,9 @@
    gint panel_size;
    gboolean small_icons;
    gboolean limit_text_width;
+   gboolean limit_font_decoration;
    gdouble font_factor;
+   gint font_sizes[D_FONT_SIZE_NUM];
    gboolean use_dicache;
    gboolean show_back;
    gboolean show_forw;
@@ -108,15 +164,36 @@
    gboolean show_url;
    gboolean show_search;
    gboolean show_progress_box;
+   gboolean show_popup_navigation;
+#ifdef ENABLE_USER_AGENT
+   gboolean show_user_agent;
+#endif
    gboolean fullwindow_start;
    gboolean transient_dialogs;
+   gboolean popup_dialogs;
    gchar *vw_fontname;
    gchar *fw_fontname;
    gboolean generate_submit;
    gboolean enterpress_forces_submit;
    gchar *search_url;
+   gchar *search_charset;
    gboolean show_msg;
    gboolean use_old_parser;
+   gboolean focus_location_on_new;
+   gchar *accept_language;
+#ifndef DISABLE_TABS
+   gboolean tab_load_in_background;
+   gboolean tab_instead_of_window;
+   gboolean tab_bar_show_fullscreen;
+   gboolean tab_bar_show_single_tab;
+   gboolean tab_bar_scroller;
+   gboolean tab_bar_homogeneous;
+   gboolean tab_title_compress;
+   gboolean tab_close_middle_click;
+   gchar *compress_vowels;
+   gchar *compress_common_prefixes;
+   gchar **compress_common_prefixes_vec;
+#endif /* DISABLE_TABS */
 };
 
 /* Global Data */
diff -Nur dillo-0.8.0/src/progressbar.h dillo-0.8.0.new/src/progressbar.h
--- dillo-0.8.0/src/progressbar.h	2004-01-18 22:26:15.000000000 +0000
+++ dillo-0.8.0.new/src/progressbar.h	2004-10-13 01:13:29.000000000 +0000
@@ -27,6 +27,8 @@
 extern "C" {
 #endif /* __cplusplus */
 
+#define PBAR_L 32 /* max length of progress bar string */
+
 #define PBAR_ISTR(s)  (s) ? "" : "Images: "
 #define PBAR_PSTR(s)  (s) ? "" : "Page: "
 
diff -Nur dillo-0.8.0/src/selection.c dillo-0.8.0.new/src/selection.c
--- dillo-0.8.0/src/selection.c	2003-11-21 15:11:26.000000000 +0000
+++ dillo-0.8.0.new/src/selection.c	2004-10-13 01:13:29.000000000 +0000
@@ -14,6 +14,7 @@
  * See doc/Selection.txt for informations about this module.
  */
 
+#include "i18n.h"
 #include "selection.h"
 #include "strbuf.h"
 #include "dw_gtk_viewport.h"
@@ -631,6 +632,7 @@
  */
 void a_Selection_set_selection(GtkWidget *widget, gchar *str)
 {
+   gchar *oldSelection;
    //g_print("a_Selection_set_selection\n  old: %s\n", Selection);
    if (gtk_selection_owner_set(widget,
                                GDK_SELECTION_PRIMARY,
@@ -641,8 +643,9 @@
       /* As the clear-selection callback is not being called automatically
        * before setting the new value, it'll be cleared here.  --Jcid
        * todo: this selection code needs a revision */
-      g_free(selection);
-      selection = g_strdup(str);
+      oldSelection = a_I18n_locale_from_DILLO_CHARSET(str, -1);
+      selection = a_I18n_string_check(oldSelection, DW_CHARSET);
+      g_free(oldSelection);
    }
 }
 
@@ -652,8 +655,13 @@
 void a_Selection_give_selection_callback(GtkWidget *widget,
         GtkSelectionData *data, guint info, guint time)
 {
-   gtk_selection_data_set(data, GDK_SELECTION_TYPE_STRING,
-                          8, selection, strlen(selection));
+   guchar *ctext;
+   gint format, length;
+   GdkAtom encoding;
+   
+   gdk_string_to_compound_text(selection, &encoding, &format, &ctext, &length);
+   gtk_selection_data_set(data, encoding, 8, ctext, length);
+   gdk_free_compound_text(ctext);
 }
 
 /*
@@ -670,3 +678,4 @@
    return TRUE;
 }
 
+/* vim: set ts=3 sw=3 sts=3 expandtab:*/
diff -Nur dillo-0.8.0/src/tab.c dillo-0.8.0.new/src/tab.c
--- dillo-0.8.0/src/tab.c	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/src/tab.c	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,502 @@
+/*
+ * File: tab.c
+ *
+ * Copyright (C) 2003 Frank de Lange <frank@unternet.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version. */
+
+#ifndef DISABLE_TABS
+
+#include <config.h>
+
+#include <stdio.h>
+#include <ctype.h>
+#include <gtk/gtk.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/time.h>
+#include <fcntl.h>
+
+#include "intl.h"
+#include "i18n.h"
+#include "misc.h"
+#include "dillo.h"
+#include "history.h"
+#include "nav.h"
+#include "doc.h"
+#include "IO/Url.h"
+#include "interface.h"
+#include "tab.h"
+#include "commands.h"
+#include "prefs.h"
+#include "menu.h"
+
+#include "dw_gtk_scrolled_window.h"
+#include "dw_gtk_viewport.h"
+
+#include <gdk/gdkkeysyms.h>
+
+#define DEBUG_EVENT  0
+#define DEBUG_SIZE  10
+#define DEBUG_ALLOC 10
+
+#define DEBUG_LEVEL 0
+#include "debug.h"
+
+/* BROWSER TABS */
+
+/* callbacks */
+
+/*
+ * callback for tab label resize_request. This adjusts
+ * the tab title to the width of the tab, compressing
+ * or shortening (according to preference) the title if needed 
+ */
+void
+Tab_label_size_request_callback(GtkWidget *widget,
+                                GtkAllocation *alloc,
+                                gpointer client_data)
+{
+   DilloDoc *dd = (DilloDoc *) client_data;
+   GtkLabel *tab_label = (GtkLabel *) widget;
+   gchar *tab_title, *checked_str, *short_title;
+   gint tab_title_size, tab_title_len;
+
+   /* the tool tip is attached to the parent of the label, an event box */
+   tab_title = ((GtkTooltipsData *) gtk_tooltips_data_get(
+                                       GTK_WIDGET(
+                                        GTK_WIDGET(
+                                         tab_label)->parent)))->tip_text;
+
+   tab_title_size = (gint) ((gfloat) alloc->width / dd->bw->tab_label_average_character_width);
+
+   /* compress or shorten the tab title? */
+   tab_title = a_I18n_DW_CHARSET_to_DILLO_CHARSET(tab_title, -1);
+   tab_title_len = strlen(tab_title);
+   if (prefs.tab_title_compress) {
+     /* use title compression algorithm */
+     short_title = a_Misc_string_compress(tab_title, tab_title_size);
+   } else {
+     /* use simple shortening */
+     short_title = a_Misc_string_shorten(tab_title, tab_title_size);
+   }
+   g_free(tab_title);
+   tab_title = a_I18n_DW_CHARSET_from_DILLO_CHARSET(short_title, -1);
+   g_free(short_title);
+   
+   /* check string */
+   checked_str = a_Misc_string_check(tab_title, DW_CHARSET);
+   g_free(tab_title);
+
+   gtk_label_set_text(GTK_LABEL(tab_label), checked_str);
+   g_free(checked_str);
+}
+
+/*
+ * callback for tab label button_press_event
+ *
+ * used to popup menu with tab options
+ *
+ * even though this is called 'tab_label_..., the callback is in
+ * fact attached to an event box surrounding the tab_label, as gtk
+ * label widgets can not receive events
+ */
+void
+Tab_label_button_press_event_callback(GtkWidget *widget,
+                                      GdkEventButton *event,
+                                      gpointer client_data)
+{
+   DilloDoc *dd = (DilloDoc *) client_data;
+   switch (event->button) {
+   case 1:
+     a_Tab_switch(dd);
+     break;
+   case 2:
+     /* currently unused */
+     DEBUG_MSG(DEBUG_EVENT, "You pressed button (%d) over a tab...\n", (gint) event->button);
+     if (prefs.tab_close_middle_click)
+         a_Tab_close(dd);
+     break;
+   case 3:
+     /* popup tab options menu */
+     if (dd->bw->menu_popup.over_tab)
+       gtk_widget_destroy(dd->bw->menu_popup.over_tab);
+     dd->bw->menu_popup.over_tab = a_Menu_popup_tab_new(dd);
+     gtk_menu_popup(GTK_MENU(dd->bw->menu_popup.over_tab), NULL, NULL,
+                    NULL, NULL, event->button, event->time);
+     break;
+   default:
+     /* weird pointer with more than 3 buttons, ignore */
+     DEBUG_MSG(DEBUG_EVENT, "You pressed button (%d) over a tab...\n", (gint) event->button);
+     break;
+   }
+}
+  
+/*
+ * callback for tab switch. This just calls a_Tab_switch for the docwin
+ * passed as page
+ */
+void
+Tab_switch_callback(GtkWidget *tabbrowser,
+                    GtkNotebookPage *page,
+                    gint page_num,
+                    gpointer client_data)
+{
+   DilloDoc *dd;
+   GtkWidget *docwin;
+
+   /* the notebook page contains a box, which contains the docwin as its first child
+    * hence this hairy function... */
+   docwin = g_list_nth_data(gtk_container_children(GTK_CONTAINER(gtk_notebook_get_nth_page(GTK_NOTEBOOK(tabbrowser), page_num))), 0);
+   dd = a_Doc_get_by_docwin(docwin);
+
+   if(dd)
+     a_Tab_switch(dd);
+}
+
+/*
+ * callback for tab add
+ */
+void
+Tab_add_callback(GtkContainer *container,
+                 GtkWidget *widget,
+                 gpointer client_data)
+{
+   DEBUG_MSG(DEBUG_EVENT, "I am the tab_add callback in src/tab.c!\n");
+}
+
+/*
+ * callback for tab remove
+ */
+void
+Tab_remove_callback(GtkContainer *container,
+                    GtkWidget *widget,
+                    gpointer client_data)
+{
+   DEBUG_MSG(DEBUG_EVENT, "I am the tab remove callback, in src/tab.c!\n");
+}
+
+/*
+ * callback for tab browser destroy
+ */
+void
+Tab_browser_destroy_callback(GtkContainer *container,
+                    GtkWidget *widget,
+                    gpointer client_data)
+{
+   DEBUG_MSG(DEBUG_EVENT, "I am the tab browser destroy callback, in src/tab.c!\n");
+}
+
+/* Public functions */
+
+/*
+ * return a new tab browser
+ */
+GtkContainer *
+a_Tab_browser_new(BrowserWindow *bw)
+{
+   GtkRequisition *req;
+   GtkWidget *label;
+   GtkNotebook *tabbrowser;
+
+   /* try to calulate the average width of a character in a label
+    * in the current context. This is something of a hack...
+    */
+   req = g_new0(GtkRequisition, 1);
+   label = gtk_label_new(D_QUICK_BROWN_FOX);
+   gtk_widget_show(label);
+   gtk_widget_size_request(GTK_WIDGET(label), req);
+   bw->tab_label_average_character_width = (gfloat) ((gfloat) req->width / (gfloat) strlen(GTK_LABEL(label)->label));
+   g_free(req);
+
+   /* Add tabbrowser */
+   tabbrowser = GTK_NOTEBOOK(gtk_notebook_new());
+   gtk_notebook_set_show_border(GTK_NOTEBOOK(tabbrowser), FALSE);
+   gtk_notebook_set_scrollable(GTK_NOTEBOOK(tabbrowser), prefs.tab_bar_scroller);
+   gtk_notebook_set_homogeneous_tabs(GTK_NOTEBOOK(tabbrowser), prefs.tab_bar_homogeneous);
+   gtk_signal_connect_after(GTK_OBJECT(tabbrowser),
+			    "switch_page",
+			    GTK_SIGNAL_FUNC(Tab_switch_callback),
+			    (gpointer) bw);
+   
+   gtk_signal_connect_after(GTK_OBJECT(tabbrowser),
+                            "add",
+                            GTK_SIGNAL_FUNC(Tab_add_callback),
+                            (gpointer) bw);
+
+   gtk_signal_connect(GTK_OBJECT(tabbrowser),
+                            "remove",
+                            GTK_SIGNAL_FUNC(Tab_remove_callback),
+                            (gpointer) bw);
+   /* commented out, currently not in use...  
+   gtk_signal_connect(GTK_OBJECT(tabbrowser),
+                            "destroy",
+                            GTK_SIGNAL_FUNC(Tab_browser_destroy_callback),
+                            (gpointer) bw);
+   */
+   
+   return GTK_CONTAINER(tabbrowser);
+}
+
+/*
+ * switch tab, update interface
+ */
+void
+a_Tab_switch(DilloDoc *dd)
+{
+   a_Interface_findtext_dialog_close();
+   a_Dw_tooltip_count_reset ();
+
+   /* set bw's current root document */
+   dd->bw->dd = a_Doc_get_root(dd);
+
+   /* add the browser window's full_screen_off_button to the dd's
+    * docwin. This button is owned by the window (this makes it easier
+    * to move tabs between windows, if needed), so it needs to
+    * be moved from tab to tab when the tab becomes current (as
+    * GTK does not allow a widget to have more than one parent).
+    *
+    * XXX:HACK
+    */
+   if (GTK_WIDGET(dd->bw->full_screen_off_button)->parent != dd->docwin) {
+     /* keep a ref to the widget to keep it alive in transit... */
+     gtk_object_ref(GTK_OBJECT(dd->bw->full_screen_off_button));
+     if (GTK_WIDGET(dd->bw->full_screen_off_button)->parent)
+       gtk_container_remove(GTK_CONTAINER(GTK_WIDGET(dd->bw->full_screen_off_button)->parent),
+			    GTK_WIDGET(dd->bw->full_screen_off_button));
+     a_Dw_gtk_scrolled_window_add_gadget(GTK_DW_SCROLLED_WINDOW (dd->docwin),
+					 dd->bw->full_screen_off_button);
+     /* ref is no longer needed, discard it... */
+     gtk_object_unref(GTK_OBJECT(dd->bw->full_screen_off_button));
+
+     /* XXX:HACK the docwin does not show (or raise?) the widget when needed... */
+     if(GTK_WIDGET_VISIBLE(dd->bw->full_screen_off_button)) {
+       gtk_widget_hide(dd->bw->full_screen_off_button);
+       gtk_widget_show(dd->bw->full_screen_off_button);
+     }
+   }
+
+   /* update progress bar and adjust button sensitivity */
+   a_Doc_progress_update(dd);
+
+   /* adjust tab specific interface elements */
+   if (dd->nav_stack_ptr != -1)
+     /* this tab has a document loaded, set values accordingly */
+     {
+       a_Interface_set_page_title(dd->bw, (gchar *) a_History_get_title(NAV_TOP(dd)));
+       a_Interface_set_location_text(dd->bw,URL_STR_(a_History_get_url(NAV_TOP(dd))));
+     } else {
+       /* no document loaded in tab, use default values */
+       gchar *title = a_I18n_locale_to_DILLO_CHARSET(_("(Untitled)"));
+       a_Interface_set_page_title(dd->bw, title);
+       g_free(title);
+       a_Interface_set_location_text(dd->bw,"");
+     }
+
+   /* show tab */
+   gtk_notebook_set_page(GTK_NOTEBOOK(dd->bw->container),
+			 gtk_notebook_page_num(GTK_NOTEBOOK(dd->bw->container),
+			 GTK_WIDGET(dd->docwin)->parent));
+
+   /* set focus to docwin */
+   gtk_widget_grab_focus(GTK_BIN(dd->docwin)->child);
+}
+
+/*
+ * set visibility of tab bar
+ */
+void
+a_Tab_visibility_update(BrowserWindow *bw)
+{
+   gboolean hide_tabs;
+
+   g_return_if_fail(bw != NULL);
+
+   /* this gets called in the tab switching code, which in turn gets called when
+    * a tab is deleted. This includes the final tab, which in turn causes the main_window
+    * to be destroyed, which of course includes the tabbrowser... So, check first if
+    * there is still a tabbrowser around to update before doing anything else...
+    */
+   if(!GTK_IS_CONTAINER(bw->container))
+     return;
+   
+   /* HIDE tab bar IF
+    * -  there is only one tab left AND the preference tab_bar_show_single_tab
+    * is set to NO
+    *  OR
+    * - when using fullscreen AND the preference tab_bar_show_fullscreen
+    * is set to NO
+    * OTHERWISE
+    * SHOW tab bar
+    */
+   hide_tabs = ((g_list_length(gtk_container_children(GTK_CONTAINER(bw->container))) == 1)
+                && (!prefs.tab_bar_show_single_tab));
+   hide_tabs |= (bw->fullwindow
+                 && (!prefs.tab_bar_show_fullscreen));
+   gtk_notebook_set_show_tabs(GTK_NOTEBOOK(bw->container), !hide_tabs);
+}
+
+
+/*
+ * close a specific browser tab,
+ * close window if no tabs left
+ *
+ * NOTE: this will destroy the document which
+ * was displayed in the tab, through the destroy callback
+ * for the docwin (in src/doc.c). If documents have to
+ * be moved between tabs or frames, unparent the
+ * pagemarks menu and reparent dd->docwin before calling
+ * this function!
+ */
+void
+a_Tab_close(DilloDoc *dd)
+{
+   gint page_num;
+   BrowserWindow *bw = dd->bw;
+
+   g_return_if_fail (dd != NULL);
+
+   a_Interface_findtext_dialog_close();
+
+   page_num = gtk_notebook_page_num(GTK_NOTEBOOK(bw->container),
+				    GTK_WIDGET(dd->docwin)->parent);
+
+   /* left-to-right tab deletion: if this is the current page, show next page */
+   if(gtk_notebook_get_current_page(GTK_NOTEBOOK(bw->container)) == page_num)
+     gtk_notebook_next_page(GTK_NOTEBOOK(bw->container));
+
+   /* this will destroy dd->docwin (and the DilloDoc)
+    * if there are no reference left to it */
+   gtk_notebook_remove_page(GTK_NOTEBOOK(bw->container), page_num);
+
+   if (gtk_notebook_get_current_page(GTK_NOTEBOOK(bw->container)) == -1)
+     {
+       /* destroying the main window causes its destroy
+          callback to be fired. This takes down the
+          rest of the BrowserWindow */
+       gtk_widget_destroy(GTK_WIDGET(bw->main_window));
+     }
+
+   a_Tab_visibility_update(bw);
+}
+
+/*
+ * Add a tab (containing a new DilloDoc) to a browser window
+ */
+void
+a_Tab_new(BrowserWindow *bw)
+{
+   DilloDoc *dd;
+
+   g_return_if_fail (bw != NULL);
+
+   dd = a_Doc_new();
+   a_Tab_add(bw, dd);
+
+   /* always show new tabs, even when background loading */
+   a_Tab_switch(dd);
+
+   /* set focus to url bar */
+   gtk_widget_grab_focus(dd->bw->location);
+}
+
+
+/*
+ * Add a tab (containing an existing DilloDoc) to a browser window
+ */
+void
+a_Tab_add(BrowserWindow *bw, DilloDoc *dd)
+{
+   GString *tab_title;
+   GtkWidget *tab_label, *tab_label_event_box, *box;
+   GtkPackType *pack_type = g_new0(GtkPackType, 1);
+
+   g_return_if_fail (bw != NULL && dd != NULL);
+
+   a_Doc_set_browserwindow(dd, bw);
+
+   if (dd->nav_stack_ptr != -1)
+     {
+       tab_title = g_string_new(a_History_get_title(NAV_TOP(dd)));
+     } else {
+       tab_title = g_string_new(_("(Untitled)"));
+     }
+   
+   tab_label_event_box = gtk_event_box_new();
+   tab_label = gtk_label_new(tab_title->str);
+   gtk_widget_show(tab_label);
+   gtk_container_add(GTK_CONTAINER(tab_label_event_box), tab_label);
+   box = gtk_hbox_new(TRUE, 0);
+   gtk_container_set_border_width(GTK_CONTAINER(box), 0);
+   gtk_box_pack_start(GTK_BOX(box), GTK_WIDGET(dd->docwin), TRUE, TRUE, 0);
+#ifdef XHTML_DTD_FRAMESET
+   if(dd->frameset)
+     gtk_box_pack_start(GTK_BOX(box), GTK_WIDGET(dd->frameset), TRUE, TRUE, 0);
+#endif /* XHTML_DTD_FRAMESET */
+   gtk_widget_show(box);
+   gtk_notebook_append_page(GTK_NOTEBOOK(bw->container), box, tab_label_event_box);
+
+   /* add tooltip with full title. This has to be attached to the event box,
+    * since label widgets are windowless and hence can not receive events */
+   gtk_tooltips_set_tip(GTK_TOOLTIPS(dd->bw->tooltips),
+                        GTK_WIDGET(tab_label_event_box),
+                        tab_title->str,
+                        tab_title->str);
+
+   /* make sure the tab labels adjust their size according to available space */
+   gtk_signal_connect_after(GTK_OBJECT(tab_label),
+                            "size_allocate",
+                            GTK_SIGNAL_FUNC(Tab_label_size_request_callback),
+                            (gpointer) dd);
+
+   /* catch button press events for showing menu, etc. This has to be attached
+    * to the event box, since label widgets are windowless and hence can not
+    * receive events */
+   gtk_signal_connect_after(GTK_OBJECT(tab_label_event_box),
+                      "button_press_event",
+                      GTK_SIGNAL_FUNC(Tab_label_button_press_event_callback),
+                      (gpointer) dd);
+
+   g_string_free(tab_title, TRUE);
+   gtk_notebook_query_tab_label_packing(GTK_NOTEBOOK(bw->container), GTK_WIDGET(dd->docwin)->parent, NULL, NULL, pack_type);
+   gtk_notebook_set_tab_label_packing(GTK_NOTEBOOK(bw->container), GTK_WIDGET(dd->docwin)->parent, TRUE, TRUE, *pack_type);
+   g_free(pack_type);
+   a_Tab_visibility_update(bw);
+}
+
+
+/*
+ * set tab title
+ * also sets window title if this tab is the current tab
+ */
+void
+a_Tab_title_set(DilloDoc *dd, gchar *title)
+{
+   GtkWidget *tab_label;
+   gchar *title_enc;
+
+   g_return_if_fail (dd != NULL && title != NULL);
+
+   /* set tooltip on tab label container (a GtkEventBox), and queue a resize
+    * for the label itself so the title is redrawn */
+   tab_label = gtk_notebook_get_tab_label(GTK_NOTEBOOK(dd->bw->container),GTK_WIDGET(dd->docwin)->parent);
+   title_enc = a_I18n_DW_CHARSET_from_DILLO_CHARSET(title, -1);
+   gtk_tooltips_set_tip(GTK_TOOLTIPS(dd->bw->tooltips),
+                       GTK_WIDGET(tab_label),
+                       title_enc,
+                       title_enc);
+   g_free(title_enc);
+
+   gtk_widget_queue_resize(GTK_WIDGET(GTK_BIN(tab_label)->child));
+
+   /* if this is the current tab, set window title */
+   if (dd->bw->dd == dd)
+     a_Interface_set_page_title(dd->bw, title);
+}
+
+#endif /* !DISABLE_TABS */
+
+/* vim: set ts=3 sw=3 sts=3 expandtab:*/
diff -Nur dillo-0.8.0/src/tab.h dillo-0.8.0.new/src/tab.h
--- dillo-0.8.0/src/tab.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/src/tab.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,22 @@
+#ifndef __TAB_H__
+#define __TAB_H__
+
+#ifndef DISABLE_TABS
+#include "browser.h"
+
+/* this string is used to calculate the average width of a
+ * character in a GTK_LABEL in the current context.
+ */
+#define D_QUICK_BROWN_FOX "The Quick Brown Fox Jumped Over The Lazy Dog"
+
+GtkContainer *
+a_Tab_browser_new(BrowserWindow *bw);
+void a_Tab_new(BrowserWindow *bw);
+void a_Tab_close(DilloDoc *dd);
+void a_Tab_add(BrowserWindow *bw, DilloDoc *dd);
+void a_Tab_switch(DilloDoc *dd);
+void a_Tab_title_set(DilloDoc *dd, gchar *title);
+void a_Tab_visibility_update(BrowserWindow *bw);
+
+#endif /* !DISABLE_TABS */
+#endif /* __TAB_H__ */
diff -Nur dillo-0.8.0/src/url.c dillo-0.8.0.new/src/url.c
--- dillo-0.8.0/src/url.c	2004-01-05 19:25:46.000000000 +0000
+++ dillo-0.8.0.new/src/url.c	2004-10-13 01:13:29.000000000 +0000
@@ -70,7 +70,8 @@
          url->fragment  ? url->fragment : "");
    }
 
-   return url->url_string->str;
+   if(url->url_string) return url->url_string->str;
+   return NULL;
 }
 
 /*
@@ -172,6 +173,8 @@
       g_free((gchar *)url->buffer);
       g_free((gchar *)url->data);
       g_free((gchar *)url->alt);
+      g_free((gchar *)url->target);
+      g_free((gchar *)url->referer);
       g_free(url);
    }
 }
@@ -323,6 +326,7 @@
  *     flags              = 0
  *     data               = NULL
  *     alt                = NULL
+ *     target             = NULL
  *     ismap_url_len      = 0
  *     scrolling_position = 0
  *  }
@@ -371,6 +375,7 @@
    url->scrolling_position_x = posx;
    url->scrolling_position_y = posy;
    url->illegal_chars = n_ic;
+   url->referer = NULL;//g_strdup(base_url);
 
    return url;
 }
@@ -391,9 +396,11 @@
    url->flags                = ori->flags;
    url->data                 = g_strdup(ori->data);
    url->alt                  = g_strdup(ori->alt);
+   url->target               = g_strdup(ori->target);
    url->ismap_url_len        = ori->ismap_url_len;
    url->scrolling_position_x = ori->scrolling_position_x;
    url->scrolling_position_y = ori->scrolling_position_y;
+   url->referer              = g_strdup(ori->referer);
 
    return url;
 }
@@ -454,6 +461,18 @@
 }
 
 /*
+ * Set DilloUrl target (used to target link at specific frame or window)
+ */
+void a_Url_set_target(DilloUrl *u, const gchar *target)
+{
+   if (u) {
+      if (u->target)
+ 	     g_free((gchar *)u->target);
+      u->target = g_strdup(target);
+   }
+}
+
+/*
  * Set DilloUrl scrolling position
  */
 void a_Url_set_pos(DilloUrl *u, gint32 posx, gint32 posy)
@@ -465,6 +484,18 @@
 }
 
 /*
+ * Set DilloUrl referer URL
+ */
+void a_Url_set_referer(DilloUrl *u, DilloUrl *ref)
+{
+   if (u && ref) {
+      if (u->referer)
+         g_free((gchar *)u->referer);
+      u->referer = g_strdup(a_Url_str(ref));
+   }
+}
+
+/*
  * Set DilloUrl ismap coordinates
  * (this is optimized for not hogging the CPU)
  */
@@ -558,3 +589,4 @@
    }
    return new_str;
 }
+
diff -Nur dillo-0.8.0/src/url.h dillo-0.8.0.new/src/url.h
--- dillo-0.8.0/src/url.h	2004-01-05 19:25:46.000000000 +0000
+++ dillo-0.8.0.new/src/url.h	2004-10-13 01:13:29.000000000 +0000
@@ -55,6 +55,8 @@
 #define URL_DATA_(u)           u->data
 #define URL_ALT_(u)            u->alt
 #define URL_STR_(u)            a_Url_str(u)
+#define URL_REFERER_(u)    u->referer
+#define URL_TARGET_(u)     u->target
 /* these return an integer */
 #define URL_PORT_(u)           (URL_HOST(u) ? u->port : u->port)
 #define URL_FLAGS_(u)          u->flags
@@ -82,6 +84,8 @@
 #define URL_POSX(u)           URL_POSX_(u)
 #define URL_POSY(u)           URL_POSY_(u)
 #define URL_ILLEGAL_CHARS(u)  URL_ILLEGAL_CHARS_(u)
+#define URL_REFERER(u)     NPTR2STR(URL_REFERER_(u))
+#define URL_TARGET(u)      NPTR2STR(URL_TARGET_(u))
 
 
 
@@ -115,10 +119,12 @@
    gint flags;
    const gchar *data;              /* POST */
    const gchar *alt;               /* "alt" text (used by image maps) */
+   const gchar *target;            /* target frame/window */
    gint ismap_url_len;             /* Used by server side image maps */
    gint32 scrolling_position_x, scrolling_position_y;
                                    /* remember position of visited urls */
    gint illegal_chars;             /* number of illegal chars */
+   const gchar *referer;           /* The URL that refered to this one */
 };
 
 
@@ -132,7 +138,9 @@
 void a_Url_set_flags(DilloUrl *u, gint flags);
 void a_Url_set_data(DilloUrl *u, gchar *data);
 void a_Url_set_alt(DilloUrl *u, const gchar *alt);
+void a_Url_set_target(DilloUrl *u, const gchar *target);
 void a_Url_set_pos(DilloUrl *u, gint32 posx, gint32 posy);
+void a_Url_set_referer(DilloUrl *u, DilloUrl *ref);
 void a_Url_set_ismap_coords(DilloUrl *u, gchar *coord_str);
 gchar *a_Url_parse_hex_path(const DilloUrl *u);
 gchar *a_Url_string_strip_delimiters(gchar *str);
diff -Nur dillo-0.8.0/src/user_agent.h dillo-0.8.0.new/src/user_agent.h
--- dillo-0.8.0/src/user_agent.h	1970-01-01 00:00:00.000000000 +0000
+++ dillo-0.8.0.new/src/user_agent.h	2004-10-13 01:13:29.000000000 +0000
@@ -0,0 +1,22 @@
+/*
+ * File: user_agent.h
+ *
+ * Copyright (C) 2003 LJ and edit by Kiyo
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ */
+
+gchar *user_agent_text[] = {
+   "Dillo/" VERSION, /* Original. */
+   "Mozilla/3.0 (compatible;) Dillo/" VERSION,
+   "Mozilla/4.0 (compatible; MSIE 4.0;) Dillo/" VERSION,
+   "Mozilla/4.0 (Macintosh; U; PPC Mac OS X; ja-jp) Dillo/" VERSION,
+   "DoCoMo/1.0/x505i (Dillo/" VERSION ")",
+   "J-PHONE/4.2/J-x53 (Dillo/" VERSION ")",
+   "KDDI-x24 UP.Browser/6.0.x.x (GUI) MMP/1.1 (Dillo/" VERSION ")",
+   "",
+};
+
diff -Nur dillo-0.8.0/src/web.c dillo-0.8.0.new/src/web.c
--- dillo-0.8.0/src/web.c	2004-02-06 23:10:34.000000000 +0000
+++ dillo-0.8.0.new/src/web.c	2004-10-13 01:13:29.000000000 +0000
@@ -16,8 +16,9 @@
 
 #include "msg.h"
 #include "browser.h"
-#include "nav.h"
 #include "interface.h"
+#include "nav.h"
+#include "doc.h"
 #include "IO/IO.h"
 #include "IO/mime.h"
 
@@ -27,7 +28,7 @@
 #include "prefs.h"
 #include "web.h"
 
-#define DEBUG_LEVEL 5
+//#define DEBUG_LEVEL 5
 #include "debug.h"
 
 /*
@@ -44,55 +45,44 @@
                                   CA_Callback_t *Call, void **Data)
 {
    DwWidget *dw = NULL;
-   DwStyle style_attrs, *style;
-   DwStyleFont font;
+//   DwStyle style_attrs, *style;
+//   DwStyleFont font;
 
    DEBUG_MSG(1, "a_Web_dispatch_by_type\n");
 
-   g_return_val_if_fail(Web->bw != NULL, NULL);
+   g_return_val_if_fail(Web->dd != NULL, NULL);
 
    if (Web->flags & WEB_RootUrl) {
       /* We have RootUrl! */
       dw = a_Mime_set_viewer(Type, Web, Call, Data);
       g_return_val_if_fail(dw != NULL, NULL);
 
-      /* Set a style for the widget */
-      font.name = prefs.vw_fontname; /* must be defined */
-      font.size = rint(12.0 * prefs.font_factor);
-      font.weight = 400;
-      font.style = DW_STYLE_FONT_STYLE_NORMAL;
-
-      a_Dw_style_init_values (&style_attrs, Web->bw->main_window->window);
-      a_Dw_style_box_set_val (&style_attrs.margin, 5);
-      style_attrs.font = a_Dw_style_font_new (&font);
-      style_attrs.color =
-         a_Dw_style_color_new (prefs.text_color, Web->bw->main_window->window);
-      style_attrs.background_color =
-         a_Dw_style_color_new (prefs.bg_color, Web->bw->main_window->window);
-      style = a_Dw_style_new (&style_attrs, Web->bw->main_window->window);
-      a_Dw_widget_set_style (dw, style);
-      a_Dw_style_unref (style);
+      /* set widget style */
+      a_Dw_widget_set_style(dw, Web->dd->style);
 
       a_Dw_gtk_scrolled_window_set_dw(
-         GTK_DW_SCROLLED_WINDOW(Web->bw->docwin), dw);
+         GTK_DW_SCROLLED_WINDOW(Web->dd->docwin), dw);
 
       if (URL_POSX(Web->url) || URL_POSY(Web->url))
         a_Dw_gtk_scrolled_window_set_scrolling_position(
-           GTK_DW_SCROLLED_WINDOW(Web->bw->docwin),
+           GTK_DW_SCROLLED_WINDOW(Web->dd->docwin),
            URL_POSX(Web->url), URL_POSY(Web->url));
       else
         a_Dw_gtk_scrolled_window_set_anchor(
-           GTK_DW_SCROLLED_WINDOW(Web->bw->docwin), URL_FRAGMENT_(Web->url));
-
-      /* Clear the title bar for pages without a <TITLE> tag */
-      a_Interface_set_page_title(Web->bw, "");
-      a_Interface_set_location_text(Web->bw, URL_STR(Web->url));
-      a_Interface_reset_progress_bars(Web->bw);
+           GTK_DW_SCROLLED_WINDOW(Web->dd->docwin), URL_FRAGMENT_(Web->url));
+      
+	/* Set document title to url, will be replaced by real title
+	 * if this page has a <TITLE> tag */
+	a_Doc_title_set(Web->dd, URL_STR(Web->url));
+
+      /* update progress */
+      a_Doc_progress_update(Web->dd);
+      a_Doc_location_set(Web->dd, URL_STR(Web->url));
       /* Reset the bug meter */
-      a_Interface_bug_meter_update(Web->bw, 0);
+      a_Interface_bug_meter_update(Web->dd->bw, 0);
 
       /* Let the Nav module know... */
-      a_Nav_expect_done(Web->bw);
+      a_Nav_expect_done(Web->dd);
 
    } else {
       /* A non-RootUrl. At this moment we only handle image-children */
@@ -119,7 +109,7 @@
    DilloWeb *web= g_new(DilloWeb, 1);
 
    web->url = a_Url_dup(url);
-   web->bw = NULL;
+   web->dd = NULL;
    web->flags = 0;
    web->Image = NULL;
    web->stream  = NULL;
diff -Nur dillo-0.8.0/src/web.h dillo-0.8.0.new/src/web.h
--- dillo-0.8.0/src/web.h	2002-01-08 13:52:23.000000000 +0000
+++ dillo-0.8.0.new/src/web.h	2004-10-13 01:13:29.000000000 +0000
@@ -23,7 +23,7 @@
 
 struct _DilloWeb {
   DilloUrl *url;              /* Requested URL */
-  BrowserWindow *bw;          /* The requesting browser window [reference] */
+  DilloDoc *dd;               /* The requesting browser document [reference] */
   gint flags;                 /* Additional info */
 
   DilloImage *Image;          /* For image urls [reference] */
